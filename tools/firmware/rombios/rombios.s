! 1 
! 1 # 1 "_rombios_.c"
! 1 struct rombios_info {
! 2     unsigned long bios32_entry;
!BCC_EOS
! 3 };
!BCC_EOS
! 4 #asm
!BCC_ASM
.rom
.org 0x0000
use16 386
MACRO HALT
  ;; the HALT macro is called with the line number of the HALT call.
  ;; The line number is then sent to the 0x400, causing Bochs/Plex
  ;; to print a BX_PANIC message. This will normally halt the simulation
  ;; with a message such as "BIOS panic at rombios.c, line 4091".
  ;; However, users can choose to make panics non-fatal and continue.
  mov dx,#0x400
  mov ax,#?1
  out dx,ax
MEND
MACRO JMP_AP
  db 0xea
  dw ?2
  dw ?1
MEND
MACRO SET_INT_VECTOR
  mov ax, ?3
  mov ?1*4, ax
  mov ax, ?2
  mov ?1*4+2, ax
MEND
! 29 endasm
!BCC_ENDASM
! 30 typedef unsigned char Bit8u;
!BCC_EOS
! 31 typedef unsigned short Bit16u;
!BCC_EOS
! 32 typedef unsigned short bx_bool;
!BCC_EOS
! 33 typedef unsigned long Bit32u;
!BCC_EOS
! 34   void memsetb(seg,offset,value,count);
!BCC_EOS
! 35   void memcpyb(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 36   void memcpyd(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 37     void
! 38   memsetb(seg,offset,value,count)
! 39     Bit16u seg;
export	_memsetb
_memsetb:
!BCC_EOS
! 40     Bit16u offset;
!BCC_EOS
! 41     Bit16u value;
!BCC_EOS
! 42     Bit16u count;
!BCC_EOS
! 43   {
! 44 #asm
!BCC_ASM
_memsetb.count	set	8
_memsetb.seg	set	2
_memsetb.value	set	6
_memsetb.offset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      mov cx, 10[bp] ; count
      test cx, cx
      je memsetb_end
      mov ax, 4[bp] ; segment
      mov es, ax
      mov ax, 6[bp] ; offset
      mov di, ax
      mov al, 8[bp] ; value
      cld
      rep
       stosb
  memsetb_end:
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 68 endasm
!BCC_ENDASM
! 69   }
ret
! 70     void
! 71   memcpyb(dseg,doffset,sseg,soffset,count)
! 72     Bit16u dseg;
export	_memcpyb
_memcpyb:
!BCC_EOS
! 73     Bit16u doffset;
!BCC_EOS
! 74     Bit16u sseg;
!BCC_EOS
! 75     Bit16u soffset;
!BCC_EOS
! 76     Bit16u count;
!BCC_EOS
! 77   {
! 78 #asm
!BCC_ASM
_memcpyb.count	set	$A
_memcpyb.sseg	set	6
_memcpyb.soffset	set	8
_memcpyb.dseg	set	2
_memcpyb.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyb_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsb
  memcpyb_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 109 endasm
!BCC_ENDASM
! 110   }
ret
! 111     void
! 112   memcpyd(dseg,doffset,sseg,soffset,count)
! 113     Bit16u dseg;
export	_memcpyd
_memcpyd:
!BCC_EOS
! 114     Bit16u doffset;
!BCC_EOS
! 115     Bit16u sseg;
!BCC_EOS
! 116     Bit16u soffset;
!BCC_EOS
! 117     Bit16u count;
!BCC_EOS
! 118   {
! 119 #asm
!BCC_ASM
_memcpyd.count	set	$A
_memcpyd.sseg	set	6
_memcpyd.soffset	set	8
_memcpyd.dseg	set	2
_memcpyd.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyd_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsd
  memcpyd_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 150 endasm
!BCC_ENDASM
! 151   }
ret
! 152   static Bit32u read_dword();
!BCC_EOS
! 153   static void write_dword();
!BCC_EOS
! 154     Bit32u
! 155   read_dword(seg, offset)
! 156     Bit16u seg;
export	_read_dword
_read_dword:
!BCC_EOS
! 157     Bit16u offset;
!BCC_EOS
! 158   {
! 159 #asm
!BCC_ASM
_read_dword.seg	set	2
_read_dword.offset	set	4
    push bp
    mov bp, sp
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, [bx]
      add bx, #2
      mov dx, [bx]
      ;; ax = return value (word)
      ;; dx = return value (word)
      pop ds
      pop bx
    pop bp
! 175 endasm
!BCC_ENDASM
! 176   }
ret
! 177     void
! 178   write_dword(seg, offset, data)
! 179     Bit16u seg;
export	_write_dword
_write_dword:
!BCC_EOS
! 180     Bit16u offset;
!BCC_EOS
! 181     Bit32u data;
!BCC_EOS
! 182   {
! 183 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
    push bp
    mov bp, sp
      push ax
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, 8[bp] ; data word
      mov [bx], ax ; write data word
      add bx, #2
      mov ax, 10[bp] ; data word
      mov [bx], ax ; write data word
      pop ds
      pop bx
      pop ax
    pop bp
! 201 endasm
!BCC_ENDASM
! 202   }
ret
! 203 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
  ;; and function
  landl:
  landul:
    SEG SS
      and ax,[di]
    SEG SS
      and bx,2[di]
    ret
  ;; add function
  laddl:
  laddul:
    SEG SS
      add ax,[di]
    SEG SS
      adc bx,2[di]
    ret
  ;; cmp function
  lcmpl:
  lcmpul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    SEG SS
      cmp eax, dword ptr [di]
    ret
  ;; sub function
  lsubl:
  lsubul:
    SEG SS
    sub ax,[di]
    SEG SS
    sbb bx,2[di]
    ret
  ;; mul function
  lmull:
  lmulul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    SEG SS
    mul eax, dword ptr [di]
    mov ebx, eax
    shr ebx, #16
    ret
  ;; dec function
  ldecl:
  ldecul:
    SEG SS
    dec dword ptr [bx]
    ret
  ;; or function
  lorl:
  lorul:
    SEG SS
    or ax,[di]
    SEG SS
    or bx,2[di]
    ret
  ;; inc function
  lincl:
  lincul:
    SEG SS
    inc dword ptr [bx]
    ret
  ;; tst function
  ltstl:
  ltstul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    test eax, eax
    ret
  ;; sr function
  lsrul:
    mov cx,di
    jcxz lsr_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsr_loop:
    shr eax, #1
    loop lsr_loop
    mov ebx, eax
    shr ebx, #16
  lsr_exit:
    ret
  ;; sl function
  lsll:
  lslul:
    mov cx,di
    jcxz lsl_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsl_loop:
    shl eax, #1
    loop lsl_loop
    mov ebx, eax
    shr ebx, #16
  lsl_exit:
    ret
  idiv_:
    cwd
    idiv bx
    ret
  idiv_u:
    xor dx,dx
    div bx
    ret
  ldivul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    xor edx, edx
    SEG SS
    mov bx, 2[di]
    shl ebx, #16
    SEG SS
    mov bx, [di]
    div ebx
    mov ebx, eax
    shr ebx, #16
    ret
! 329 endasm
!BCC_ENDASM
! 330 typedef struct {
! 331   unsigned char filler1[0x400];
!BCC_EOS
! 332   unsigned char filler2[0x6c];
!BCC_EOS
! 333   Bit16u ticks_low;
!BCC_EOS
! 334   Bit16u ticks_high;
!BCC_EOS
! 335   Bit8u midnight_flag;
!BCC_EOS
! 336   } bios_data_t;
!BCC_EOS
! 337   typedef struct {
! 338     Bit16u heads;
!BCC_EOS
! 339     Bit16u cylinders;
!BCC_EOS
! 340     Bit16u spt;
!BCC_EOS
! 341     } chs_t;
!BCC_EOS
! 342   typedef struct {
! 343     Bit16u iobase1;
!BCC_EOS
! 344     Bit16u iobase2;
!BCC_EOS
! 345     Bit8u prefix;
!BCC_EOS
! 346     Bit8u unused;
!BCC_EOS
! 347     Bit8u irq;
!BCC_EOS
! 348     Bit8u blkcount;
!BCC_EOS
! 349     Bit8u dma;
!BCC_EOS
! 350     Bit8u pio;
!BCC_EOS
! 351     Bit16u options;
!BCC_EOS
! 352     Bit16u reserved;
!BCC_EOS
! 353     Bit8u revision;
!BCC_EOS
! 354     Bit8u checksum;
!BCC_EOS
! 355     } dpte_t;
!BCC_EOS
! 356   typedef struct {
! 357     Bit8u iface;
!BCC_EOS
! 358     Bit16u iobase1;
!BCC_EOS
! 359     Bit16u iobase2;
!BCC_EOS
! 360     Bit8u irq;
!BCC_EOS
! 361     } ata_channel_t;
!BCC_EOS
! 362   typedef struct {
! 363     Bit8u type;
!BCC_EOS
! 364     Bit8u device;
!BCC_EOS
! 365     Bit8u removab
! 365 le;
!BCC_EOS
! 366     Bit8u lock;
!BCC_EOS
! 367     Bit8u mode;
!BCC_EOS
! 368     Bit16u blksize;
!BCC_EOS
! 369     Bit8u translation;
!BCC_EOS
! 370     chs_t lchs;
!BCC_EOS
! 371     chs_t pchs;
!BCC_EOS
! 372     Bit32u sectors_low;
!BCC_EOS
! 373     Bit32u sectors_high;
!BCC_EOS
! 374     } ata_device_t;
!BCC_EOS
! 375   typedef struct {
! 376     ata_channel_t channels[4];
!BCC_EOS
! 377     ata_device_t devices[(4*2)];
!BCC_EOS
! 378     Bit8u hdcount, hdidmap[(4*2)];
!BCC_EOS
! 379     Bit8u cdcount, cdidmap[(4*2)];
!BCC_EOS
! 380     dpte_t dpte;
!BCC_EOS
! 381     Bit16u trsfsectors;
!BCC_EOS
! 382     Bit32u trsfbytes;
!BCC_EOS
! 383     } ata_t;
!BCC_EOS
! 384   typedef struct {
! 385     Bit8u active;
!BCC_EOS
! 386     Bit8u media;
!BCC_EOS
! 387     Bit8u emulated_drive;
!BCC_EOS
! 388     Bit8u controller_index;
!BCC_EOS
! 389     Bit16u device_spec;
!BCC_EOS
! 390     Bit32u ilba;
!BCC_EOS
! 391     Bit16u buffer_segment;
!BCC_EOS
! 392     Bit16u load_segment;
!BCC_EOS
! 393     Bit16u sector_count;
!BCC_EOS
! 394     chs_t vdevice;
!BCC_EOS
! 395     } cdemu_t;
!BCC_EOS
! 396 Bit32u TCGInterruptHandler ();
!BCC_EOS
! 397 void tcpa_acpi_init ();
!BCC_EOS
! 398 Bit32u tcpa_extend_acpi_log ();
!BCC_EOS
! 399 void tcpa_calling_int19h ();
!BCC_EOS
! 400 void tcpa_returned_int19h ();
!BCC_EOS
! 401 void tcpa_add_event_separators ();
!BCC_EOS
! 402 void tcpa_wake_event ();
!BCC_EOS
! 403 void tcpa_add_bootdevice ();
!BCC_EOS
! 404 void tcpa_start_option_rom_scan ();
!BCC_EOS
! 405 void tcpa_option_rom ();
!BCC_EOS
! 406 void tcpa_ipl ();
!BCC_EOS
! 407 void tcpa_measure_post ();
!BCC_EOS
! 408 Bit32u tcpa_initialize_tpm ();
!BCC_EOS
! 409 Bit32u get_s3_waking_vector ();
!BCC_EOS
! 410 Bit32u pmm ();
!BCC_EOS
! 411   typedef struct {
! 412     unsigned char ebda_size;
!BCC_EOS
! 413     unsigned char cmos_shutdown_status;
!BCC_EOS
! 414     unsigned char filler1[0x3B];
!BCC_EOS
! 415     unsigned char fdpt0[0x10];
!BCC_EOS
! 416     unsigned char fdpt1[0x10];
!BCC_EOS
! 417     unsigned char filler2[0xC4];
!BCC_EOS
! 418     ata_t ata;
!BCC_EOS
! 419     cdemu_t cdemu;
!BCC_EOS
! 420     } ebda_data_t;
!BCC_EOS
! 421   typedef struct {
! 422     Bit8u size;
!BCC_EOS
! 423     Bit8u reserved;
!BCC_EOS
! 424     Bit16u count;
!BCC_EOS
! 425     Bit16u offset;
!BCC_EOS
! 426     Bit16u segment;
!BCC_EOS
! 427     Bit32u lba1;
!BCC_EOS
! 428     Bit32u lba2;
!BCC_EOS
! 429     } int13ext_t;
!BCC_EOS
! 430   typedef struct {
! 431     Bit16u size;
!BCC_EOS
! 432     Bit16u infos;
!BCC_EOS
! 433     Bit32u cylinders;
!BCC_EOS
! 434     Bit32u heads;
!BCC_EOS
! 435     Bit32u spt;
!BCC_EOS
! 436     Bit32u sector_count1;
!BCC_EOS
! 437     Bit32u sector_count2;
!BCC_EOS
! 438     Bit16u blksize;
!BCC_EOS
! 439     Bit16u dpte_offset;
!BCC_EOS
! 440     Bit16u dpte_segment;
!BCC_EOS
! 441     Bit16u key;
!BCC_EOS
! 442     Bit8u dpi_length;
!BCC_EOS
! 443     Bit8u reserved1;
!BCC_EOS
! 444     Bit16u reserved2;
!BCC_EOS
! 445     Bit8u host_bus[4];
!BCC_EOS
! 446     Bit8u iface_type[8];
!BCC_EOS
! 447     Bit8u iface_path[8];
!BCC_EOS
! 448     Bit8u device_path[8];
!BCC_EOS
! 449     Bit8u reserved3;
!BCC_EOS
! 450     Bit8u checksum;
!BCC_EOS
! 451     } dpt_t;
!BCC_EOS
! 452 typedef struct {
! 453   union {
! 454     struct {
! 455       Bit16u di, si, b
! 455 p, sp;
!BCC_EOS
! 456       Bit16u bx, dx, cx, ax;
!BCC_EOS
! 457       } r16;
!BCC_EOS
! 458     struct {
! 459       Bit16u filler[4];
!BCC_EOS
! 460       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
!BCC_EOS
! 461       } r8;
!BCC_EOS
! 462     } u;
!BCC_EOS
! 463   } pusha_regs_t;
!BCC_EOS
! 464 typedef struct {
! 465  union {
! 466   struct {
! 467     Bit32u edi, esi, ebp, esp;
!BCC_EOS
! 468     Bit32u ebx, edx, ecx, eax;
!BCC_EOS
! 469     } r32;
!BCC_EOS
! 470   struct {
! 471     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
!BCC_EOS
! 472     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
!BCC_EOS
! 473     } r16;
!BCC_EOS
! 474   struct {
! 475     Bit32u filler[4];
!BCC_EOS
! 476     Bit8u bl, bh;
!BCC_EOS
! 477     Bit16u filler1;
!BCC_EOS
! 478     Bit8u dl, dh;
!BCC_EOS
! 479     Bit16u filler2;
!BCC_EOS
! 480     Bit8u cl, ch;
!BCC_EOS
! 481     Bit16u filler3;
!BCC_EOS
! 482     Bit8u al, ah;
!BCC_EOS
! 483     Bit16u filler4;
!BCC_EOS
! 484     } r8;
!BCC_EOS
! 485   } u;
!BCC_EOS
! 486 } pushad_regs_t;
!BCC_EOS
! 487 typedef struct {
! 488   union {
! 489     struct {
! 490       Bit16u flags;
!BCC_EOS
! 491       } r16;
!BCC_EOS
! 492     struct {
! 493       Bit8u flagsl;
!BCC_EOS
! 494       Bit8u flagsh;
!BCC_EOS
! 495       } r8;
!BCC_EOS
! 496     } u;
!BCC_EOS
! 497   } flags_t;
!BCC_EOS
! 498 typedef struct {
! 499   Bit16u ip;
!BCC_EOS
! 500   Bit16u cs;
!BCC_EOS
! 501   flags_t flags;
!BCC_EOS
! 502   } iret_addr_t;
!BCC_EOS
! 503 typedef struct {
! 504   Bit16u type;
!BCC_EOS
! 505   Bit16u flags;
!BCC_EOS
! 506   Bit32u vector;
!BCC_EOS
! 507   Bit32u description;
!BCC_EOS
! 508   Bit32u reserved;
!BCC_EOS
! 509   } ipl_entry_t;
!BCC_EOS
! 510 static Bit8u inb();
!BCC_EOS
! 511 static Bit8u inb_cmos();
!BCC_EOS
! 512 static void outb();
!BCC_EOS
! 513 static void outb_cmos();
!BCC_EOS
! 514 static Bit16u inw();
!BCC_EOS
! 515 static void outw();
!BCC_EOS
! 516 static void init_rtc();
!BCC_EOS
! 517 static bx_bool rtc_updating();
!BCC_EOS
! 518 static Bit8u read_byte();
!BCC_EOS
! 519 static Bit16u read_word();
!BCC_EOS
! 520 static void write_byte();
!BCC_EOS
! 521 static void write_word();
!BCC_EOS
! 522 static void bios_printf();
!BCC_EOS
! 523 static Bit8u inhibit_mouse_int_and_events();
!BCC_EOS
! 524 static void enable_mouse_int_and_events();
!BCC_EOS
! 525 static Bit8u send_to_mouse_ctrl();
!BCC_EOS
! 526 static Bit8u get_mouse_data();
!BCC_EOS
! 527 static void set_kbd_command_byte();
!BCC_EOS
! 528 static void int09_function();
!BCC_EOS
! 529 static void int13_harddisk();
!BCC_EOS
! 530 static void int13_cdrom();
!BCC_EOS
! 531 static void int13_cdemu();
!BCC_EOS
! 532 static void int13_eltorito();
!BCC_EOS
! 533 static void int13_diskette_function();
!BCC_EOS
! 534 static void int14_function();
!BCC_EOS
! 535 static void int15_function();
!BCC_EOS
! 536 static void int16_function();
!BCC_EOS
! 537 static void int17_function();
!BCC_EOS
! 538 static void int18_function();
!BCC_EOS
! 539 static void int1a_function();
!BCC_EOS
! 540 static void int70_function();
!BCC_EOS
! 541 static void int74_function();
!BCC_EOS
! 542 static Bit16u get_CS();
!BCC_EOS
! 543 static Bit16u get_SS();
!BCC_EOS
! 544 static unsigned int enqueue_key();
!BCC_EOS
! 545 static unsigned int dequeue_
! 545 key();
!BCC_EOS
! 546 static void get_hd_geometry();
!BCC_EOS
! 547 static void set_diskette_ret_status();
!BCC_EOS
! 548 static void set_diskette_current_cyl();
!BCC_EOS
! 549 static void determine_floppy_media();
!BCC_EOS
! 550 static bx_bool floppy_drive_exists();
!BCC_EOS
! 551 static bx_bool floppy_drive_recal();
!BCC_EOS
! 552 static bx_bool floppy_media_known();
!BCC_EOS
! 553 static bx_bool floppy_media_sense();
!BCC_EOS
! 554 static bx_bool set_enable_a20();
!BCC_EOS
! 555 static void debugger_on();
!BCC_EOS
! 556 static void debugger_off();
!BCC_EOS
! 557 static void keyboard_init();
!BCC_EOS
! 558 static void keyboard_panic();
!BCC_EOS
! 559 static void shutdown_status_panic();
!BCC_EOS
! 560 static void nmi_handler_msg();
!BCC_EOS
! 561 static void delay_ticks();
!BCC_EOS
! 562 static void delay_ticks_and_check_for_keystroke();
!BCC_EOS
! 563 static void interactive_bootkey();
!BCC_EOS
! 564 static void print_bios_banner();
!BCC_EOS
! 565 static void print_boot_device();
!BCC_EOS
! 566 static void print_boot_failure();
!BCC_EOS
! 567 static void print_cdromboot_failure();
!BCC_EOS
! 568 void ata_init();
!BCC_EOS
! 569 void ata_detect();
!BCC_EOS
! 570 void ata_reset();
!BCC_EOS
! 571 Bit16u ata_cmd_non_data();
!BCC_EOS
! 572 Bit16u ata_cmd_data_in();
!BCC_EOS
! 573 Bit16u ata_cmd_data_out();
!BCC_EOS
! 574 Bit16u ata_cmd_packet();
!BCC_EOS
! 575 Bit16u atapi_get_sense();
!BCC_EOS
! 576 Bit16u atapi_is_ready();
!BCC_EOS
! 577 Bit16u atapi_is_cdrom();
!BCC_EOS
! 578 void cdemu_init();
!BCC_EOS
! 579 Bit8u cdemu_isactive();
!BCC_EOS
! 580 Bit8u cdemu_emulated_drive();
!BCC_EOS
! 581 Bit16u cdrom_boot();
!BCC_EOS
! 582 static char bios_cvs_version_string[] = "$Revision: 1.221 $ $Date: 2008/12/07 17:32:29 $";
.data
_bios_cvs_version_string:
.1:
.ascii	"$Revision: 1.221 $ $Date: 2008/12/07 17:"
.ascii	"32:29 $"
.byte	0
!BCC_EOS
! 583 static struct {
! 584   Bit16u normal;
!BCC_EOS
! 585   Bit16u shift;
!BCC_EOS
! 586   Bit16u control;
!BCC_EOS
! 587   Bit16u alt;
!BCC_EOS
! 588   Bit8u lock_flags;
!BCC_EOS
! 589   } scan_to_scanascii[0x58 + 1] = {
_scan_to_scanascii:
! 590       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 591       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
.word	$11B
.word	$11B
.word	$11B
.word	$100
.byte	0
.blkb	1
! 592       { 0x0231, 0x0221, 0, 0x7800, 0 },
.word	$231
.word	$221
.word	0
.word	$7800
.byte	0
.blkb	1
! 593       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
.word	$332
.word	$340
.word	$300
.word	$7900
.byte	0
.blkb	1
! 594       { 0x0433, 0x0423, 0, 0x7a00, 0 },
.word	$433
.word	$423
.word	0
.word	$7A00
.byte	0
.blkb	1
! 595       { 0x0534, 0x0524, 0, 0x7b00, 0 },
.word	$534
.word	$524
.word	0
.word	$7B00
.byte	0
.blkb	1
! 596       { 0x0635, 0x0625, 0, 0x7c00, 0 },
.word	$635
.word	$625
.word	0
.word	$7C00
.byte	0
.blkb	1
! 597       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
.word	$736
.word	$75E
.word	$71E
.word	$7D00
.byte	0
.blkb	1
! 598       { 0x0837, 0x0826, 0, 0x7e00, 0 },
.word	$837
.word	$826
.word	0
.word	$7E00
.byte	0
.blkb	1
! 599       { 0x0938, 0x092a, 0, 0x7f00, 0 },
.word	$938
.word	$92A
.word	0
.word	$7F00
.byte	0
.blkb	1
! 600       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
.word	$A39
.word	$A28
.word	0
.word	$8000
.byte	0
.blkb	1
! 601       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
.word	$B30
.word	$B29
.word	0
.word	$8100
.byte	0
.blkb	1
! 602       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
.word	$C2D
.word	$C5F
.word	$C1F
.word	$8200
.byte	0
.blkb	1
! 603       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
.word	$D3D
.word	$D2B
.word	0
.word	$8300
.byte	0
.blkb	1
! 604       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
.word	$E08
.word	$E08
.word	$E7F
.word	0
.byte	0
.blkb	1
! 605       { 0x0f09, 0x0f00, 0, 0, 0 },
.word	$F09
.word	$F00
.word	0
.word	0
.byte	0
.blkb	1
! 606       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
.word	$1071
.word	$1051
.word	$1011
.word	$1000
.byte	$40
.blkb	1
! 607       { 0x1177, 0x1157, 0x1117, 
.word	$1177
.word	$1157
.word	$1117
! 607 0x1100, 0x40 },
.word	$1100
.byte	$40
.blkb	1
! 608       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
.word	$1265
.word	$1245
.word	$1205
.word	$1200
.byte	$40
.blkb	1
! 609       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
.word	$1372
.word	$1352
.word	$1312
.word	$1300
.byte	$40
.blkb	1
! 610       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
.word	$1474
.word	$1454
.word	$1414
.word	$1400
.byte	$40
.blkb	1
! 611       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
.word	$1579
.word	$1559
.word	$1519
.word	$1500
.byte	$40
.blkb	1
! 612       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
.word	$1675
.word	$1655
.word	$1615
.word	$1600
.byte	$40
.blkb	1
! 613       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
.word	$1769
.word	$1749
.word	$1709
.word	$1700
.byte	$40
.blkb	1
! 614       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
.word	$186F
.word	$184F
.word	$180F
.word	$1800
.byte	$40
.blkb	1
! 615       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
.word	$1970
.word	$1950
.word	$1910
.word	$1900
.byte	$40
.blkb	1
! 616       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
.word	$1A5B
.word	$1A7B
.word	$1A1B
.word	0
.byte	0
.blkb	1
! 617       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
.word	$1B5D
.word	$1B7D
.word	$1B1D
.word	0
.byte	0
.blkb	1
! 618       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
.word	$1C0D
.word	$1C0D
.word	$1C0A
.word	0
.byte	0
.blkb	1
! 619       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 620       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
.word	$1E61
.word	$1E41
.word	$1E01
.word	$1E00
.byte	$40
.blkb	1
! 621       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
.word	$1F73
.word	$1F53
.word	$1F13
.word	$1F00
.byte	$40
.blkb	1
! 622       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
.word	$2064
.word	$2044
.word	$2004
.word	$2000
.byte	$40
.blkb	1
! 623       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
.word	$2166
.word	$2146
.word	$2106
.word	$2100
.byte	$40
.blkb	1
! 624       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
.word	$2267
.word	$2247
.word	$2207
.word	$2200
.byte	$40
.blkb	1
! 625       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
.word	$2368
.word	$2348
.word	$2308
.word	$2300
.byte	$40
.blkb	1
! 626       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
.word	$246A
.word	$244A
.word	$240A
.word	$2400
.byte	$40
.blkb	1
! 627       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
.word	$256B
.word	$254B
.word	$250B
.word	$2500
.byte	$40
.blkb	1
! 628       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
.word	$266C
.word	$264C
.word	$260C
.word	$2600
.byte	$40
.blkb	1
! 629       { 0x273b, 0x273a, 0, 0, 0 },
.word	$273B
.word	$273A
.word	0
.word	0
.byte	0
.blkb	1
! 630       { 0x2827, 0x2822, 0, 0, 0 },
.word	$2827
.word	$2822
.word	0
.word	0
.byte	0
.blkb	1
! 631       { 0x2960, 0x297e, 0, 0, 0 },
.word	$2960
.word	$297E
.word	0
.word	0
.byte	0
.blkb	1
! 632       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 633       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
.word	$2B5C
.word	$2B7C
.word	$2B1C
.word	0
.byte	0
.blkb	1
! 634       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
.word	$2C7A
.word	$2C5A
.word	$2C1A
.word	$2C00
.byte	$40
.blkb	1
! 635       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
.word	$2D78
.word	$2D58
.word	$2D18
.word	$2D00
.byte	$40
.blkb	1
! 636       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
.word	$2E63
.word	$2E43
.word	$2E03
.word	$2E00
.byte	$40
.blkb	1
! 637       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
.word	$2F76
.word	$2F56
.word	$2F16
.word	$2F00
.byte	$40
.blkb	1
! 638       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
.word	$3062
.word	$3042
.word	$3002
.word	$3000
.byte	$40
.blkb	1
! 639       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
.word	$316E
.word	$314E
.word	$310E
.word	$3100
.byte	$40
.blkb	1
! 640       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
.word	$326D
.word	$324D
.word	$320D
.word	$3200
.byte	$40
.blkb	1
! 641       { 0x332c, 0x333c, 0, 0, 0 },
.word	$332C
.word	$333C
.word	0
.word	0
.byte	0
.blkb	1
! 642       { 0x342e, 0x343e, 0, 0, 0 },
.word	$342E
.word	$343E
.word	0
.word	0
.byte	0
.blkb	1
! 643       { 0x352f, 0x353f, 0, 0, 0 },
.word	$352F
.word	$353F
.word	0
.word	0
.byte	0
.blkb	1
! 644       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 645       { 0x372a, 0x372a, 0, 0, 0 },
.word	$372A
.word	$372A
.word	0
.word	0
.byte	0
.blkb	1
! 646       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 647       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
.word	$3920
.word	$3920
.word	$3920
.word	$3920
.byte	0
.blkb	1
! 648       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 649       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
.word	$3B00
.word	$5400
.word	$5E00
.word	$6800
.byte	0
.blkb	1
! 650       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
.word	$3C00
.word	$5500
.word	$5F00
.word	$6900
.byte	0
.blkb	1
! 651       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
.word	$3D00
.word	$5600
.word	$6000
.word	$6A00
.byte	0
.blkb	1
! 652       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
.word	$3E00
.word	$5700
.word	$6100
.word	$6B00
.byte	0
.blkb	1
! 653       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
.word	$3F00
.word	$5800
.word	$6200
.word	$6C00
.byte	0
.blkb	1
! 654       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
.word	$4000
.word	$5900
.word	$6300
.word	$6D00
.byte	0
.blkb	1
! 655       { 0x4100, 0x5a00, 0x6400, 0x6
.word	$4100
.word	$5A00
.word	$6400
! 655 e00, 0 },
.word	$6E00
.byte	0
.blkb	1
! 656       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
.word	$4200
.word	$5B00
.word	$6500
.word	$6F00
.byte	0
.blkb	1
! 657       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
.word	$4300
.word	$5C00
.word	$6600
.word	$7000
.byte	0
.blkb	1
! 658       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
.word	$4400
.word	$5D00
.word	$6700
.word	$7100
.byte	0
.blkb	1
! 659       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 660       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 661       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
.word	$4700
.word	$4737
.word	$7700
.word	0
.byte	$20
.blkb	1
! 662       { 0x4800, 0x4838, 0, 0, 0x20 },
.word	$4800
.word	$4838
.word	0
.word	0
.byte	$20
.blkb	1
! 663       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
.word	$4900
.word	$4939
.word	$8400
.word	0
.byte	$20
.blkb	1
! 664       { 0x4a2d, 0x4a2d, 0, 0, 0 },
.word	$4A2D
.word	$4A2D
.word	0
.word	0
.byte	0
.blkb	1
! 665       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
.word	$4B00
.word	$4B34
.word	$7300
.word	0
.byte	$20
.blkb	1
! 666       { 0x4c00, 0x4c35, 0, 0, 0x20 },
.word	$4C00
.word	$4C35
.word	0
.word	0
.byte	$20
.blkb	1
! 667       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
.word	$4D00
.word	$4D36
.word	$7400
.word	0
.byte	$20
.blkb	1
! 668       { 0x4e2b, 0x4e2b, 0, 0, 0 },
.word	$4E2B
.word	$4E2B
.word	0
.word	0
.byte	0
.blkb	1
! 669       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
.word	$4F00
.word	$4F31
.word	$7500
.word	0
.byte	$20
.blkb	1
! 670       { 0x5000, 0x5032, 0, 0, 0x20 },
.word	$5000
.word	$5032
.word	0
.word	0
.byte	$20
.blkb	1
! 671       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
.word	$5100
.word	$5133
.word	$7600
.word	0
.byte	$20
.blkb	1
! 672       { 0x5200, 0x5230, 0, 0, 0x20 },
.word	$5200
.word	$5230
.word	0
.word	0
.byte	$20
.blkb	1
! 673       { 0x5300, 0x532e, 0, 0, 0x20 },
.word	$5300
.word	$532E
.word	0
.word	0
.byte	$20
.blkb	1
! 674       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 675       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 676       { 0x565c, 0x567c, 0, 0, 0 },
.word	$565C
.word	$567C
.word	0
.word	0
.byte	0
.blkb	1
! 677       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
.word	$8500
.word	$8700
.word	$8900
.word	$8B00
.byte	0
.blkb	1
! 678       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
.word	$8600
.word	$8800
.word	$8A00
.word	$8C00
.byte	0
.blkb	1
! 679       };
!BCC_EOS
! 680   Bit8u
! 681 inb(port)
! 682   Bit16u port;
.text
export	_inb
_inb:
!BCC_EOS
! 683 {
! 684 #asm
!BCC_ASM
_inb.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in al, dx
    pop dx
  pop bp
! 692 endasm
!BCC_ENDASM
! 693 }
ret
! 694   Bit16u
! 695 inw(port)
! 696   Bit16u port;
export	_inw
_inw:
!BCC_EOS
! 697 {
! 698 #asm
!BCC_ASM
_inw.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in ax, dx
    pop dx
  pop bp
! 706 endasm
!BCC_ENDASM
! 707 }
ret
! 708   void
! 709 outb(port, val)
! 710   Bit16u port;
export	_outb
_outb:
!BCC_EOS
! 711   Bit8u val;
!BCC_EOS
! 712 {
! 713 #asm
!BCC_ASM
_outb.val	set	4
_outb.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov al, 6[bp]
    out dx, al
    pop dx
    pop ax
  pop bp
! 724 endasm
!BCC_ENDASM
! 725 }
ret
! 726   void
! 727 outw(port, val)
! 728   Bit16u port;
export	_outw
_outw:
!BCC_EOS
! 729   Bit16u val;
!BCC_EOS
! 730 {
! 731 #asm
!BCC_ASM
_outw.val	set	4
_outw.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov ax, 6[bp]
    out dx, ax
    pop dx
    pop ax
  pop bp
! 742 endasm
!BCC_ENDASM
! 743 }
ret
! 744   void
! 745 outb_cmos(cmos_reg, val)
! 746   Bit8u cmos_reg;
export	_outb_cmos
_outb_cmos:
!BCC_EOS
! 747   Bit8u val;
!BCC_EOS
! 748 {
! 749 #asm
!BCC_ASM
_outb_cmos.cmos_reg	set	2
_outb_cmos.val	set	4
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    mov al, 6[bp] ;; val
    out 0x71, al
  pop bp
! 757 endasm
!BCC_ENDASM
! 758 }
ret
! 759   Bit8u
! 760 inb_cmos(cmos_reg)
! 761   Bit8u cmos_reg;
export	_inb_cmos
_inb_cmos:
!BCC_EOS
! 762 {
! 763 #asm
!BCC_ASM
_inb_cmos.cmos_reg	set	2
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    in al, 0x71
  pop bp
! 770 endasm
!BCC_ENDASM
! 771 }
ret
! 772   void
! 773 init_rtc()
! 774 {
export	_init_rtc
_init_rtc:
! 775   outb_cmos(0x0a, 0x26);
push	bp
mov	bp,sp
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 776   outb_cmos(0x0b, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 777   inb_cmos(0x0c);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 778   inb_cmos(0x0d);
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 779 }
pop	bp
ret
! 780   bx_bool
! 781 rtc_u
! 781 pdating()
! 782 {
export	_rtc_updating
_rtc_updating:
! 783   Bit16u count;
!BCC_EOS
! 784   count = 25000;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
mov	ax,#$61A8
mov	-2[bp],ax
!BCC_EOS
! 785   while (--count != 0) {
jmp .3
.4:
! 786     if ( (inb_cmos(0x0a) & 0x80) == 0 )
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.5
.6:
! 787       return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 788     }
.5:
! 789   return(1);
.3:
! Debug: predec unsigned short count = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.4
.7:
.2:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 790 }
! 791   Bit8u
! 792 read_byte(seg, offset)
! 793   Bit16u seg;
export	_read_byte
_read_byte:
!BCC_EOS
! 794   Bit16u offset;
!BCC_EOS
! 795 {
! 796 #asm
!BCC_ASM
_read_byte.seg	set	2
_read_byte.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, [bx]
    ;; al = return value (byte)
    pop ds
    pop bx
  pop bp
! 809 endasm
!BCC_ENDASM
! 810 }
ret
! 811   Bit16u
! 812 read_word(seg, offset)
! 813   Bit16u seg;
export	_read_word
_read_word:
!BCC_EOS
! 814   Bit16u offset;
!BCC_EOS
! 815 {
! 816 #asm
!BCC_ASM
_read_word.seg	set	2
_read_word.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, [bx]
    ;; ax = return value (word)
    pop ds
    pop bx
  pop bp
! 829 endasm
!BCC_ENDASM
! 830 }
ret
! 831   void
! 832 write_byte(seg, offset, data)
! 833   Bit16u seg;
export	_write_byte
_write_byte:
!BCC_EOS
! 834   Bit16u offset;
!BCC_EOS
! 835   Bit8u data;
!BCC_EOS
! 836 {
! 837 #asm
!BCC_ASM
_write_byte.seg	set	2
_write_byte.data	set	6
_write_byte.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, 8[bp] ; data byte
    mov [bx], al ; write data byte
    pop ds
    pop bx
    pop ax
  pop bp
! 852 endasm
!BCC_ENDASM
! 853 }
ret
! 854   void
! 855 write_word(seg, offset, data)
! 856   Bit16u seg;
export	_write_word
_write_word:
!BCC_EOS
! 857   Bit16u offset;
!BCC_EOS
! 858   Bit16u data;
!BCC_EOS
! 859 {
! 860 #asm
!BCC_ASM
_write_word.seg	set	2
_write_word.data	set	6
_write_word.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, 8[bp] ; data word
    mov [bx], ax ; write data word
    pop ds
    pop bx
    pop ax
  pop bp
! 875 endasm
!BCC_ENDASM
! 876 }
ret
! 877   Bit16u
! 878 get_CS()
! 879 {
export	_get_CS
_get_CS:
! 880 #asm
!BCC_ASM
  mov ax, cs
! 882 endasm
!BCC_ENDASM
! 883 }
ret
! 884   Bit16u
! 885 get_SS()
! 886 {
export	_get_SS
_get_SS:
! 887 #asm
!BCC_ASM
  mov ax, ss
! 889 endasm
!BCC_ENDASM
! 890 }
ret
! 891 void
! 892 fixup_base_mem_in_k()
! 893 {
export	_fixup_base_mem_in_k
_fixup_base_mem_in_k:
! 894   Bit32u base_mem = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 8);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+6-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 895   write_word(0x40, 0x13, base_mem >> 10);
! Debug: sr int = const $A to unsigned long base_mem = [S+6-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*2
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $13 (used reg = )
mov	ax,*$13
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 896 }
mov	sp,bp
pop	bp
ret
! 897 void enable_rom_write_access()
! Register BX used in function fixup_base_mem_in_k
! 898 {
export	_enable_rom_write_access
_enable_rom_write_access:
! 899     outb(0x10, 0);
push	bp
mov	bp,sp
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 900 }
pop	bp
ret
! 901 void disable_rom_write_access()
! 902 {
export	_disable_rom_write_access
_disable_rom_write_access:
! 903     outb(0x10, 1);
push	bp
mov	bp,sp
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 904 }
pop	bp
ret
! 905   void
! 906 wrch(c)
! 907   Bit8u c;
export	_wrch
_wrch:
!BCC_EOS
! 908 {
! 909 #asm
!BCC_ASM
_wrch.c	set	2
  push bp
  mov bp, sp
  push bx
  mov ah, #0x0e
  mov al, 4[bp]
  xor bx,bx
  int #0x10
  pop bx
  pop bp
! 919 endasm
!BCC_ENDASM
! 920 }
ret
! 921   void
! 922 send(action, c)
! 923   Bit16u action;
export	_send
_send:
!BCC_EOS
! 924   Bit8u c;
!BCC_EOS
! 925 {
! 926   outb(0xE9, c);
push	bp
mov	bp,sp
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $E9 (used reg = )
mov	ax,#$E9
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 927   if (action & 8) outb(0x403, c);
! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*8
test	al,al
je  	.8
.9:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $403 (used reg = )
mov	ax,#$403
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 928   if (action & 4) outb(0x402, c);
.8:
! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*4
test	al,al
je  	.A
.B:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $402 (used reg = )
mov	ax,#$402
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 929   if (action & 2) {
.A:
! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*2
test	al,al
je  	.C
.D:
! 930     if (c == '\n') wrc
! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
cmp	al,*$A
jne 	.E
.F:
! 930 h('\r');
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 931     wrch(c);
.E:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 932   }
! 933 }
.C:
pop	bp
ret
! 934   void
! 935 put_int(action, val, width, neg)
! 936   Bit16u action;
export	_put_int
_put_int:
!BCC_EOS
! 937   short val, width;
!BCC_EOS
! 938   bx_bool neg;
!BCC_EOS
! 939 {
! 940   short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
cwd
idiv	bx
! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 941   if (nval)
mov	ax,-2[bp]
test	ax,ax
beq 	.10
.11:
! 942     put_int(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 943   else {
jmp .12
.10:
! 944     while (--width > 0) send(action, ' ');
jmp .14
.15:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 945     if (neg) send(action, '-');
.14:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.15
.16:
.13:
mov	ax,$A[bp]
test	ax,ax
je  	.17
.18:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 946   }
.17:
! 947   send(action, val - (nval * 10) + '0');
.12:
! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to int = ax+0 (used reg = )
! Debug: list int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 948 }
mov	sp,bp
pop	bp
ret
! 949   void
! Register BX used in function put_int
! 950 put_uint(action, val, width, neg)
! 951   Bit16u action;
export	_put_uint
_put_uint:
!BCC_EOS
! 952   unsigned short val;
!BCC_EOS
! 953   short width;
!BCC_EOS
! 954   bx_bool neg;
!BCC_EOS
! 955 {
! 956   unsigned short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
call	idiv_u
! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 957   if (nval)
mov	ax,-2[bp]
test	ax,ax
je  	.19
.1A:
! 958     put_uint(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 959   else {
jmp .1B
.19:
! 960     while (--width > 0) send(action, ' ');
jmp .1D
.1E:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 961     if (neg) send(action, '-');
.1D:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.1E
.1F:
.1C:
mov	ax,$A[bp]
test	ax,ax
je  	.20
.21:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 962   }
.20:
! 963   send(action, val - (nval * 10) + '0');
.1B:
! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 964 }
mov	sp,bp
pop	bp
ret
! 965   void
! Register BX used in function put_uint
! 966 put_luint(action, val, width, neg)
! 967   Bit16u action;
export	_put_luint
_put_luint:
!BCC_EOS
! 968   unsigned long val;
!BCC_EOS
! 969   short width;
!BCC_EOS
! 970   bx_bool neg;
!BCC_EOS
! 971 {
! 972   unsigned long nval = val / 10;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
mov	ax,*$A
xor	bx,bx
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 973   if (nval)
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
je  	.22
.23:
! 974     put_luint(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+6+$A] (used reg = )
push	$C[bp]
! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned long nval = [S+$A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short action = [S+$E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 975   else {
jmp .24
.22:
! 976     while (--width > 0) send(action, ' ');
jmp .26
.27:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 977     if (neg) send(action, '-');
.26:
! Debug: predec short width = [S+6+8] (used reg = )
mov	ax,$A[bp]
dec	ax
mov	$A[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.27
.28:
.25:
mov	ax,$C[bp]
test	ax,ax
je  	.29
.2A:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 978   }
.29:
! 979   send(action, val - (nval * 10) + '0');
.24:
! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$A
xor	bx,bx
lea	di,-4[bp]
call	lmulul
! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	lsubul
add	sp,*4
! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$30
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-$C[bp]
call	laddul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*6
!BCC_EOS
! 980 }
mov	sp,bp
pop	bp
ret
! 981 void put_str(action, segment, offset)
! Register BX used in function put_luint
! 982   Bit16u action;
export	_put_str
_put_str:
!BCC_EOS
! 983   Bit16u segment;
!BCC_EOS
! 984   Bit16u offset;
!BCC_EOS
! 985 {
! 986   Bit8u c;
!BCC_EOS
! 987   while (c = read_byte(segment, offset)) {
push	bp
mov	bp,sp
dec	sp
dec	sp
jmp .2C
.2D:
! 988     send(action, c);
! Debug: list unsigned char c = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 989     offset++;
! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
mov	ax,8[bp]
inc	ax
mov	8[bp],ax
!BCC_EOS
! 990   }
! 991 }
.2C:
! Debug: list unsigned short offset = [S+4+6] (used reg = )
push	8[bp]
! Debug: list unsigned short segment = [S+6+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
mov	-1[bp],al
test	al,al
jne	.2D
.2E:
.2B:
mov	sp,bp
pop	bp
ret
! 992   void
! 993 delay_ticks(ticks)
! 994   Bit16u ticks;
export	_delay_ticks
_delay_ticks:
!BCC_EOS
! 995 {
! 996   long ticks_to_wait, delta;
!BCC_EOS
! 997   Bit32u prev_ticks, t;
!BCC_EOS
! 998 #asm
push	bp
mov	bp,sp
add	sp,*-$10
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  pushf
  sti
! 1001 endasm
!BCC_ENDASM
!BCC_EOS
! 1002   ticks_to_wait = ticks;
! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,4[bp]
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1003   prev_ticks = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 1004   do
! 1005   {
.31:
! 1006 #asm
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
    hlt
! 1008 endasm
!BCC_ENDASM
!BCC_EOS
! 1009     t = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 1010     if (t > prev_ticks)
! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jae 	.32
.33:
! 1011     {
! 1012       delta = t - prev_ticks;
! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
lea	di,-$C[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1013       ticks_to_wait -= delta;
! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-8[bp]
call	lsubl
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1014     }
! 1015     else if (t < prev_ticks)
jmp .34
.32:
! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jbe 	.35
.36:
! 1016     {
! 1017       ticks_to_wait -= t;
! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-$10[bp]
call	lsubul
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1018     }
! 1019     prev_ticks = t;
.35:
.34:
! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 1020   } while (ticks_to_wait > 0);
.30:
! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
xor	ax,ax
xor	bx,bx
lea	di,-4[bp]
call	lcmpl
blt 	.31
.37:
!BCC_EOS
! 1021 #asm
.2F:
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  cli
  popf
! 1024 endasm
!BCC_ENDASM
!BCC_EOS
! 1025 }
mov	sp,bp
pop	bp
ret
! 1026   Bit8u
! Register BX used in function delay_ticks
! 1027 check_for_keystroke()
! 1028 {
export	_check_for_keystroke
_check_for_keystroke:
! 1029 #asm
!BCC_ASM
  mov ax, #0x100
  int #0x16
  jz no_key
  mov al, #1
  jmp done
no_key:
  xor al, al
done:
! 1038 endasm
!BCC_ENDASM
! 1039 }
ret
! 1040   Bit8u
! 1041 get_keystroke()
! 1042 {
export	_get_keystroke
_get_keystroke:
! 1043 #asm
!BCC_ASM
  mov ax, #0x0
  int #0x16
  xchg ah, al
! 1047 endasm
!BCC_ENDASM
! 1048 }
ret
! 1049   void
! 1050 delay_ticks_and_check_for_keystroke(ticks, count)
! 1051   Bit16u ticks, count;
export	_delay_ticks_and_check_for_keystroke
_delay_ticks_and_check_for_keystroke:
!BCC_EOS
! 1052 {
! 1053   Bit16u i;
!BCC_EOS
! 1054   for (i = 1; i <= count; i++) {
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
!BCC_EOS
jmp .3A
.3B:
! 1055     delay_ticks(ticks)
! 1055 ;
! Debug: list unsigned short ticks = [S+4+2] (used reg = )
push	4[bp]
! Debug: func () void = delay_ticks+0 (used reg = )
call	_delay_ticks
inc	sp
inc	sp
!BCC_EOS
! 1056     if (check_for_keystroke())
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
je  	.3C
.3D:
! 1057       break;
jmp .38
!BCC_EOS
! 1058   }
.3C:
! 1059 }
.39:
! Debug: postinc unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
inc	ax
mov	-2[bp],ax
.3A:
! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,6[bp]
jbe	.3B
.3E:
.38:
mov	sp,bp
pop	bp
ret
! 1060   void
! 1061 bios_printf(action, s)
! 1062   Bit16u action;
export	_bios_printf
_bios_printf:
!BCC_EOS
! 1063   Bit8u *s;
!BCC_EOS
! 1064 {
! 1065   Bit8u c, format_char;
!BCC_EOS
! 1066   bx_bool in_format;
!BCC_EOS
! 1067   short i;
!BCC_EOS
! 1068   Bit16u *arg_ptr;
!BCC_EOS
! 1069   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
!BCC_EOS
! 1070   arg_ptr = &s;
push	bp
mov	bp,sp
add	sp,*-$16
! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
lea	bx,6[bp]
mov	-8[bp],bx
!BCC_EOS
! 1071   arg_seg = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 1072   in_format = 0;
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1073   format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1074   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*7
! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
cmp	al,*7
jne 	.3F
.40:
! 1075     outb(0x401, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $401 (used reg = )
mov	ax,#$401
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1076     bios_printf (2, "FATAL: ");
! Debug: list * char = .41+0 (used reg = )
mov	bx,#.41
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1077   }
! 1078   while (c = read_byte(get_CS(), s)) {
.3F:
br 	.43
.44:
! 1079     if ( c == '%' ) {
! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$25
jne 	.45
.46:
! 1080       in_format = 1;
! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
mov	ax,*1
mov	-4[bp],ax
!BCC_EOS
! 1081       format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1082       }
! 1083     else if (in_format) {
br 	.47
.45:
mov	ax,-4[bp]
test	ax,ax
beq 	.48
.49:
! 1084       if ( (c>='0') && (c<='9') ) {
! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$30
jb  	.4A
.4C:
! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$39
ja  	.4A
.4B:
! 1085         format_width = (format_width * 10) + (c - '0');
! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
add	ax,*-$30
push	ax
! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
add	ax,-$18[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1086         }
! 1087       else {
br 	.4D
.4A:
! 1088         arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1089         arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1090         if (c == 'x' || c == 'X') {
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.4F
.50:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
jne 	.4E
.4F:
! 1091           if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.51
.52:
! 1092             format_width = 4;
! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*4
mov	-$14[bp],ax
!BCC_EOS
! 1093           if (c == 'x')
.51:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.53
.54:
! 1094             hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1095           else
! 1096             hexadd = 'A';
jmp .55
.53:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1097           for (i=format_width-1; i>=0; i--) {
.55:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .58
.59:
! 1098             nibble = (arg >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	bx,ax
mov	ax,-$C[bp]
mov	cx,bx
shr	ax,cl
! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 1099             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.5A
.5B:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .5C
.5A:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.5C:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1100             }
! 1101           }
.57:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.58:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.59
.5D:
.56:
! 1102         else if (c == 'u') {
br 	.5E
.4E:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.5F
.60:
! 1103           put_uint(action, arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 1104           }
! 1105         else if (c == 'l') {
br 	.61
.5F:
! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$6C
bne 	.62
.63:
! 1106           s++;
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1107           c = read_byte(get_CS(), s);
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1108           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1109           hibyte = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 1110           if (c == 'd') {
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
bne 	.64
.65:
! 1111             if (hibyte & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$10[bp]
and	ax,#$8000
test	ax,ax
je  	.66
.67:
! 1112               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
push	bx
push	ax
xor	ax,ax
xor	bx,bx
lea	di,-$1E[bp]
call	lsubul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1113             else
! 1114               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
jmp .68
.66:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1115            }
.68:
! 1116           else if (c == 'u') {
br 	.69
.64:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.6A
.6B:
! 1117             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1118            }
! 1119           else if (c == 'x' || c == 'X')
br 	.6C
.6A:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.6E
.6F:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
bne 	.6D
.6E:
! 1120            {
! 1121             if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.70
.71:
! 1122               format_width = 8;
! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*8
mov	-$14[bp],ax
!BCC_EOS
! 1123             if (c == 'x')
.70:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.72
.73:
! 1124               hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1125             else
! 1126               hexadd = 'A';
jmp .74
.72:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1127             for (i=format_width-1; i>=0; i--) {
.74:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .77
.78:
! 1128             
! 1128   nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
lea	di,-$1C[bp]
call	lorul
add	sp,*4
! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
mov	di,-$18[bp]
call	lsrul
inc	sp
inc	sp
! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 1129               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.79
.7A:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .7B
.79:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.7B:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1130               }
! 1131            }
.76:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.77:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.78
.7C:
.75:
! 1132           }
.6D:
.6C:
.69:
! 1133         else if (c == 'd') {
br 	.7D
.62:
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
jne 	.7E
.7F:
! 1134           if (arg & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
mov	ax,-$C[bp]
and	ax,#$8000
test	ax,ax
je  	.80
.81:
! 1135             put_int(action, -arg, format_width - 1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
xor	ax,ax
sub	ax,-$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1136           else
! 1137             put_int(action, arg, format_width, 0);
jmp .82
.80:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1138           }
.82:
! 1139         else if (c == 's') {
jmp .83
.7E:
! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$73
jne 	.84
.85:
! 1140           put_str(action, get_CS(), arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1141           }
! 1142         else if (c == 'S') {
jmp .86
.84:
! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
jne 	.87
.88:
! 1143           hibyte = arg;
! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$C[bp]
mov	-$10[bp],ax
!BCC_EOS
! 1144           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1145           arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1146           put_str(action, hibyte, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1147           }
! 1148         else if (c == 'c') {
jmp .89
.87:
! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$63
jne 	.8A
.8B:
! 1149           send(action, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1150           }
! 1151         else
! 1152           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
jmp .8C
.8A:
! Debug: list * char = .8D+0 (used reg = )
mov	bx,#.8D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1153           in_format = 0;
.8C:
.89:
.86:
.83:
.7D:
.61:
.5E:
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1154         }
! 1155       }
.4D:
! 1156     else {
jmp .8E
.48:
! 1157       send(action, c);
! Debug: list unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1158       }
! 1159     s ++;
.8E:
.47:
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1160     }
! 1161   if (action & 1) {
.43:
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
test	al,al
bne 	.44
.8F:
.42:
! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*1
test	al,al
je  	.90
.91:
! 1162 #asm
!BCC_EOS
!BCC_ASM
_bios_printf.format_width	set	2
.bios_printf.format_width	set	-$14
_bios_printf.format_char	set	$14
.bios_printf.format_char	set	-2
_bios_printf.hibyte	set	6
.bios_printf.hibyte	set	-$10
_bios_printf.arg_ptr	set	$E
.bios_printf.arg_ptr	set	-8
_bios_printf.action	set	$1A
.bios_printf.action	set	4
_bios_printf.i	set	$10
.bios_printf.i	set	-6
_bios_printf.arg_seg	set	$C
.bios_printf.arg_seg	set	-$A
_bios_printf.shift_count	set	4
.bios_printf.shift_count	set	-$12
_bios_printf.in_format	set	$12
.bios_printf.in_format	set	-4
_bios_printf.s	set	$1C
.bios_printf.s	set	6
_bios_printf.nibble	set	8
.bios_printf.nibble	set	-$E
_bios_printf.c	set	$15
.bios_printf.c	set	-1
_bios_printf.hexadd	set	0
.bios_printf.hexadd	set	-$16
_bios_printf.arg	set	$A
.bios_printf.arg	set	-$C
    cli
 halt2_loop:
    hlt
    jmp halt2_loop
! 1167 endasm
!BCC_ENDASM
!BCC_EOS
! 1168     }
! 1169 }
.90:
mov	sp,bp
pop	bp
ret
! 1170   void
! Register BX used in function bios_printf
! 1171 keyboard_init()
! 1172 {
export	_keyboard_init
_keyboard_init:
! 1173     Bit16u max;
!BCC_EOS
! 1174     max=0xffff;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1175     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .93
.94:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1176     max=2;
.93:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.95
.96:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.94
.95:
.92:
! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
mov	ax,*2
mov	-2[bp],ax
!BCC_EOS
! 1177     while (--max > 0) {
jmp .98
.99:
! 1178         outb(0x80, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1179         if (inb(0x64) & 0x01) {
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
je  	.9A
.9B:
! 1180             inb(0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 1181             max = 2;
! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
mov	ax,*2
mov	-2[bp],ax
!BCC_EOS
! 1182             }
! 1183         }
.9A:
! 1184     outb(0x64, 0xaa);
.98:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.99
.9C:
.97:
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1185     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1186     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .9E
.9F:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1187     if (max==0x0) keyboard_panic(00);
.9E:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.A0
.A1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.9F
.A0:
.9D:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A2
.A3:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1188     max=0xffff;
.A2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1189     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
jmp .A5
.A6:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1190     if (max==0x0) keyboard_panic(01);
.A5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.A7
.A8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.A6
.A7:
.A4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A9
.AA:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1191     if ((inb(0x60) != 0x55)){
.A9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
cmp	al,*$55
je  	.AB
.AC:
! 1192         keyboard_panic(991);
! Debug: list int = const $3DF (used reg = )
mov	ax,#$3DF
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1193     }
! 1194     outb(0x64,0xab);
.AB:
! Debug: list int = const $AB (used reg = )
mov	ax,#$AB
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1195     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1196     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
jmp .AE
.AF:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1197     if (max==0x0) keyboard_panic(10);
.AE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.B0
.B1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.AF
.B0:
.AD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B2
.B3:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1198     max=0xffff;
.B2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1199     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
jmp .B5
.B6:
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1200     if (max==0x0) keyboard_panic(11);
.B5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.B7
.B8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.B6
.B7:
.B4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B9
.BA:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1201     if ((inb(0x60) != 0x00)) {
.B9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.BB
.BC:
! 1202         keyboard_panic(992);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1203     }
! 1204     outb(0x64,0xae);
.BB:
! Debug: list int = const $AE (used reg = )
mov	ax,#$AE
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1205     outb(0x64,0xa8);
! Debug: list int = const $A8 (used reg = )
mov	ax,#$A8
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1206     outb(0x60, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1207     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1208     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20)
jmp .BE
.BF:
! 1208 ;
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1209     if (max==0x0) keyboard_panic(20);
.BE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.C0
.C1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.BF
.C0:
.BD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C2
.C3:
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1210     max=0xffff;
.C2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1211     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
jmp .C5
.C6:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1212     if (max==0x0) keyboard_panic(21);
.C5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.C7
.C8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.C6
.C7:
.C4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C9
.CA:
! Debug: list int = const $15 (used reg = )
mov	ax,*$15
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1213     if ((inb(0x60) != 0xfa)) {
.C9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.CB
.CC:
! 1214         keyboard_panic(993);
! Debug: list int = const $3E1 (used reg = )
mov	ax,#$3E1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1215     }
! 1216     max=0xffff;
.CB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1217     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
jmp .CE
.CF:
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1218     if (max==0x0) keyboard_panic(31);
.CE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.D0
.D1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.CF
.D0:
.CD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.D2
.D3:
! Debug: list int = const $1F (used reg = )
mov	ax,*$1F
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1219     if ((inb(0x60) != 0xaa)) {
.D2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
cmp	al,#$AA
je  	.D4
.D5:
! 1220         keyboard_panic(994);
! Debug: list int = const $3E2 (used reg = )
mov	ax,#$3E2
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1221     }
! 1222     outb(0x60, 0xf5);
.D4:
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1223     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1224     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
jmp .D7
.D8:
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1225     if (max==0x0) keyboard_panic(40);
.D7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.D9
.DA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.D8
.D9:
.D6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.DB
.DC:
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1226     max=0xffff;
.DB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1227     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
jmp .DE
.DF:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1228     if (max==0x0) keyboard_panic(41);
.DE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.E0
.E1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.DF
.E0:
.DD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.E2
.E3:
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1229     if ((inb(0x60) != 0xfa)) {
.E2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.E4
.E5:
! 1230         keyboard_panic(995);
! Debug: list int = const $3E3 (used reg = )
mov	ax,#$3E3
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1231     }
! 1232     outb(0x64, 0x60);
.E4:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1233     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1234     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
jmp .E7
.E8:
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1235     if (max==0x0) keyboard_panic(50);
.E7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.E9
.EA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.E8
.E9:
.E6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.EB
.EC:
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1236     outb(0x60, 0x61);
.EB:
! Debug: list int = const $61 (used reg = )
mov	ax,*$61
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1237     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1238     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
jmp .EE
.EF:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1239     if (max==0x0) keyboard_panic(60);
.EE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F0
.F1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.EF
.F0:
.ED:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F2
.F3:
! Debug: list int = const $3C (used reg = )
mov	ax,*$3C
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1240     outb(0x60, 0xf4);
.F2:
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1241     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1242     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
jmp .F5
.F6:
! Debug: list int = const $70 (used reg = )
mov	ax,*$70
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1243     if (max==0x0) keyboard_panic(70);
.F5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F7
.F8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.F6
.F7:
.F4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F9
.FA:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1244     max=0xffff;
.F9:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1245     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
jmp .FC
.FD:
! Debug: list int = const $71 (used reg = )
mov	ax,*$71
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1246     if (max==0x0) keyboard_panic(70);
.FC:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.FE
.FF:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.FD
.FE:
.FB:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.100
.101:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1247     if ((inb(0x60) != 0xfa)) {
.100:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.102
.103:
! 1248         keyboard_panic(996);
! Debug: list int = const $3E4 (used reg = )
mov	ax,#$3E4
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1249     }
! 1250     outb(0x80, 0x77);
.102:
! Debug: list int = const $77 (used reg = )
mov	ax,*$77
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1251 }
mov	sp,bp
pop	bp
ret
! 1252   void
! 1253 keyboard_panic(status)
! 1254   Bit16u status;
export	_keyboard_panic
_keyboard_panic:
!BCC_EOS
! 1255 {
! 1256   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
push	bp
mov	bp,sp
! Debug: list unsigned short status = [S+2+2] (used reg = )
push	4[bp]
! Debug: list * char = .104+0 (used reg = )
mov	bx,#.104
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1257 }
pop	bp
ret
! 1258   void
! Register BX used in function keyboard_panic
! 1259 machine_reset()
! 1260 {
export	_machine_reset
_machine_reset:
! 1261 #asm
!BCC_ASM
;we must check whether 0xFE is set or not
;if it is s3 resume, just jmp back to normal Post Entry
;below port io will prevent s3 resume
  mov al, #0x0f
  out 0x70, al
  in al, 0x71
  cmp al, #0xFE
  jz post
! 1270 endasm
!BCC_ENDASM
! 1271   outb(0x64, 0x60);
push	bp
mov	bp,sp
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1272   outb(0x60, 0x14);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1273   outb(0x64, 0xfe);
! Debug: list int = const $FE (used reg = )
mov	ax,#$FE
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1274   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
! Debug: list * char = .105+0 (used reg = )
mov	bx,#.105
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1275 }
pop	bp
ret
! 1276   void
! Register BX used in function machine_reset
! 1277 clobber_entry_point()
! 1278 {
export	_clobber_entry_point
_clobber_entry_point:
! 1279     write_word(0xffff, 0x0001, machine_reset);
push	bp
mov	bp,sp
! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
! Debug: list * () void = machine_reset+0 (used reg = )
mov	bx,#_machine_reset
push	bx
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 1280 }
pop	bp
ret
! 1281   void
! Register BX used in function clobber_entry_point
! 1282 shutdown_status_panic(status)
! 1283   Bit16u status;
export	_shutdown_status_panic
_shutdown_status_panic:
!BCC_EOS
! 1284 {
! 1285   bios_printf((2 | 4 | 1), "Unimplemented shutdown statu
push	bp
mov	bp,sp
! 1285 s: %02x\n",(Bit8u)status);
! Debug: list unsigned char status = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list * char = .106+0 (used reg = )
mov	bx,#.106
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1286 }
pop	bp
ret
! 1287 void s3_resume_panic()
! Register BX used in function shutdown_status_panic
! 1288 {
export	_s3_resume_panic
_s3_resume_panic:
! 1289   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
push	bp
mov	bp,sp
! Debug: list * char = .107+0 (used reg = )
mov	bx,#.107
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1290 }
pop	bp
ret
! 1291 void
! Register BX used in function s3_resume_panic
! 1292 print_bios_banner()
! 1293 {
export	_print_bios_banner
_print_bios_banner:
! 1294   int i = 0;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const 0 to int i = [S+4-4] (used reg = )
xor	ax,ax
mov	-2[bp],ax
!BCC_EOS
! 1295   for (; i < 1; i++)
!BCC_EOS
!BCC_EOS
! 1296     bios_printf(2, "Processor %d: Xen(R) Virtual CPU\n", i+1);
jmp .10A
.10B:
! Debug: add int = const 1 to int i = [S+4-4] (used reg = )
mov	ax,-2[bp]
! Debug: list int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * char = .10C+0 (used reg = )
mov	bx,#.10C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1297 }
.109:
! Debug: postinc int i = [S+4-4] (used reg = )
mov	ax,-2[bp]
inc	ax
mov	-2[bp],ax
.10A:
! Debug: lt int = const 1 to int i = [S+4-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,*1
jl 	.10B
.10D:
.108:
mov	sp,bp
pop	bp
ret
! 1298 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
! Register BX used in function print_bios_banner
.data
_drivetypes:
.10E:
.byte	0
.blkb	9
.10F:
.ascii	"Floppy"
.byte	0
.blkb	3
.110:
.ascii	"Hard Disk"
.byte	0
.111:
.ascii	"CD-Rom"
.byte	0
.blkb	3
.112:
.ascii	"Network"
.byte	0
.blkb	2
!BCC_EOS
! 1299 static void
! 1300 init_boot_vectors()
! 1301 {
.text
_init_boot_vectors:
! 1302   ipl_entry_t e;
!BCC_EOS
! 1303   Bit16u count = 0;
push	bp
mov	bp,sp
add	sp,*-$12
! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
xor	ax,ax
mov	-$12[bp],ax
!BCC_EOS
! 1304   Bit16u ss = get_SS();
dec	sp
dec	sp
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1305   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$18-$18] (used reg = )
mov	-$16[bp],ax
!BCC_EOS
! 1306   memsetb(ebda_seg, 0x0300, 0, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $300 (used reg = )
mov	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$1E-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 1307   write_word(ebda_seg, 0x0384, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1308   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 1 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*1
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1309   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1310   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1311   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 2 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*2
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1312   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1313   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1314   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 3 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*3
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1315   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1316   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1317   write_word(ebda_seg, 0x0380, count);
! Debug: list unsigned short count = [S+$18-$14] (used reg = )
push	-$12[bp]
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1318   write_word(ebda_seg, 0x0382, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $382 (used reg = )
mov	ax,#$382
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1319 }
mov	sp,bp
pop	bp
ret
! 1320 static Bit8u
! Register BX used in function init_boot_vectors
! 1321 get_boot_vector(i, e)
! 1322 Bit16u i; ipl_entry_t *e;
_get_boot_vector:
!BCC_EOS
!BCC_EOS
! 1323 {
! 1324   Bit16u count;
!BCC_EOS
! 1325   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-4
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1326   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1327   count = read_word(ebda_seg, 0x0380);
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-8] (used reg = )
push	-6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+8-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1328   if (i >= count) return 0;
! Debug: ge unsigned short count = [S+8-4] to unsigned short i = [S+8+2] (used reg = )
mov	ax,4[bp]
cmp	ax,-2[bp]
jb  	.113
.114:
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1329   memcpyb(ss, e, ebda_seg, 0x0300 + i * sizeof (*e), sizeof (*e));
.113:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
mov	ax,4[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-8] (used reg = )
push	-6[bp]
! Debug: list * struct  e = [S+$E+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$10-6] (used reg = )
push	-4[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1330   return 1;
mov	al,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1331 }
! 1332   void
! 1333 interactive_bootkey()
! 1334 {
export	_interactive_bootkey
_interactive_bootkey:
! 1335   ipl_entry_t e;
!BCC_EOS
! 1336   Bit16u count;
!BCC_EOS
! 1337   char description[33];
!BCC_EOS
! 1338   Bit8u scan_code;
!BCC_EOS
! 1339   Bit8u i;
!BCC_EOS
! 1340   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$38
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
mov	-$38[bp],ax
!BCC_EOS
! 1341   Bit16u valid_choice = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
xor	ax,ax
mov	-$3A[bp],ax
!BCC_EOS
! 1342   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$3E-$3E] (used reg = )
mov	-$3C[bp],ax
!BCC_EOS
! 1343   bios_printf(2, "\n\nPress F12 for boot menu.\n\n");
! Debug: list * char = .115+0 (used reg = )
mov	bx,#.115
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1344   while (check_for_keystroke())
! 1345   {
br 	.117
.118:
! 1346     scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1347     if (scan_code != 0x86)
! Debug: ne int = const $86 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,#$86
je  	.119
.11A:
! 1348       continue;
br 	.117
!BCC_EOS
! 1349     while (check_for_keystroke())
.119:
! 1350       get_keystroke();
jmp .11C
.11D:
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
!BCC_EOS
! 1351     bios_printf(2, "Select boot device:\n\n");
.11C:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
jne	.11D
.11E:
.11B:
! Debug: list * char = .11F+0 (used reg = )
mov	bx,#.11F
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1352     count = read_word(ebda_seg, 0x0380);
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$40-$3E] (used reg = )
push	-$3C[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3E-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 1353     for (i = 0; i < count; i++)
! Debug: eq int = const 0 to unsigned char i = [S+$3E-$37] (used reg = )
xor	al,al
mov	-$35[bp],al
!BCC_EOS
!BCC_EOS
! 1354     {
br 	.122
.123:
! 1355       memcpyb(ss, &e, ebda_seg, 0x0300 + i * sizeof (e), sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
push	-$3C[bp]
! Debug: list * struct  e = S+$44-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1356       bios_printf
! 1356 (2, "%d. ", i+1);
! Debug: add int = const 1 to unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * char = .124+0 (used reg = )
mov	bx,#.124
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1357       switch(e.type)
mov	ax,-$10[bp]
! 1358       {
br 	.127
! 1359         case 0x01:
! 1360         case 0x02:
.128:
! 1361         case 0x03:
.129:
! 1362           bios_printf(2, "%s\n", drivetypes[e.type]);
.12A:
! Debug: ptradd unsigned short e = [S+$3E-$12] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,-$10[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .12B+0 (used reg = )
mov	bx,#.12B
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1363           break;
br 	.125
!BCC_EOS
! 1364         case 0x80:
! 1365           bios_printf(2, "%s", drivetypes[4]);
.12C:
! Debug: list * char = drivetypes+$28 (used reg = )
mov	bx,#_drivetypes+$28
push	bx
! Debug: list * char = .12D+0 (used reg = )
mov	bx,#.12D
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1366           if (e.description != 0)
! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3E-$A] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-2+..FFFF[bp]
call	lcmpul
lea	sp,2+..FFFF[bp]
je  	.12E
.12F:
! 1367           {
! 1368             memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$40-$A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-8[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: sr int = const $10 to unsigned long e = [S+$42-$A] (used reg = )
mov	ax,-8[bp]
mov	bx,-6[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$44-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1369             description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$3E-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 1370             bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$3E-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$40-$3A] (used reg = )
push	-$38[bp]
! Debug: list * char = .130+0 (used reg = )
mov	bx,#.130
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1371          }
! 1372          bios_printf(2, "\n");
.12E:
! Debug: list * char = .131+0 (used reg = )
mov	bx,#.131
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1373          break;
jmp .125
!BCC_EOS
! 1374       }
! 1375     }
jmp .125
.127:
sub	ax,*1
beq 	.128
sub	ax,*1
beq 	.129
sub	ax,*1
beq 	.12A
sub	ax,*$7D
beq 	.12C
.125:
..FFFF	=	-$3E
! 1376     count++;
.121:
! Debug: postinc unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
inc	ax
mov	-$35[bp],al
.122:
! Debug: lt unsigned short count = [S+$3E-$14] to unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
cmp	ax,-$12[bp]
blo 	.123
.132:
.120:
! Debug: postinc unsigned short count = [S+$3E-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1377     while (!valid_choice) {
jmp .134
.135:
! 1378       scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1379       if (scan_code == 0x01 || scan_code == 0x58)
! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*1
je  	.137
.138:
! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*$58
jne 	.136
.137:
! 1380       {
! 1381         valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1382       }
! 1383       else if (scan_code <= count)
jmp .139
.136:
! Debug: le unsigned short count = [S+$3E-$14] to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
cmp	ax,-$12[bp]
ja  	.13A
.13B:
! 1384       {
! 1385         valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1386         scan_code -= 1;
! Debug: subab int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
dec	ax
mov	-$34[bp],al
!BCC_EOS
! 1387         write_word(ebda_seg, 0x0384, scan_code);
! Debug: list unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
push	-$3C[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1388       }
! 1389     }
.13A:
.139:
! 1390     bios_printf(2, "\n");
.134:
mov	ax,-$3A[bp]
test	ax,ax
je 	.135
.13C:
.133:
! Debug: list * char = .13D+0 (used reg = )
mov	bx,#.13D
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1391     break;
jmp .116
!BCC_EOS
! 1392   }
! 1393 }
.117:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
bne 	.118
.13E:
.116:
mov	sp,bp
pop	bp
ret
! 1394 void
! Register BX used in function interactive_bootkey
! 1395 print_boot_device(type, desc)
! 1396   Bit16u type; Bit32u desc;
export	_print_boot_device
_print_boot_device:
!BCC_EOS
!BCC_EOS
! 1397 {
! 1398   char description[33];
!BCC_EOS
! 1399   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$24
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$26-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 1400   if (type == 0x80) type = 0x4;
! Debug: logeq int = const $80 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,#$80
jne 	.13F
.140:
! Debug: eq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,*4
mov	4[bp],ax
!BCC_EOS
! 1401   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
.13F:
! Debug: logeq int = const 0 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
je  	.142
.143:
! Debug: gt int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jbe 	.141
.142:
! Debug: list * char = .144+0 (used reg = )
mov	bx,#.144
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1402   bios_printf(2, "Boot device: %s", drivetypes[type]);
.141:
! Debug: ptradd unsigned short type = [S+$26+2] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,4[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .145+0 (used reg = )
mov	bx,#.145
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1403   if (type == 4 && desc != 0) {
! Debug: logeq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jne 	.146
.148:
! Debug: ne unsigned long = const 0 to unsigned long desc = [S+$26+4] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-$28[bp]
call	lcmpul
lea	sp,-$24[bp]
je  	.146
.147:
! 1404     memcpyb(ss, &description, (Bit16u)(desc >> 16), (Bit16u)(desc & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: and unsigned long = const $FFFF to unsigned long desc = [S+$28+4] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,6[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: sr int = const $10 to unsigned long desc = [S+$2A+4] (used reg = )
mov	ax,6[bp]
mov	bx,8[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$2C-$23 (used reg = )
lea	bx,-$21[bp]
push	bx
! Debug: list unsigned short ss = [S+$2E-$26] (used reg = )
push	-$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1405     description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$26-3] (used reg = )
xor	al,al
mov	-1[bp],al
!BCC_EOS
! 1406     bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$26-$23 (used reg = )
lea	bx,-$21[bp]
push	bx
! Debug: list unsigned short ss = [S+$28-$26] (used reg = )
push	-$24[bp]
! Debug: list * char = .149+0 (used reg = )
mov	bx,#.149
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1407   }
! 1408 }
.146:
mov	sp,bp
pop	bp
ret
! 1409   void
! Register BX used in function print_boot_device
! 1410 print_boot_failure(type, reason)
! 1411   Bit16u type; Bit8u reason;
export	_print_boot_failure
_print_boot_failure:
!BCC_EOS
!BCC_EOS
! 1412 {
! 1413   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
push	bp
mov	bp,sp
! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
je  	.14B
.14C:
! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*3
jbe 	.14A
.14B:
! Debug: list * char = .14D+0 (used reg = )
mov	bx,#.14D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1414   bios_printf(2, " - failure", drivetypes[type]);
.14A:
! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,4[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .14E+0 (used reg = )
mov	bx,#.14E
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1415   if (type < 4) {
! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jae 	.14F
.150:
! 1416     if (reason==0)
! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
mov	al,6[bp]
test	al,al
jne 	.151
.152:
! 1417       bios_printf(2, ": disk not bootable");
! Debug: list * char = .153+0 (used reg = )
mov	bx,#.153
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1418     else
! 1419       bios_printf(2, ": could not read boot disk");
jmp .154
.151:
! Debug: list * char = .155+0 (used reg = )
mov	bx,#.155
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1420   }
.154:
! 1421   bios_printf(2, "\n\n");
.14F:
! Debug: list * char = .156+0 (used reg = )
mov	bx,#.156
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1422 }
pop	bp
ret
! 1423   void
! Register BX used in function print_boot_failure
! 1424 print_cdromboot_failure( code )
! 1425   Bit16u code;
export	_print_cdromboot_failure
_print_cdromboot_failure:
!BCC_EOS
! 1426 {
! 1427   return;
push	bp
mov	bp,sp
pop	bp
ret
!BCC_EOS
! 1428 }
! 1429 void
! 1430 nmi_handler_msg()
! 1431 {
export	_nmi_handler_msg
_nmi_handler_msg:
! 1432   bios_printf((2 | 4 | 1), "NMI Handler called\n");
push	bp
mov	bp,sp
! Debug: list * char = .157+0 (used reg = )
mov	bx,#.157
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1433 }
pop	bp
ret
! 1434 void
! Register BX used in function nmi_handler_msg
! 1435 int18_panic_msg()
! 1436 {
export	_int18_panic_msg
_int18_panic_msg:
! 1437   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
push	bp
mov	bp,sp
! Debug: list * char = .158+0 (used reg = )
mov	bx,#.158
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1438 }
pop	bp
ret
! 1439 void
! Register BX used in function int18_panic_msg
! 1440 log_bios_start()
! 1441 {
export	_log_bios_start
_log_bios_start:
! 1442   ;
push	bp
mov	bp,sp
!BCC_EOS
! 1443 }
pop	bp
ret
! 1444   bx_bool
! 1445 set_enable_a20(val)
! 1445 
! 1446   bx_bool val;
export	_set_enable_a20
_set_enable_a20:
!BCC_EOS
! 1447 {
! 1448   Bit8u oldval;
!BCC_EOS
! 1449   oldval = inb(0x92);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1450   if (val)
mov	ax,4[bp]
test	ax,ax
je  	.159
.15A:
! 1451     outb(0x92, oldval | 0x02);
! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1452   else
! 1453     outb(0x92, oldval & 0xfd);
jmp .15B
.159:
! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1454   return((oldval & 0x02) != 0);
.15B:
! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.15C
mov	al,*1
jmp	.15D
.15C:
xor	al,al
.15D:
! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
xor	ah,ah
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1455 }
! 1456   void
! 1457 debugger_on()
! 1458 {
export	_debugger_on
_debugger_on:
! 1459   outb(0xfedc, 0x01);
push	bp
mov	bp,sp
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1460 }
pop	bp
ret
! 1461   void
! 1462 debugger_off()
! 1463 {
export	_debugger_off
_debugger_off:
! 1464   outb(0xfedc, 0x00);
push	bp
mov	bp,sp
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1465 }
pop	bp
ret
! 1466 int
! 1467 s3_resume()
! 1468 {
export	_s3_resume
_s3_resume:
! 1469     Bit32u s3_wakeup_vector;
!BCC_EOS
! 1470     Bit8u s3_resume_flag;
!BCC_EOS
! 1471     s3_resume_flag = read_byte(0x40, 0xb0);
push	bp
mov	bp,sp
add	sp,*-6
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 1472     s3_wakeup_vector = get_s3_waking_vector();
! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
call	_get_s3_waking_vector
mov	bx,dx
! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1473     ;
!BCC_EOS
! 1474     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FE
jne 	.15F
.160:
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
jne 	.15E
.15F:
! 1475      return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1476     write_byte(0x40, 0xb0, 0);
.15E:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1477     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$F
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B6 (used reg = )
mov	ax,#$B6
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1478     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	di,*4
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B8 (used reg = )
mov	ax,#$B8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1479     ;
!BCC_EOS
! 1480 #asm
!BCC_EOS
!BCC_ASM
_s3_resume.s3_resume_flag	set	1
.s3_resume.s3_resume_flag	set	-5
_s3_resume.s3_wakeup_vector	set	2
.s3_resume.s3_wakeup_vector	set	-4
    jmpf [0x04b6]
! 1482 endasm
!BCC_ENDASM
!BCC_EOS
! 1483     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1484 }
! 1485 void ata_init( )
! Register BX used in function s3_resume
! 1486 {
export	_ata_init
_ata_init:
! 1487   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1488   Bit8u channel, device;
!BCC_EOS
! 1489   for (channel=0; channel<4; channel++) {
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
!BCC_EOS
jmp .163
.164:
! 1490     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1491     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1492     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1493     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1494     }
! 1495   for (device=0; device<(4*2); device++) {
.162:
! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
.163:
! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
cmp	al,*4
jb 	.164
.165:
.161:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
br 	.168
.169:
! 1496     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1497     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1498     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1499     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1500     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1501     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1502     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1503     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1504     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1505     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1506     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[
! 1506 device].pchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1507     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1508     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1509     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1510     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1511     }
! 1512   for (device=0; device<(4*2); device++) {
.167:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.168:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
blo 	.169
.16A:
.166:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
jmp .16D
.16E:
! 1513     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1514     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1515     }
! 1516   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
.16C:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.16D:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
jb 	.16E
.16F:
.16B:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1518 }
mov	sp,bp
pop	bp
ret
! 1519 Bit8u await_ide();
! Register BX used in function ata_init
!BCC_EOS
! 1520 static Bit8u await_ide(when_done,base,timeout)
! 1521   Bit8u when_done;
_await_ide:
!BCC_EOS
! 1522   Bit16u base;
!BCC_EOS
! 1523   Bit16u timeout;
!BCC_EOS
! 1524 {
! 1525   Bit32u time=0,last=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*-4
! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1526   Bit8u status;
!BCC_EOS
! 1527   Bit8u result;
!BCC_EOS
! 1528   for(;;) {
dec	sp
dec	sp
!BCC_EOS
!BCC_EOS
.172:
! 1529     status = inb(base+7);
! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$C-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1530     time++;
! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	si,-2[bp]
lea	bx,-4[bp]
call	lincl
!BCC_EOS
! 1531     if (when_done == 1)
! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jne 	.173
.174:
! 1532       result = status & 0x80;
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1533     else if (when_done == 2)
br 	.175
.173:
! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*2
jne 	.176
.177:
! 1534       result = !(status & 0x80);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.178
.179:
mov	al,*1
jmp	.17A
.178:
xor	al,al
.17A:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1535     else if (when_done == 3)
br 	.17B
.176:
! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*3
jne 	.17C
.17D:
! 1536       result = !(status & 0x80) && (status & 0x08);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.17E
.180:
! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*8
test	al,al
je  	.17E
.17F:
mov	al,*1
jmp	.181
.17E:
xor	al,al
.181:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1537     else if (when_done == 4)
jmp .182
.17C:
! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*4
jne 	.183
.184:
! 1538       result = !(status & 0x80) && !(status & 0x08);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.185
.187:
! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*8
test	al,al
jne 	.185
.186:
mov	al,*1
jmp	.188
.185:
xor	al,al
.188:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1539     else if (when_done == 5)
jmp .189
.183:
! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*5
jne 	.18A
.18B:
! 1540       result = !(status & 0x80) && (status & 0x40);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.18C
.18E:
! Debug: and int = const $40 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*$40
test	al,al
je  	.18C
.18D:
mov	al,*1
jmp	.18F
.18C:
xor	al,al
.18F:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1541     else if (when_done == 0)
jmp .190
.18A:
! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
test	al,al
jne 	.191
.192:
! 1542       result = 0;
! Debug: eq int = const 0 to unsigned char result = [S+$C-$C] (used reg = )
xor	al,al
mov	-$A[bp],al
!BCC_EOS
! 1543     if (result) return status;
.191:
.190:
.189:
.182:
.17B:
.175:
mov	al,-$A[bp]
test	al,al
je  	.193
.194:
mov	al,-9[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1544     if (time>>16 != last)
.193:
! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: ne unsigned long last = [S+$C-$A] to unsigned long = bx+0 (used reg = )
lea	di,-8[bp]
call	lcmpul
je  	.195
.196:
! 1545     {
! 1546       last = time >>16;
! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$C-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1547       ;
!BCC_EOS
! 1548     }
! 1549     if (status & 0x01)
.195:
! Debug: and int = const 1 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*1
test	al,al
je  	.197
.198:
! 1550     {
! 1551       ;
!BCC_EOS
! 1552       return status;
mov	al,-9[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1553     }
! 1554     if ((timeout == 0) || ((time>>11) > timeout)) break;
.197:
! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
je  	.19A
.19B:
! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
lea	di,-$E[bp]
call	lcmpul
lea	sp,-$A[bp]
jbe 	.199
.19A:
jmp .170
!BCC_EOS
! 1555   }
.199:
! 1556   ;
.171:
br 	.172
.170:
!BCC_EOS
! 1557   return status;
mov	al,-9[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1558 }
! 1559 void ata_detect( )
! Register BX used in function await_ide
! 1560 {
export	_ata_detect
_ata_detect:
! 1561   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1562   Bit8u hdcount, cdcount, device, type;
!BCC_EOS
! 1563   Bit8u buffer[0x0200];
!BCC_EOS
! 1564   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
add	sp,#-$204
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $122 (used reg = )
mov	ax,#$122
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1565   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
! Debug: list int = const $1F0 (used reg = )
mov	ax,#$1F0
push	ax
! Debug: list * unsigned short = const $124 (used reg = )
mov	ax,#$124
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1566   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
! Debug: list int = const $3F0 (used reg = )
mov	ax,#$3F0
push	ax
! Debug: list * unsigned short = const $126 (used reg = )
mov	ax,#$126
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1567   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list * unsigned char = const $128 (used reg = )
mov	ax,#$128
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1568   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].if
! 1568 ace,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $12A (used reg = )
mov	ax,#$12A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1569   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
! Debug: list int = const $170 (used reg = )
mov	ax,#$170
push	ax
! Debug: list * unsigned short = const $12C (used reg = )
mov	ax,#$12C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1570   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
! Debug: list int = const $370 (used reg = )
mov	ax,#$370
push	ax
! Debug: list * unsigned short = const $12E (used reg = )
mov	ax,#$12E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1571   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned char = const $130 (used reg = )
mov	ax,#$130
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1572   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $132 (used reg = )
mov	ax,#$132
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1573   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
! Debug: list int = const $1E8 (used reg = )
mov	ax,#$1E8
push	ax
! Debug: list * unsigned short = const $134 (used reg = )
mov	ax,#$134
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1574   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: list * unsigned short = const $136 (used reg = )
mov	ax,#$136
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1575   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list * unsigned char = const $138 (used reg = )
mov	ax,#$138
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1576   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $13A (used reg = )
mov	ax,#$13A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1577   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
! Debug: list int = const $168 (used reg = )
mov	ax,#$168
push	ax
! Debug: list * unsigned short = const $13C (used reg = )
mov	ax,#$13C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1578   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
! Debug: list int = const $360 (used reg = )
mov	ax,#$360
push	ax
! Debug: list * unsigned short = const $13E (used reg = )
mov	ax,#$13E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1579   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: list * unsigned char = const $140 (used reg = )
mov	ax,#$140
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1580   hdcount=cdcount=0;
! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
xor	al,al
mov	-4[bp],al
! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 1581   for(device=0; device<(4*2); device++) {
! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
xor	al,al
mov	-5[bp],al
!BCC_EOS
!BCC_EOS
br 	.19E
.19F:
! 1582     Bit16u iobase1, iobase2;
!BCC_EOS
! 1583     Bit8u channel, slave, shift;
!BCC_EOS
! 1584     Bit8u sc, sn, cl, ch, st;
!BCC_EOS
! 1585     channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
mov	-$20B[bp],al
!BCC_EOS
! 1586     slave = device % 2;
! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
mov	-$20C[bp],al
!BCC_EOS
! 1587     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	-$208[bp],ax
!BCC_EOS
! 1588     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
mov	-$20A[bp],ax
!BCC_EOS
! 1589     outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
mov	ax,-$20A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1590     outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.1A0
.1A1:
mov	al,#$B0
jmp .1A2
.1A0:
mov	al,#$A0
.1A2:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1591     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1592     outb(iobase1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1593     outb(iobase1+2, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1594     outb(iobase1+3, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1595     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1596     outb(iobase1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1597     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1598     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1599     if ( (sc == 0x55) && (sn == 0xaa) ) {
! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*$55
bne 	.1A3
.1A5:
! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,#$AA
bne 	.1A3
.1A4:
! 1600       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1601       ata_reset(device);
! Debug: list unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 1602       outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.1A6
.1A7:
mov	al,#$B0
jmp .1A8
.1A6:
mov	al,#$A0
.1A8:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1603       sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1604       sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1605       if ((sc==0x01) && (sn==0x01)) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*1
bne 	.1A9
.1AB:
! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,*1
bne 	.1A9
.1AA:
! 1606         cl = inb(iobase1+4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	-$210[bp],al
!BCC_EOS
! 1607         ch = inb(iobase1+5);
! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	-$211[bp],al
!BCC_EOS
! 1608         st = inb(iobase1+7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
mov	-$212[bp],al
!BCC_EOS
! 1609         if ((cl==0x14) && (ch==0xeb)) {
! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,*$14
jne 	.1AC
.1AE:
! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$EB
jne 	.1AC
.1AD:
! 1610           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1611         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
jmp .1AF
.1AC:
! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
test	al,al
jne 	.1B0
.1B3:
! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
test	al,al
jne 	.1B0
.1B2:
! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
mov	al,-$212[bp]
test	al,al
je  	.1B0
.1B1:
! 1612         
! 1612   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1613         } else if ((cl==0xff) && (ch==0xff)) {
jmp .1B4
.1B0:
! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,#$FF
jne 	.1B5
.1B7:
! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$FF
jne 	.1B5
.1B6:
! 1614           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1615         }
! 1616       }
.1B5:
.1B4:
.1AF:
! 1617     }
.1A9:
! 1618     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
.1A3:
! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 1619     if(type == 0x02) {
! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*2
bne 	.1B8
.1B9:
! 1620       Bit32u sectors_low, sectors_high;
!BCC_EOS
! 1621       Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 1622       Bit8u translation, removable, mode;
!BCC_EOS
! 1623       mode = 0x00;
add	sp,*-$14
! Debug: eq int = const 0 to unsigned char mode = [S+$228-$227] (used reg = )
xor	al,al
mov	-$225[bp],al
!BCC_EOS
! 1624       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1625       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1626       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $EC (used reg = )
mov	ax,#$EC
push	ax
! Debug: list unsigned char device = [S+$23E-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1BA
.1BB:
! 1627         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
! Debug: list * char = .1BC+0 (used reg = )
mov	bx,#.1BC
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1628       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
.1BA:
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.1BD
.1BE:
mov	al,*1
jmp .1BF
.1BD:
xor	al,al
.1BF:
! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
mov	-$224[bp],al
!BCC_EOS
! 1629       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.1C0
.1C1:
mov	al,*1
jmp .1C2
.1C0:
xor	al,al
.1C2:
! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
mov	-$225[bp],al
!BCC_EOS
! 1630       blksize = read_word(get_SS(),buffer+10);
! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
lea	bx,-$1FC[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
mov	-$222[bp],ax
!BCC_EOS
! 1631       cylinders = read_word(get_SS(),buffer+(1*2));
! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
lea	bx,-$204[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1632       heads = read_word(get_SS(),buffer+(3*2));
! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
lea	bx,-$200[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1633       spt = read_word(get_SS(),buffer+(6*2));
! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
lea	bx,-$1FA[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
mov	-$220[bp],ax
!BCC_EOS
! 1634       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
lea	bx,-$160[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
and	ax,#$400
test	ax,ax
je  	.1C3
.1C4:
! 1635         sectors_low = read_dword(get_SS(),buffer+(100*2));
! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
lea	bx,-$13E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1636         sectors_high = read_dword(get_SS(),buffer+(102*2));
! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
lea	bx,-$13A[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1637       } else {
jmp .1C5
.1C3:
! 1638         sectors_low = read_dword(get_SS(),buffer+(60*2));
! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
lea	bx,-$18E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1639         sectors_high = 0;
! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1640       }
! 1641       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
.1C5:
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1642       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
mov	al,-$224[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1643       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
mov	al,-$225[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1644       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
push	-$222[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1647       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1648       write_dword(ebda_seg,&((ebda_da
! 1648 ta_t *) 0)->ata.devices[device].sectors_low, sectors_low);
! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
push	-$214[bp]
push	-$216[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1649       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
push	-$218[bp]
push	-$21A[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1650       ;
!BCC_EOS
! 1651       translation = inb_cmos(0x39 + channel/2);
! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
mov	-$223[bp],al
!BCC_EOS
! 1652       for (shift=device%4; shift>0; shift--) translation >>= 2;
! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	-$20D[bp],al
!BCC_EOS
!BCC_EOS
jmp .1C8
.1C9:
! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
shr	ax,*1
shr	ax,*1
mov	-$223[bp],al
!BCC_EOS
! 1653       translation &= 0x03;
.1C7:
! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
dec	ax
mov	-$20D[bp],al
.1C8:
! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
test	al,al
jne	.1C9
.1CA:
.1C6:
! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
and	al,*3
mov	-$223[bp],al
!BCC_EOS
! 1654       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1655       switch (translation) {
mov	al,-$223[bp]
jmp .1CD
! 1656         case 0:
! 1657           ;
.1CE:
!BCC_EOS
! 1658           break;
jmp .1CB
!BCC_EOS
! 1659         case 1:
! 1660           ;
.1CF:
!BCC_EOS
! 1661           break;
jmp .1CB
!BCC_EOS
! 1662         case 2:
! 1663           ;
.1D0:
!BCC_EOS
! 1664           break;
jmp .1CB
!BCC_EOS
! 1665         case 3:
! 1666           ;
.1D1:
!BCC_EOS
! 1667           break;
jmp .1CB
!BCC_EOS
! 1668         }
! 1669       switch (translation) {
jmp .1CB
.1CD:
sub	al,*0
je 	.1CE
sub	al,*1
je 	.1CF
sub	al,*1
je 	.1D0
sub	al,*1
je 	.1D1
.1CB:
..FFFE	=	-$228
mov	al,-$223[bp]
br 	.1D4
! 1670         case 0:
! 1671           break;
.1D5:
br 	.1D2
!BCC_EOS
! 1672         case 1:
! 1673           spt = 63;
.1D6:
! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
mov	ax,*$3F
mov	-$220[bp],ax
!BCC_EOS
! 1674           sectors_low /= 63;
! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,*$3F
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
mov	-$216[bp],ax
mov	-$214[bp],bx
add	sp,*4
!BCC_EOS
! 1675           heads = sectors_low / 1024;
! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,#$400
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1676           if (heads>128) heads = 255;
! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,#$80
jbe 	.1D7
.1D8:
! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$FF
mov	-$21E[bp],ax
!BCC_EOS
! 1677           else if (heads>64) heads = 128;
jmp .1D9
.1D7:
! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$40
jbe 	.1DA
.1DB:
! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$80
mov	-$21E[bp],ax
!BCC_EOS
! 1678           else if (heads>32) heads = 64;
jmp .1DC
.1DA:
! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$20
jbe 	.1DD
.1DE:
! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$40
mov	-$21E[bp],ax
!BCC_EOS
! 1679           else if (heads>16) heads = 32;
jmp .1DF
.1DD:
! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jbe 	.1E0
.1E1:
! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$20
mov	-$21E[bp],ax
!BCC_EOS
! 1680           else heads=16;
jmp .1E2
.1E0:
! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$10
mov	-$21E[bp],ax
!BCC_EOS
! 1681           cylinders = sectors_low / heads;
.1E2:
.1DF:
.1DC:
.1D9:
! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1682           break;
br 	.1D2
!BCC_EOS
! 1683         case 3:
! 1684           if (heads==16) {
.1E3:
! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jne 	.1E4
.1E5:
! 1685             if(cylinders>61439) cylinders=61439;
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$EFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lcmpul
lea	sp,2+..FFFD[bp]
jbe 	.1E6
.1E7:
! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$EFFF
mov	-$21C[bp],ax
!BCC_EOS
! 1686             heads=15;
.1E6:
! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$F
mov	-$21E[bp],ax
!BCC_EOS
! 1687             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$10
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lmulul
add	sp,*8
! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	ldivul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1688             }
! 1689         case 2:
.1E4:
! 1690           while(cylinders > 1024) {
.1E8:
jmp .1EA
.1EB:
! 1691             cylinders >>= 1;
! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
shr	ax,*1
mov	-$21C[bp],ax
!BCC_EOS
! 1692             heads <<= 1;
! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
shl	ax,*1
mov	-$21E[bp],ax
!BCC_EOS
! 1693             if (heads > 127) break;
! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$7F
jbe 	.1EC
.1ED:
jmp .1E9
!BCC_EOS
! 1694           }
.1EC:
! 1695           break;
.1EA:
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
ja 	.1EB
.1EE:
.1E9:
jmp .1D2
!BCC_EOS
! 1696         }
! 1697       if (cylinders > 1024) cylinders=1024;
jmp .1D2
.1D4:
sub	al,*0
beq 	.1D5
sub	al,*1
beq 	.1D6
sub	al,*1
je 	.1E8
sub	al,*1
beq 	.1E3
.1D2:
..FFFD	=	-$228
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
jbe 	.1EF
.1F0:
! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$400
mov	-$21C[bp],ax
!BCC_EOS
! 1698       ;
.1EF:
!BCC_EOS
! 1699       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1700       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1701       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1702       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
! Debug: list unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1703       hdcount++;
! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
!BCC_EOS
! 1704       }
add	sp,*$14
! 1705     if(type == 0x03) {
.1B8:
! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*3
bne 	.1F1
.1F2:
! 1706       Bit8u type, removable, mode;
!BCC_EOS
! 1707       Bit16u blksize;
!BCC_EOS
! 1708       mode = 0x00;
add	sp,*-6
! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
xor	al,al
mov	-$215[bp],al
!BCC_EOS
! 1709       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1710       write_byte(ebda_seg,&((ebda_data_t *)
! 1710  0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1711       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: list unsigned char device = [S+$230-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1F3
.1F4:
! 1712         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
! Debug: list * char = .1F5+0 (used reg = )
mov	bx,#.1F5
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1713       type = read_byte(get_SS(),buffer+1) & 0x1f;
.1F3:
! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
lea	bx,-$205[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
and	al,*$1F
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
mov	-$213[bp],al
!BCC_EOS
! 1714       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.1F6
.1F7:
mov	al,*1
jmp .1F8
.1F6:
xor	al,al
.1F8:
! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
mov	-$214[bp],al
!BCC_EOS
! 1715       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.1F9
.1FA:
mov	al,*1
jmp .1FB
.1F9:
xor	al,al
.1FB:
! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
mov	-$215[bp],al
!BCC_EOS
! 1716       blksize = 2048;
! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
mov	ax,#$800
mov	-$218[bp],ax
!BCC_EOS
! 1717       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
mov	al,-$213[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1718       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
mov	al,-$214[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1719       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
mov	al,-$215[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1720       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
push	-$218[bp]
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1721       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
! Debug: list unsigned char device = [S+$21A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1722       cdcount++;
! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
!BCC_EOS
! 1723       }
add	sp,*6
! 1724       {
.1F1:
! 1725       Bit32u sizeinmb;
!BCC_EOS
! 1726       Bit16u ataversion;
!BCC_EOS
! 1727       Bit8u c, i, version, model[41];
!BCC_EOS
! 1728       switch (type) {
add	sp,*-$32
mov	al,-6[bp]
br 	.1FE
! 1729         case 0x02:
! 1730           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
.1FF:
! 1731             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
mov	cl,*5
shl	ax,cl
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFFC[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1732         case 0x03:
! 1733           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
.200:
! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
lea	bx,-$166[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
lea	bx,-$165[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
or	al,0+..FFFC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
mov	-$218[bp],ax
!BCC_EOS
! 1734           for(version=15;version>0;version--) {
! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,*$F
mov	-$21B[bp],al
!BCC_EOS
!BCC_EOS
jmp .203
.204:
! 1735             if((ataversion&(1<<version))!=0)
! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
mov	bx,ax
mov	ax,*1
mov	cx,bx
shl	ax,cl
! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
! Debug: expression subtree swapping
and	ax,-$218[bp]
! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
test	ax,ax
je  	.205
.206:
! 1736             break;
jmp .201
!BCC_EOS
! 1737             }
.205:
! 1738           for(i=0;i<20;i++){
.202:
! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
dec	ax
mov	-$21B[bp],al
.203:
! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
test	al,al
jne	.204
.207:
.201:
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
br 	.20A
.20B:
! 1739             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
! Debug: list * unsigned char = bx-$1CF (used reg = )
add	bx,#-$1CF
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1740             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: list * unsigned char = bx-$1D0 (used reg = )
add	bx,#-$1D0
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
! Debug: list * unsigned char = bx-$243 (used reg = )
add	bx,#-$243
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1741           }
! 1742           write_byte(get_SS(),model+40,0x00);
.209:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
.20A:
! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$14
blo 	.20B
.20C:
.208:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$21E (used reg = )
lea	bx,-$21C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1743           for(i=39;i>0;i--){
! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$27
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .20F
.210:
! 1744             if(read_byte(get_SS(),model+i)==0x20)
! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
cmp	al,*$20
jne 	.211
.212:
! 1745               write_byte(get_SS(),model+i,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1746             else break;
jmp .213
.211:
jmp .20D
!BCC_EOS
! 1747           }
.213:
! 1748           if (i>36) {
.20E:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.20F:
! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
test	al,al
jne	.210
.214:
.20D:
! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$24
jbe 	.215
.216:
! 1749             write_byte(get_SS(),model+36,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$222 (used reg = )
lea	bx,-$220[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1750             for(i=35;i>32;i--){
! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$23
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .219
.21A:
! 1751               write_byte(get_SS(),model+i,0x2E);
! Debug: list int = const $2E (used reg = )
mov	ax,*$2E
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1752             }
! 1753           }
.218:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.219:
! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$20
ja 	.21A
.21B:
.217:
! 1754           break;
.215:
jmp .1FC
!BCC_EOS
! 1755         }
! 1756  
! 1756      switch (type) {
jmp .1FC
.1FE:
sub	al,*2
beq 	.1FF
sub	al,*1
beq 	.200
.1FC:
..FFFC	=	-$246
mov	al,-6[bp]
br 	.21E
! 1757         case 0x02:
! 1758           bios_printf(2, "XS Virtual IDE Controller      Hard Drive");
.21F:
! Debug: list * char = .220+0 (used reg = )
mov	bx,#.220
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1759    if (sizeinmb < (1UL<<16))
! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
xor	ax,ax
mov	bx,*1
lea	di,-$216[bp]
call	lcmpul
jbe 	.221
.222:
! 1760             bios_printf(2, " (%uMB)\n", sizeinmb);
! Debug: list unsigned long sizeinmb = [S+$246-$218] (used reg = )
push	-$214[bp]
push	-$216[bp]
! Debug: list * char = .223+0 (used reg = )
mov	bx,#.223
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1761    else
! 1762             bios_printf(2, " (%uGB)\n", sizeinmb>>10);
jmp .224
.221:
! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	ax,-$216[bp]
mov	bx,-$214[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*2
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list * char = .225+0 (used reg = )
mov	bx,#.225
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1763           break;
.224:
br 	.21C
!BCC_EOS
! 1764         case 0x03:
! 1765           bios_printf(2, "XS Virtual ATAPI-");
.226:
! Debug: list * char = .227+0 (used reg = )
mov	bx,#.227
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1766           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
jne 	.228
.229:
! 1767             bios_printf(2, "%d             CD-Rom/DVD-Rom\n",version);
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .22A+0 (used reg = )
mov	bx,#.22A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1768           else
! 1769             bios_printf(2, "%d             Device\n",version);
jmp .22B
.228:
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .22C+0 (used reg = )
mov	bx,#.22C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1770           break;
.22B:
jmp .21C
!BCC_EOS
! 1771         case 0x01:
! 1772           bios_printf(2, "Unknown device\n");
.22D:
! Debug: list * char = .22E+0 (used reg = )
mov	bx,#.22E
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1773           break;
jmp .21C
!BCC_EOS
! 1774         }
! 1775       }
jmp .21C
.21E:
sub	al,*1
je 	.22D
sub	al,*1
beq 	.21F
sub	al,*1
je 	.226
.21C:
..FFFB	=	-$246
add	sp,*$32
! 1776     }
add	sp,*$C
! 1777   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
.19D:
! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
.19E:
! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
blo 	.19F
.22F:
.19C:
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1778   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1779   write_byte(0x40,0x75, hdcount);
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $75 (used reg = )
mov	ax,*$75
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1780   bios_printf(2, "\n");
! Debug: list * char = .230+0 (used reg = )
mov	bx,#.230
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1781 }
mov	sp,bp
pop	bp
ret
! 1782 void ata_reset(device)
! Register BX used in function ata_detect
! 1783 Bit16u device;
export	_ata_reset
_ata_reset:
!BCC_EOS
! 1784 {
! 1785   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1786   Bit16u iobase1, iobase2;
!BCC_EOS
! 1787   Bit8u channel, slave, sn, sc;
!BCC_EOS
! 1788   Bit8u type;
!BCC_EOS
! 1789   Bit16u max;
!BCC_EOS
! 1790   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 1791   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
mov	-8[bp],al
!BCC_EOS
! 1792   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1793   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1794   outb(iobase2+6, 0x08 | 0x02 | 0x04);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1795   outb(0x80, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1796   outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1797   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1798   if (type != 0x00) {
! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
beq 	.231
.232:
! 1799     outb(iobase1+6, slave?0xb0:0xa0);
mov	al,-8[bp]
test	al,al
je  	.233
.234:
mov	al,#$B0
jmp .235
.233:
mov	al,#$A0
.235:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1800     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1801     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1802     if ( (sc==0x01) && (sn==0x01) ) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
mov	al,-$A[bp]
cmp	al,*1
jne 	.236
.238:
! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
mov	al,-9[bp]
cmp	al,*1
jne 	.236
.237:
! 1803       if (type == 0x02)
! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
cmp	al,*2
jne 	.239
.23A:
! 1804         await_ide(5, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1805       else
! 1806         await_ide(2, iobase1, 32000u);
jmp .23B
.239:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1807     }
.23B:
! 1808     await_ide(2, iobase1, 32000u);
.236:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1809   }
! 1810   outb(iobase2+6, 0x08);
.231:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1811 }
mov	sp,bp
pop	bp
ret
! 1812 Bit16u ata_cmd_non_data()
! Register BX used in function ata_reset
! 1813 {return 0;}
export	_ata_cmd_non_data
_ata_cmd_non_data:
push	bp
mov	bp,sp
xor	ax,ax
pop	bp
ret
!BCC_EOS
! 1814 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! 1815 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_in
_ata_cmd_data_in:
!BCC_EOS
! 1816 Bit32u lba_low, lba_high;
!BCC_EOS
! 1817 {
! 1818   Bit16u ebda_seg=read_
! 1818 word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1819   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1820   Bit8u channel, slave;
!BCC_EOS
! 1821   Bit8u status, current, mode;
!BCC_EOS
! 1822   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1823   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1824   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1825   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1826   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1827   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1828   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.23C
.23D:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1829   else blksize>>=1;
jmp .23E
.23C:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1830   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.23E:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1831   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1832   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1833   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1834   if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.23F
.240:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1835   outb(iobase2 + 6, 0x08 | 0x02);
.23F:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1836   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.241
.242:
! 1837     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.247
mov	al,*1
jmp	.248
.247:
xor	al,al
.248:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.244
.246:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.244
.245:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.243
.244:
! 1838       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1839       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1840       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1841       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1842       outb(iobase1 + 5, lba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1843       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1844       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1845       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1846       }
! 1847     sector = (Bit16u) (lba_low & 0x000000ffL);
.243:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1848     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1849     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1850   }
! 1851   outb(iobase1 + 1, 0x00);
.241:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1852   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1853   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1854   outb(iobase1 + 4, cylinder & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1855   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1856   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.24A
.24B:
mov	al,#$B0
jmp .24C
.24A:
mov	al,#$A0
.24C:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1857   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1858   status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1859   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.24D
.24E:
! 1860     ;
!BCC_EOS
! 1861     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1862     } else if ( !(status & 0x08) ) {
jmp .24F
.24D:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.250
.251:
! 1863     ;
!BCC_EOS
! 1864     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1865   }
! 1866 #asm
.250:
.24F:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1868 endasm
!BCC_ENDASM
!BCC_EOS
! 1869   while (1) {
.254:
! 1870 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        push bp
        mov bp, sp
        mov di, _ata_cmd_data_in.offset + 2[bp]
        mov ax, _ata_cmd_data_in.segment + 2[bp]
        mov cx, _ata_cmd_data_in.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp di, #0xf800 ;;
        jbe ata_in_no_adjust
ata_in_adjust:
        sub di, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_in_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
        mov ah, _ata_cmd_data_in.mode + 2[bp]
        cmp ah, #0x01
        je ata_in_32
ata_in_16:
        rep
          insw ;; CX words transfered from port(DX) to ES:[DI]
        jmp ata_in_done
ata_in_32:
        rep
          insd ;; CX dwords transfered from port(DX) to ES:[DI]
ata_in_done:
        mov _ata_cmd_data_in.offset + 2[bp], di
        mov _ata_cmd_data_in.segment + 2[bp], es
        pop bp
! 1899 endasm
!BCC_ENDASM
!BCC_EOS
! 1900     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 1901     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1902     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 1903     status = await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1904     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.255
.256:
! 1905       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1906           != 0x40 ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.257
.258:
! 1907         ;
!BCC_EOS
! 1908         return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1909         }
! 1910       break;
.257:
jmp .252
!BCC_EOS
! 1911       }
! 1912     else {
jmp .259
.255:
! 1913       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1914           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.25A
.25B:
! 1915         ;
!BCC_EOS
! 1916         return 5;
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1917       }
! 1918       continue;
.25A:
jmp .253
!BCC_EOS
! 1919     }
! 1920   }
.259:
! 1921   outb(iobase2+6, 0x08);
.253:
jmp	.254
.25C:
.252:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1922   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1923 }
! 1924 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! Register BX used in function ata_cmd_data_in
! 1925 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_out
_ata_cmd_data_out:
!BCC_EOS
! 1926 Bit32u lba_low, lba_high;
!BCC_EOS
! 1927 {
! 1928   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1929   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1930   Bit8u channel, slave;
!BCC_EOS
! 1931   Bit8u status, current, mode;
!BCC_EOS
! 1932   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1933   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1934   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1935   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1936   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1937   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1938   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.25D
.25E:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1939   else blksize>>=1;
jmp .25F
.25D:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1940   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.25F:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1941   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1942   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1943   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1944  
! 1944  if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.260
.261:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1945   outb(iobase2 + 6, 0x08 | 0x02);
.260:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1946   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.262
.263:
! 1947     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.268
mov	al,*1
jmp	.269
.268:
xor	al,al
.269:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.265
.267:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.265
.266:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.264
.265:
! 1948       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1949       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1950       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1951       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1952       outb(iobase1 + 5, lba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1953       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1954       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1955       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1956       }
! 1957     sector = (Bit16u) (lba_low & 0x000000ffL);
.264:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1958     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1959     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1960   }
! 1961   outb(iobase1 + 1, 0x00);
.262:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1962   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1963   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1964   outb(iobase1 + 4, cylinder & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1965   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1966   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.26B
.26C:
mov	al,#$B0
jmp .26D
.26B:
mov	al,#$A0
.26D:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1967   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1968   status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1969   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.26E
.26F:
! 1970     ;
!BCC_EOS
! 1971     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1972     } else if ( !(status & 0x08) ) {
jmp .270
.26E:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.271
.272:
! 1973     ;
!BCC_EOS
! 1974     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1975     }
! 1976 #asm
.271:
.270:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1978 endasm
!BCC_ENDASM
!BCC_EOS
! 1979   while (1) {
.275:
! 1980 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        push bp
        mov bp, sp
        mov si, _ata_cmd_data_out.offset + 2[bp]
        mov ax, _ata_cmd_data_out.segment + 2[bp]
        mov cx, _ata_cmd_data_out.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp si, #0xf800 ;;
        jbe ata_out_no_adjust
ata_out_adjust:
        sub si, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_out_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
        mov ah, _ata_cmd_data_out.mode + 2[bp]
        cmp ah, #0x01
        je ata_out_32
ata_out_16:
        seg ES
        rep
          outsw ;; CX words transfered from port(DX) to ES:[SI]
        jmp ata_out_done
ata_out_32:
        seg ES
        rep
          outsd ;; CX dwords transfered from port(DX) to ES:[SI]
ata_out_done:
        mov _ata_cmd_data_out.offset + 2[bp], si
        mov _ata_cmd_data_out.segment + 2[bp], es
        pop bp
! 2011 endasm
!BCC_ENDASM
!BCC_EOS
! 2012     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 2013     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2014     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 2015     status = await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2016     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.276
.277:
! 2017       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
! 2018           != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.278
.279:
! 2019         ;
!BCC_EOS
! 2020         return 6;
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2021         }
! 2022       break;
.278:
jmp .273
!BCC_EOS
! 2023       }
! 2024     else {
jmp .27A
.276:
! 2025       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 2026           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.27B
.27C:
! 2027         ;
!BCC_EOS
! 2028         return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2029       }
! 2030       continue;
.27B:
jmp .274
!BCC_EOS
! 2031     }
! 2032   }
.27A:
! 2033   outb(iobase2+6, 0x08);
.274:
jmp	.275
.27D:
.273:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2034   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2035 }
! 2036 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
! Register BX used in function ata_cmd_data_out
! 2037 Bit8u cmdlen,inout;
export	_ata_cmd_packet
_ata_cmd_packet:
!BCC_EOS
! 2038 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
!BCC_EOS
! 2039 Bit16u header;
!BCC_EOS
! 2040 Bit32u length;
!BCC_EOS
! 2041 {
! 2042   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2043   Bit16u iobase1, iobase2;
!BCC_EOS
! 2044   Bit16u lcount, lbefore, lafter, count;
!BCC_EOS
! 2045   Bit8u channel, slave;
!BCC_EOS
! 2046   Bit8u status, mode, lmode;
!BCC_EOS
! 2047   Bit32u total, transfer;
!BCC_EOS
! 2048   channel = device / 2;
add	sp,*-$1A
! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 2049   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
mov	-$10[bp],al
!BCC_EOS
! 2050   if (inout == 0x02) {
! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.27E
.27F:
! 2051     ;
!BCC_EOS
! 2052     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2053     }
! 2054   if (header & 1) {
.27E:
! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
mov	al,$C[bp]
and	al,*1
test	al,al
je  	.280
.281:
! 2055     ;
!BCC_EOS
! 2056     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2057     }
! 2058   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
.280:
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2059   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2060   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 2061   transfer= 0L;
! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2062   if (cmdlen < 12) cmdlen=12;
! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jae 	.282
.283:
! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$C
mov	6[bp],al
!BCC_EOS
! 2063   if (cmdlen > 12) cmdlen=16;
.282:
! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jbe 	.284
.285:
! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$10
mov	6[bp],al
!BCC_EOS
! 2064   cmdlen>>=1;
.284:
! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
shr	ax,*1
mov	6[bp],al
!BCC_EOS
! 2065   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2066   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2067   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2068   if (status & 0x80) return 2;
! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$80
test	al,al
je  	.286
.287:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2069   outb(iobase2 + 6, 0x08 | 0x02);
.286:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2070   outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2071   outb(iobase1 + 2, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2072   outb(iobase1 + 3, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2073   outb(iobase1 + 4, 0xfff0 & 0x00ff);
! Debug: list unsigned int = const $F0 (used reg = )
mov	ax,#$F0
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2074   outb(iobase1 + 5, 0xfff0 >> 8);
! Debug: list unsigned int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2075   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
mov	al,-$10[bp]
test	al,al
je  	.288
.289:
mov	al,#$B0
jmp .28A
.288:
mov	al,#$A0
.28A:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2076   outb(iobase1 + 7, 0xA0);
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2077   status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2078   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.28B
.28C:
! 2079     ;
!BCC_EOS
! 2080     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2081     } else if ( !(status & 0x08) ) {
jmp .28D
.28B:
! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*8
test	al,al
jne 	.28E
.28F:
! 2082     ;
!BCC_EOS
! 2083     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2084     }
! 2085   cmdseg += (cmdoff / 16);
.28E:
.28D:
! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
add	ax,8[bp]
mov	8[bp],ax
!BCC_EOS
! 2086 
! 2086   cmdoff %= 16;
! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
and	al,*$F
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 2087 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$26
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$28
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$E
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$10
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$18
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$D
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$24
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$22
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	9
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$20
.ata_cmd_packet.device	set	4
_ata_cmd_packet.ebda_seg	set	$1A
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$14
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	4
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$B
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$A
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$32
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	0
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.iobase2	set	$16
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$12
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$30
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$C
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$2E
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2A
.ata_cmd_packet.length	set	$E
      sti ;; enable higher priority interrupts
      push bp
      mov bp, sp
      mov si, _ata_cmd_packet.cmdoff + 2[bp]
      mov ax, _ata_cmd_packet.cmdseg + 2[bp]
      mov cx, _ata_cmd_packet.cmdlen + 2[bp]
      mov es, ax ;; segment in es
      mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
      seg ES
      rep
        outsw ;; CX words transfered from port(DX) to ES:[SI]
      pop bp
! 2100 endasm
!BCC_ENDASM
!BCC_EOS
! 2101   if (inout == 0x00) {
! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
test	al,al
jne 	.290
.291:
! 2102     status = await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2103     }
! 2104   else {
br 	.292
.290:
! 2105         Bit16u loops = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
xor	ax,ax
mov	-$1E[bp],ax
!BCC_EOS
! 2106         Bit8u sc;
!BCC_EOS
! 2107   while (1) {
dec	sp
dec	sp
.295:
! 2108       if (loops == 0) {
! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
test	ax,ax
jne 	.296
.297:
! 2109         status = inb(iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2110         status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2111       }
! 2112       else
! 2113         status = await_ide(2, iobase1, 32000u);
jmp .298
.296:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2114       loops++;
.298:
! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
inc	ax
mov	-$1E[bp],ax
!BCC_EOS
! 2115       sc = inb(iobase1 + 2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
mov	-$1F[bp],al
!BCC_EOS
! 2116       if(((inb(iobase1 + 2)&0x7)==0x3) &&
! 2117          ((status & (0x40 | 0x01)) == 0x40)) break;
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
and	al,*7
! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
jne 	.299
.29B:
! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*$41
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.299
.29A:
br 	.293
!BCC_EOS
! 2118       if (status & 0x01) {
.299:
! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.29C
.29D:
! 2119         ;
!BCC_EOS
! 2120         return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2121       }
! 2122       bufseg += (bufoff / 16);
.29C:
! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
add	ax,$14[bp]
mov	$14[bp],ax
!BCC_EOS
! 2123       bufoff %= 16;
! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
and	al,*$F
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 2124       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
add	al,-$22[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 2125       if(header>lcount) {
! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
cmp	ax,-8[bp]
jbe 	.29E
.29F:
! 2126          lbefore=lcount;
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2127          header-=lcount;
! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
sub	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 2128          lcount=0;
! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 2129          }
! 2130       else {
jmp .2A0
.29E:
! 2131         lbefore=header;
! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,$C[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2132         header=0;
! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
xor	ax,ax
mov	$C[bp],ax
!BCC_EOS
! 2133         lcount-=lbefore;
! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
sub	ax,-$A[bp]
mov	-8[bp],ax
!BCC_EOS
! 2134         }
! 2135       if(lcount>length) {
.2A0:
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lcmpul
jbe 	.2A1
.2A2:
! 2136         lafter=lcount-length;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 2137         lcount=length;
! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,$E[bp]
mov	-8[bp],ax
!BCC_EOS
! 2138         length=0;
! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$E[bp],ax
mov	$10[bp],bx
!BCC_EOS
! 2139         }
! 2140       else {
jmp .2A3
.2A1:
! 2141         lafter=0;
! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 2142         length-=lcount;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
push	bx
push	ax
mov	ax,$E[bp]
mov	bx,$10[bp]
lea	di,-$24[bp]
call	lsubul
mov	$E[bp],ax
mov	$10[bp],bx
add	sp,*4
!BCC_EOS
! 2143         }
! 2144       count = lcount;
.2A3:
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-8[bp]
mov	-$E[bp],ax
!BCC_EOS
! 2145       ;
!BCC_EOS
! 2146       ;
!BCC_EOS
! 2147       lmode = mode;
! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$12[bp]
mov	-$13[bp],al
!BCC_EOS
! 2148       if (lbefore & 0x03) lmode=0x00;
! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	al,-$A[bp]
and	al,*3
test	al,al
je  	.2A4
.2A5:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2149       if (lcount & 0x03) lmode=0x00;
.2A4:
! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*3
test	al,al
je  	.2A6
.2A7:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2150       if (lafter & 0x03) lmode=0x00;
.2A6:
! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*3
test	al,al
je  	.2A8
.2A9:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2151       if (lcount & 0x01) {
.2A8:
! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*1
test	al,al
je  	.2AA
.2AB:
! 2152         lcount+=1;
! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 2153         if ((lafter > 0) && (lafter & 0x01)) {
! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.2AC
.2AE:
! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*1
test	al,al
je  	.2AC
.2AD:
! 2154           lafter-=1;
! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
dec	ax
mov	-$C[bp],ax
!BCC_EOS
! 2155           }
! 2156         }
.2AC:
! 2157       if (lmode == 0x01) {
.2AA:
! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$13[bp]
cmp	al,*1
jne 	.2AF
.2B0:
! 2158         lcount>>=2; lbefore>>=2; lafter>>=2;
! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2159         }
! 2160       else {
jmp .2B1
.2AF:
! 2161         lcount>>=1; lbefore>>=1; lafter>>=1;
! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2162         }
! 2163        ;
.2B1:
!BCC_EOS
! 2164 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$2A
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$2C
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$12
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$14
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$1C
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$11
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$28
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$26
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	$D
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$24
.ata_cmd_packet.device	set	4
_ata_cmd_packet.loops	set	2
.ata_cmd_packet.loops	set	-$1E
_ata_cmd_packet.ebda_seg	set	$1E
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$18
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	8
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$F
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$E
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$36
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	4
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.sc	set	1
.ata_cmd_packet.sc	set	-$1F
_ata_cmd_packet.iobase2	set	$1A
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$16
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$34
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$10
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$32
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2E
.ata_cmd_packet.length	set	$E
        push bp
        mov bp, sp
        mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
        mov cx, _ata_cmd_packet.lbefore + 2[bp]
        jcxz ata_packet_no_before
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_before_32
ata_packet_in_before_16:
        in ax, dx
        loop ata_packet_in_before_16
        jmp ata_packet_no_before
ata_packet_in_before_32:
        push eax
ata_packet_in_before_32_loop:
        in eax, dx
        loop ata_packet_in_before_32_loop
        pop eax
ata_packet_no_before:
        mov cx, _ata_cmd_packet.lcount + 2[bp]
        jcxz ata_packet_after
        mov di, _ata_cmd_packet.bufoff + 2[bp]
        mov ax, _ata_cmd_packet.bufseg + 2[bp]
        mov es, ax
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_32
ata_packet_in_16:
        rep
          insw ;; CX words transfered tp port(DX) to ES:[DI]
        jmp ata_packet_after
ata_packet_in_32:
        rep
          insd ;; CX dwords transfered to port(DX) to ES:[DI]
ata_packet_after:
        mov cx, _ata_cmd_packet.lafter + 2[bp]
        jcxz ata_packet_done
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_after_32
ata_packet_in_after_16:
        in ax, dx
        loop ata_packet_in_after_16
        jmp ata_packet_done
ata_packet_in_after_32:
        push eax
ata_packet_in_after_32_loop:
        in eax, dx
        loop ata_packet_in_after_32_loop
        pop eax
ata_packet_done:
        pop bp
! 2217 endasm
!BCC_ENDASM
!BCC_EOS
! 2218       bufoff += count;
! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
add	ax,-$E[bp]
mov	$16[bp],ax
!BCC_EOS
! 2219       transfer += count;
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
lea	di,-$1C[bp]
call	laddul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2220       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2221       }
! 2222     }
.294:
br 	.295
.2B2:
.293:
add	sp,*4
! 2223   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
.292:
! 2224          != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.2B3
.2B4:
! 2225     ;
!BCC_EOS
! 2226     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2227     }
! 2228   outb(iobase2+6, 0x08);
.2B3:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2229   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2230 }
! 2231   Bit16u
! Register BX used in function ata_cmd_packet
! 2232 atapi_get_sense(device, seg, asc, ascq)
! 2233   Bit16u device;
export	_atapi_get_sense
_atapi_get_sense:
!BCC_EOS
! 2234 {
! 2235   Bit8u atacmd[12];
!BCC_EOS
! 2236   Bit8u buffer[18];
!BCC_EOS
! 2237   Bit8u i;
!BCC_EOS
! 2238   memsetb(get_SS(),atacmd,0,12);
push	bp
mov	bp,sp
add	sp,*-$20
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2239   atacmd[0]=0x03;
! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	al,*3
mov	-$C[bp],al
!BCC_EOS
! 2240   atacmd[4]=sizeof(buffer);
! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
mov	al,*$12
mov	-8[bp],al
!BCC_EOS
! 2241   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $12 (used reg = )
mov	ax,*$12
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$34+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.2B5
.2B6:
! 2242     return 0x0002;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2243   write_byte(seg,asc,buffer[12]);
.2B5:
! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int asc = [S+$24+6] (used reg = )
push	8[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2244   write
! 2244 _byte(seg,ascq,buffer[13]);
! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int ascq = [S+$24+8] (used reg = )
push	$A[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2245   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2246 }
! 2247   Bit16u
! Register BX used in function atapi_get_sense
! 2248 atapi_is_ready(device)
! 2249   Bit16u device;
export	_atapi_is_ready
_atapi_is_ready:
!BCC_EOS
! 2250 {
! 2251   Bit8u packet[12];
!BCC_EOS
! 2252   Bit8u buf[8];
!BCC_EOS
! 2253   Bit32u block_len;
!BCC_EOS
! 2254   Bit32u sectors;
!BCC_EOS
! 2255   Bit32u timeout;
!BCC_EOS
! 2256   Bit32u time;
!BCC_EOS
! 2257   Bit8u asc, ascq;
!BCC_EOS
! 2258   Bit8u in_progress;
!BCC_EOS
! 2259   Bit16u ebda_seg = read_word(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$2A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 2260   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2B7
.2B8:
! 2261     bios_printf(2, "not implemented for non-ATAPI device\n");
! Debug: list * char = .2B9+0 (used reg = )
mov	bx,#.2B9
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2262     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2263   }
! 2264   ;
.2B7:
!BCC_EOS
! 2265   memsetb(get_SS(),packet, 0, sizeof packet);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$30-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2266   packet[0] = 0x25;
! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
mov	al,*$25
mov	-$C[bp],al
!BCC_EOS
! 2267   timeout = 5000;
! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$1388
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2268   time = 0;
! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$24[bp],ax
mov	-$22[bp],bx
!BCC_EOS
! 2269   in_progress = 0;
! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
xor	al,al
mov	-$27[bp],al
!BCC_EOS
! 2270   while (time < timeout) {
br 	.2BB
.2BC:
! 2271     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
lea	bx,-$14[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const 8 (used reg = )
mov	ax,*8
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$38-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$3E+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2BD
.2BE:
! 2272       goto ok;
add	sp,#..FFFA+$2C
br 	.FFFA
!BCC_EOS
! 2273     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
.2BD:
! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
lea	bx,-$26[bp]
push	bx
! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
lea	bx,-$25[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short device = [S+$32+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
call	_atapi_get_sense
add	sp,*8
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2BF
.2C0:
! 2274       if (asc == 0x3a) {
! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*$3A
jne 	.2C1
.2C2:
! 2275         ;
!BCC_EOS
! 2276         return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2277       }
! 2278       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
.2C1:
! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*4
jne 	.2C3
.2C6:
! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*1
jne 	.2C3
.2C5:
mov	al,-$27[bp]
test	al,al
jne 	.2C3
.2C4:
! 2279         bios_printf(2, "Waiting for device to detect medium... ");
! Debug: list * char = .2C7+0 (used reg = )
mov	bx,#.2C7
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2280         timeout = 30000;
! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$7530
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2281         in_progress = 1;
! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
mov	al,*1
mov	-$27[bp],al
!BCC_EOS
! 2282       }
! 2283     }
.2C3:
! 2284     time += 100;
.2BF:
! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,*$64
xor	bx,bx
push	bx
push	ax
mov	ax,-$24[bp]
mov	bx,-$22[bp]
lea	di,-$2E[bp]
call	laddul
mov	-$24[bp],ax
mov	-$22[bp],bx
add	sp,*4
!BCC_EOS
! 2285   }
! 2286   ;
.2BB:
! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,-$20[bp]
mov	bx,-$1E[bp]
lea	di,-$24[bp]
call	lcmpul
bhi 	.2BC
.2C8:
.2BA:
!BCC_EOS
! 2287   return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2288 ok:
.FFFA:
..FFFA	=	-$2C
! 2289   block_len = (Bit32u) buf[4] << 24
! 2290     | (Bit32u) buf[5] << 16
! 2291     | (Bit32u) buf[6] << 8
! 2292     | (Bit32u) buf[7] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
mov	al,-$10[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
mov	-$18[bp],ax
mov	-$16[bp],bx
!BCC_EOS
! 2293   ;
!BCC_EOS
! 2294   if (block_len!= 2048 && block_len!= 512)
! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2C9
.2CB:
! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2C9
.2CA:
! 2295   {
! 2296     bios_printf(2, "Unsupported sector size %u\n", block_len);
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: list * char = .2CC+0 (used reg = )
mov	bx,#.2CC
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2297     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2298   }
! 2299   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
.2C9:
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2300   sectors = (Bit32u) buf[0] << 24
! 2301     | (Bit32u) buf[1] << 16
! 2302     | (Bit32u) buf[2] << 8
! 2303     | (Bit32u) buf[3] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2304   ;
!BCC_EOS
! 2305   if (block_len == 2048)
! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
jne 	.2CD
.2CE:
! 2306     sectors <<= 2;
! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	di,*2
call	lslul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2307   if (sectors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
.2CD:
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
! Debug: expression subtree swapping
lea	di,-$1C[bp]
call	lcmpul
je  	.2CF
.2D0:
! 2308     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list * char = .2D1+0 (used reg = )
mov	bx,#.2D1
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2309   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
.2CF:
! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2310   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2311 }
! 2312   Bit16u
! Register BX used in function atapi_is_ready
! 2313 atapi_is_cdrom(device)
! 2314   Bit8u device;
export	_atapi_is_cdrom
_atapi_is_cdrom:
!BCC_EOS
! 2315 {
! 2316   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2317   if (device >= (4*2))
! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
mov	al,4[bp]
cmp	al,*8
jb  	.2D2
.2D3:
! 2318     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2319   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
.2D2:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2D4
.2D5:
! 2320     retu
! 2320 rn 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2321   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
.2D4:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
je  	.2D6
.2D7:
! 2322     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2323   return 1;
.2D6:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2324 }
! 2325   void
! Register BX used in function atapi_is_cdrom
! 2326 cdemu_init()
! 2327 {
export	_cdemu_init
_cdemu_init:
! 2328   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2329   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2330 }
mov	sp,bp
pop	bp
ret
! 2331   Bit8u
! 2332 cdemu_isactive()
! 2333 {
export	_cdemu_isactive
_cdemu_isactive:
! 2334   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2335   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2336 }
! 2337   Bit8u
! 2338 cdemu_emulated_drive()
! 2339 {
export	_cdemu_emulated_drive
_cdemu_emulated_drive:
! 2340   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2341   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2342 }
! 2343 static char isotag[6]="CD001";
.data
_isotag:
.2D8:
.ascii	"CD001"
.byte	0
!BCC_EOS
! 2344 static char eltorito[24]="EL TORITO SPECIFICATION";
_eltorito:
.2D9:
.ascii	"EL TORITO SPECIFICATION"
.byte	0
!BCC_EOS
! 2345   Bit16u
! 2346 cdrom_boot()
! 2347 {
.text
export	_cdrom_boot
_cdrom_boot:
! 2348   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2349   Bit8u atacmd[12], buffer[2048];
!BCC_EOS
! 2350   Bit32u lba;
!BCC_EOS
! 2351   Bit16u boot_segment, nbsectors, i, error;
!BCC_EOS
! 2352   Bit8u device;
!BCC_EOS
! 2353   for (device=0; device<(4*2);device++) {
add	sp,#-$81A
! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
xor	al,al
mov	-$81B[bp],al
!BCC_EOS
!BCC_EOS
jmp .2DC
.2DD:
! 2354     if (atapi_is_cdrom(device)) break;
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
call	_atapi_is_cdrom
inc	sp
inc	sp
test	ax,ax
je  	.2DE
.2DF:
jmp .2DA
!BCC_EOS
! 2355     }
.2DE:
! 2356   if(device >= (4*2)) return 2;
.2DB:
! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
inc	ax
mov	-$81B[bp],al
.2DC:
! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb 	.2DD
.2E0:
.2DA:
! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb  	.2E1
.2E2:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2357   if(error = atapi_is_ready(device) != 0)
.2E1:
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
call	_atapi_is_ready
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je 	.2E5
mov	al,*1
jmp	.2E6
.2E5:
xor	al,al
.2E6:
! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
xor	ah,ah
mov	-$81A[bp],ax
test	ax,ax
je  	.2E3
.2E4:
! 2358     ;
!BCC_EOS
! 2359   memsetb(get_SS(),atacmd,0,12);
.2E3:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2360   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2361   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2362   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2363   atacmd[2]=(0x11 & 0xff000000) >> 24;
! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2364   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
xor	al,al
mov	-$B[bp],al
!BCC_EOS
! 2365   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
xor	al,al
mov	-$A[bp],al
!BCC_EOS
! 2366   atacmd[5]=(0x11 & 0x000000ff);
! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	al,*$11
mov	-9[bp],al
!BCC_EOS
! 2367   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.2E7
.2E8:
! 2368     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2369   if(buffer[0]!=0)return 4;
.2E7:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
test	al,al
je  	.2E9
.2EA:
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2370   for(i=0;i<5;i++){
.2E9:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
jmp .2ED
.2EE:
! 2371     if(read_byte(get_SS(),&buffer[1+i])!=read_byte(0xf000,&isotag[i]))return 5;
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_isotag+0] (used reg = )
! Debug: list * char = bx+_isotag+0 (used reg = )
add	bx,#_isotag
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
inc	ax
mov	bx,bp
add	bx,ax
! Debug: address unsigned char = [bx-$80E] (used reg = )
! Debug: list * unsigned char = bx-$80E (used reg = )
add	bx,#-$80E
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
je  	.2EF
.2F0:
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2372    }
.2EF:
! 2373   for(i=0;i<23;i++)
.2EC:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.2ED:
! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*5
jb 	.2EE
.2F1:
.2EB:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
! 2374     if(read_byte(get_SS(),&buffer[7+i])!=read_byte(0xf000,&eltorito[i]))return 6;
jmp .2F4
.2F5:
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_eltorito+0] (used reg = )
! Debug: list * char = bx+_eltorito+0 (used reg = )
add	bx,#_eltorito
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
add	ax,*7
mov	bx,bp
add	bx,ax
! Debug: address unsigned char = [bx-$80E] (used reg = )
! Debug: list * unsigned char = bx-$80E (used reg = )
add	bx,#-$80E
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
je  	.2F6
.2F7:
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2375   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
.2F6:
.2F3:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.2F4:
! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*$17
jb 	.2F5
.2F8:
.2F2:
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
mov	al,-$7C7[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
mov	al,-$7C6[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
mov	al,-$7C5[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
mov	al,-$7C4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2376   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2377   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2378   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2379   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2380   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2381   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2382   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2383   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2384   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.2F9
.2FA:
! 2385     return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2386   if(buffer[
.2F9:
! 2386 0x00]!=0x01)return 8;
! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
cmp	al,*1
je  	.2FB
.2FC:
mov	ax,*8
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2387   if(buffer[0x01]!=0x00)return 9;
.2FB:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
mov	al,-$80D[bp]
test	al,al
je  	.2FD
.2FE:
mov	ax,*9
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2388   if(buffer[0x1E]!=0x55)return 10;
.2FD:
! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
mov	al,-$7F0[bp]
cmp	al,*$55
je  	.2FF
.300:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2389   if(buffer[0x1F]!=0xAA)return 10;
.2FF:
! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
mov	al,-$7EF[bp]
cmp	al,#$AA
je  	.301
.302:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2390   if(buffer[0x20]!=0x88)return 11;
.301:
! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
mov	al,-$7EE[bp]
cmp	al,#$88
je  	.303
.304:
mov	ax,*$B
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2391   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
.303:
! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2392   if(buffer[0x21]==0){
! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
test	al,al
jne 	.305
.306:
! 2393     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
! Debug: list int = const $E0 (used reg = )
mov	ax,#$E0
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2394     }
! 2395   else if(buffer[0x21]<4)
jmp .307
.305:
! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
cmp	al,*4
jae 	.308
.309:
! 2396     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2397   else
! 2398     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
jmp .30A
.308:
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2399   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
.30A:
.307:
! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
shr	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2400   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2401   boot_segment=buffer[0x23]*0x100+buffer[0x22];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
mov	al,-$7EB[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
add	al,-$7EC[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	-$814[bp],ax
!BCC_EOS
! 2402   if(boot_segment==0x0000)boot_segment=0x07C0;
! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,-$814[bp]
test	ax,ax
jne 	.30B
.30C:
! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,#$7C0
mov	-$814[bp],ax
!BCC_EOS
! 2403   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
.30B:
! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
push	-$814[bp]
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2404   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2405   nbsectors=buffer[0x27]*0x100+buffer[0x26];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
mov	al,-$7E7[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
add	al,-$7E8[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	-$816[bp],ax
!BCC_EOS
! 2406   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
push	-$816[bp]
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2407   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
mov	al,-$7E6[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
mov	al,-$7E5[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
mov	al,-$7E4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
mov	al,-$7E3[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2408   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
push	-$810[bp]
push	-$812[bp]
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2409   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2410   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2411   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
inc	ax
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2412   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
inc	ax
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 2413   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2414   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2415   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2416   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2417   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
mov	ax,-$816[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$826[bp]
mov	bx,-$824[bp]
lea	di,-$82A[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.30D
.30E:
! 2418     return 12;
mov	ax,*$C
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2419   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
.30D:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
br 	.311
! 2420     case 0x01:
! 2421       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
.312:
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2422       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2423       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2424       break;
br 	.30F
!BCC_EOS
! 2425     case 0x02:
! 2426       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
.313:
! Debug: list int = const $12 (used reg = )
mov	ax,*$12
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2427       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdev
! 2427 ice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2428       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2429       break;
br 	.30F
!BCC_EOS
! 2430     case 0x03:
! 2431       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
.314:
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2432       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2433       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2434       break;
br 	.30F
!BCC_EOS
! 2435     case 0x04:
! 2436       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
.315:
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2437       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
! 2438               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
! Debug: list int = const $1C5 (used reg = )
mov	ax,#$1C5
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
add	al,0+..FFF9[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2439       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
! Debug: list int = const $1C3 (used reg = )
mov	ax,#$1C3
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2440       break;
jmp .30F
!BCC_EOS
! 2441    }
! 2442   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
jmp .30F
.311:
sub	al,*1
beq 	.312
sub	al,*1
beq 	.313
sub	al,*1
beq 	.314
sub	al,*1
beq 	.315
.30F:
..FFF9	=	-$81E
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.316
.317:
! 2443     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.318
.319:
! 2444       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
or	al,*$41
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2445     else
! 2446       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
jmp .31A
.318:
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2447    }
.31A:
! 2448   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
.316:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.31B
.31C:
! 2449     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2450   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
.31B:
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2451 }
! 2452   void
! Register BX used in function cdrom_boot
! 2453 int14_function(regs, ds, iret_addr)
! 2454   pusha_regs_t regs;
export	_int14_function
_int14_function:
!BCC_EOS
! 2455   Bit16u ds;
!BCC_EOS
! 2456   iret_addr_t iret_addr;
!BCC_EOS
! 2457 {
! 2458   Bit16u addr,timer,val16;
!BCC_EOS
! 2459   Bit8u timeout;
!BCC_EOS
! 2460 #asm
push	bp
mov	bp,sp
add	sp,*-8
!BCC_EOS
!BCC_ASM
_int14_function.ds	set	$1C
.int14_function.ds	set	$14
_int14_function.timer	set	4
.int14_function.timer	set	-4
_int14_function.timeout	set	1
.int14_function.timeout	set	-7
_int14_function.iret_addr	set	$1E
.int14_function.iret_addr	set	$16
_int14_function.addr	set	6
.int14_function.addr	set	-2
_int14_function.val16	set	2
.int14_function.val16	set	-6
_int14_function.regs	set	$C
.int14_function.regs	set	4
  sti
! 2462 endasm
!BCC_ENDASM
!BCC_EOS
! 2463   addr = read_word(0x0040, (regs.u.r16.dx << 1));
! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2464   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$7C (used reg = )
add	ax,*$7C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2465   if ((regs.u.r16.dx < 4) && (addr > 0)) {
! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*4
bhis	.31D
.31F:
! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.31D
.31E:
! 2466     switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.322
! 2467       case 0:
! 2468         outb(addr+3, inb(addr+3) | 0x80);
.323:
! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2469         if (regs.u.r8.al & 0xE0 == 0) {
! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	al,al
test	al,al
je  	.324
.325:
! 2470           outb(addr, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2471           outb(addr+1, 0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2472         } else {
jmp .326
.324:
! 2473           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,#$E0
! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*5
shr	ax,cl
! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
mov	bx,ax
mov	ax,#$600
mov	cx,bx
sar	ax,cl
! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2474           outb(addr, val16 & 0xFF);
! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
mov	al,-6[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2475           outb(addr+1, val16 >> 8);
! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2476         }
! 2477         outb(addr+3, regs.u.r8.al & 0x1F);
.326:
! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,*$1F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2478         regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2479         regs.u.r
! 2479 8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2480         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2481         break;
br 	.320
!BCC_EOS
! 2482       case 1:
! 2483         timer = read_word(0x0040, 0x006C);
.327:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2484         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
jmp .329
.32A:
! 2485           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2486           if (val16 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.32B
.32C:
! 2487             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2488             timeout--;
! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2489             }
! 2490           }
.32B:
! 2491         if (timeout) outb(addr, regs.u.r8.al);
.329:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
cmp	al,*$60
je  	.32D
.32E:
mov	al,-7[bp]
test	al,al
jne	.32A
.32D:
.328:
mov	al,-7[bp]
test	al,al
je  	.32F
.330:
! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2492         regs.u.r8.ah = inb(addr+5);
.32F:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2493         if (!timeout) regs.u.r8.ah |= 0x80;
mov	al,-7[bp]
test	al,al
jne 	.331
.332:
! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
mov	al,$13[bp]
or	al,#$80
mov	$13[bp],al
!BCC_EOS
! 2494         iret_addr.flags.u.r8.flagsl &= 0xfe;
.331:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2495         break;
br 	.320
!BCC_EOS
! 2496       case 2:
! 2497         timer = read_word(0x0040, 0x006C);
.333:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2498         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
jmp .335
.336:
! 2499           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2500           if (val16 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.337
.338:
! 2501             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2502             timeout--;
! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2503             }
! 2504           }
.337:
! 2505         if (timeout) {
.335:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.339
.33A:
mov	al,-7[bp]
test	al,al
jne	.336
.339:
.334:
mov	al,-7[bp]
test	al,al
je  	.33B
.33C:
! 2506           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2507           regs.u.r8.al = inb(addr);
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2508         } else {
jmp .33D
.33B:
! 2509           regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2510           }
! 2511         iret_addr.flags.u.r8.flagsl &= 0xfe;
.33D:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2512         break;
jmp .320
!BCC_EOS
! 2513       case 3:
! 2514         regs.u.r8.ah = inb(addr+5);
.33E:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2515         regs.u.r8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2516         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2517         break;
jmp .320
!BCC_EOS
! 2518       default:
! 2519         iret_addr.flags.u.r8.flagsl |= 0x01;
.33F:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2520       }
! 2521   } else {
jmp .320
.322:
sub	al,*0
beq 	.323
sub	al,*1
beq 	.327
sub	al,*1
beq 	.333
sub	al,*1
je 	.33E
jmp	.33F
.320:
..FFF8	=	-$A
jmp .340
.31D:
! 2522     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2523     }
! 2524 }
.340:
mov	sp,bp
pop	bp
ret
! 2525   void
! Register BX used in function int14_function
! 2526 int15_function(regs, ES, DS, FLAGS)
! 2527   pusha_regs_t regs;
export	_int15_function
_int15_function:
!BCC_EOS
! 2528   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2529 {
! 2530   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2531   bx_bool prev_a20_enable;
!BCC_EOS
! 2532   Bit16u base15_00;
!BCC_EOS
! 2533   Bit8u base23_16;
!BCC_EOS
! 2534   Bit16u ss;
!BCC_EOS
! 2535   Bit16u CX,DX;
!BCC_EOS
! 2536   Bit16u bRegister;
!BCC_EOS
! 2537   Bit8u irqDisable;
!BCC_EOS
! 2538 ;
add	sp,*-$10
!BCC_EOS
! 2539   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.343
! 2540     case 0x24:
! 2541       switch (regs.u.r8.al) {
.344:
mov	al,$12[bp]
jmp .347
! 2542         case 0x00:
! 2543           set_enable_a20(0);
.348:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2544           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2545           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2546           break;
jmp .345
!BCC_EOS
! 2547         case 0x01:
! 2548           set_enable_a20(1);
.349:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2549           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2550           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2551           break;
jmp .345
!BCC_EOS
! 2552         case 0x02:
! 2553           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
.34A:
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
shr	ax,*1
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2554           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2555           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2556           break;
jmp .345
!BCC_EOS
! 2557         case 0x03:
! 2558           
! 2558 FLAGS &= 0xfffe;
.34B:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2559           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2560           regs.u.r16.bx = 3;
! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
mov	ax,*3
mov	$C[bp],ax
!BCC_EOS
! 2561           break;
jmp .345
!BCC_EOS
! 2562         default:
! 2563           ;
.34C:
!BCC_EOS
! 2564           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2565           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2566       }
! 2567       break;
jmp .345
.347:
sub	al,*0
je 	.348
sub	al,*1
je 	.349
sub	al,*1
je 	.34A
sub	al,*1
je 	.34B
jmp	.34C
.345:
br 	.341
!BCC_EOS
! 2568     case 0x41:
! 2569       FLAGS |= 0x0001;
.34D:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2570       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2571       break;
br 	.341
!BCC_EOS
! 2572     case 0x4f:
! 2573       FLAGS |= 0x0001;
.34E:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2574       break;
br 	.341
!BCC_EOS
! 2575     case 0x52:
! 2576       FLAGS &= 0xfffe;
.34F:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2577       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2578       break;
br 	.341
!BCC_EOS
! 2579     case 0x83: {
.350:
! 2580       if( regs.u.r8.al == 0 ) {
! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
test	al,al
bne 	.351
.352:
! 2581         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
bne 	.353
.354:
! 2582           write_byte( 0x40, 0xA0, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2583           write_word( 0x40, 0x98, ES );
! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
push	$14[bp]
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2584           write_word( 0x40, 0x9A, regs.u.r16.bx );
! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
push	$C[bp]
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2585           write_word( 0x40, 0x9C, regs.u.r16.dx );
! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
push	$E[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2586           write_word( 0x40, 0x9E, regs.u.r16.cx );
! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
push	$10[bp]
! Debug: list int = const $9E (used reg = )
mov	ax,#$9E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2587           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2588           irqDisable = inb( 0xA1 );
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2589           outb( 0xA1, irqDisable & 0xFE );
! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2590           bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 2591           outb_cmos( 0xB, bRegister | 0x40 );
! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
mov	ax,-$10[bp]
or	al,*$40
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2592         } else {
jmp .355
.353:
! 2593           ;
!BCC_EOS
! 2594           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2595           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2596         }
! 2597       } else if( regs.u.r8.al == 1 ) {
.355:
jmp .356
.351:
! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*1
jne 	.357
.358:
! 2598         write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2599         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2600         bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 2601         outb_cmos( 0xB, bRegister & ~0x40 );
! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
mov	ax,-$10[bp]
and	al,#$BF
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2602       } else {
jmp .359
.357:
! 2603         ;
!BCC_EOS
! 2604         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2605         regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2606         regs.u.r8.al--;
! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
dec	ax
mov	$12[bp],al
!BCC_EOS
! 2607       }
! 2608       break;
.359:
.356:
br 	.341
!BCC_EOS
! 2609     }
! 2610     case 0x87:
! 2611 #asm
.35A:
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
  cli
! 2613 endasm
!BCC_ENDASM
!BCC_EOS
! 2614       prev_a20_enable = set_enable_a20(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2615       base15_00 = (ES << 4) + regs.u.r16.si;
! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2616       base23_16 = ES >> 12;
! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2617       if (base15_00 < (ES<<4))
! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
cmp	ax,-6[bp]
jbe 	.35B
.35C:
! 2618         base23_16++;
! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
inc	ax
mov	-7[bp],al
!BCC_EOS
! 2619       write_word(ES, regs.u.r16.si+0x08+0, 47);
.35B:
! Debug: list int = const $2F (used reg = )
mov	ax,*$2F
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2620       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
push	-6[bp]
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2621       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2622       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$D (used reg = )
add	ax,*$D
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2623       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2624       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2625       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2626       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2627       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
! Debug: list int = const $9B (used reg = )
mov	ax,#$9B
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2628       write_word(ES, regs.u.r16.si+0x20+6,
! 2628  0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2629       ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 2630       base15_00 = ss << 4;
! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
mov	ax,-$A[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2631       base23_16 = ss >> 12;
! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2632       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2633       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
push	-6[bp]
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2634       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2C (used reg = )
add	ax,*$2C
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2635       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2D (used reg = )
add	ax,*$2D
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2636       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2E (used reg = )
add	ax,*$2E
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2637       CX = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
mov	ax,$10[bp]
mov	-$C[bp],ax
!BCC_EOS
! 2638 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
      mov bx, sp
      SEG SS
        mov cx, _int15_function.CX [bx]
      push eax
      xor eax, eax
      mov ds, ax
      mov 0x0469, ss
      mov 0x0467, sp
      SEG ES
        lgdt [si + 0x08]
      SEG CS
        lidt [pmode_IDT_info]
      ;; perhaps do something with IDT here
      ;; set PE bit in CR0
      mov eax, cr0
      or al, #0x01
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to protected mode
      JMP_AP(0x0020, protected_mode)
protected_mode:
      ;; GDT points to valid descriptor table, now load SS, DS, ES
      mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
      mov ss, ax
      mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
      mov ds, ax
      mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
      mov es, ax
      xor si, si
      xor di, di
      cld
      rep
        movsw ;; move CX words from DS:SI to ES:DI
      ;; make sure DS and ES limits are 64KB
      mov ax, #0x28
      mov ds, ax
      mov es, ax
      ;; reset PG bit in CR0 ???
      mov eax, cr0
      and al, #0xFE
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to real mode
      JMP_AP(0xf000, real_mode)
real_mode:
      ;; restore IDT to normal real-mode defaults
      SEG CS
        lidt [rmode_IDT_info]
      xor ax, ax
      mov ds, ax
      mov ss, 0x0469
      mov sp, 0x0467
      pop eax
! 2690 endasm
!BCC_ENDASM
!BCC_EOS
! 2691       set_enable_a20(prev_a20_enable);
! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2692 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
  sti
! 2694 endasm
!BCC_ENDASM
!BCC_EOS
! 2695       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2696       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2697       break;
br 	.341
!BCC_EOS
! 2698     case 0x88:
! 2699       regs.u.r8.al = inb_cmos(0x30);
.35D:
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2700       regs.u.r8.ah = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2701       if(regs.u.r16.ax > 0xffc
! 2701 0)
! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
mov	ax,$12[bp]
cmp	ax,#$FFC0
jbe 	.35E
.35F:
! 2702         regs.u.r16.ax = 0xffc0;
! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
mov	ax,#$FFC0
mov	$12[bp],ax
!BCC_EOS
! 2703       FLAGS &= 0xfffe;
.35E:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2704       break;
br 	.341
!BCC_EOS
! 2705     case 0x90:
! 2706       break;
.360:
br 	.341
!BCC_EOS
! 2707     case 0x91:
! 2708       break;
.361:
br 	.341
!BCC_EOS
! 2709     case 0xbf:
! 2710       ;
.362:
!BCC_EOS
! 2711       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2712       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2713       break;
br 	.341
!BCC_EOS
! 2714     case 0xC0:
! 2715       FLAGS &= 0xfffe;
.363:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2716       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2717       regs.u.r16.bx = 0xe6f5;
! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
mov	ax,#$E6F5
mov	$C[bp],ax
!BCC_EOS
! 2718       ES = 0xF000;
! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,#$F000
mov	$14[bp],ax
!BCC_EOS
! 2719       break;
br 	.341
!BCC_EOS
! 2720     case 0xc1:
! 2721       ES = ebda_seg;
.364:
! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,-2[bp]
mov	$14[bp],ax
!BCC_EOS
! 2722       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2723       break;
br 	.341
!BCC_EOS
! 2724     case 0xd8:
! 2725       bios_printf(8, "EISA BIOS not present\n");
.365:
! Debug: list * char = .366+0 (used reg = )
mov	bx,#.366
push	bx
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2726       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2727       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2728       break;
jmp .341
!BCC_EOS
! 2729     default:
! 2730       ;
.367:
!BCC_EOS
! 2731       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2732       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2733       break;
jmp .341
!BCC_EOS
! 2734     }
! 2735 }
jmp .341
.343:
sub	al,*$24
beq 	.344
sub	al,*$1D
beq 	.34D
sub	al,*$E
beq 	.34E
sub	al,*3
beq 	.34F
sub	al,*$31
beq 	.350
sub	al,*4
beq 	.35A
sub	al,*1
beq 	.35D
sub	al,*8
beq 	.360
sub	al,*1
beq 	.361
sub	al,*$2E
beq 	.362
sub	al,*1
beq 	.363
sub	al,*1
beq 	.364
sub	al,*$17
beq 	.365
jmp	.367
.341:
..FFF7	=	-$14
mov	sp,bp
pop	bp
ret
! 2736   void
! Register BX used in function int15_function
! 2737 int15_function_mouse(regs, ES, DS, FLAGS)
! 2738   pusha_regs_t regs;
export	_int15_function_mouse
_int15_function_mouse:
!BCC_EOS
! 2739   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2740 {
! 2741   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2742   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 2743   Bit16u mouse_driver_seg;
!BCC_EOS
! 2744   Bit16u mouse_driver_offset;
!BCC_EOS
! 2745   Bit8u comm_byte, prev_command_byte;
!BCC_EOS
! 2746   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
!BCC_EOS
! 2747 ;
add	sp,*-$C
!BCC_EOS
! 2748   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.36A
! 2749     case 0xC2:
! 2750       switch (regs.u.r8.al) {
.36B:
mov	al,$12[bp]
br 	.36E
! 2751         case 0:
! 2752 ;
.36F:
!BCC_EOS
! 2753           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.372
! 2754             case 0:
! 2755 ;
.373:
!BCC_EOS
! 2756               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2757               ret = send_to_mouse_ctrl(0xF5);
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2758               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.374
.375:
! 2759                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2760                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
je  	.377
.378:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.376
.377:
! 2761                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2762                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2763                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2764                   }
! 2765                 }
.376:
! 2766               FLAGS |= 0x0001;
.374:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2767               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2768               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2769               break;
br 	.370
!BCC_EOS
! 2770             case 1:
! 2771 ;
.379:
!BCC_EOS
! 2772               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2773               if ( (mouse_flags_2 & 0x80) == 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.37A
.37B:
! 2774                 ;
!BCC_EOS
! 2775                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2776                 regs.u.r8.ah = 5;
! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*5
mov	$13[bp],al
!BCC_EOS
! 2777                 return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2778                 }
! 2779               inhibit_mouse_int_and_events();
.37A:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2780               ret = send_to_mouse_ctrl(0xF4);
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2781               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.37C
.37D:
! 2782                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2783                 if ( (ret == 0) && (m
! 2783 ouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.37E
.380:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.37E
.37F:
! 2784                   enable_mouse_int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2785                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2786                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2787                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2788                   }
! 2789                 }
.37E:
! 2790               FLAGS |= 0x0001;
.37C:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2791               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2792               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2793             default:
! 2794               ;
.381:
!BCC_EOS
! 2795               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2796               regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 2797               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2798             }
! 2799           break;
jmp .370
.372:
sub	al,*0
beq 	.373
sub	al,*1
beq 	.379
jmp	.381
.370:
br 	.36C
!BCC_EOS
! 2800         case 1:
! 2801         case 5:
.382:
! 2802 ;
.383:
!BCC_EOS
! 2803           if (regs.u.r8.al == 5) {
! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*5
jne 	.384
.385:
! 2804             if (regs.u.r8.bh != 3) {
! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*3
je  	.386
.387:
! 2805               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2806               regs.u.r8.ah = 0x02;
! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*2
mov	$13[bp],al
!BCC_EOS
! 2807               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2808             }
! 2809             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
.386:
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2810             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	al,al
! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
or	al,$D[bp]
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2811             mouse_flags_1 = 0x00;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
! 2812             write_byte(ebda_seg, 0x0026, mouse_flags_1);
! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2813             write_byte(ebda_seg, 0x0027, mouse_flags_2);
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2814           }
! 2815           inhibit_mouse_int_and_events();
.384:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2816           ret = send_to_mouse_ctrl(0xFF);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2817           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.388
.389:
! 2818             ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2819             if (mouse_data3 == 0xfe) {
! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FE
jne 	.38A
.38B:
! 2820               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2821               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2822             }
! 2823             if (mouse_data3 != 0xfa)
.38A:
! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FA
je  	.38C
.38D:
! 2824               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list * char = .38E+0 (used reg = )
mov	bx,#.38E
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2825             if ( ret == 0 ) {
.38C:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.38F
.390:
! 2826               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2827               if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.391
.392:
! 2828                 ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2829                 if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.393
.394:
! 2830                   enable_mouse_int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2831                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2832                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2833                   regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2834                   regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2835                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2836                   }
! 2837                 }
.393:
! 2838               }
.391:
! 2839             }
.38F:
! 2840           FLAGS |= 0x0001;
.388:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2841           regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2842           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2843         case 2:
! 2844 ;
.395:
!BCC_EOS
! 2845           switch (regs.u.r8.bh) {
mov	al,$D[bp]
jmp .398
! 2846             case 0: mouse_data1 = 10; break;
.399:
! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$A
mov	-$C[bp],al
!BCC_EOS
jmp .396
!BCC_EOS
! 2847             case 1: m
! 2847 ouse_data1 = 20; break;
.39A:
! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$14
mov	-$C[bp],al
!BCC_EOS
jmp .396
!BCC_EOS
! 2848             case 2: mouse_data1 = 40; break;
.39B:
! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$28
mov	-$C[bp],al
!BCC_EOS
jmp .396
!BCC_EOS
! 2849             case 3: mouse_data1 = 60; break;
.39C:
! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$3C
mov	-$C[bp],al
!BCC_EOS
jmp .396
!BCC_EOS
! 2850             case 4: mouse_data1 = 80; break;
.39D:
! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$50
mov	-$C[bp],al
!BCC_EOS
jmp .396
!BCC_EOS
! 2851             case 5: mouse_data1 = 100; break;
.39E:
! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$64
mov	-$C[bp],al
!BCC_EOS
jmp .396
!BCC_EOS
! 2852             case 6: mouse_data1 = 200; break;
.39F:
! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,#$C8
mov	-$C[bp],al
!BCC_EOS
jmp .396
!BCC_EOS
! 2853             default: mouse_data1 = 0;
.3A0:
! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2854           }
! 2855           if (mouse_data1 > 0) {
jmp .396
.398:
sub	al,*0
jb 	.3A0
cmp	al,*6
ja  	.3A1
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.3A2[bx]
.3A2:
.word	.399
.word	.39A
.word	.39B
.word	.39C
.word	.39D
.word	.39E
.word	.39F
.3A1:
jmp	.3A0
.396:
! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
test	al,al
je  	.3A3
.3A4:
! 2856             ret = send_to_mouse_ctrl(0xF3);
! Debug: list int = const $F3 (used reg = )
mov	ax,#$F3
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2857             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3A5
.3A6:
! 2858               ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2859               ret = send_to_mouse_ctrl(mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2860               ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2861               FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2862               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2863             } else {
jmp .3A7
.3A5:
! 2864               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2865               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2866             }
! 2867           } else {
.3A7:
jmp .3A8
.3A3:
! 2868             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2869             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2870           }
! 2871           break;
.3A8:
br 	.36C
!BCC_EOS
! 2872         case 3:
! 2873 ;
.3A9:
!BCC_EOS
! 2874           comm_byte = inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2875           if (regs.u.r8.bh < 4) {
! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*4
bhis	.3AA
.3AB:
! 2876             ret = send_to_mouse_ctrl(0xE8);
! Debug: list int = const $E8 (used reg = )
mov	ax,#$E8
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2877             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3AC
.3AD:
! 2878               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2879               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3AE
.3AF:
! 2880                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3B0+0 (used reg = )
mov	bx,#.3B0
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2881               ret = send_to_mouse_ctrl(regs.u.r8.bh);
.3AE:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2882               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2883               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3B1
.3B2:
! 2884                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3B3+0 (used reg = )
mov	bx,#.3B3
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2885               FLAGS &= 0xfffe;
.3B1:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2886               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2887             } else {
jmp .3B4
.3AC:
! 2888               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2889               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2890             }
! 2891           } else {
.3B4:
jmp .3B5
.3AA:
! 2892             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2893             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2894           }
! 2895           set_kbd_command_byte(comm_byte);
.3B5:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2896           break;
br 	.36C
!BCC_EOS
! 2897         case 4:
! 2898 ;
.3B6:
!BCC_EOS
! 2899           inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2900           ret = send_to_mouse_ctrl(0xF2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2901           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3B7
.3B8:
! 2902             ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2903             ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2904             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2905          
! 2905    regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2906             regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2907           } else {
jmp .3B9
.3B7:
! 2908             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2909             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2910           }
! 2911           break;
.3B9:
br 	.36C
!BCC_EOS
! 2912         case 6:
! 2913 ;
.3BA:
!BCC_EOS
! 2914           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.3BD
! 2915             case 0:
! 2916               comm_byte = inhibit_mouse_int_and_events();
.3BE:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2917               ret = send_to_mouse_ctrl(0xE9);
! Debug: list int = const $E9 (used reg = )
mov	ax,#$E9
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2918               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3BF
.3C0:
! 2919                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2920                 if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3C1
.3C2:
! 2921                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3C3+0 (used reg = )
mov	bx,#.3C3
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2922                 if (ret == 0) {
.3C1:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3C4
.3C5:
! 2923                   ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2924                   if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3C6
.3C7:
! 2925                     ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2926                     if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3C8
.3C9:
! 2927                       ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2928                       if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3CA
.3CB:
! 2929                         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2930                         regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2931                         regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2932                         regs.u.r8.cl = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
mov	al,-$D[bp]
mov	$10[bp],al
!BCC_EOS
! 2933                         regs.u.r8.dl = mouse_data3;
! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
mov	al,-$E[bp]
mov	$E[bp],al
!BCC_EOS
! 2934                         set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2935                         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2936                         }
! 2937                       }
.3CA:
! 2938                     }
.3C8:
! 2939                   }
.3C6:
! 2940                 }
.3C4:
! 2941               FLAGS |= 0x0001;
.3BF:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2942               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2943               set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2944               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2945             case 1:
! 2946             case 2:
.3CC:
! 2947               comm_byte = inhibit_mouse_int_and_events();
.3CD:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2948               if (regs.u.r8.bh == 1) {
! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*1
jne 	.3CE
.3CF:
! 2949                 ret = send_to_mouse_ctrl(0xE6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2950               } else {
jmp .3D0
.3CE:
! 2951                 ret = send_to_mouse_ctrl(0xE7);
! Debug: list int = const $E7 (used reg = )
mov	ax,#$E7
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2952               }
! 2953               if (ret == 0) {
.3D0:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3D1
.3D2:
! 2954                 get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
!BCC_EOS
! 2955                 ret = (mouse_data1 != 0xFA);
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je 	.3D3
mov	al,*1
jmp	.3D4
.3D3:
xor	al,al
.3D4:
! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2956               }
! 2957               if (ret == 0) {
.3D1:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3D5
.3D6:
! 2958                 FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2959                 regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2960               } else {
jmp .3D7
.3D5:
! 2961                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2962                
! 2962  regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2963               }
! 2964               set_kbd_command_byte(comm_byte);
.3D7:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2965               break;
jmp .3BB
!BCC_EOS
! 2966             default:
! 2967               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
.3D8:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3D9+0 (used reg = )
mov	bx,#.3D9
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2968             }
! 2969           break;
jmp .3BB
.3BD:
sub	al,*0
beq 	.3BE
sub	al,*1
beq 	.3CC
sub	al,*1
beq 	.3CD
jmp	.3D8
.3BB:
br 	.36C
!BCC_EOS
! 2970         case 7:
! 2971 ;
.3DA:
!BCC_EOS
! 2972           mouse_driver_seg = ES;
! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,$14[bp]
mov	-6[bp],ax
!BCC_EOS
! 2973           mouse_driver_offset = regs.u.r16.bx;
! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,$C[bp]
mov	-8[bp],ax
!BCC_EOS
! 2974           write_word(ebda_seg, 0x0022, mouse_driver_offset);
! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $22 (used reg = )
mov	ax,*$22
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2975           write_word(ebda_seg, 0x0024, mouse_driver_seg);
! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
push	-6[bp]
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2976           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2977           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
test	ax,ax
jne 	.3DB
.3DD:
! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jne 	.3DB
.3DC:
! 2978             if ( (mouse_flags_2 & 0x80) != 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.3DE
.3DF:
! 2979               mouse_flags_2 &= ~0x80;
! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,*$7F
mov	-4[bp],al
!BCC_EOS
! 2980               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2981               }
! 2982             }
.3DE:
! 2983           else {
jmp .3E0
.3DB:
! 2984             mouse_flags_2 |= 0x80;
! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
or	al,#$80
mov	-4[bp],al
!BCC_EOS
! 2985             }
! 2986           write_byte(ebda_seg, 0x0027, mouse_flags_2);
.3E0:
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2987           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2988           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2989           break;
jmp .36C
!BCC_EOS
! 2990         default:
! 2991 ;
.3E1:
!BCC_EOS
! 2992           regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 2993           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2994         }
! 2995       break;
jmp .36C
.36E:
sub	al,*0
jb 	.3E1
cmp	al,*7
ja  	.3E2
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.3E3[bx]
.3E3:
.word	.36F
.word	.382
.word	.395
.word	.3A9
.word	.3B6
.word	.383
.word	.3BA
.word	.3DA
.3E2:
jmp	.3E1
.36C:
jmp .368
!BCC_EOS
! 2996     default:
! 2997       ;
.3E4:
!BCC_EOS
! 2998       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2999       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 3000       break;
jmp .368
!BCC_EOS
! 3001     }
! 3002 }
jmp .368
.36A:
sub	al,#$C2
beq 	.36B
jmp	.3E4
.368:
..FFF6	=	-$10
mov	sp,bp
pop	bp
ret
! 3003 void set_e820_range(ES, DI, start, end, type)
! Register BX used in function int15_function_mouse
! 3004      Bit16u ES;
export	_set_e820_range
_set_e820_range:
!BCC_EOS
! 3005      Bit16u DI;
!BCC_EOS
! 3006      Bit32u start;
!BCC_EOS
! 3007      Bit32u end;
!BCC_EOS
! 3008      Bit16u type;
!BCC_EOS
! 3009 {
! 3010     write_word(ES, DI, start);
push	bp
mov	bp,sp
! Debug: list unsigned long start = [S+2+6] (used reg = )
push	$A[bp]
push	8[bp]
! Debug: list unsigned short DI = [S+6+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3011     write_word(ES, DI+2, start >> 16);
! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
mov	ax,8[bp]
mov	bx,$A[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3012     write_word(ES, DI+4, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3013     write_word(ES, DI+6, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3014     end -= start;
! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
lea	di,8[bp]
call	lsubul
mov	$C[bp],ax
mov	$E[bp],bx
!BCC_EOS
! 3015     write_word(ES, DI+8, end);
! Debug: list unsigned long end = [S+2+$A] (used reg = )
push	$E[bp]
push	$C[bp]
! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3016     write_word(ES, DI+10, end >> 16);
! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3017     write_word(ES, DI+12, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3018     write_word(ES, DI+14, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3019     write_word(ES, DI+16, type);
! Debug: list unsigned short type = [S+2+$E] (used reg = )
push	$10[bp]
! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3020     write_word(ES, DI+18, 0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3021 }
pop	bp
ret
! 3022   void
! Register BX used in function set_e820_range
! 3023 int15_function32(regs, ES, DS, FLAGS)
! 3024   pushad_regs_t regs;
export	_int15_function32
_int15_function32:
!BCC_EOS
! 3025   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 3026 {
! 3027   Bit32u extended_memory_size=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3028   Bit16u CX,DX;
!BCC_EOS
! 3029   Bit16u off, e820_table_size;
!BCC_EOS
! 3030   Bit32u base, type, size;
!BCC_EOS
! 3031 ;
add	sp,*-$14
!BCC_EOS
! 3032   switch (regs.u.r8.ah) {
mov	al,$21[bp]
br 	.3E7
! 3033     case 0x86:
! 3034       CX = regs.u.r16.cx;
.3E8:
! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
mov	ax,$1C[bp]
mov	-6[bp],ax
!BCC_EOS
! 3035       DX = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
mov	ax,$18[bp]
mov	-8[bp],ax
!BCC_EOS
! 3036 #asm
!BCC_EOS
!BCC_ASM
_int15_function32.CX	set	$12
.int15_function32.CX	set	-6
_int15_function32.extended_memory_size	set	$14
.int15_function32.extended_memory_size	set	-4
_int15_function32.FLAGS	set	$40
.int15_function32.FLAGS	set	$28
_int15_function32.type	set	4
.int15_function32.type	set	-$14
_int15_function32.DS	set	$3E
.int15_function32.DS	set	$26
_int15_function32.DX	set	$10
.int15_function32.DX	set	-8
_int15_function32.size	set	0
.int15_function32.size	set	-$18
_int15_function32.ES	set	$3C
.int15_function32.ES	set	$24
_int15_function32.e820_table_size	set	$C
.int15_function32.e820_table_size	set	-$C
_int15_function32.base	set	8
.int15_function32.base	set	-$10
_int15_function32.regs	set	$1C
.int15_function32.regs	set	4
_int15_function32.off	set	$E
.int15_function32.off	set	-$A
      sti
      ;; Get the count in eax
      mov bx, sp
SEG SS
      mov ax, _int15_function32.CX [bx]
      shl eax, #16
SEG SS
      mov ax, _int15_function32.DX [bx]
      ;; convert to numbers of 15usec ticks
      mov ebx, #15
      xor edx, edx
      div eax, ebx
      mov ecx, eax
      ;; wait for ecx number of refresh requests
      in al, #0x61
      and al,#0x10
      mov ah, al
      or ecx, ecx
      je int1586_tick_end
int1586_tick:
      in al, #0x61
      and al,#0x10
      cmp al, ah
      je int1586_tick
      mov ah, al
      dec ecx
      jnz int1586_tick
int1586_tick_end:
! 3065 endasm
!BCC_ENDASM
!BCC_EOS
! 3066       break;
br 	.3E5
!BCC_EOS
! 3067     case 0xe8:
! 3068         switch(regs.u.r8.al)
.3E9:
mov	al,$20[bp]
! 3069         {
br 	.3EC
! 3070        case 0x20: {
.3ED:
! 3071             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3072             if (regs.u.r32.edx != 0x534D4150)
! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$4150
mov	bx,#$534D
push	bx
push	ax
mov	ax,$18[bp]
mov	bx,$1A[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
je  	.3EE
.3EF:
! 3073                 goto int15_unimplemented;
add	sp,#..FFF4-..FFF5
br 	.FFF4
!BCC_EOS
! 3074             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
.3EE:
! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,*$14
call	idiv_u
! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
cmp	ax,$14[bp]
bne 	.3F0
.3F1:
! 3075                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
add	ax,*$14
cmp	ax,-$C[bp]
ja  	.3F2
.3F3:
! 3076                     memcpyb(ES, regs.u.r16.di,
! 3077                             (Bit16u)(0x000EA100 >> 4), 0x8 + regs.u.r16.bx, 0x14);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: add unsigned short regs = [S+$1C+$12] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,$14[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: list unsigned short regs = [S+$20+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
push	$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 3078                 regs.u.r32.ebx += 0x14;
.3F2:
! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
mov	ax,*$14
xor	bx,bx
push	bx
push	ax
mov	ax,$14[bp]
mov	bx,$16[bp]
lea	di,-2+..FFF5[bp]
call	laddul
mov	$14[bp],ax
mov	$16[bp],bx
add	sp,*4
!BCC_EOS
! 3079                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$14
xor	bx,bx
lea	di,$14[bp]
call	laddul
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-6+..FFF5[bp]
mov	bx,-4+..FFF5[bp]
lea	di,-$A+..FFF5[bp]
call	lsubul
add	sp,*8
! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jbe 	.3F4
.3F5:
! 3080                     regs.u.r32.ebx = 0;
! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3081             } else if (regs.u.r16.bx == 1) {
.3F4:
br 	.3F6
.3F0:
! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
cmp	ax,*1
bne 	.3F7
.3F8:
! 3082                 for (off = 0; off < e820_table_size; off += 0x14) {
! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
xor	ax,ax
mov	-$A[bp],ax
!BCC_EOS
!BCC_EOS
jmp .3FB
.3FC:
! 3083                     base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 3084                     type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
mov	-$14[bp],ax
mov	-$12[bp],bx
!BCC_EOS
! 3085                     if ((base >= 0x100000) && (type == 1))
! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
xor	ax,ax
mov	bx,*$10
lea	di,-$10[bp]
call	lcmpul
ja  	.3FD
.3FF:
! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-$14[bp]
mov	bx,-$12[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jne 	.3FD
.3FE:
! 3086                         break;
jmp .3F9
!BCC_EOS
! 3087                 }
.3FD:
! 3088                 if (off == e820_table_size) {
.3FA:
! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
add	ax,*$14
mov	-$A[bp],ax
.3FB:
! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jb 	.3FC
.400:
.3F9:
! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jne 	.401
.402:
! 3089                     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 3090                     break;
br 	.3EA
!BCC_EOS
! 3091                 }
! 3092                 memcpyb(ES, regs.u.r16.di, (Bit16u)(0x000EA100 >> 4), 0x8 + off, 0x14);
.401:
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: add unsigned short off = [S+$1C-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: list unsigned short regs = [S+$20+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
push	$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 3093                 regs.u.r32.ebx = 0;
! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3094             } else {
jmp .403
.3F7:
! 3095                 goto int15_unimplemented;
add	sp,#..FFF4-..FFF5
br 	.FFF4
!BCC_EOS
! 3096             }
! 3097             regs.u.r32.eax = 0x534D4150;
.403:
.3F6:
! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
mov	ax,#$4150
mov	bx,#$534D
mov	$20[bp],ax
mov	$22[bp],bx
!BCC_EOS
! 3098             regs.u.r32.ecx = 0x14;
! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
mov	ax,*$14
xor	bx,bx
mov	$1C[bp],ax
mov	$1E[bp],bx
!BCC_EOS
! 3099             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3100             break;
br 	.3EA
!BCC_EOS
! 3101         }
! 3102         case 0x01: {
.404:
! 3103             e820_table_size = rea
! 3103 d_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3104             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3105             regs.u.r8.cl = inb_cmos(0x30);
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
mov	$1C[bp],al
!BCC_EOS
! 3106             regs.u.r8.ch = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
mov	$1D[bp],al
!BCC_EOS
! 3107             if (regs.u.r16.cx > (15*1024))
! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
mov	ax,$1C[bp]
cmp	ax,#$3C00
jbe 	.405
.406:
! 3108                 regs.u.r16.cx = 15*1024;
! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
mov	ax,#$3C00
mov	$1C[bp],ax
!BCC_EOS
! 3109             for (off = 0; off < e820_table_size; off += 0x14) {
.405:
! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
xor	ax,ax
mov	-$A[bp],ax
!BCC_EOS
!BCC_EOS
jmp .409
.40A:
! 3110                 base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 3111                 type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
mov	-$14[bp],ax
mov	-$12[bp],bx
!BCC_EOS
! 3112                 if ((base >= 0x100000) && (type == 1))
! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
xor	ax,ax
mov	bx,*$10
lea	di,-$10[bp]
call	lcmpul
ja  	.40B
.40D:
! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-$14[bp]
mov	bx,-$12[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jne 	.40B
.40C:
! 3113                     break;
jmp .407
!BCC_EOS
! 3114             }
.40B:
! 3115             regs.u.r16.dx = 0;
.408:
! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
add	ax,*$14
mov	-$A[bp],ax
.409:
! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jb 	.40A
.40E:
.407:
! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
xor	ax,ax
mov	$18[bp],ax
!BCC_EOS
! 3116             if (off != e820_table_size) {
! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
je  	.40F
.410:
! 3117                 size = base + read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
! Debug: expression subtree swapping
lea	di,-$10[bp]
call	laddul
! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
mov	-$18[bp],ax
mov	-$16[bp],bx
!BCC_EOS
! 3118                 if (size > 0x1000000) {
! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
xor	ax,ax
mov	bx,#$100
lea	di,-$18[bp]
call	lcmpul
jae 	.411
.412:
! 3119                     size -= 0x1000000;
! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-2+..FFF5[bp]
call	lsubul
mov	-$18[bp],ax
mov	-$16[bp],bx
add	sp,*4
!BCC_EOS
! 3120                     regs.u.r16.dx = (Bit16u)(size >> 16);
! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
mov	ax,-$18[bp]
mov	bx,-$16[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3121                 }
! 3122             }
.411:
! 3123             regs.u.r16.ax = regs.u.r16.cx;
.40F:
! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
mov	ax,$1C[bp]
mov	$20[bp],ax
!BCC_EOS
! 3124             regs.u.r16.bx = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$18[bp]
mov	$14[bp],ax
!BCC_EOS
! 3125             break;
jmp .3EA
!BCC_EOS
! 3126         }
! 3127         default:
! 3128             goto int15_unimplemented;
.413:
add	sp,#..FFF4-..FFF5
jmp .FFF4
!BCC_EOS
! 3129         }
! 3130         break;
jmp .3EA
.3EC:
sub	al,*1
beq 	.404
sub	al,*$1F
beq 	.3ED
jmp	.413
.3EA:
jmp .3E5
!BCC_EOS
! 3131     int15_unimplemented:
.FFF4:
! 3132     default:
! 3133       ;
.414:
!BCC_EOS
! 3134       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 3135       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
mov	al,#$86
mov	$21[bp],al
!BCC_EOS
! 3136       break;
jmp .3E5
!BCC_EOS
! 3137     }
! 3138 }
jmp .3E5
.3E7:
sub	al,#$86
beq 	.3E8
sub	al,*$62
beq 	.3E9
jmp	.414
.3E5:
..FFF5	=	-$1A
..FFF4	=	-$1A
mov	sp,bp
pop	bp
ret
! 3139   void
! Register BX used in function int15_function32
! 3140 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
! 3141   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
export	_int16_function
_int16_function:
!BCC_EOS
! 3142 {
! 3143   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
!BCC_EOS
! 3144   Bit16u kbd_code, max;
!BCC_EOS
! 3145   ;
push	bp
mov	bp,sp
add	sp,*-$A
!BCC_EOS
! 3146   shift_flags = read_byte(0x0040, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3147   led_flags = read_byte(0x0040, 0x97);
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3148   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
push	ax
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	al,-$C[bp]
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.415
.416:
! 3149 #asm
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    cli
! 3151 endasm
!BCC_ENDASM
!BCC_EOS
! 3152     outb(0x60, 0xed);
! Debug: list int = const $ED (used reg = )
mov	ax,#$ED
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3153     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .418
.419:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3154     if ((inb(0x60) == 0xfa)) {
.418:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.419
.41A:
.417:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.41B
.41C:
! 3155       led_flags &= 0xf8;
! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,#$F8
mov	-4[bp],al
!BCC_EOS
! 3156       led_flags |= ((shift_flags >> 4) & 0x07);
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
or	al,-4[bp]
mov	-4[bp],al
!BCC_EOS
! 3157       outb(0x60, led_flags & 0x07);
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3158       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .41E
.41F:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3159       inb(0x60);
.41E:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.41F
.420:
.41D:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 3160       write_byte(0x0040, 0x97, led_flags);
! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3161     }
! 3162 #asm
.41B:
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    sti
! 3164 endasm
!BCC_ENDASM
!BCC_EOS
! 3165   }
! 3166   switch (( AX >> 8 )) {
.415:
! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
br 	.423
! 3167     case 0x00:
! 3168       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.424:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.425
.426:
! 3169         bios_printf((2 
! 3169 | 4 | 1), "KBD: int16h: out of keyboard input\n");
! Debug: list * char = .427+0 (used reg = )
mov	bx,#.427
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3170         }
! 3171       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.425:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.428
.42A:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.428
.429:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3172       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .42B
.428:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.42C
.42D:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3173       AX = (scan_code << 8) | ascii_code;
.42C:
.42B:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3174       break;
br 	.421
!BCC_EOS
! 3175     case 0x01:
! 3176       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.42E:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.42F
.430:
! 3177         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3178         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3179         }
! 3180       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.42F:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.431
.433:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.431
.432:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3181       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .434
.431:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.435
.436:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3182       AX = (scan_code << 8) | ascii_code;
.435:
.434:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3183       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3184       break;
br 	.421
!BCC_EOS
! 3185     case 0x02:
! 3186       shift_flags = read_byte(0x0040, 0x17);
.437:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3187       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3188       break;
br 	.421
!BCC_EOS
! 3189     case 0x05:
! 3190       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
.438:
! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
mov	ax,$10[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
test	ax,ax
jne 	.439
.43A:
! 3191         AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3192         }
! 3193       else {
jmp .43B
.439:
! 3194         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3195         }
! 3196       break;
.43B:
br 	.421
!BCC_EOS
! 3197     case 0x09:
! 3198       AX = ((AX & 0xff00) | (0x30));
.43C:
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
or	al,*$30
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3199       break;
br 	.421
!BCC_EOS
! 3200     case 0x0A:
! 3201       count = 2;
.43D:
! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
mov	al,*2
mov	-5[bp],al
!BCC_EOS
! 3202       kbd_code = 0x0;
! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 3203       outb(0x60, 0xf2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3204       max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3205       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .43F
.440:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3206       if (max>0x0) {
.43F:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.441
.442:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.440
.441:
.43E:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
beq 	.443
.444:
! 3207         if ((inb(0x60) == 0xfa)) {
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.445
.446:
! 3208           do {
.449:
! 3209             max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3210             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .44B
.44C:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3211             if (max>0x0) {
.44B:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.44D
.44E:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.44C
.44D:
.44A:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
je  	.44F
.450:
! 3212               kbd_code >>= 8;
! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
mov	-8[bp],ax
!BCC_EOS
! 3213               kbd_code |= (inb(0x60) << 8);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
or	ax,-8[bp]
mov	-8[bp],ax
!BCC_EOS
! 3214             }
! 3215           } while (--count>0);
.44F:
.448:
! Debug: predec unsigned char count = [S+$C-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne	.449
.451:
!BCC_EOS
! 3216         }
.447:
! 3217       }
.445:
! 3218       BX=kbd_code;
.443:
! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
mov	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 3219       break;
br 	.421
!BCC_EOS
! 3220     case 0x10:
! 3221       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.452:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.453
.454:
! 3222         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
! Debug: list * char = .455+0 (used reg = )
mov	bx,#.455
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3223         }
! 3224       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.453:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.456
.458:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.456
.457:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3225       AX = (scan_code << 8) | ascii_code;
.456:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3226       break;
br 	.421
!BCC_EOS
! 3227     case 0x11:
! 3228       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.459:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.45A
.45B:
! 3229         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3230         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3231         }
! 3232       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.45A:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.45C
.45E:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.45C
.45D:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3233       AX = (scan_code << 8) | ascii_code;
.45C:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3234       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3235       break;
br 	.421
!BCC_EOS
! 3236     case 0x12:
! 3237       shift_flags = read_byte(0x0040, 0x1
.45F:
! 3237 7);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3238       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3239       shift_flags = read_byte(0x0040, 0x18) & 0x73;
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
and	al,*$73
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3240       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $C to unsigned char = al+0 (used reg = )
and	al,*$C
! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
or	al,-3[bp]
mov	-3[bp],al
!BCC_EOS
! 3241       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF3[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3242       ;
!BCC_EOS
! 3243       break;
jmp .421
!BCC_EOS
! 3244     case 0x92:
! 3245       AX = ((AX & 0x00ff) | ((0x80) << 8));
.460:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3246       break;
jmp .421
!BCC_EOS
! 3247     case 0xA2:
! 3248       break;
.461:
jmp .421
!BCC_EOS
! 3249     case 0x6F:
! 3250       if (( AX & 0x00ff ) == 0x08)
.462:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
cmp	al,*8
jne 	.463
.464:
! 3251         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3252     default:
.463:
! 3253       ;
.465:
!BCC_EOS
! 3254     }
! 3255 }
jmp .421
.423:
sub	ax,*0
jl 	.465
cmp	ax,*$12
ja  	.466
shl	ax,*1
mov	bx,ax
seg	cs
br	.467[bx]
.467:
.word	.424
.word	.42E
.word	.437
.word	.465
.word	.465
.word	.438
.word	.465
.word	.465
.word	.465
.word	.43C
.word	.43D
.word	.465
.word	.465
.word	.465
.word	.465
.word	.465
.word	.452
.word	.459
.word	.45F
.466:
sub	ax,*$6F
je 	.462
sub	ax,*$23
je 	.460
sub	ax,*$10
je 	.461
jmp	.465
.421:
..FFF3	=	-$C
mov	sp,bp
pop	bp
ret
! 3256   unsigned int
! Register BX used in function int16_function
! 3257 dequeue_key(scan_code, ascii_code, incr)
! 3258   Bit8u *scan_code;
export	_dequeue_key
_dequeue_key:
!BCC_EOS
! 3259   Bit8u *ascii_code;
!BCC_EOS
! 3260   unsigned int incr;
!BCC_EOS
! 3261 {
! 3262   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
!BCC_EOS
! 3263   Bit16u ss;
!BCC_EOS
! 3264   Bit8u acode, scode;
!BCC_EOS
! 3265   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$C
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3266   buffer_end = read_word(0x0040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3267   buffer_head = read_word(0x0040, 0x001a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3268   buffer_tail = read_word(0x0040, 0x001c);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3269   if (buffer_head != buffer_tail) {
! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-8[bp]
beq 	.468
.469:
! 3270     ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3271     acode = read_byte(0x0040, buffer_head);
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 3272     scode = read_byte(0x0040, buffer_head+1);
! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 3273     write_byte(ss, ascii_code, acode);
! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
mov	al,-$B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3274     write_byte(ss, scan_code, scode);
! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3275     if (incr) {
mov	ax,8[bp]
test	ax,ax
je  	.46A
.46B:
! 3276       buffer_head += 2;
! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
inc	ax
inc	ax
mov	-6[bp],ax
!BCC_EOS
! 3277       if (buffer_head >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
jb  	.46C
.46D:
! 3278         buffer_head = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-2[bp]
mov	-6[bp],ax
!BCC_EOS
! 3279       write_word(0x0040, 0x001a, buffer_head);
.46C:
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3280       }
! 3281     return(1);
.46A:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3282     }
! 3283   else {
jmp .46E
.468:
! 3284     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3285     }
! 3286 }
.46E:
mov	sp,bp
pop	bp
ret
! 3287 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
.data
_panic_msg_keyb_buffer_full:
.46F:
.ascii	"%s: keyboard input buffer full"
.byte	$A
.byte	0
!BCC_EOS
! 3288   Bit8u
! 3289 inhibit_mouse_int_and_events()
! 3290 {
.text
export	_inhibit_mouse_int_and_events
_inhibit_mouse_int_and_events:
! 3291   Bit8u command_byte, prev_command_byte;
!BCC_EOS
! 3292   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.470
.471:
! 3293     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .472+0 (used reg = )
mov	bx,#.472
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3294   outb(0x64, 0x20);
.470:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3295   while ( (inb(0x64) & 0x01) != 0x01 );
jmp .474
.475:
!BCC_EOS
! 3296   prev_command_byte = inb(0x60);
.474:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.475
.476:
.473:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 3297   command_byte = prev_command_byte;
! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-2[bp]
mov	-1[bp],al
!BCC_EOS
! 3298   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.477
.478:
! 3299     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .479+0 (used reg = )
mov	bx,#.479
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3300   command_byte &= 0xfd;
.477:
! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
mov	-1[bp],al
!BCC_EOS
! 3301   command_byte |= 0x20;
! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*$20
mov	-1[bp],al
!BCC_EOS
! 3302   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3303   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3304   return(prev_command_byte);
mov	al,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3305 }
! 3306   void
! Register BX used in function inhibit_mouse_int_and_events
! 3307 enable_mouse_int_and_events()
! 3308 {
export	_enable_mouse_int_and_events
_enable_mouse_int_and_events:
! 3309   Bit8u command_byte;
!BCC_EOS
! 3310   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.47A
.47B:
! 3311     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! 3311 
! Debug: list * char = .47C+0 (used reg = )
mov	bx,#.47C
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3312   outb(0x64, 0x20);
.47A:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3313   while ( (inb(0x64) & 0x01) != 0x01 );
jmp .47E
.47F:
!BCC_EOS
! 3314   command_byte = inb(0x60);
.47E:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.47F
.480:
.47D:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3315   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.481
.482:
! 3316     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! Debug: list * char = .483+0 (used reg = )
mov	bx,#.483
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3317   command_byte |= 0x02;
.481:
! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 3318   command_byte &= 0xdf;
! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$DF
mov	-1[bp],al
!BCC_EOS
! 3319   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3320   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3321 }
mov	sp,bp
pop	bp
ret
! 3322   Bit8u
! Register BX used in function enable_mouse_int_and_events
! 3323 send_to_mouse_ctrl(sendbyte)
! 3324   Bit8u sendbyte;
export	_send_to_mouse_ctrl
_send_to_mouse_ctrl:
!BCC_EOS
! 3325 {
! 3326   Bit8u response;
!BCC_EOS
! 3327   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.484
.485:
! 3328     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
! Debug: list * char = .486+0 (used reg = )
mov	bx,#.486
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3329   outb(0x64, 0xD4);
.484:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3330   outb(0x60, sendbyte);
! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3331   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3332 }
! 3333   Bit8u
! Register BX used in function send_to_mouse_ctrl
! 3334 get_mouse_data(data)
! 3335   Bit8u *data;
export	_get_mouse_data
_get_mouse_data:
!BCC_EOS
! 3336 {
! 3337   Bit8u response;
!BCC_EOS
! 3338   Bit16u ss;
!BCC_EOS
! 3339   while ( (inb(0x64) & 0x21) != 0x21 ) {
push	bp
mov	bp,sp
add	sp,*-4
jmp .488
.489:
! 3340     }
! 3341   response = inb(0x60);
.488:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
jne	.489
.48A:
.487:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3342   ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3343   write_byte(ss, data, response);
! Debug: list unsigned char response = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char data = [S+8+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$A-6] (used reg = )
push	-4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3344   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3345 }
! 3346   void
! 3347 set_kbd_command_byte(command_byte)
! 3348   Bit8u command_byte;
export	_set_kbd_command_byte
_set_kbd_command_byte:
!BCC_EOS
! 3349 {
! 3350   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
mov	sp,bp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.48B
.48C:
! 3351     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
! Debug: list * char = .48D+0 (used reg = )
mov	bx,#.48D
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 3352   outb(0x64, 0xD4);
.48B:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3353   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3354   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3355 }
pop	bp
ret
! 3356   void
! Register BX used in function set_kbd_command_byte
! 3357 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
! 3358   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
export	_int09_function
_int09_function:
!BCC_EOS
! 3359 {
! 3360   Bit8u scancode, asciicode, shift_flags;
!BCC_EOS
! 3361   Bit8u mf2_flags, mf2_state;
!BCC_EOS
! 3362   scancode = ( AX & 0x00ff );
push	bp
mov	bp,sp
add	sp,*-6
! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
mov	al,$12[bp]
! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3363   if (scancode == 0) {
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.48E
.48F:
! 3364     ;
!BCC_EOS
! 3365     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3366     }
! 3367   shift_flags = read_byte(0x0040, 0x17);
.48E:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3368   mf2_flags = read_byte(0x0040, 0x18);
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3369   mf2_state = read_byte(0x0040, 0x96);
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3370   asciicode = 0;
! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3371   switch (scancode) {
mov	al,-1[bp]
br 	.492
! 3372     case 0x3a:
! 3373       shift_flags ^= 0x40;
.493:
! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$40
mov	-3[bp],al
!BCC_EOS
! 3374       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3375       mf2_flags |= 0x40;
! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$40
mov	-4[bp],al
!BCC_EOS
! 3376       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3377       break;
br 	.490
!BCC_EOS
! 3378     case 0xba:
! 3379       mf2_flags &= ~0x40;
.494:
! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$BF
mov	-4[bp],al
!BCC_EOS
! 3380       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3381       break;
br 	.490
!BCC_EOS
! 3382     case 0x2a:
! 3383       shift_flags |= 0x02;
.495:
! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*2
mov	-3[bp],al
!BCC_EOS
! 3384       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3385       break;
br 	.490
!BCC_EOS
! 3386     case 0xaa:
! 3387       shift_flags &= ~0x02;
.496:
! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FD
mov	-3[bp],al
!BCC_EOS
! 3388       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3389       break;
br 	.490
!BCC_EOS
! 3390     case 0x36:
! 3391       shift_flags |= 0x01;
.497:
! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*1
mov	-3[bp],al
!BCC_EOS
! 3392       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3393       break;
br 	.490
!BCC_EOS
! 3394     case 0xb6:
! 3395       shift_flags &= ~0x01;
.498:
! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FE
mov	-3[bp],al
!BCC_EOS
! 3396       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3397       break;
br 	.490
!BCC_EOS
! 3398     case 0x1d:
! 3399   
! 3399     if ((mf2_state & 0x01) == 0) {
.499:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.49A
.49B:
! 3400         shift_flags |= 0x04;
! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*4
mov	-3[bp],al
!BCC_EOS
! 3401         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3402         if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.49C
.49D:
! 3403           mf2_state |= 0x04;
! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
mov	-5[bp],al
!BCC_EOS
! 3404           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3405         } else {
jmp .49E
.49C:
! 3406           mf2_flags |= 0x01;
! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*1
mov	-4[bp],al
!BCC_EOS
! 3407           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3408         }
! 3409       }
.49E:
! 3410       break;
.49A:
br 	.490
!BCC_EOS
! 3411     case 0x9d:
! 3412       if ((mf2_state & 0x01) == 0) {
.49F:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4A0
.4A1:
! 3413         shift_flags &= ~0x04;
! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FB
mov	-3[bp],al
!BCC_EOS
! 3414         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3415         if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4A2
.4A3:
! 3416           mf2_state &= ~0x04;
! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
mov	-5[bp],al
!BCC_EOS
! 3417           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3418         } else {
jmp .4A4
.4A2:
! 3419           mf2_flags &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FE
mov	-4[bp],al
!BCC_EOS
! 3420           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3421         }
! 3422       }
.4A4:
! 3423       break;
.4A0:
br 	.490
!BCC_EOS
! 3424     case 0x38:
! 3425       shift_flags |= 0x08;
.4A5:
! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*8
mov	-3[bp],al
!BCC_EOS
! 3426       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3427       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4A6
.4A7:
! 3428         mf2_state |= 0x08;
! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*8
mov	-5[bp],al
!BCC_EOS
! 3429         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3430       } else {
jmp .4A8
.4A6:
! 3431         mf2_flags |= 0x02;
! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*2
mov	-4[bp],al
!BCC_EOS
! 3432         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3433       }
! 3434       break;
.4A8:
br 	.490
!BCC_EOS
! 3435     case 0xb8:
! 3436       shift_flags &= ~0x08;
.4A9:
! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$F7
mov	-3[bp],al
!BCC_EOS
! 3437       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3438       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4AA
.4AB:
! 3439         mf2_state &= ~0x08;
! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$F7
mov	-5[bp],al
!BCC_EOS
! 3440         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3441       } else {
jmp .4AC
.4AA:
! 3442         mf2_flags &= ~0x02;
! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FD
mov	-4[bp],al
!BCC_EOS
! 3443         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3444       }
! 3445       break;
.4AC:
br 	.490
!BCC_EOS
! 3446     case 0x45:
! 3447       if ((mf2_state & 0x03) == 0) {
.4AD:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4AE
.4AF:
! 3448         mf2_flags |= 0x20;
! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$20
mov	-4[bp],al
!BCC_EOS
! 3449         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3450         shift_flags ^= 0x20;
! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$20
mov	-3[bp],al
!BCC_EOS
! 3451         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3452       }
! 3453       break;
.4AE:
br 	.490
!BCC_EOS
! 3454     case 0xc5:
! 3455       if ((mf2_state & 0x03) == 0) {
.4B0:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4B1
.4B2:
! 3456         mf2_flags &= ~0x20;
! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$DF
mov	-4[bp],al
!BCC_EOS
! 3457         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3458       }
! 3459       break;
.4B1:
br 	.490
!BCC_EOS
! 3460     case 0x46:
! 3461       mf2_flags |= 0x10;
.4B3:
! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$10
mov	-4[bp],al
!BCC_EOS
! 3462       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3463       shift_flags ^= 0x10;
! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$10
mov	-3[bp],al
!BCC_EOS
! 3464       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3465       break;
br 	.490
!BCC_EOS
! 3466     case 0xc6:
! 3467       mf2_flags &= ~0x10;
.4B4:
! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$EF
mov	-4[bp],al
!BCC_EOS
! 3468       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3469       break;
br 	.490
!BCC_EOS
! 3470     case 0x53:
! 3471         if ((shift_flags & 0x0c) == 0x0c)
.4B5:
! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*$C
! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
cmp	al,*$C
jne 	.4B6
.4B7:
! 3472             machine_reset();
! Debug: func () void = machine_reset+0 (used reg = )
call	_machine_reset
!BCC_EOS
! 3473     default:
.4B6:
! 3474       if (scan
.4B8:
! 3474 code & 0x80) {
! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
test	al,al
je  	.4B9
.4BA:
! 3475         break;
br 	.490
!BCC_EOS
! 3476       }
! 3477       if (scancode > 0x58) {
.4B9:
! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
jbe 	.4BB
.4BC:
! 3478         ;
!BCC_EOS
! 3479         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3480       }
! 3481       if (shift_flags & 0x08) {
.4BB:
! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*8
test	al,al
je  	.4BD
.4BE:
! 3482         asciicode = scan_to_scanascii[scancode].alt;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,6[bx]
mov	-2[bp],al
!BCC_EOS
! 3483         scancode = scan_to_scanascii[scancode].alt >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
mov	ax,6[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3484       } else if (shift_flags & 0x04) {
br 	.4BF
.4BD:
! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*4
test	al,al
je  	.4C0
.4C1:
! 3485         asciicode = scan_to_scanascii[scancode].control;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,4[bx]
mov	-2[bp],al
!BCC_EOS
! 3486         scancode = scan_to_scanascii[scancode].control >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
mov	ax,4[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3487       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
br 	.4C2
.4C0:
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.4C3
.4C5:
! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$47
jb  	.4C3
.4C6:
! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
ja  	.4C3
.4C4:
! 3488         asciicode = 0xe0;
! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,#$E0
mov	-2[bp],al
!BCC_EOS
! 3489         scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3490       } else if (shift_flags & 0x03) {
br 	.4C7
.4C3:
! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*3
test	al,al
beq 	.4C8
.4C9:
! 3491         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4CA
.4CB:
! 3492           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3493           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3494         } else {
jmp .4CC
.4CA:
! 3495           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3496           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3497         }
! 3498       } else {
.4CC:
br 	.4CD
.4C8:
! 3499         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4CE
.4CF:
! 3500           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3501           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3502         } else {
jmp .4D0
.4CE:
! 3503           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3504           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3505         }
! 3506       }
.4D0:
! 3507       if (scancode==0 && asciicode==0) {
.4CD:
.4C7:
.4C2:
.4BF:
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.4D1
.4D3:
! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
test	al,al
jne 	.4D1
.4D2:
! 3508         ;
!BCC_EOS
! 3509       }
! 3510       enqueue_key(scancode, asciicode);
.4D1:
! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
!BCC_EOS
! 3511       break;
jmp .490
!BCC_EOS
! 3512   }
! 3513   if ((scancode & 0x7f) != 0x1d) {
jmp .490
.492:
sub	al,*$1D
beq 	.499
sub	al,*$D
beq 	.495
sub	al,*$C
beq 	.497
sub	al,*2
beq 	.4A5
sub	al,*2
beq 	.493
sub	al,*$B
beq 	.4AD
sub	al,*1
beq 	.4B3
sub	al,*$D
beq 	.4B5
sub	al,*$4A
beq 	.49F
sub	al,*$D
beq 	.496
sub	al,*$C
beq 	.498
sub	al,*2
beq 	.4A9
sub	al,*2
beq 	.494
sub	al,*$B
beq 	.4B0
sub	al,*1
beq 	.4B4
br 	.4B8
.490:
..FFF2	=	-8
! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
cmp	al,*$1D
je  	.4D4
.4D5:
! 3514     mf2_state &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
mov	-5[bp],al
!BCC_EOS
! 3515   }
! 3516   mf2_state &= ~0x02;
.4D4:
! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FD
mov	-5[bp],al
!BCC_EOS
! 3517   write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3518 }
mov	sp,bp
pop	bp
ret
! 3519   unsigned int
! Register BX used in function int09_function
! 3520 enqueue_key(scan_code, ascii_code)
! 3521   Bit8u scan_code, ascii_code;
export	_enqueue_key
_enqueue_key:
!BCC_EOS
! 3522 {
! 3523   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
!BCC_EOS
! 3524   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3525   buffer_end = read_word(0x0040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3526   buffer_head = read_word(0x0040, 0x001A);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3527   buffer_tail = read_word(0x0040, 0x001C);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3528   temp_tail = buffer_tail;
! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 3529   buffer_tail += 2;
! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 3530   if (buffer_tail >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-4[bp]
jb  	.4D6
.4D7:
! 3531     buffer_tail = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-2[bp]
mov	-8[bp],ax
!BCC_EOS
! 3532   if (buffer_tail == buffer_head) {
.4D6:
! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-6[bp]
jne 	.4D8
.4D9:
! 3533     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3534     }
! 3535    wr
! 3535 ite_byte(0x0040, temp_tail, ascii_code);
.4D8:
! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3536    write_byte(0x0040, temp_tail+1, scan_code);
! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3537    write_word(0x0040, 0x001C, buffer_tail);
! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3538    return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3539 }
! 3540   void
! 3541 int74_function(make_farcall, Z, Y, X, status)
! 3542   Bit16u make_farcall, Z, Y, X, status;
export	_int74_function
_int74_function:
!BCC_EOS
! 3543 {
! 3544   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3545   Bit8u in_byte, index, package_count;
!BCC_EOS
! 3546   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 3547 ;
add	sp,*-6
!BCC_EOS
! 3548   make_farcall = 0;
! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
xor	ax,ax
mov	4[bp],ax
!BCC_EOS
! 3549   in_byte = inb(0x64);
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3550   if ( (in_byte & 0x21) != 0x21 ) {
! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
je  	.4DA
.4DB:
! 3551     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3552     }
! 3553   in_byte = inb(0x60);
.4DA:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3554 ;
!BCC_EOS
! 3555   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 3556   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 3557   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
je  	.4DC
.4DD:
! 3558       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3559   }
! 3560   package_count = mouse_flags_2 & 0x07;
.4DC:
! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3561   index = mouse_flags_1 & 0x07;
! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3562   write_byte(ebda_seg, 0x28 + index, in_byte);
! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
! Debug: expression subtree swapping
mov	al,-4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3563   if ( (index+1) >= package_count ) {
! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
inc	ax
push	ax
mov	al,-5[bp]
xor	ah,ah
cmp	ax,-$A[bp]
lea	sp,-8[bp]
ja  	.4DE
.4DF:
! 3564 ;
!BCC_EOS
! 3565     status = read_byte(ebda_seg, 0x0028 + 0);
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
xor	ah,ah
mov	$C[bp],ax
!BCC_EOS
! 3566     X = read_byte(ebda_seg, 0x0028 + 1);
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 3567     Y = read_byte(ebda_seg, 0x0028 + 2);
! Debug: list int = const $2A (used reg = )
mov	ax,*$2A
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
xor	ah,ah
mov	8[bp],ax
!BCC_EOS
! 3568     Z = 0;
! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 3569     mouse_flags_1 = 0;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 3570     if (mouse_flags_2 & 0x80)
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
test	al,al
je  	.4E0
.4E1:
! 3571       make_farcall = 1;
! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
mov	ax,*1
mov	4[bp],ax
!BCC_EOS
! 3572     }
.4E0:
! 3573   else {
jmp .4E2
.4DE:
! 3574     mouse_flags_1++;
! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
inc	ax
mov	-6[bp],al
!BCC_EOS
! 3575     }
! 3576   write_byte(ebda_seg, 0x0026, mouse_flags_1);
.4E2:
! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3577 }
mov	sp,bp
pop	bp
ret
! 3578   void
! 3579 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3580   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_harddisk
_int13_harddisk:
!BCC_EOS
! 3581 {
! 3582   Bit32u lba_low, lba_high;
!BCC_EOS
! 3583   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3584   Bit16u cylinder, head, sector;
!BCC_EOS
! 3585   Bit16u segment, offset;
!BCC_EOS
! 3586   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
!BCC_EOS
! 3587   Bit16u size, count;
!BCC_EOS
! 3588   Bit8u device, status;
!BCC_EOS
! 3589   ;
add	sp,*-$1C
!BCC_EOS
! 3590   write_byte(0x0040, 0x008e, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $8E (used reg = )
mov	ax,#$8E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3591   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jb  	.4E4
.4E5:
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
cmp	al,#$88
jb  	.4E3
.4E4:
! 3592     ;
!BCC_EOS
! 3593     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3594     }
! 3595   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
.4E3:
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
add	ax,*-$80
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 3596   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*8
jb  	.4E6
.4E7:
! 3597     ;
!BCC_EOS
! 3598     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3599     }
! 3600   switch (( AX >> 8 )) {
.4E6:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.4EA
! 3601     case 0x00:
! 3602       ata_reset (device);
.4EB:
! Debug: list unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 3603       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3604       break;
br 	.4E8
!BCC_EOS
! 3605     case 0x01:
! 3606       status = read_byte(0x0040, 0x0074);
.4EC:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3607       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3608       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3609       if (status) goto 
mov	al,-$26[bp]
test	al,al
je  	.4ED
.4EE:
! 3609 int13_fail_nostatus;
add	sp,#..FFEE-..FFF0
br 	.FFEE
!BCC_EOS
! 3610       else goto int13_success_noah;
jmp .4EF
.4ED:
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3611       break;
.4EF:
br 	.4E8
!BCC_EOS
! 3612     case 0x02:
! 3613     case 0x03:
.4F0:
! 3614     case 0x04:
.4F1:
! 3615       count = ( AX & 0x00ff );
.4F2:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3616       cylinder = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3617       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
shl	ax,*1
shl	ax,*1
! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
and	ax,#$300
! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
or	ax,-$C[bp]
mov	-$C[bp],ax
!BCC_EOS
! 3618       sector = (( CX & 0x00ff ) & 0x3f);
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 3619       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 3620       segment = ES;
! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
mov	ax,8[bp]
mov	-$12[bp],ax
!BCC_EOS
! 3621       offset = BX;
! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
mov	ax,$12[bp]
mov	-$14[bp],ax
!BCC_EOS
! 3622       if ((count > 128) || (count == 0) || (sector == 0)) {
! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
cmp	ax,#$80
ja  	.4F4
.4F6:
! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
test	ax,ax
je  	.4F4
.4F5:
! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
test	ax,ax
jne 	.4F3
.4F4:
! 3623         ;
!BCC_EOS
! 3624         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3625       }
! 3626       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.4F3:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3627       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3628       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3629       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-$1C[bp]
jae 	.4F8
.4FA:
! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-$1E[bp]
jae 	.4F8
.4F9:
! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$20[bp]
jbe 	.4F7
.4F8:
! 3630         ;
!BCC_EOS
! 3631         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3632         }
! 3633       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
.4F7:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.4FB
.4FC:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3634       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
.4FB:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3635       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3636       if ( (nph != nlh) || (npspt != nlspt)) {
! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
cmp	ax,-$1E[bp]
jne 	.4FE
.4FF:
! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	ax,-$1A[bp]
cmp	ax,-$20[bp]
je  	.4FD
.4FE:
! 3637         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lsubul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3638         lba_high = 0;
! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3639         sector = 0;
! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ax,ax
mov	-$10[bp],ax
!BCC_EOS
! 3640         }
! 3641       if ( ( AX >> 8 ) == 0x02 )
.4FD:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
cmp	ax,*2
jne 	.500
.501:
! 3642         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3643       else
! 3644         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
br 	.502
.500:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3645       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
.502:
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3646       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.503
.504:
! 3647         ;
!BCC_EOS
! 3648         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3649         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3650         }
! 3651       goto int13_success;
.503:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3652       break;
br 	.4E8
!BCC_EOS
! 3653     case 0x05:
! 3654       ;
.505:
!BCC_EOS
! 3655       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3656       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3657       break;
br 	.4E8
!BCC_EOS
! 3658     case 0x08:
! 3659       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.506:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3660       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads
! 3660 );
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3661       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3662       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3663       nlc = nlc - 2;
! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
dec	ax
dec	ax
mov	-$1C[bp],ax
!BCC_EOS
! 3664       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3665       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	al,-$1C[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3666       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	al,-$20[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
mov	ax,-$1C[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3667       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	ax,-$1E[bp]
! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
dec	ax
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3668       DX = ((DX & 0xff00) | (count));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
or	ax,-$24[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3669       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3670       break;
br 	.4E8
!BCC_EOS
! 3671     case 0x10:
! 3672       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
.507:
! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3673       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
and	al,#$C0
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.508
.509:
! 3674         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3675         }
! 3676       else {
jmp .50A
.508:
! 3677         AX = ((AX & 0x00ff) | ((0xAA) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3678         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3679         }
! 3680       break;
.50A:
br 	.4E8
!BCC_EOS
! 3681     case 0x15:
! 3682       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.50B:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3683       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3684       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3685       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3686       CX = lba_low >> 16;
! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3687       DX = lba_low & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3688       AX = ((AX & 0x00ff) | ((3) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3689       goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3690       break;
br 	.4E8
!BCC_EOS
! 3691     case 0x41:
! 3692       BX=0xaa55;
.50C:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3693       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3694       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3695       goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3696       break;
br 	.4E8
!BCC_EOS
! 3697     case 0x42:
! 3698     case 0x43:
.50D:
! 3699     case 0x44:
.50E:
! 3700     case 0x47:
.50F:
! 3701       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.510:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3702       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 3703       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 3704       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3705       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
lea	di,-8[bp]
call	lcmpul
jae 	.511
.512:
! 3706         ;
!BCC_EOS
! 3707         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3708         }
! 3709       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.511:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3710       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
! 3711        
! 3711    && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
! Debug: expression subtree swapping
lea	di,-8[bp]
call	lcmpul
jne 	.513
.515:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
lea	di,-4[bp]
call	lcmpul
ja  	.513
.514:
! 3712         ;
!BCC_EOS
! 3713         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3714         }
! 3715       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
.513:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.517
.518:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.516
.517:
! 3716         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3717       if ( ( AX >> 8 ) == 0x42 )
.516:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
cmp	ax,*$42
jne 	.519
.51A:
! 3718         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3719       else
! 3720         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
jmp .51B
.519:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3721       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
.51B:
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3722       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$28-$26] (used reg = )
push	-$24[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3723       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.51C
.51D:
! 3724         ;
!BCC_EOS
! 3725         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3726         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3727         }
! 3728       goto int13_success;
.51C:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3729       break;
br 	.4E8
!BCC_EOS
! 3730     case 0x45:
! 3731     case 0x49:
.51E:
! 3732       goto int13_success;
.51F:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3733       break;
br 	.4E8
!BCC_EOS
! 3734     case 0x46:
! 3735       AX = ((AX & 0x00ff) | ((0xb2) << 8));
.520:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4E00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3736       goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3737       break;
br 	.4E8
!BCC_EOS
! 3738     case 0x48:
! 3739       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
.521:
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
mov	-$22[bp],ax
!BCC_EOS
! 3740       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
jae 	.522
.523:
! 3741         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3742       if(size >= 0x1a) {
.522:
! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
blo 	.524
.525:
! 3743         Bit16u blksize;
!BCC_EOS
! 3744         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	-$16[bp],ax
!BCC_EOS
! 3745         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3746         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3747         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3748         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3749         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 3750         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3751         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
mov	ax,-8[bp]
mov	bx,-6[bp]
call	ltstl
jne 	.527
.528:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-6+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$3FFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lcmpul
jbe	.529
mov	al,*1
jmp	.52A
.529:
xor	al,al
.52A:
add	sp,*8
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
je  	.526
.527:
! 3752         {
! 3753           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3754           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
! Debug: list int = const $3FFF (used reg = )
mov	ax,#$3FFF
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*6
!BCC_EOS
! 3755         }
! 3756         else
! 3757         {
jmp .52C
.526:
! 3758           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3759           write_dwo
! 3759 rd(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	ax,-$16[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3760         }
! 3761         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
.52C:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3762         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3763         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3764         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3765         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3766         }
! 3767       if(size >= 0x1e) {
.524:
! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1E
blo 	.52D
.52E:
! 3768         Bit8u channel, dev, irq, mode, checksum, i, translation;
!BCC_EOS
! 3769         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 3770         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3771         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
push	-$A[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3772         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3773         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3774         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
mov	-$30[bp],ax
!BCC_EOS
! 3775         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	-$32[bp],ax
!BCC_EOS
! 3776         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3777         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	-$2A[bp],al
!BCC_EOS
! 3778         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 3779         options = (translation==0?0:1)<<3;
! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
test	al,al
jne 	.52F
.530:
xor	al,al
jmp .531
.52F:
mov	al,*1
.531:
! Debug: sl int = const 3 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*3
shl	ax,cl
! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
mov	-$34[bp],ax
!BCC_EOS
! 3780         options |= (1<<4);
! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
mov	ax,-$34[bp]
or	al,*$10
mov	-$34[bp],ax
!BCC_EOS
! 3781         options |= (mode==0x01?1:0)<<7;
! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*1
jne 	.532
.533:
mov	al,*1
jmp .534
.532:
xor	al,al
.534:
! Debug: sl int = const 7 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*7
shl	ax,cl
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3782         options |= (translation==1?1:0)<<9;
! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*1
jne 	.535
.536:
mov	al,*1
jmp .537
.535:
xor	al,al
.537:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3783         options |= (translation==3?3:0)<<9;
! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*3
jne 	.538
.539:
mov	al,*3
jmp .53A
.538:
xor	al,al
.53A:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3784         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
push	-$30[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3785         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	ax,-$32[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3786         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3787         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3788         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3789         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3790         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3791         w
! 3791 rite_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3792         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
! Debug: list unsigned short options = [S+$36-$36] (used reg = )
push	-$34[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3793         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3794         if (size >=0x42)
! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
jb  	.53B
.53C:
! 3795           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3796         else
! 3797           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
jmp .53D
.53B:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3798         checksum=0;
.53D:
! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	al,al
mov	-$2B[bp],al
!BCC_EOS
! 3799         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
xor	al,al
mov	-$2C[bp],al
!BCC_EOS
!BCC_EOS
jmp .540
.541:
! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
mov	al,-$2C[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	ah,ah
add	al,-$2B[bp]
adc	ah,*0
mov	-$2B[bp],al
!BCC_EOS
! 3800         checksum = ~checksum;
.53F:
! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
inc	ax
mov	-$2C[bp],al
.540:
! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
cmp	al,*$F
jb 	.541
.542:
.53E:
! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
mov	-$2B[bp],al
!BCC_EOS
! 3801         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3802         }
! 3803       if(size >= 0x42) {
.52D:
! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
blo 	.543
.544:
! 3804         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 3805         Bit16u iobase1;
!BCC_EOS
! 3806         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3807         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	-$28[bp],al
!BCC_EOS
! 3808         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
mov	-$2C[bp],ax
!BCC_EOS
! 3809         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3810         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3811         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3812         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3813         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3814         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.545
.546:
! 3815           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3816           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3817           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3818           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3819           }
! 3820         else {
jmp .547
.545:
! 3821           }
! 3822         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.547:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3823         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3824         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3825         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3826         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.548
.549:
! 3827           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3828           write_word(DS, SI
! 3828 +(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3829           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3830           }
! 3831         else {
jmp .54A
.548:
! 3832           }
! 3833         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.54A:
! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3834         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3835         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3836         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3837         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	al,al
mov	-$29[bp],al
!BCC_EOS
! 3838         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,*$1E
mov	-$2A[bp],al
!BCC_EOS
!BCC_EOS
jmp .54D
.54E:
! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$2A[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	ah,ah
add	al,-$29[bp]
adc	ah,*0
mov	-$29[bp],al
!BCC_EOS
! 3839         checksum = ~checksum;
.54C:
! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
inc	ax
mov	-$2A[bp],al
.54D:
! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*$40
jb 	.54E
.54F:
.54B:
! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3840         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3841         }
! 3842       goto int13_success;
.543:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3843       break;
br 	.4E8
!BCC_EOS
! 3844     case 0x4e:
! 3845       switch (( AX & 0x00ff )) {
.550:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
jmp .553
! 3846         case 0x01:
! 3847         case 0x03:
.554:
! 3848         case 0x04:
.555:
! 3849         case 0x06:
.556:
! 3850           goto int13_success;
.557:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3851           break;
jmp .551
!BCC_EOS
! 3852         default :
! 3853           goto int13_fail;
.558:
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3854         }
! 3855       break;
jmp .551
.553:
sub	al,*1
je 	.554
sub	al,*2
je 	.555
sub	al,*1
je 	.556
sub	al,*2
je 	.557
jmp	.558
.551:
br 	.4E8
!BCC_EOS
! 3856     case 0x09:
! 3857     case 0x0c:
.559:
! 3858     case 0x0d:
.55A:
! 3859     case 0x11:
.55B:
! 3860     case 0x14:
.55C:
! 3861       ;
.55D:
!BCC_EOS
! 3862       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3863       break;
br 	.4E8
!BCC_EOS
! 3864     case 0x0a:
! 3865     case 0x0b:
.55E:
! 3866     case 0x18:
.55F:
! 3867     case 0x50:
.560:
! 3868     default:
.561:
! 3869       ;
.562:
!BCC_EOS
! 3870       goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3871       break;
br 	.4E8
!BCC_EOS
! 3872     }
! 3873 int13_fail:
jmp .4E8
.4EA:
add	sp,*-$E
sub	ax,*0
jl 	.562
cmp	ax,*$18
ja  	.563
shl	ax,*1
mov	bx,ax
seg	cs
br	.564[bx]
.564:
.word	.4EB
.word	.4EC
.word	.4F0
.word	.4F1
.word	.4F2
.word	.505
.word	.562
.word	.562
.word	.506
.word	.559
.word	.55E
.word	.55F
.word	.55A
.word	.55B
.word	.562
.word	.562
.word	.507
.word	.55C
.word	.562
.word	.562
.word	.55D
.word	.50B
.word	.562
.word	.562
.word	.560
.563:
sub	ax,*$41
jb 	.562
cmp	ax,*$F
ja  	.565
shl	ax,*1
mov	bx,ax
seg	cs
br	.566[bx]
.566:
.word	.50C
.word	.50D
.word	.50E
.word	.50F
.word	.51E
.word	.520
.word	.510
.word	.521
.word	.51F
.word	.562
.word	.562
.word	.562
.word	.562
.word	.550
.word	.562
.word	.561
.565:
br 	.562
.4E8:
..FFF0	=	-$36
add	sp,*$E
.FFF1:
..FFF1	=	-$28
! 3874     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3875 int13_fail_noah:
.FFEC:
..FFEC	=	-$28
! 3876     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3877 int13_fail_nostatus:
.FFEE:
..FFEE	=	-$28
! 3878     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 3879     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3880 int13_success:
.FFEF:
..FFEF	=	-$28
! 3881     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 3882 int13_success_noah:
.FFED:
..FFED	=	-$28
! 3883     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3884     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 3885     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3886 }
! 3887   void
! Register BX used in function int13_harddisk
! 3888 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3889   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_cdrom
_int13_cdrom:
!BCC_EOS
! 3890 {
! 3891   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3892   Bit8u device, status, locks;
!BCC_EOS
! 3893   Bit8u atacmd[12];
!BCC_EOS
! 3894   Bit32u lba;
!BCC_EOS
! 3895   Bit16u count, segment, offset, i, size;
!BCC_EOS
! 3896   ;
add	sp,*-$1E
!BCC_EOS
! 3897   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3898   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
cmp	al,#$E0
jb  	.568
.569:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
cmp	al,#$E8
jb  	.567
.568:
! 3899     ;
!BCC_EOS
! 3900     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3901     }
! 3902   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
.567:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
add	ax,#-$E0
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3903   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
mov	al,-3[bp]
cmp	al,*8
jb  	.56A
.56B:
! 3903 
! 3904     ;
!BCC_EOS
! 3905     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3906     }
! 3907   switch (( AX >> 8 )) {
.56A:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.56E
! 3908     case 0x00:
! 3909     case 0x09:
.56F:
! 3910     case 0x0c:
.570:
! 3911     case 0x0d:
.571:
! 3912     case 0x10:
.572:
! 3913     case 0x11:
.573:
! 3914     case 0x14:
.574:
! 3915     case 0x16:
.575:
! 3916       goto int13_success;
.576:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3917       break;
br 	.56C
!BCC_EOS
! 3918     case 0x03:
! 3919     case 0x05:
.577:
! 3920     case 0x43:
.578:
! 3921       AX = ((AX & 0x00ff) | ((0x03) << 8));
.579:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3922       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3923       break;
br 	.56C
!BCC_EOS
! 3924     case 0x01:
! 3925       status = read_byte(0x0040, 0x0074);
.57A:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3926       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3927       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3928       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.57B
.57C:
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 3929       else goto int13_success_noah;
jmp .57D
.57B:
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3930       break;
.57D:
br 	.56C
!BCC_EOS
! 3931     case 0x15:
! 3932       AX = ((AX & 0x00ff) | ((0x02) << 8));
.57E:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3933       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3934       break;
br 	.56C
!BCC_EOS
! 3935     case 0x41:
! 3936       BX=0xaa55;
.57F:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3937       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3938       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3939       goto int13_success_noah;
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3940       break;
br 	.56C
!BCC_EOS
! 3941     case 0x42:
! 3942     case 0x44:
.580:
! 3943     case 0x47:
.581:
! 3944       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.582:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3945       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3946       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3947       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 3948       if (lba != 0L) {
! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFEA[bp]
call	lcmpul
lea	sp,2+..FFEA[bp]
je  	.583
.584:
! 3949         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .585+0 (used reg = )
mov	bx,#.585
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3950         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 3951         }
! 3952       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.583:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 3953       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.587
.588:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.586
.587:
! 3954         goto int13_success;
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3955       memsetb(get_SS(),atacmd,0,12);
.586:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 3956       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
mov	al,*$28
mov	-$11[bp],al
!BCC_EOS
! 3957       atacmd[7]=(count & 0xff00) >> 8;
! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
mov	ax,-$18[bp]
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 3958       atacmd[8]=(count & 0x00ff);
! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
mov	al,-$18[bp]
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 3959       atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 3960       atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
mov	-$E[bp],al
!BCC_EOS
! 3961       atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 3962       atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 3963       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
push	-$1C[bp]
! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
push	-$1A[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFEA[bp]
mov	bx,-6+..FFEA[bp]
lea	di,-$C+..FFEA[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$34-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3964       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3965       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
push	-$18[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3966       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.589
.58A:
! 3967         ;
!BCC_EOS
! 3968         AX = ((AX & 0
! 3968 x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3969         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3970         }
! 3971       goto int13_success;
.589:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3972       break;
br 	.56C
!BCC_EOS
! 3973     case 0x45:
! 3974       if (( AX & 0x00ff ) > 2) goto int13_fail;
.58B:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
cmp	al,*2
jbe 	.58C
.58D:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 3975       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.58C:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3976       switch (( AX & 0x00ff )) {
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
br 	.590
! 3977         case 0 :
! 3978           if (locks == 0xff) {
.591:
! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FF
jne 	.592
.593:
! 3979             AX = ((AX & 0x00ff) | ((0xb4) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3980             AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3981             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3982             }
! 3983           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
.592:
! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3984           AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3985           break;
br 	.58E
!BCC_EOS
! 3986         case 1 :
! 3987           if (locks == 0x00) {
.594:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.595
.596:
! 3988             AX = ((AX & 0x00ff) | ((0xb0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3989             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3990             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3991             }
! 3992           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
.595:
! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3993           AX = ((AX & 0xff00) | (locks==0?0:1));
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.597
.598:
xor	al,al
jmp .599
.597:
mov	al,*1
.599:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3994           break;
jmp .58E
!BCC_EOS
! 3995         case 2 :
! 3996           AX = ((AX & 0xff00) | (locks==0?0:1));
.59A:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.59B
.59C:
xor	al,al
jmp .59D
.59B:
mov	al,*1
.59D:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3997           break;
jmp .58E
!BCC_EOS
! 3998         }
! 3999       goto int13_success;
jmp .58E
.590:
sub	al,*0
beq 	.591
sub	al,*1
beq 	.594
sub	al,*1
je 	.59A
.58E:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4000       break;
br 	.56C
!BCC_EOS
! 4001     case 0x46:
! 4002       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.59E:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4003       if (locks != 0) {
! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
je  	.59F
.5A0:
! 4004         AX = ((AX & 0x00ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4005         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4006         }
! 4007 #asm
.59F:
!BCC_EOS
!BCC_ASM
_int13_cdrom.BP	set	$2E
.int13_cdrom.BP	set	$E
_int13_cdrom.EHBX	set	$24
.int13_cdrom.EHBX	set	4
_int13_cdrom.CS	set	$3C
.int13_cdrom.CS	set	$1C
_int13_cdrom.count	set	8
.int13_cdrom.count	set	-$18
_int13_cdrom.CX	set	$36
.int13_cdrom.CX	set	$16
_int13_cdrom.segment	set	6
.int13_cdrom.segment	set	-$1A
_int13_cdrom.DI	set	$2A
.int13_cdrom.DI	set	$A
_int13_cdrom.FLAGS	set	$3E
.int13_cdrom.FLAGS	set	$1E
_int13_cdrom.DS	set	$26
.int13_cdrom.DS	set	6
_int13_cdrom.ELDX	set	$30
.int13_cdrom.ELDX	set	$10
_int13_cdrom.DX	set	$34
.int13_cdrom.DX	set	$14
_int13_cdrom.size	set	0
.int13_cdrom.size	set	-$20
_int13_cdrom.i	set	2
.int13_cdrom.i	set	-$1E
_int13_cdrom.device	set	$1D
.int13_cdrom.device	set	-3
_int13_cdrom.ES	set	$28
.int13_cdrom.ES	set	8
_int13_cdrom.ebda_seg	set	$1E
.int13_cdrom.ebda_seg	set	-2
_int13_cdrom.SI	set	$2C
.int13_cdrom.SI	set	$C
_int13_cdrom.IP	set	$3A
.int13_cdrom.IP	set	$1A
_int13_cdrom.lba	set	$A
.int13_cdrom.lba	set	-$16
_int13_cdrom.status	set	$1C
.int13_cdrom.status	set	-4
_int13_cdrom.atacmd	set	$F
.int13_cdrom.atacmd	set	-$11
_int13_cdrom.AX	set	$38
.int13_cdrom.AX	set	$18
_int13_cdrom.offset	set	4
.int13_cdrom.offset	set	-$1C
_int13_cdrom.BX	set	$32
.int13_cdrom.BX	set	$12
_int13_cdrom.locks	set	$1B
.int13_cdrom.locks	set	-5
        push bp
        mov bp, sp
        mov ah, #0x52
        int #0x15
        mov _int13_cdrom.status + 2[bp], ah
        jnc int13_cdrom_rme_end
        mov _int13_cdrom.status, #1
int13_cdrom_rme_end:
        pop bp
! 4017 endasm
!BCC_ENDASM
!BCC_EOS
! 4018       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.5A1
.5A2:
! 4019         AX = ((AX & 0x00ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4020         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4021       }
! 4022       goto int13_success;
.5A1:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4023       break;
br 	.56C
!BCC_EOS
! 4024     case 0x48:
! 4025       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
.5A3:
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 4026       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
jae 	.5A4
.5A5:
! 4027         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4028       if(size >= 0x1a) {
.5A4:
! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
blo 	.5A6
.5A7:
! 4029         Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 4030         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4031         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4032         write_word
! 4032 (DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4033         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4034         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4035         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4036         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4037         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4038         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4039         }
! 4040       if(size >= 0x1e) {
.5A6:
! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1E
blo 	.5A8
.5A9:
! 4041         Bit8u channel, dev, irq, mode, checksum, i;
!BCC_EOS
! 4042         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 4043         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4044         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
push	-2[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4045         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4046         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4047         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4048         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 4049         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4050         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	-$24[bp],al
!BCC_EOS
! 4051         options = (1<<4);
! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,*$10
mov	-$2C[bp],ax
!BCC_EOS
! 4052         options |= (1<<5);
! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$20
mov	-$2C[bp],ax
!BCC_EOS
! 4053         options |= (1<<6);
! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$40
mov	-$2C[bp],ax
!BCC_EOS
! 4054         options |= (mode==0x01?1:0<<7);
! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*1
jne 	.5AA
.5AB:
mov	al,*1
jmp .5AC
.5AA:
xor	al,al
.5AC:
! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
xor	ah,ah
or	ax,-$2C[bp]
mov	-$2C[bp],ax
!BCC_EOS
! 4055         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
push	-$28[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4056         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	ax,-$2A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4057         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4058         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4059         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4060         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4061         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4062         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4063         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, option
! 4063 s);
! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4064         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4065         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4066         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	al,al
mov	-$25[bp],al
!BCC_EOS
! 4067         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
xor	al,al
mov	-$26[bp],al
!BCC_EOS
!BCC_EOS
jmp .5AF
.5B0:
! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
mov	al,-$26[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	ah,ah
add	al,-$25[bp]
adc	ah,*0
mov	-$25[bp],al
!BCC_EOS
! 4068         checksum = ~checksum;
.5AE:
! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
inc	ax
mov	-$26[bp],al
.5AF:
! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*$F
jb 	.5B0
.5B1:
.5AD:
! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 4069         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4070         }
! 4071       if(size >= 0x42) {
.5A8:
! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$42
blo 	.5B2
.5B3:
! 4072         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 4073         Bit16u iobase1;
!BCC_EOS
! 4074         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4075         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	-$22[bp],al
!BCC_EOS
! 4076         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4077         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4078         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4079         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4080         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4081         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4082         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5B4
.5B5:
! 4083           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4084           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4085           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4086           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4087           }
! 4088         else {
jmp .5B6
.5B4:
! 4089           }
! 4090         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.5B6:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4091         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4092         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4093         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4094         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5B7
.5B8:
! 4095           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
push	-$26[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4096           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4097           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4098           }
! 4099         else {
jmp .5B9
.5B7:
! 4100           }
! 4101         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.5B9:
! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4102         write_byte(DS,
! 4102  SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4103         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4104         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4105         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	al,al
mov	-$23[bp],al
!BCC_EOS
! 4106         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
mov	al,*$1E
mov	-$24[bp],al
!BCC_EOS
!BCC_EOS
jmp .5BC
.5BD:
! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$24[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	ah,ah
add	al,-$23[bp]
adc	ah,*0
mov	-$23[bp],al
!BCC_EOS
! 4107         checksum = ~checksum;
.5BB:
! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
inc	ax
mov	-$24[bp],al
.5BC:
! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*$40
jb 	.5BD
.5BE:
.5BA:
! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4108         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4109         }
! 4110       goto int13_success;
.5B2:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4111       break;
br 	.56C
!BCC_EOS
! 4112     case 0x49:
! 4113       AX = ((AX & 0x00ff) | ((06) << 8));
.5BF:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4114       goto int13_fail_nostatus;
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 4115       break;
br 	.56C
!BCC_EOS
! 4116     case 0x4e:
! 4117       switch (( AX & 0x00ff )) {
.5C0:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
jmp .5C3
! 4118         case 0x01:
! 4119         case 0x03:
.5C4:
! 4120         case 0x04:
.5C5:
! 4121         case 0x06:
.5C6:
! 4122           goto int13_success;
.5C7:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4123           break;
jmp .5C1
!BCC_EOS
! 4124         default :
! 4125           goto int13_fail;
.5C8:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4126         }
! 4127       break;
jmp .5C1
.5C3:
sub	al,*1
je 	.5C4
sub	al,*2
je 	.5C5
sub	al,*1
je 	.5C6
sub	al,*2
je 	.5C7
jmp	.5C8
.5C1:
br 	.56C
!BCC_EOS
! 4128     case 0x02:
! 4129     case 0x04:
.5C9:
! 4130     case 0x08:
.5CA:
! 4131     case 0x0a:
.5CB:
! 4132     case 0x0b:
.5CC:
! 4133     case 0x18:
.5CD:
! 4134     case 0x50:
.5CE:
! 4135     default:
.5CF:
! 4136       ;
.5D0:
!BCC_EOS
! 4137       goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4138       break;
br 	.56C
!BCC_EOS
! 4139     }
! 4140 int13_fail:
jmp .56C
.56E:
add	sp,*-$C
sub	ax,*0
jl 	.5D0
cmp	ax,*$18
ja  	.5D1
shl	ax,*1
mov	bx,ax
seg	cs
br	.5D2[bx]
.5D2:
.word	.56F
.word	.57A
.word	.5C9
.word	.577
.word	.5CA
.word	.578
.word	.5D0
.word	.5D0
.word	.5CB
.word	.570
.word	.5CC
.word	.5CD
.word	.571
.word	.572
.word	.5D0
.word	.5D0
.word	.573
.word	.574
.word	.5D0
.word	.5D0
.word	.575
.word	.57E
.word	.576
.word	.5D0
.word	.5CE
.5D1:
sub	ax,*$41
jb 	.5D0
cmp	ax,*$F
ja  	.5D3
shl	ax,*1
mov	bx,ax
seg	cs
br	.5D4[bx]
.5D4:
.word	.57F
.word	.580
.word	.579
.word	.581
.word	.58B
.word	.59E
.word	.582
.word	.5A3
.word	.5BF
.word	.5D0
.word	.5D0
.word	.5D0
.word	.5D0
.word	.5C0
.word	.5D0
.word	.5CF
.5D3:
br 	.5D0
.56C:
..FFEA	=	-$2E
add	sp,*$C
.FFEB:
..FFEB	=	-$22
! 4141     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4142 int13_fail_noah:
.FFE8:
..FFE8	=	-$22
! 4143     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4144 int13_fail_nostatus:
.FFE7:
..FFE7	=	-$22
! 4145     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 4146     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4147 int13_success:
.FFE9:
..FFE9	=	-$22
! 4148     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 4149 int13_success_noah:
.FFE6:
..FFE6	=	-$22
! 4150     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4151     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 4152     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4153 }
! 4154   void
! Register BX used in function int13_cdrom
! 4155 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4156   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_eltorito
_int13_eltorito:
!BCC_EOS
! 4157 {
! 4158   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4159   ;
!BCC_EOS
! 4160   switch (( AX >> 8 )) {
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.5D7
! 4161     case 0x4a:
! 4162     case 0x4c:
.5D8:
! 4163     case 0x4d:
.5D9:
! 4164       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
.5DA:
! Debug: list unsigned short AX = [S+4+$14] (used reg = )
push	$16[bp]
! Debug: list * char = .5DB+0 (used reg = )
mov	bx,#.5DB
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4165       goto int13_fail;
add	sp,#..FFE4-..FFE5
br 	.FFE4
!BCC_EOS
! 4166       break;
br 	.5D5
!BCC_EOS
! 4167     case 0x4b:
! 4168       write_byte(DS,SI+0x00,0x13);
.5DC:
! Debug: list int = const $13 (used reg = )
mov	ax,*$13
push	ax
! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4169       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4170       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4171       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4172       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4173     
! 4173   write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4174       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4175       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4176       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4177       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4178       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$11 (used reg = )
add	ax,*$11
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4179       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4180       if(( AX & 0x00ff ) == 0x00) {
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.5DD
.5DE:
! 4181         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4182         }
! 4183       goto int13_success;
.5DD:
add	sp,#..FFE3-..FFE5
jmp .FFE3
!BCC_EOS
! 4184       break;
jmp .5D5
!BCC_EOS
! 4185     default:
! 4186       ;
.5DF:
!BCC_EOS
! 4187       goto int13_fail;
add	sp,#..FFE4-..FFE5
jmp .FFE4
!BCC_EOS
! 4188       break;
jmp .5D5
!BCC_EOS
! 4189     }
! 4190 int13_fail:
jmp .5D5
.5D7:
sub	ax,*$4A
beq 	.5D8
sub	ax,*1
beq 	.5DC
sub	ax,*1
beq 	.5D9
sub	ax,*1
beq 	.5DA
jmp	.5DF
.5D5:
..FFE5	=	-4
.FFE4:
..FFE4	=	-4
! 4191     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4192     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4193     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4194     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4195 int13_success:
.FFE3:
..FFE3	=	-4
! 4196     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4197     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4198     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4199     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4200 }
! 4201   void
! Register BX used in function int13_eltorito
! 4202 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4203   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_cdemu
_int13_cdemu:
!BCC_EOS
! 4204 {
! 4205   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4206   Bit8u device, status;
!BCC_EOS
! 4207   Bit16u vheads, vspt, vcylinders;
!BCC_EOS
! 4208   Bit16u head, sector, cylinder, nbsectors;
!BCC_EOS
! 4209   Bit32u vlba, ilba, slba, elba;
!BCC_EOS
! 4210   Bit16u before, segment, offset;
!BCC_EOS
! 4211   Bit8u atacmd[12];
!BCC_EOS
! 4212   ;
add	sp,*-$32
!BCC_EOS
! 4213   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4214   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
xor	ah,ah
add	al,-3[bp]
adc	ah,*0
mov	-3[bp],al
!BCC_EOS
! 4215   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4216   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
! 4217    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.5E1
.5E2:
! Debug: expression subtree swapping
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
cmp	al,-$36[bp]
lea	sp,-$34[bp]
je  	.5E0
.5E1:
! 4218     ;
!BCC_EOS
! 4219     goto int13_fail;
add	sp,#..FFE2+$36
br 	.FFE2
!BCC_EOS
! 4220     }
! 4221   switch (( AX >> 8 )) {
.5E0:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.5E5
! 4222     case 0x00:
! 4223     case 0x09:
.5E6:
! 4224     case 0x0c:
.5E7:
! 4225     case 0x0d:
.5E8:
! 4226     case 0x10:
.5E9:
! 4227     case 0x11:
.5EA:
! 4228     case 0x14:
.5EB:
! 4229     case 0x16:
.5EC:
! 4230       goto int13_suc
.5ED:
! 4230 cess;
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4231       break;
br 	.5E3
!BCC_EOS
! 4232     case 0x03:
! 4233     case 0x05:
.5EE:
! 4234       AX = ((AX & 0x00ff) | ((0x03) << 8));
.5EF:
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4235       goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4236       break;
br 	.5E3
!BCC_EOS
! 4237     case 0x01:
! 4238       status=read_byte(0x0040, 0x0074);
.5F0:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4239       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4240       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4241       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.5F1
.5F2:
add	sp,#..FFDE-..FFE1
br 	.FFDE
!BCC_EOS
! 4242       else goto int13_success_noah;
jmp .5F3
.5F1:
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4243       break;
.5F3:
br 	.5E3
!BCC_EOS
! 4244     case 0x02:
! 4245     case 0x04:
.5F4:
! 4246       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.5F5:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4247       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 4248       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 4249       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	-$1A[bp],ax
mov	-$18[bp],bx
!BCC_EOS
! 4250       sector = ( CX & 0x00ff ) & 0x003f;
! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 4251       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
and	al,#$C0
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 4252       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4253       nbsectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
xor	ah,ah
mov	-$12[bp],ax
!BCC_EOS
! 4254       segment = ES;
! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
mov	ax,6[bp]
mov	-$26[bp],ax
!BCC_EOS
! 4255       offset = BX;
! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
mov	ax,$10[bp]
mov	-$28[bp],ax
!BCC_EOS
! 4256       if(nbsectors==0) goto int13_success;
! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
test	ax,ax
jne 	.5F6
.5F7:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4257       if ((sector > vspt)
.5F6:
! 4258        || (cylinder >= vcylinders)
! 4259        || (head >= vheads)) {
! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-8[bp]
ja  	.5F9
.5FB:
! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$A[bp]
jae 	.5F9
.5FA:
! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-6[bp]
jb  	.5F8
.5F9:
! 4260         goto int13_fail;
add	sp,#..FFE2-..FFE1
br 	.FFE2
!BCC_EOS
! 4261         }
! 4262       if (( AX >> 8 ) == 0x04) goto int13_success;
.5F8:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.5FC
.5FD:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4263       segment = ES+(BX / 16);
.5FC:
! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
mov	cl,*4
shr	ax,cl
! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
! Debug: expression subtree swapping
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4264       offset = BX % 16;
! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
xor	ah,ah
mov	-$28[bp],ax
!BCC_EOS
! 4265       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
mov	ax,-6[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 4266       AX = ((AX & 0xff00) | (nbsectors));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
or	ax,-$12[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4267       slba = (Bit32u)vlba/4;
! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFE1[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
mov	-$1E[bp],ax
mov	-$1C[bp],bx
!BCC_EOS
! 4268       before= (Bit16u)vlba%4;
! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
mov	ax,-$16[bp]
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 4269       elba = (Bit32u)(vlba+nbsectors-1)/4;
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
! Debug: expression subtree swapping
lea	di,-$16[bp]
call	laddul
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	lsubul
add	sp,*8
! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	ldivul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
mov	-$22[bp],ax
mov	-$20[bp],bx
!BCC_EOS
! 4270       memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 4271       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
mov	al,*$28
mov	-$34[bp],al
!BCC_EOS
! 4272       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 4273       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
mov	-$2C[bp],al
!BCC_EOS
! 4274       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF00
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
mov	-$32[bp],al
!BCC_EOS
! 4275       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
mov	-$31[bp],al
!BCC_EOS
! 4276       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF00
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
mov	-$30[bp],al
!BCC_EOS
! 4277       atacmd[5]=(ilba+slba & 0x000000ff);
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
mov	-$2F[bp],al
!BCC_EOS
! 4278       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
push	-$28[bp]
! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
push	-$26[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFE1[bp]
mov	bx,-6+..FFE1[bp]
lea	di,-$C+..FFE1[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
mov	ax,-$24[bp]
mov	cx,#$200
imul	cx
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$48-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.5FE
.5FF:
! 4279         ;
!BCC_EOS
! 4280         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4281         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4282         goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4283         }
! 4284       goto int13_succes
.5FE:
! 4284 s;
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4285       break;
br 	.5E3
!BCC_EOS
! 4286     case 0x08:
! 4287       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.600:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4288       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4289       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
! 4290       AX = ((AX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4291       BX = ((BX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4292       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	al,-$A[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4293       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
mov	al,-8[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4294       DX = ((DX & 0x00ff) | ((vheads) << 8));
! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
mov	ax,-6[bp]
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4295       DX = ((DX & 0xff00) | (0x02));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4296       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
jmp .603
! 4297         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
.604:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .601
!BCC_EOS
! 4298         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
.605:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
or	al,*4
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .601
!BCC_EOS
! 4299         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
.606:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
or	al,*6
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .601
!BCC_EOS
! 4300         }
! 4301 #asm
jmp .601
.603:
sub	al,*1
je 	.604
sub	al,*1
je 	.605
sub	al,*1
je 	.606
.601:
!BCC_EOS
!BCC_ASM
_int13_cdemu.BP	set	$40
.int13_cdemu.BP	set	$C
_int13_cdemu.CS	set	$4E
.int13_cdemu.CS	set	$1A
_int13_cdemu.nbsectors	set	$22
.int13_cdemu.nbsectors	set	-$12
_int13_cdemu.CX	set	$48
.int13_cdemu.CX	set	$14
_int13_cdemu.elba	set	$12
.int13_cdemu.elba	set	-$22
_int13_cdemu.segment	set	$E
.int13_cdemu.segment	set	-$26
_int13_cdemu.DI	set	$3C
.int13_cdemu.DI	set	8
_int13_cdemu.FLAGS	set	$50
.int13_cdemu.FLAGS	set	$1C
_int13_cdemu.vcylinders	set	$2A
.int13_cdemu.vcylinders	set	-$A
_int13_cdemu.sector	set	$26
.int13_cdemu.sector	set	-$E
_int13_cdemu.DS	set	$38
.int13_cdemu.DS	set	4
_int13_cdemu.head	set	$28
.int13_cdemu.head	set	-$C
_int13_cdemu.cylinder	set	$24
.int13_cdemu.cylinder	set	-$10
_int13_cdemu.DX	set	$46
.int13_cdemu.DX	set	$12
_int13_cdemu.device	set	$31
.int13_cdemu.device	set	-3
_int13_cdemu.ES	set	$3A
.int13_cdemu.ES	set	6
_int13_cdemu.vspt	set	$2C
.int13_cdemu.vspt	set	-8
_int13_cdemu.vlba	set	$1E
.int13_cdemu.vlba	set	-$16
_int13_cdemu.ebda_seg	set	$32
.int13_cdemu.ebda_seg	set	-2
_int13_cdemu.SI	set	$3E
.int13_cdemu.SI	set	$A
_int13_cdemu.IP	set	$4C
.int13_cdemu.IP	set	$18
_int13_cdemu.status	set	$30
.int13_cdemu.status	set	-4
_int13_cdemu.atacmd	set	0
.int13_cdemu.atacmd	set	-$34
_int13_cdemu.AX	set	$4A
.int13_cdemu.AX	set	$16
_int13_cdemu.ilba	set	$1A
.int13_cdemu.ilba	set	-$1A
_int13_cdemu.before	set	$10
.int13_cdemu.before	set	-$24
_int13_cdemu.offset	set	$C
.int13_cdemu.offset	set	-$28
_int13_cdemu.slba	set	$16
.int13_cdemu.slba	set	-$1E
_int13_cdemu.SP	set	$42
.int13_cdemu.SP	set	$E
_int13_cdemu.vheads	set	$2E
.int13_cdemu.vheads	set	-6
_int13_cdemu.BX	set	$44
.int13_cdemu.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_cdemu.DI+2[bp], ax
      mov _int13_cdemu.ES+2[bp], cs
      pop bp
! 4308 endasm
!BCC_ENDASM
!BCC_EOS
! 4309       goto int13_success;
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4310       break;
br 	.5E3
!BCC_EOS
! 4311     case 0x15:
! 4312       AX = ((AX & 0x00ff) | ((0x03) << 8));
.607:
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4313       goto int13_success_noah;
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4314       break;
br 	.5E3
!BCC_EOS
! 4315     case 0x0a:
! 4316     case 0x0b:
.608:
! 4317     case 0x18:
.609:
! 4318     case 0x41:
.60A:
! 4319     case 0x42:
.60B:
! 4320     case 0x43:
.60C:
! 4321     case 0x44:
.60D:
! 4322     case 0x45:
.60E:
! 4323     case 0x46:
.60F:
! 4324     case 0x47:
.610:
! 4325     case 0x48:
.611:
! 4326     case 0x49:
.612:
! 4327     case 0x4e:
.613:
! 4328     case 0x50:
.614:
! 4329     default:
.615:
! 4330       ;
.616:
!BCC_EOS
! 4331       goto int13_fail;
add	sp,#..FFE2-..FFE1
jmp .FFE2
!BCC_EOS
! 4332       break;
jmp .5E3
!BCC_EOS
! 4333     }
! 4334 int13_fail:
jmp .5E3
.5E5:
sub	ax,*0
jl 	.616
cmp	ax,*$18
ja  	.617
shl	ax,*1
mov	bx,ax
seg	cs
br	.618[bx]
.618:
.word	.5E6
.word	.5F0
.word	.5F4
.word	.5EE
.word	.5F5
.word	.5EF
.word	.616
.word	.616
.word	.600
.word	.5E7
.word	.608
.word	.609
.word	.5E8
.word	.5E9
.word	.616
.word	.616
.word	.5EA
.word	.5EB
.word	.616
.word	.616
.word	.5EC
.word	.607
.word	.5ED
.word	.616
.word	.60A
.617:
sub	ax,*$41
jb 	.616
cmp	ax,*$F
ja  	.619
shl	ax,*1
mov	bx,ax
seg	cs
br	.61A[bx]
.61A:
.word	.60B
.word	.60C
.word	.60D
.word	.60E
.word	.60F
.word	.610
.word	.611
.word	.612
.word	.613
.word	.616
.word	.616
.word	.616
.word	.616
.word	.614
.word	.616
.word	.615
.619:
br 	.616
.5E3:
..FFE1	=	-$36
.FFE2:
..FFE2	=	-$36
! 4335     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4336 int13_fail_noah:
.FFDF:
..FFDF	=	-$36
! 4337     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4338 int13_fail_nostatus:
.FFDE:
..FFDE	=	-$36
! 4339     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4340     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4341 int13_success:
.FFE0:
..FFE0	=	-$36
! 4342     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4343 int13_success_noah:
.FFDD:
..FFDD	=	-$36
! 4344     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4345     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4346     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4347 }
! 4348 void floppy_reset_controller()
! Register BX used in function int13_cdemu
! 4349 {
export	_floppy_reset_controller
_floppy_reset_controller:
! 4350   Bit8u val8;
!BCC_EOS
! 4351   val8 = inb(0x03f2);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4352   outb(0x03f2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4353   outb(0x03f2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4354   do {
.61D:
! 4355     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4356   } while ( (val8 & 0xc0) != 0x80 );
.61C:
! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.61D
.61E:
!BCC_EOS
! 4357 }
.61B:
mov	sp,bp
pop	bp
ret
! 4358 void floppy_prepare_controller(drive)
! 4359   Bit16u drive;
export	_floppy_prepare_controller
_floppy_prepare_controller:
!BCC_EOS
! 4360 {
! 4361   Bit8u val8, dor, prev_reset;
!BCC_EOS
! 4362   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4363   val8 &= 0x7
! 4363 f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4364   write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4365   prev_reset = inb(0x03f2) & 0x04;
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
and	al,*4
! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4366   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.61F
.620:
! 4367     dor = 0x20;
! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$20
mov	-2[bp],al
!BCC_EOS
! 4368   else
! 4369     dor = 0x10;
jmp .621
.61F:
! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$10
mov	-2[bp],al
!BCC_EOS
! 4370   dor |= 0x0c;
.621:
! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
or	al,*$C
mov	-2[bp],al
!BCC_EOS
! 4371   dor |= drive;
! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
mov	ax,4[bp]
or	al,-2[bp]
mov	-2[bp],al
!BCC_EOS
! 4372   outb(0x03f2, dor);
! Debug: list unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4373   write_byte(0x40,0x40, 37);
! Debug: list int = const $25 (used reg = )
mov	ax,*$25
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4374   do {
.624:
! 4375     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4376   } while ( (val8 & 0xc0) != 0x80 );
.623:
! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.624
.625:
!BCC_EOS
! 4377   if (prev_reset == 0) {
.622:
! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	al,-3[bp]
test	al,al
jne 	.626
.627:
! 4378 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    sti
! 4380 endasm
!BCC_ENDASM
!BCC_EOS
! 4381     do {
.62A:
! 4382       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4383     } while ( (val8 & 0x80) == 0 );
.629:
! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.62A
.62B:
!BCC_EOS
! 4384     val8 &= 0x7f;
.628:
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4385 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    cli
! 4387 endasm
!BCC_ENDASM
!BCC_EOS
! 4388     write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4389   }
! 4390 }
.626:
mov	sp,bp
pop	bp
ret
! 4391   bx_bool
! 4392 floppy_media_known(drive)
! 4393   Bit16u drive;
export	_floppy_media_known
_floppy_media_known:
!BCC_EOS
! 4394 {
! 4395   Bit8u val8;
!BCC_EOS
! 4396   Bit16u media_state_offset;
!BCC_EOS
! 4397   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4398   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.62C
.62D:
! 4399     val8 >>= 1;
! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
shr	ax,*1
mov	-1[bp],al
!BCC_EOS
! 4400   val8 &= 0x01;
.62C:
! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*1
mov	-1[bp],al
!BCC_EOS
! 4401   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.62E
.62F:
! 4402     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4403   media_state_offset = 0x0090;
.62E:
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4404   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.630
.631:
! 4405     media_state_offset += 1;
! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,-4[bp]
inc	ax
mov	-4[bp],ax
!BCC_EOS
! 4406   val8 = read_byte(0x0040, media_state_offset);
.630:
! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4407   val8 = (val8 >> 4) & 0x01;
! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4408   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.632
.633:
! 4409     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4410   return(1);
.632:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4411 }
! 4412   bx_bool
! 4413 floppy_media_sense(drive)
! 4414   Bit16u drive;
export	_floppy_media_sense
_floppy_media_sense:
!BCC_EOS
! 4415 {
! 4416   bx_bool retval;
!BCC_EOS
! 4417   Bit16u media_state_offset;
!BCC_EOS
! 4418   Bit8u drive_type, config_data, media_state;
!BCC_EOS
! 4419   if (floppy_drive_recal(drive) == 0) {
push	bp
mov	bp,sp
add	sp,*-8
! Debug: list unsigned short drive = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
call	_floppy_drive_recal
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.634
.635:
! 4420     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4421     }
! 4422   drive_type = inb_cmos(0x10);
.634:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4423   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.636
.637:
! 4424     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-5[bp],al
!BCC_EOS
! 4425   else
! 4426     drive_type &= 0x0f;
jmp .638
.636:
! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
and	al,*$F
mov	-5[bp],al
!BCC_EOS
! 4427   if ( drive_type == 1 ) {
.638:
! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
jne 	.639
.63A:
! 4428     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4429     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4430     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4431     }
! 4432   else if ( drive_type == 2 ) {
br 	.63B
.639:
! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*2
jne 	.63C
.63D:
! 4433     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4434     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4435     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4436     }
! 4437   else if ( drive_type == 3 ) {
br 	.63E
.63C:
! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*3
jne 	.63F
.640:
! 4438     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4439     media_state = 0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4440     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4441     }
! 4442   else if ( drive_type == 4 ) {
br 	.641
.63F:
! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*4
jne 	.642
.643:
! 4443     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4444     media_state = 0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4445     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4446     }
! 4447   else if ( drive_type == 5 ) {
br 	.644
.642:
! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*5
jne 	.645
.646:
! 4448     config_data = 0xCC;
! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
mov	al,#$CC
mov	-6[bp],al
!BCC_EOS
! 4449     media_state = 0xD7;
! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,#$D7
mov	-7[bp],al
!BCC_EOS
! 4450     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4451     }
! 4452   else if ( drive_type == 6 ) {
jmp .647
.645:
! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*6
jne 	.648
.649:
! 4453     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4454     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4455     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4456     }
! 4457   else if ( drive_type == 7 ) {
jmp .64A
.648:
! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*7
jne 	.64B
.64C:
! 4458     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4459     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4460     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4461     }
! 4462   else if ( drive_type == 8 ) {
jmp .64D
.64B:
! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
jne 	.64E
.64F:
! 4463     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4464     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4465     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4466     }
! 4467   else {
jmp .650
.64E:
! 4468     config_data = 0x00;
! 4468 
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4469     media_state = 0x00;
! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 4470     retval = 0;
! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
xor	ax,ax
mov	-2[bp],ax
!BCC_EOS
! 4471     }
! 4472   if (drive == 0)
.650:
.64D:
.64A:
.647:
.644:
.641:
.63E:
.63B:
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.651
.652:
! 4473     media_state_offset = 0x90;
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4474   else
! 4475     media_state_offset = 0x91;
jmp .653
.651:
! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$91
mov	-4[bp],ax
!BCC_EOS
! 4476   write_byte(0x0040, 0x008B, config_data);
.653:
! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $8B (used reg = )
mov	ax,#$8B
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4477   write_byte(0x0040, media_state_offset, media_state);
! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4478   return(retval);
mov	ax,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4479 }
! 4480   bx_bool
! 4481 floppy_drive_recal(drive)
! 4482   Bit16u drive;
export	_floppy_drive_recal
_floppy_drive_recal:
!BCC_EOS
! 4483 {
! 4484   Bit8u val8;
!BCC_EOS
! 4485   Bit16u curr_cyl_offset;
!BCC_EOS
! 4486   floppy_prepare_controller(drive);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4487   outb(0x03f5, 0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4488   outb(0x03f5, drive);
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4489 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  sti
! 4491 endasm
!BCC_ENDASM
!BCC_EOS
! 4492   do {
.656:
! 4493     val8 = (read_byte(0x0040, 0x003e) & 0x80);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4494   } while ( val8 == 0 );
.655:
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
je 	.656
.657:
!BCC_EOS
! 4495   val8 = 0;
.654:
! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
xor	al,al
mov	-1[bp],al
!BCC_EOS
! 4496 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  cli
! 4498 endasm
!BCC_ENDASM
!BCC_EOS
! 4499   val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4500   val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4501   if (drive) {
mov	ax,4[bp]
test	ax,ax
je  	.658
.659:
! 4502     val8 |= 0x02;
! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 4503     curr_cyl_offset = 0x0095;
! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$95
mov	-4[bp],ax
!BCC_EOS
! 4504   } else {
jmp .65A
.658:
! 4505     val8 |= 0x01;
! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*1
mov	-1[bp],al
!BCC_EOS
! 4506     curr_cyl_offset = 0x0094;
! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$94
mov	-4[bp],ax
!BCC_EOS
! 4507   }
! 4508   write_byte(0x0040, 0x003e, val8);
.65A:
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4509   write_byte(0x0040, curr_cyl_offset, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4510   return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4511 }
! 4512   bx_bool
! 4513 floppy_drive_exists(drive)
! 4514   Bit16u drive;
export	_floppy_drive_exists
_floppy_drive_exists:
!BCC_EOS
! 4515 {
! 4516   Bit8u drive_type;
!BCC_EOS
! 4517   drive_type = inb_cmos(0x10);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4518   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.65B
.65C:
! 4519     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-1[bp],al
!BCC_EOS
! 4520   else
! 4521     drive_type &= 0x0f;
jmp .65D
.65B:
! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$F
mov	-1[bp],al
!BCC_EOS
! 4522   if ( drive_type == 0 )
.65D:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.65E
.65F:
! 4523     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4524   else
! 4525     return(1);
jmp .660
.65E:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4526 }
.660:
mov	sp,bp
pop	bp
ret
! 4527   void
! 4528 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 4529   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_diskette_function
_int13_diskette_function:
!BCC_EOS
! 4530 {
! 4531   Bit8u drive, num_sectors, track, sector, head, status;
!BCC_EOS
! 4532   Bit16u base_address, base_count, base_es;
!BCC_EOS
! 4533   Bit8u page, mode_register, val8, dor;
!BCC_EOS
! 4534   Bit8u return_status[7];
!BCC_EOS
! 4535   Bit8u drive_type, num_floppies, ah;
!BCC_EOS
! 4536   Bit16u es, last_addr;
!BCC_EOS
! 4537   ;
push	bp
mov	bp,sp
add	sp,*-$1E
!BCC_EOS
! 4538   ah = ( AX >> 8 );
! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	-$1A[bp],al
!BCC_EOS
! 4539   switch ( ah ) {
mov	al,-$1A[bp]
br 	.663
! 4540     case 0x00:
! 4541 ;
.664:
!BCC_EOS
! 4542       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4543       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.665
.666:
! 4544         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4545         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4546         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4547         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4548       }
! 4549       drive_type = inb_cmos(0x10);
.665:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4550       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.667
.668:
! 4551         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4552       else
! 4553         drive_type &= 0x0f;
jmp .669
.667:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4554       if (drive_type == 0) {
.669:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.66A
.66B:
! 4555         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4556         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4557         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4558         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4559       }
! 4560       AX = ((AX & 0x00ff) | ((0) << 8));
.66A:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4561       set_diskette_ret_sta
! 4561 tus(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4562       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4563       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4564       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4565     case 0x01:
! 4566       FLAGS &= 0xfffe;
.66C:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4567       val8 = read_byte(0x0000, 0x0441);
! Debug: list int = const $441 (used reg = )
mov	ax,#$441
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4568       AX = ((AX & 0x00ff) | ((val8) << 8));
! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFDC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4569       if (val8) {
mov	al,-$F[bp]
test	al,al
je  	.66D
.66E:
! 4570         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4571       }
! 4572       return;
.66D:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4573     case 0x02:
! 4574     case 0x03:
.66F:
! 4575     case 0x04:
.670:
! 4576       num_sectors = ( AX & 0x00ff );
.671:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4577       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4578       sector = ( CX & 0x00ff );
! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
mov	al,$14[bp]
! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4579       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4580       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4581       if ((drive > 1) || (head > 1) || (sector == 0) ||
! 4582           (num_sectors == 0) || (num_sectors > 72)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.673
.677:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.673
.676:
! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.673
.675:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.673
.674:
! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$48
jbe 	.672
.673:
! 4583         ;
!BCC_EOS
! 4584         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4585         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4586         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4587         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4588         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4589       }
! 4590       if (floppy_drive_exists(drive) == 0) {
.672:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.678
.679:
! 4591         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4592         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4593         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4594         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4595         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4596       }
! 4597       if (floppy_media_known(drive) == 0) {
.678:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.67A
.67B:
! 4598         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.67C
.67D:
! 4599           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4600           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4601           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4602           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4603           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4604         }
! 4605       }
.67C:
! 4606       if (ah == 0x02) {
.67A:
! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*2
bne 	.67E
.67F:
! 4607         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4608         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4609         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4610         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.680
.681:
! 4611           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4612         }
! 4613         base_count = (num_sectors * 512) - 1;
.680:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4614         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4615         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.682
.683:
! 4616           AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4617           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4618           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4619           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4620           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4621         }
! 4622         ;
.682:
!BCC_EOS
! 4623         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4624   ;
!BCC_EOS
! 4625         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4626         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4627         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4628   ;
!BCC_EOS
! 4629         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4630         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4631         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4632         mode_register = 0x46;
! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$46
mov	-$E[bp],al
!BCC_EOS
! 4633   ;
!BCC_EOS
! 4634         outb(
! 4634 0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4635   ;
!BCC_EOS
! 4636         outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4637   ;
!BCC_EOS
! 4638         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4639         ;
!BCC_EOS
! 4640         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4641         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4642         outb(0x03f5, 0xe6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4643         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4644         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4645         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4646         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4647         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4648         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4649         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4650         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4651 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4653 endasm
!BCC_ENDASM
!BCC_EOS
! 4654         do {
.686:
! 4655           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4656           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.687
.688:
! 4657             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4658             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4659             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4660             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4661             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4662             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4663           }
! 4664           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.687:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4665         } while ( val8 == 0 );
.685:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.686
.689:
!BCC_EOS
! 4666         val8 = 0;
.684:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4667 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4669 endasm
!BCC_ENDASM
!BCC_EOS
! 4670         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4671         val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4672         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4673         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4674         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.68A
.68B:
! 4675           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .68C+0 (used reg = )
mov	bx,#.68C
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4676         return_status[0] = inb(0x3f5);
.68A:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4677         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4678         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4679         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4680         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4681         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4682         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4683         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4684         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4685         write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4686         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4687         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4688         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4689         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4690         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.68D
.68E:
! 4691           AX = ((AX & 0x00ff) | ((0x20) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$2000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4692           set_diskette_ret_status(0x20);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4693           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4694           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4695           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4696         }
! 4697     
! 4697     set_diskette_current_cyl(drive, track);
.68D:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4698         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4699         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4700         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4701       } else if (ah == 0x03) {
br 	.68F
.67E:
! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*3
bne 	.690
.691:
! 4702         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4703         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4704         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4705         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.692
.693:
! 4706           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4707         }
! 4708         base_count = (num_sectors * 512) - 1;
.692:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4709         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4710         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.694
.695:
! 4711           AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4712           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4713           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4714           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4715           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4716         }
! 4717         ;
.694:
!BCC_EOS
! 4718         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4719         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4720         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4721         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4722         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4723         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4724         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4725         mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4726         outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4727         outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4728         ;
!BCC_EOS
! 4729         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4730         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4731         outb(0x03f5, 0xc5);
! Debug: list int = const $C5 (used reg = )
mov	ax,#$C5
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4732         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4733         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4734         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4735         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4736         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4737         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4738         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4739         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4740 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4742 endasm
!BCC_ENDASM
!BCC_EOS
! 4743         do {
.698:
! 4744           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4745           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.699
.69A:
! 4746             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4747             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4748             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4749             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4750             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4751             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4752           }
! 4753           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.699:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4754         } while ( val8 == 0 );
.697:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.698
.69B:
!BCC_EOS
! 4755         val8 = 0;
.696:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4756 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4758 endasm
!BCC_ENDASM
!BCC_EOS
! 4759         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4760         val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4761         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4762         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4763         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.69C
.69D:
! 4764           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .69E+0 (used reg = )
mov	bx,#.69E
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4765 
! 4765         return_status[0] = inb(0x3f5);
.69C:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4766         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4767         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4768         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4769         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4770         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4771         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4772         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4773         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4774         write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4775         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4776         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4777         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4778         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4779         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.69F
.6A0:
! 4780           if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6A1
.6A2:
! 4781             AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4782             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4783             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4784           } else {
jmp .6A3
.6A1:
! 4785             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
! Debug: list * char = .6A4+0 (used reg = )
mov	bx,#.6A4
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4786           }
! 4787         }
.6A3:
! 4788         set_diskette_current_cyl(drive, track);
.69F:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4789         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4790         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4791         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4792       } else {
jmp .6A5
.690:
! 4793         set_diskette_current_cyl(drive, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4794         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4795         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4796         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4797       }
! 4798       break;
.6A5:
.68F:
br 	.661
!BCC_EOS
! 4799     case 0x05:
! 4800 ;
.6A6:
!BCC_EOS
! 4801       num_sectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4802       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4803       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4804       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4805       if ((drive > 1) || (head > 1) || (track > 79) ||
! 4806           (num_sectors == 0) || (num_sectors > 18)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.6A8
.6AC:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.6A8
.6AB:
! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
cmp	al,*$4F
ja  	.6A8
.6AA:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.6A8
.6A9:
! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$12
jbe 	.6A7
.6A8:
! 4807         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4808         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4809         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4810       }
! 4811       if (floppy_drive_exists(drive) == 0) {
.6A7:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6AD
.6AE:
! 4812         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4813         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4814         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4815         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4816       }
! 4817       if (floppy_media_known(drive) == 0) {
.6AD:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6AF
.6B0:
! 4818         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6B1
.6B2:
! 4819           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4820           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4821           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4822           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4823           retur
! 4823 n;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4824         }
! 4825       }
.6B1:
! 4826       page = (ES >> 12);
.6AF:
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4827       base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4828       base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4829       if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6B3
.6B4:
! 4830         page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4831       }
! 4832       base_count = (num_sectors * 4) - 1;
.6B3:
! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4833       last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4834       if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6B5
.6B6:
! 4835         AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4836         set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4837         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4838         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4839         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4840       }
! 4841       outb(0x000a, 0x06);
.6B5:
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4842       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4843       outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4844       outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4845       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4846       outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4847       outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4848       mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4849       outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4850       outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4851       outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4852       floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4853       outb(0x03f5, 0x4d);
! Debug: list int = const $4D (used reg = )
mov	ax,*$4D
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4854       outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4855       outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4856       outb(0x03f5, num_sectors);
! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4857       outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4858       outb(0x03f5, 0xf6);
! Debug: list int = const $F6 (used reg = )
mov	ax,#$F6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4859 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      sti
! 4861 endasm
!BCC_ENDASM
!BCC_EOS
! 4862       do {
.6B9:
! 4863         val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4864         if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6BA
.6BB:
! 4865           floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4866           AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4867           set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4868           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4869           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4870         }
! 4871         val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6BA:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4872       } while ( val8 == 0 );
.6B8:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6B9
.6BC:
!BCC_EOS
! 4873       val8 = 0;
.6B7:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4874 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      cli
! 4876 endasm
!BCC_ENDASM
!BCC_EOS
! 4877       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4878       val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4879       write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4880       val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4881       if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6BD
.6BE:
! 4882         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6BF+0 (used reg = )
mov	bx,#.6BF
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4883       return_status[0] = inb(0x3f5);
.6BD:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4884       return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4885       return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4886       return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4887       return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4888       return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4889       return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4890       write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4891       write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4892       write_byte(0x0040, 0x0044, return_status
! 4892 [2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4893       write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4894       write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4895       write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4896       write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4897       if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6C0
.6C1:
! 4898         if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6C2
.6C3:
! 4899           AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4900           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4901           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4902         } else {
jmp .6C4
.6C2:
! 4903           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
! Debug: list * char = .6C5+0 (used reg = )
mov	bx,#.6C5
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4904         }
! 4905       }
.6C4:
! 4906       AX = ((AX & 0x00ff) | ((0) << 8));
.6C0:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4907       set_diskette_ret_status(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4908       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4909       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4910       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4911     case 0x08:
! 4912 ;
.6C6:
!BCC_EOS
! 4913       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4914       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.6C7
.6C8:
! 4915         AX = 0;
! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ax,ax
mov	$16[bp],ax
!BCC_EOS
! 4916         BX = 0;
! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ax,ax
mov	$10[bp],ax
!BCC_EOS
! 4917         CX = 0;
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4918         DX = 0;
! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 4919         ES = 0;
! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 4920         DI = 0;
! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
xor	ax,ax
mov	8[bp],ax
!BCC_EOS
! 4921         DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4922         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4923         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4924         }
! 4925       drive_type = inb_cmos(0x10);
.6C7:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4926       num_floppies = 0;
! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
xor	al,al
mov	-$19[bp],al
!BCC_EOS
! 4927       if (drive_type & 0xf0)
! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,#$F0
test	al,al
je  	.6C9
.6CA:
! 4928         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4929       if (drive_type & 0x0f)
.6C9:
! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
test	al,al
je  	.6CB
.6CC:
! 4930         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4931       if (drive == 0)
.6CB:
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.6CD
.6CE:
! 4932         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4933       else
! 4934         drive_type &= 0x0f;
jmp .6CF
.6CD:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4935       BX = ((BX & 0x00ff) | ((0) << 8));
.6CF:
! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
mov	al,$10[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ah,ah
mov	$10[bp],ax
!BCC_EOS
! 4936       BX = ((BX & 0xff00) | (drive_type));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
or	al,-$18[bp]
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4937       AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4938       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4939       DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4940       switch (drive_type) {
mov	al,-$18[bp]
br 	.6D2
! 4941         case 0:
! 4942           CX = 0;
.6D3:
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4943           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4944           break;
br 	.6D0
!BCC_EOS
! 4945         case 1:
! 4946           CX = 0x2709;
.6D4:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 4947           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4948           break;
br 	.6D0
!BCC_EOS
! 4949         case 2:
! 4950           CX = 0x4f0f;
.6D5:
! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F0F
mov	$14[bp],ax
!BCC_EOS
! 4951           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4952           break;
br 	.6D0
!BCC_EOS
! 4953         case 3:
! 4954           CX = 0x4f09;
.6D6:
! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F09
mov	$14[bp],ax
!BCC_EOS
! 4955           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4956           break;
br 	.6D0
!BCC_EOS
! 4957         case 4:
! 4958           CX = 0x4f12;
.6D7:
! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F12
mov	$14[bp],ax
!BCC_EOS
! 4959           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4960           break;
br 	.6D0
!BCC_EOS
! 4961         case 5:
! 4962           CX = 0x4f24;
.6D8:
! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F24
mov	$14[bp],ax
!BCC_EOS
! 4963           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4964           break;
jmp .6D0
!BCC_EOS
! 4965         case 6:
! 4966           CX = 0x2708;
.6D9:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 4967           DX =
! 4967  ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4968           break;
jmp .6D0
!BCC_EOS
! 4969         case 7:
! 4970           CX = 0x2709;
.6DA:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 4971           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4972           break;
jmp .6D0
!BCC_EOS
! 4973         case 8:
! 4974           CX = 0x2708;
.6DB:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 4975           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4976           break;
jmp .6D0
!BCC_EOS
! 4977         default:
! 4978           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
.6DC:
! Debug: list * char = .6DD+0 (used reg = )
mov	bx,#.6DD
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4979         }
! 4980 #asm
jmp .6D0
.6D2:
sub	al,*0
jb 	.6DC
cmp	al,*8
ja  	.6DE
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.6DF[bx]
.6DF:
.word	.6D3
.word	.6D4
.word	.6D5
.word	.6D6
.word	.6D7
.word	.6D8
.word	.6D9
.word	.6DA
.word	.6DB
.6DE:
jmp	.6DC
.6D0:
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_diskette_function.DI+2[bp], ax
      mov _int13_diskette_function.ES+2[bp], cs
      pop bp
! 4987 endasm
!BCC_ENDASM
!BCC_EOS
! 4988       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4989       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4990     case 0x15:
! 4991 ;
.6E0:
!BCC_EOS
! 4992       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4993       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.6E1
.6E2:
! 4994         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4995         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4996         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4997         }
! 4998       drive_type = inb_cmos(0x10);
.6E1:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4999       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.6E3
.6E4:
! 5000         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 5001       else
! 5002         drive_type &= 0x0f;
jmp .6E5
.6E3:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 5003       FLAGS &= 0xfffe;
.6E5:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 5004       if (drive_type==0) {
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.6E6
.6E7:
! 5005         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 5006         }
! 5007       else {
jmp .6E8
.6E6:
! 5008         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5009         }
! 5010       return;
.6E8:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5011     case 0x16:
! 5012 ;
.6E9:
!BCC_EOS
! 5013       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5014       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.6EA
.6EB:
! 5015         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5016         set_diskette_ret_status(0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5017         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5018         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5019         }
! 5020       AX = ((AX & 0x00ff) | ((0x06) << 8));
.6EA:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5021       set_diskette_ret_status(0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5022       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5023       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5024     case 0x17:
! 5025 ;
.6EC:
!BCC_EOS
! 5026       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5027       set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5028       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5029       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5030     case 0x18:
! 5031 ;
.6ED:
!BCC_EOS
! 5032       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5033       set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5034       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5035       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5036     default:
! 5037         ;
.6EE:
!BCC_EOS
! 5038         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5039         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5040         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5041         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5042     }
! 5043 }
jmp .661
.663:
sub	al,*0
jb 	.6EE
cmp	al,*8
ja  	.6EF
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.6F0[bx]
.6F0:
.word	.664
.word	.66C
.word	.66F
.word	.670
.word	.671
.word	.6A6
.word	.6EE
.word	.6EE
.word	.6C6
.6EF:
sub	al,*$15
beq 	.6E0
sub	al,*1
beq 	.6E9
sub	al,*1
beq 	.6EC
sub	al,*1
beq 	.6ED
jmp	.6EE
.661:
..FFDC	=	-$20
mov	sp,bp
pop	bp
ret
! 5044  void
! Register BX used in function int13_diskette_function
! 5045 set_diskette_ret_status(value)
! 5046   Bit8u value;
export	_set_diskette_ret_status
_set_diskette_ret_status:
!BCC_EOS
! 5047 {
! 5048   write_byte(0x0040, 0x0041, value);
push	bp
mov	bp,sp
! Debug: list unsigned char value = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5049 }
pop	bp
ret
! 5050   void
! 5051 set_diskette_current_cyl(drive, cyl)
! 5052   Bit8u drive;
export	_set_diskette_current_cyl
_set_diskette_current_cyl:
!BCC_EOS
! 5053   Bit8u cyl;
!BCC_EOS
! 5054 {
! 5055   if (drive > 1)
push	bp
mov	bp,sp
! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jbe 	.6F1
.6F2:
! 5056     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n")
! 5056 ;
! Debug: list * char = .6F3+0 (used reg = )
mov	bx,#.6F3
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 5057   write_byte(0x0040, 0x0094+drive, cyl);
.6F1:
! Debug: list unsigned char cyl = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
! Debug: expression subtree swapping
mov	al,4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$94 (used reg = )
add	ax,#$94
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5058 }
pop	bp
ret
! 5059   void
! Register BX used in function set_diskette_current_cyl
! 5060 determine_floppy_media(drive)
! 5061   Bit16u drive;
export	_determine_floppy_media
_determine_floppy_media:
!BCC_EOS
! 5062 {
! 5063 }
ret
! 5064   void
! 5065 int17_function(regs, ds, iret_addr)
! 5066   pusha_regs_t regs;
export	_int17_function
_int17_function:
!BCC_EOS
! 5067   Bit16u ds;
!BCC_EOS
! 5068   iret_addr_t iret_addr;
!BCC_EOS
! 5069 {
! 5070   Bit16u addr,timeout;
!BCC_EOS
! 5071   Bit8u val8;
!BCC_EOS
! 5072 #asm
push	bp
mov	bp,sp
add	sp,*-6
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
  sti
! 5074 endasm
!BCC_ENDASM
!BCC_EOS
! 5075   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5076   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*3
bhis	.6F4
.6F7:
! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*3
bhis	.6F4
.6F6:
! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.6F4
.6F5:
! 5077     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$78 (used reg = )
add	ax,*$78
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 5078     if (regs.u.r8.ah == 0) {
! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
test	al,al
jne 	.6F8
.6F9:
! 5079       outb(addr, regs.u.r8.al);
! Debug: list unsigned char regs = [S+8+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5080       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5081       outb(addr+2, val8 | 0x01);
! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5082 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5084 endasm
!BCC_ENDASM
!BCC_EOS
! 5085       outb(addr+2, val8 & ~0x01);
! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5086       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
jmp .6FB
.6FC:
! 5087         timeout--;
! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5088       }
! 5089     }
.6FB:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
and	al,*$40
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.6FD
.6FE:
mov	ax,-4[bp]
test	ax,ax
jne	.6FC
.6FD:
.6FA:
! 5090     if (regs.u.r8.ah == 1) {
.6F8:
! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*1
jne 	.6FF
.700:
! 5091       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5092       outb(addr+2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5093 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5095 endasm
!BCC_ENDASM
!BCC_EOS
! 5096       outb(addr+2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5097     }
! 5098     val8 = inb(addr+1);
.6FF:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5099     regs.u.r8.ah = (val8 ^ 0x48);
! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	al,*$48
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 5100     if (!timeout) regs.u.r8.ah |= 0x01;
mov	ax,-4[bp]
test	ax,ax
jne 	.701
.702:
! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
or	al,*1
mov	$13[bp],al
!BCC_EOS
! 5101     iret_addr.flags.u.r8.flagsl &= 0xfe;
.701:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5102   } else {
jmp .703
.6F4:
! 5103     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5104   }
! 5105 }
.703:
mov	sp,bp
pop	bp
ret
! 5106 void
! 5107 int18_function(seq_nr)
! 5108 Bit16u seq_nr;
export	_int18_function
_int18_function:
!BCC_EOS
! 5109 {
! 5110   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5111   Bit16u bootdev;
!BCC_EOS
! 5112   Bit8u bootdrv;
!BCC_EOS
! 5113   Bit8u bootchk;
!BCC_EOS
! 5114   Bit16u bootseg;
!BCC_EOS
! 5115   Bit16u bootip;
!BCC_EOS
! 5116   Bit16u status;
!BCC_EOS
! 5117   Bit16u bootfirst;
!BCC_EOS
! 5118   ipl_entry_t e;
!BCC_EOS
! 5119   bootdev = inb_cmos(0x3d);
add	sp,*-$1C
! Debug: list int = const $3D (used reg = )
mov	ax,*$3D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5120   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
and	al,#$F0
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
or	ax,-4[bp]
mov	-4[bp],ax
!BCC_EOS
! 5121   bootdev >>= 4 * seq_nr;
! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,4[bp]
shl	ax,*1
shl	ax,*1
! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	bx,ax
mov	ax,-4[bp]
mov	cx,bx
shr	ax,cl
mov	-4[bp],ax
!BCC_EOS
! 5122   bootdev &= 0xf;
! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
mov	al,-4[bp]
and	al,*$F
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5123   bootfirst = read_word(ebda_seg, 0x0384);
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5124   if (bootfirst != 0xFFFF) {
! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,#$FFFF
je  	.704
.705:
! 5125     bootdev = bootfirst;
! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-$E[bp]
mov	-4[bp],ax
!BCC_EOS
! 5126     write_word(ebda_seg, 0x0384, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5127     write_word(ebda_seg, 0x0382, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $382 (used reg = )
mov	ax,#$382
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5128   } else if (bootdev == 0) {
jmp .706
.704:
! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
test	ax,ax
jne 	.707
.708:
! 5129     bios_printf(2, "\nNo bootable device.\n");
! Debug: list * char = .709+0 (used reg = )
mov	bx,#.709
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5130     bios_printf(2, "Powering off in 30 seconds.\n");
! Debug: list * char = .70A+0 (used reg = )
mov	bx,#.70A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5131 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    sti
    mov cx, #0x01c9
    mov dx, #0xc380
    mov ah, #0x86 ;; INT 15/86: wait CX:DX usec.
    int #0x15
! 5137 endasm
!BCC_ENDASM
!BCC_EOS
! 5138     bios_printf(1, "");
! Debug: list * char = .70B+0 (used reg = )
mov	bx,#.70B
push	bx
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5139   }
! 5140   bootdev -= 1;
.707:
.706:
! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5141   if (get_boot_vector(bootdev, &e) == 0) {
! Debug: list * struct  e = S+$20-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
call	_get_boot_vector
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.70C
.70D:
! 5142     ;
!BCC_EOS
! 5143     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5144   }
! 5145   print_boot_device(e.type, e.description);
.70C:
! Debug: list unsigned long e = [S+$20-$18] (used reg = )
push	-$14[bp]
push	-$16[bp]
! Debug: list unsigned short e = [S+$24-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_device+0 (used reg = )
call	_print_boot_device
add	sp,*6
!BCC_EOS
! 5146   switch(e.type) {
mov	ax,-$1E[bp]
br 	.710
! 5147   case 0x01:
! 5148   case 0x02:
.711:
! 5149     boot
! 5149 drv = (e.type == 0x02) ? 0x80 : 0x00;
.712:
! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*2
jne 	.713
.714:
mov	al,#$80
jmp .715
.713:
xor	al,al
.715:
! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5150     bootseg = 0x07c0;
! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,#$7C0
mov	-8[bp],ax
!BCC_EOS
! 5151     status = 0;
! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 5152 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    push bp
    mov bp, sp
    push ax
    push bx
    push cx
    push dx
    mov dl, _int18_function.bootdrv + 2[bp]
    mov ax, _int18_function.bootseg + 2[bp]
    mov es, ax ;; segment
    xor bx, bx ;; offset
    mov ah, #0x02 ;; function 2, read diskette sector
    mov al, #0x01 ;; read 1 sector
    mov ch, #0x00 ;; track 0
    mov cl, #0x01 ;; sector 1
    mov dh, #0x00 ;; head 0
    int #0x13 ;; read sector
    jnc int19_load_done
    mov ax, #0x0001
    mov _int18_function.status + 2[bp], ax
int19_load_done:
    pop dx
    pop cx
    pop bx
    pop ax
    pop bp
! 5178 endasm
!BCC_ENDASM
!BCC_EOS
! 5179     if (status != 0) {
! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.716
.717:
! 5180       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5181       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5182     }
! 5183     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
.716:
! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*1
jne 	.719
.71A:
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
jne 	.718
.719:
! 5184       if (read_word(bootseg,0x1fe) != 0xaa55) {
! Debug: list int = const $1FE (used reg = )
mov	ax,#$1FE
push	ax
! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
push	-8[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
cmp	ax,#$AA55
je  	.71B
.71C:
! 5185         print_boot_failure(e.type, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5186         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5187       }
! 5188     }
.71B:
! 5189     bootip = (bootseg & 0x0fff) << 4;
.718:
! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$FFF
! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5190     bootseg &= 0xf000;
! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$F000
mov	-8[bp],ax
!BCC_EOS
! 5191   break;
br 	.70E
!BCC_EOS
! 5192   case 0x03:
! 5193     status = cdrom_boot();
.71D:
! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
call	_cdrom_boot
! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5194     if ( (status & 0x00ff) !=0 ) {
! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
mov	al,-$C[bp]
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.71E
.71F:
! 5195       print_cdromboot_failure(status);
! Debug: list unsigned short status = [S+$20-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = print_cdromboot_failure+0 (used reg = )
call	_print_cdromboot_failure
inc	sp
inc	sp
!BCC_EOS
! 5196       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5197       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5198     }
! 5199     bootdrv = (Bit8u)(status>>8);
.71E:
! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
mov	al,ah
xor	ah,ah
! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5200     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5201     bootip = (bootseg & 0x0fff) << 4;
! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$FFF
! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5202     bootseg &= 0xf000;
! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$F000
mov	-8[bp],ax
!BCC_EOS
! 5203     break;
jmp .70E
!BCC_EOS
! 5204   case 0x80:
! 5205     bootseg = e.vector >> 16;
.720:
! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5206     bootip = e.vector & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-$1A[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5207     break;
jmp .70E
!BCC_EOS
! 5208   default: return;
.721:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5209   }
! 5210   bios_printf(2, " - success.\n");
jmp .70E
.710:
sub	ax,*1
beq 	.711
sub	ax,*1
beq 	.712
sub	ax,*1
beq 	.71D
sub	ax,*$7D
je 	.720
jmp	.721
.70E:
..FFDB	=	-$20
! Debug: list * char = .722+0 (used reg = )
mov	bx,#.722
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5211   ;
!BCC_EOS
! 5212 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    mov bp, sp
    push cs
    push #int18_handler
    ;; Build an iret stack frame that will take us to the boot vector.
    ;; iret pops ip, then cs, then flags, so push them in the opposite order.
    pushf
    mov ax, _int18_function.bootseg + 0[bp]
    push ax
    mov ax, _int18_function.bootip + 0[bp]
    push ax
    ;; Set the magic number in ax and the boot drive in dl.
    mov ax, #0xaa55
    mov dl, _int18_function.bootdrv + 0[bp]
    ;; Zero some of the other registers.
    xor bx, bx
    mov ds, bx
    mov es, bx
    mov bp, bx
    ;; Go!
    iret
! 5233 endasm
!BCC_ENDASM
!BCC_EOS
! 5234 }
mov	sp,bp
pop	bp
ret
! 5235   void
! Register BX used in function int18_function
! 5236 int1a_function(regs, ds, iret_addr)
! 5237   pusha_regs_t regs;
export	_int1a_function
_int1a_function:
!BCC_EOS
! 5238   Bit16u ds;
!BCC_EOS
! 5239   iret_addr_t iret_addr;
!BCC_EOS
! 5240 {
! 5241   Bit8u val8;
!BCC_EOS
! 5242   ;
push	bp
mov	bp,sp
dec	sp
dec	sp
!BCC_EOS
! 5243 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
  sti
! 5245 endasm
!BCC_ENDASM
!BCC_EOS
! 5246   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.725
! 5247     case 0:
! 5248 #asm
.726:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5250 endasm
!BCC_ENDASM
!BCC_EOS
! 5251       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
mov	ax,[$46E]
mov	$10[bp],ax
!BCC_EOS
! 5252       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
mov	ax,[$46C]
mov	$E[bp],ax
!BCC_EOS
! 5253       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,[$470]
mov	$12[bp],al
!BCC_EOS
! 5254       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5255 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5257 endasm
!BCC_ENDASM
!BCC_EOS
! 5258       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5259       break;
br 	.723
!BCC_EOS
! 5260     case 1:
! 5261 #asm
.727:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5263 endasm
!BCC_ENDASM
!BCC_EOS
! 5264       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
mov	ax,$10[bp]
mov	[$46E],ax
!BCC_EOS
! 5265       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
mov	ax,$E[bp]
mov	[$46C],ax
!BCC_EOS
! 5266       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5267 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5269 endasm
!BCC_ENDASM
!BCC_EOS
! 5270       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5271       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5272       break;
br 	.723
!BCC_EOS
! 5273     case 2:
! 5274       if (rtc_updating()) {
.728:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.729
.72A:
! 5275         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5276         break;
br 	.723
!BCC_EOS
! 5277         }
! 5278       regs.u.r8.dh = inb_cmos(0x00);
.729:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5279       regs.u.r8.cl = inb_cmos(0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5280       regs.u.r8.ch = inb_cmos(0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5281       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5282       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5283       regs.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5284       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5285       break;
br 	.723
!BCC_EOS
! 5286     case 3:
! 5287       if (rtc_updating()) {
.72B:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.72C
.72D:
! 5288         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5289         }
! 5290       outb_cmos(0x00, regs.u.r8.dh);
.72C:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5291       outb_cmos(0x02, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5292       outb_cmos(0x04, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5293       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
! Debug: expression subtree swapping
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
or	al,*2
push	ax
! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
mov	al,$E[bp]
and	al,*1
! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
or	al,0+..FFDA[bp]
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5294       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5295       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5296       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5297       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5298       break;
br 	.723
!BCC_EOS
! 5299     case 4:
! 5300       regs.u.r8.ah = 0;
.72E:
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5301       if (rtc_updating()) {
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.72F
.730:
! 5302         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5303         break;
br 	.723
!BCC_EOS
! 5304         }
! 5305       regs.u.r8.cl = inb_cmos(0x09);
.72F:
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5306       regs.u.r8.dh = inb_cmos(0x08);
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5307       regs.u.r8.dl = inb_cmos(0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5308       regs.u.r8.ch = inb_cmos(0x32);
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5309       regs.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5310       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5311       break;
br 	.723
!BCC_EOS
! 5312     case 5:
! 5313       if (rtc_updating()) {
.731:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.732
.733:
! 5314         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5315         iret_addr.flags.u.r8.flagsl |
! 5315 = 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5316         break;
br 	.723
!BCC_EOS
! 5317         }
! 5318       outb_cmos(0x09, regs.u.r8.cl);
.732:
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5319       outb_cmos(0x08, regs.u.r8.dh);
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5320       outb_cmos(0x07, regs.u.r8.dl);
! Debug: list unsigned char regs = [S+4+$C] (used reg = )
mov	al,$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5321       outb_cmos(0x32, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5322       val8 = inb_cmos(0x0b) & 0x7f;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
and	al,*$7F
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5323       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5324       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5325       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5326       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5327       break;
br 	.723
!BCC_EOS
! 5328     case 6:
! 5329       val8 = inb_cmos(0x0b);
.734:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5330       regs.u.r16.ax = 0;
! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 5331       if (val8 & 0x20) {
! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$20
test	al,al
je  	.735
.736:
! 5332         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5333         break;
br 	.723
!BCC_EOS
! 5334         }
! 5335       if (rtc_updating()) {
.735:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.737
.738:
! 5336         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5337         }
! 5338       outb_cmos(0x01, regs.u.r8.dh);
.737:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5339       outb_cmos(0x03, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5340       outb_cmos(0x05, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5341       outb(0xa1, inb(0xa1) & 0xfe);
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5342       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
or	al,*$20
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5343       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5344       break;
br 	.723
!BCC_EOS
! 5345     case 7:
! 5346       val8 = inb_cmos(0x0b);
.739:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5347       outb_cmos(0x0b, val8 & 0x57);
! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$57
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5348       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5349       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5350       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5351       break;
jmp .723
!BCC_EOS
! 5352     case 0xb1:
! 5353       if (regs.u.r8.bl == 0xff) {
.73A:
! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$FF
jne 	.73B
.73C:
! 5354         ;
!BCC_EOS
! 5355       } else if (regs.u.r8.bl == 0x81) {
jmp .73D
.73B:
! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$81
jne 	.73E
.73F:
! 5356         ;
!BCC_EOS
! 5357       } else if (regs.u.r8.bl == 0x83) {
jmp .740
.73E:
! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$83
jne 	.741
.742:
! 5358         ;
!BCC_EOS
! 5359       } else if (regs.u.r8.bl == 0x86) {
jmp .743
.741:
! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$86
jne 	.744
.745:
! 5360         if (regs.u.r8.al == 0x02) {
! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.746
.747:
! 5361           ;
!BCC_EOS
! 5362         } else {
jmp .748
.746:
! 5363           ;
!BCC_EOS
! 5364         }
! 5365       }
.748:
! 5366       regs.u.r8.ah = regs.u.r8.bl;
.744:
.743:
.740:
.73D:
! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
mov	al,$C[bp]
mov	$13[bp],al
!BCC_EOS
! 5367       iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5368       break;
jmp .723
!BCC_EOS
! 5369     default:
! 5370       iret_addr.flags.u.r8.flagsl |= 0x01;
.749:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5371     }
! 5372 }
jmp .723
.725:
sub	al,*0
jb 	.749
cmp	al,*7
ja  	.74A
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.74B[bx]
.74B:
.word	.726
.word	.727
.word	.728
.word	.72B
.word	.72E
.word	.731
.word	.734
.word	.739
.74A:
sub	al,#$B1
je 	.73A
jmp	.749
.723:
..FFDA	=	-4
mov	sp,bp
pop	bp
ret
! 5373   void
! 5374 int70_function(regs, ds, iret_addr)
! 5375   pusha_regs_t regs;
export	_int70_function
_int70_function:
!BCC_EOS
! 5376   Bit16u ds;
!BCC_EOS
! 5377   iret_addr_t iret_addr;
!BCC_EOS
! 5378 {
! 5379   Bit8u registerB = 0, registerC = 0;
push	bp
mov	bp,sp
dec	sp
! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
xor	al,al
mov	-1[bp],al
dec	sp
! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 5380   registerB = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5381   registerC = inb_cmos( 0xC );
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 5382   if( ( registerB & 0x60 ) != 0 ) {
! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$60
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.74C
.74D:
! 5383     if( ( registerC & 0x20 ) != 0 ) {
! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$20
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.74E
.74F:
! 5384 #asm
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
      sti
      int #0x4a
      cli
! 5388 endasm
!BCC_ENDASM
!BCC_EOS
! 5389     }
! 5390     if( ( registerC & 0x40 ) != 0 ) {
.74E:
! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$40
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.750
.751:
! 5391       if( read_byte( 0x40, 0xA0 ) != 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.752
.753:
! 5392         Bit32u time, toggle;
!BCC_EOS
! 5393         time = read_dword( 0x40, 0x9C );
add	sp,*-8
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
mov	-6[bp],ax
mov	-4[bp],bx
!BCC_EOS
! 5394         if( time < 0x3D1 ) {
! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
lea	di,-6[bp]
call	lcmpul
jbe 	.754
.755:
! 5395           Bit16u segment, offset;
!BCC_EOS
! 5396           segment = read_word( 0x40, 0x98 );
add	sp,*-4
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5397 
! 5397           offset = read_word( 0x40, 0x9A );
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5398           write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5399           outb_cmos( 0xB, registerB & 0x37 );
! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
mov	al,-1[bp]
and	al,*$37
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5400           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5401         } else {
add	sp,*4
jmp .756
.754:
! 5402           time -= 0x3D1;
! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
push	bx
push	ax
mov	ax,-6[bp]
mov	bx,-4[bp]
lea	di,-$E[bp]
call	lsubul
mov	-6[bp],ax
mov	-4[bp],bx
add	sp,*4
!BCC_EOS
! 5403           write_dword( 0x40, 0x9C, time );
! Debug: list unsigned long time = [S+$C-8] (used reg = )
push	-4[bp]
push	-6[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 5404         }
! 5405       }
.756:
add	sp,*8
! 5406     }
.752:
! 5407   }
.750:
! 5408 #asm
.74C:
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
  call eoi_both_pics
! 5410 endasm
!BCC_ENDASM
!BCC_EOS
! 5411 }
mov	sp,bp
pop	bp
ret
! 5412 #asm
!BCC_ASM
_int70_function.ds	set	$12
_int70_function.iret_addr	set	$14
_int70_function.regs	set	2
;------------------------------------------
;- INT74h : PS/2 mouse hardware interrupt -
;------------------------------------------
int74_handler:
  sti
  pusha
  push ds ;; save DS
  push #0x00 ;; placeholder for status
  push #0x00 ;; placeholder for X
  push #0x00 ;; placeholder for Y
  push #0x00 ;; placeholder for Z
  push #0x00 ;; placeholder for make_far_call boolean
  call _int74_function
  pop cx ;; remove make_far_call from stack
  jcxz int74_done
  ;; make far call to EBDA:0022
  push #0x00
  pop ds
  push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
  pop ds
  call far ptr[0x22]
int74_done:
  cli
  call eoi_both_pics
  add sp, #8 ;; pop status, x, y, z
  pop ds ;; restore DS
  popa
  iret
;; This will perform an IRET, but will retain value of current CF
;; by altering flags on stack. Better than RETF #02.
iret_modify_cf:
  jc carry_set
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xfe
  pop bp
  iret
carry_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x01
  pop bp
  iret
;----------------------
;- INT13h (relocated) -
;----------------------
;
; int13_relocated is a little bit messed up since I played with it
; I have to rewrite it:
; - call a function that detect which function to call
; - make all called C function get the same parameters list
;
int13_relocated:
  ;; check for an eltorito function
  cmp ah,#0x4a
  jb int13_not_eltorito
  cmp ah,#0x4d
  ja int13_not_eltorito
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_eltorito ;; ELDX not used
int13_not_eltorito:
  push ax
  push bx
  push cx
  push dx
  ;; check if emulation active
  call _cdemu_isactive
  cmp al,#0x00
  je int13_cdemu_inactive
  ;; check if access to the emulated drive
  call _cdemu_emulated_drive
  pop dx
  push dx
  cmp al,dl ;; int13 on emulated drive
  jne int13_nocdemu
  pop dx
  pop cx
  pop bx
  pop ax
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_cdemu ;; ELDX not used
int13_nocdemu:
  and dl,#0xE0 ;; mask to get device class, including cdroms
  cmp al,dl ;; al is 0x00 or 0x80
  jne int13_cdemu_inactive ;; inactive for device class
  pop dx
  pop cx
  pop bx
  pop ax
  push ax
  push cx
  push dx
  push bx
  dec dl ;; real drive is dl - 1
  jmp int13_legacy
int13_cdemu_inactive:
  pop dx
  pop cx
  pop bx
  pop ax
int13_noeltorito:
  push ax
  push cx
  push dx
  push bx
int13_legacy:
  push dx ;; push eltorito value of dx instead of sp
  push bp
  push si
  push di
  push es
  push ds
  push ss
  pop ds
  ;; now the 16-bit registers can be restored with:
  ;; pop ds; pop es; popa; iret
  ;; arguments passed to functions should be
  ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
  test dl, #0x80
  jnz int13_notfloppy
  push #int13_out
  jmp _int13_diskette_function
int13_notfloppy:
  cmp dl, #0xE0
  jb int13_notcdrom
  shr ebx, #16
  push bx
  call _int13_cdrom
  pop bx
  shl ebx, #16
  jmp int13_out
int13_notcdrom:
int13_disk:
  ;; int13_harddisk modifies high word of EAX
  shr eax, #16
  push ax
  call _int13_harddisk
  pop ax
  shl eax, #16
int13_out:
  pop ds
  pop es
  popa
  iret
;----------
;- INT18h -
;----------
int18_handler: ;; Boot Failure recovery: try the next device.
  ;; Reset SP and SS
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  ;; The first time we do this it will have been set to -1 so
  ;; we will start from device 0.
  xor ax, ax
  mov ds, ax
  mov bx, word ptr [0x40E] ;; EBDA segment
  mov ds, bx ;; Set segment
  mov bx, 0x0382 ;; BX is now the sequence number
  inc bx ;; ++
  mov 0x0382, bx ;; Write it back
  mov ds, ax ;; and reset the segment to zero.
  ;; Call the C code for the next boot device
  push bx
  call _int18_function
  ;; Boot failed: invoke the boot recovery function...
  int #0x18
;----------
;- INT19h -
;----------
int19_relocated: ;; Boot function, relocated
  ;;
  ;; *** Warning: INT 19h resets the whole machine ***
  ;;
  ;; Because PV drivers in HVM guests detach some of the emulated devices,
  ;; it is not safe to do a soft reboot by just dropping to real mode and
  ;; invoking INT 19h -- the boot drives might have disappeared!
  ;; If the user asks for a soft reboot, the only thing we can do is
  ;; reset the whole machine. When it comes back up, the normal BIOS
  ;; boot sequence will start, which is more or less the required behaviour.
  ;;
  ;; Reset SP and SS
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  call _machine_reset
;----------
;- INT1Ch -
;----------
int1c_handler: ;; User Timer Tick
  iret
;----------------------
;- POST: Floppy Drive -
;----------------------
floppy_drive_post:
  xor ax, ax
  mov ds, ax
  mov al, #0x00
  mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
  mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
  mov 0x0440, al ;; diskette motor timeout counter: not active
  mov 0x0441, al ;; diskette controller status return code
  mov 0x0442, al ;; disk & diskette controller status register 0
  mov 0x0443, al ;; diskette controller status register 1
  mov 0x0444, al ;; diskette controller status register 2
  mov 0x0445, al ;; diskette controller cylinder number
  mov 0x0446, al ;; diskette controller head number
  mov 0x0447, al ;; diskette controller sector number
  mov 0x0448, al ;; diskette controller bytes written
  mov 0x048b, al ;; diskette configuration data
  ;; -----------------------------------------------------------------
  ;; (048F) diskette controller information
  ;;
  mov al, #0x10 ;; get CMOS diskette drive type
  out 0x70, AL
  in AL, 0x71
  mov ah, al ;; save byte to AH
look_drive0:
  shr al, #4 ;; look at top 4 bits for drive 0
  jz f0_missing ;; jump if no drive0
  mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
  jmp look_drive1
f0_missing:
  mov bl, #0x00 ;; no drive0
look_drive1:
  mov al, ah ;; restore from AH
  and al, #0x0f ;; look at bottom 4 bits for drive 1
  jz f1_missing ;; jump if no drive1
  or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
f1_missing:
                   ;; leave high bits in BL zerod
  mov 0x048f, bl ;; put new val in BDA (diskette controller information)
  ;; -----------------------------------------------------------------
  mov al, #0x00
  mov 0x0490, al ;; diskette 0 media state
  mov 0x0491, al ;; diskette 1 media state
                   ;; diskette 0,1 operational starting state
                   ;; drive type has not been determined,
                   ;; has no changed detection line
  mov 0x0492, al
  mov 0x0493, al
  mov 0x0494, al ;; diskette 0 current cylinder
  mov 0x0495, al ;; diskette 1 current cylinder
  mov al, #0x02
  out #0x0a, al ;; clear DMA-1 channel 2 mask bit
  SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
  SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
  SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
  ret
;--------------------
;- POST: HARD DRIVE -
;--------------------
; relocated here because the primary POST area isnt big enough.
hard_drive_post:
  mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
  mov dx, #0x03f6
  out dx, al
  xor ax, ax
  mov ds, ax
  mov 0x0474, al
  mov 0x0477, al
  mov 0x048c, al
  mov 0x048d, al
  mov 0x048e, al
  mov al, #0x01
  mov 0x0475, al
  mov al, #0xc0
  mov 0x0476, al
  SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
  SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
  ;; INT 41h: hard disk 0 configuration pointer
  ;; INT 46h: hard disk 1 configuration pointer
  SET_INT_VECTOR(0x41, word ptr [0x40E], #0x003D)
  SET_INT_VECTOR(0x46, word ptr [0x40E], #0x004D)
  ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0xf0
  cmp al, #0xf0
  je post_d0_extended
  jmp check_for_hd1
post_d0_extended:
  mov al, #0x19
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d0_type47
  HALT(9010)
post_d0_type47:
  ;; CMOS purpose param table offset
  ;; 1b cylinders low 0
  ;; 1c cylinders high 1
  ;; 1d heads 2
  ;; 1e write pre-comp low 5
  ;; 1f write pre-comp high 6
  ;; 20 retries/bad map/heads>8 8
  ;; 21 landing zone low C
  ;; 22 landing zone high D
  ;; 23 sectors/track E
  xor ax, ax
  mov ds, ax
  mov ax, word ptr [0x40E] ;; EBDA segment
  mov ds, ax
  ;;; Filling EBDA table for hard disk 0.
  mov al, #0x1f
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x1e
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x05), ax ;; write precomp word
  mov al, #0x20
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x08), al ;; drive control byte
  mov al, #0x22
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x21
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x0C), ax ;; landing zone word
  mov al, #0x1c ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x1b
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x1d
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x23
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd0_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  mov (0x003d + 0x0E), dl ;; number of physical sectors
  jmp check_for_hd1
hd0_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x09), bx ;; number of physical cylinders
  mov (0x003d + 0x0b), cl ;; number of physical heads
  mov (0x003d + 0x04), dl ;; number of physical sectors
  mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd0_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd0_post_store_logical
hd0_post_above_2048:
  cmp bx, #4096
  jnbe hd0_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd0_post_store_logical
hd0_post_above_4096:
  cmp bx, #8192
  jnbe hd0_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd0_post_store_logical
hd0_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd0_post_store_logical:
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x003d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd0_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd0_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 0.
check_for_hd1:
  ;; is there really a second hard disk? if not, return now
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0x0f
  jnz post_d1_exists
  ret
post_d1_exists:
  ;; check that the hd type is really 0x0f.
  cmp al, #0x0f
  jz post_d1_extended
  HALT(9149)
post_d1_extended:
  ;; check that the extended type is 47 - user definable
  mov al, #0x1a
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d1_type47
  HALT(9157)
post_d1_type47:
  ;; Table for disk1.
  ;; CMOS purpose param table offset
  ;; 0x24 cylinders low 0
  ;; 0x25 cylinders high 1
  ;; 0x26 heads 2
  ;; 0x27 write pre-comp low 5
  ;; 0x28 write pre-comp high 6
  ;; 0x29 heads>8 8
  ;; 0x2a landing zone low C
  ;; 0x2b landing zone high D
  ;; 0x2c sectors/track E
;;; Fill EBDA table for hard disk 1.
  xor ax, ax
  mov ds, ax
  mov ax, word ptr [0x40E] ;; EBDA segment
  mov ds, ax
  mov al, #0x28
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x27
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x05), ax ;; write precomp word
  mov al, #0x29
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x08), al ;; drive control byte
  mov al, #0x2b
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x2a
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x0C), ax ;; landing zone word
  mov al, #0x25 ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x24
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x26
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x2c
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd1_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  mov (0x004d + 0x0E), dl ;; number of physical sectors
  ret
hd1_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x09), bx ;; number of physical cylinders
  mov (0x004d + 0x0b), cl ;; number of physical heads
  mov (0x004d + 0x04), dl ;; number of physical sectors
  mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd1_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd1_post_store_logical
hd1_post_above_2048:
  cmp bx, #4096
  jnbe hd1_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd1_post_store_logical
hd1_post_above_4096:
  cmp bx, #8192
  jnbe hd1_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd1_post_store_logical
hd1_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd1_post_store_logical:
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x004d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd1_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd1_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 1.
  ret
;--------------------
;- POST: EBDA segment
;--------------------
; relocated here because the primary POST area isnt big enough.
ebda_post:
  mov ax, #0x9FC0
  mov ds, ax
  mov byte ptr [0x0], #1
  xor ax, ax ; mov EBDA seg into 40E
  mov ds, ax
  mov word ptr [0x40E], #0x9FC0
  ret;;
;--------------------
;- POST: EOI + jmp via [0x40:67)
;--------------------
; relocated here because the primary POST area isnt big enough.
eoi_jmp_post:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
jmp_post_0x467:
  xor ax, ax
  mov ds, ax
  jmp far ptr [0x467]
iret_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  iret
retf_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  retf
s3_post:
  call _s3_resume
  mov bl, #0x00
  and ax, ax
  jz normal_post
  call _s3_resume_panic
;--------------------
eoi_both_pics:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
eoi_master_pic:
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
  ret
;--------------------
BcdToBin:
  ;; in: AL in BCD format
  ;; out: AL in binary format, AH will always be 0
  ;; trashes BX
  mov bl, al
  and bl, #0x0f ;; bl has low digit
  shr al, #4 ;; al has high digit
  mov bh, #10
  mul al, bh ;; multiply high digit by 10 (result in AX)
  add al, bl ;; then add low digit
  ret
;--------------------
timer_tick_post:
  ;; Setup the Timer Ticks Count (0x46C:dword) and
  ;; Timer Ticks Roller Flag (0x470:byte)
  ;; The Timer Ticks Count needs to be set according to
  ;; the current CMOS time, as if ticks have been occurring
  ;; at 18.2hz since midnight up to this point. Calculating
  ;; this is a little complicated. Here are the factors I gather
  ;; regarding this. 14,318,180 hz was the original clock speed,
  ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
  ;; at the time, or 4 to drive the CGA video adapter. The div3
  ;; source was divided again by 4 to feed a 1.193Mhz signal to
  ;; the timer. With a maximum 16bit timer count, this is again
  ;; divided down by 65536 to 18.2hz.
  ;;
  ;; 14,318,180 Hz clock
  ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
  ;; /4 = 1,193,181 Hz fed to timer
  ;; /65536 (maximum timer count) = 18.20650736 ticks/second
  ;; 1 second = 18.20650736 ticks
  ;; 1 minute = 1092.390442 ticks
  ;; 1 hour = 65543.42651 ticks
  ;;
  ;; Given the values in the CMOS clock, one could calculate
  ;; the number of ticks by the following:
  ;; ticks = (BcdToBin(seconds) * 18.206507) +
  ;; (BcdToBin(minutes) * 1092.3904)
  ;; (BcdToBin(hours) * 65543.427)
  ;; To get a little more accuracy, since Im using integer
  ;; arithmatic, I use:
  ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
  ;; (BcdToBin(minutes) * 10923904) / 10000 +
  ;; (BcdToBin(hours) * 65543427) / 1000
  ;; assuming DS=0000
  ;; get CMOS seconds
  xor eax, eax ;; clear EAX
  mov al, #0x00
  out #0x70, al
  in al, #0x71 ;; AL has CMOS seconds in BCD
  call BcdToBin ;; EAX now has seconds in binary
  mov edx, #18206507
  mul eax, edx
  mov ebx, #1000000
  xor edx, edx
  div eax, ebx
  mov ecx, eax ;; ECX will accumulate total ticks
  ;; get CMOS minutes
  xor eax, eax ;; clear EAX
  mov al, #0x02
  out #0x70, al
  in al, #0x71 ;; AL has CMOS minutes in BCD
  call BcdToBin ;; EAX now has minutes in binary
  mov edx, #10923904
  mul eax, edx
  mov ebx, #10000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  ;; get CMOS hours
  xor eax, eax ;; clear EAX
  mov al, #0x04
  out #0x70, al
  in al, #0x71 ;; AL has CMOS hours in BCD
  call BcdToBin ;; EAX now has hours in binary
  mov edx, #65543427
  mul eax, edx
  mov ebx, #1000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  mov 0x46C, ecx ;; Timer Ticks Count
  xor al, al
  mov 0x470, al ;; Timer Ticks Rollover Flag
  ret
;--------------------
int76_handler:
  ;; record completion in BIOS task complete flag
  push ax
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov 0x008E, #0xff
  call eoi_both_pics
  pop ds
  pop ax
  iret
;--------------------
use32 386
apm32_out_str:
  push eax
  push ebx
  mov ebx, eax
apm32_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm32_out_str2
  outb dx, al
  inc ebx
  jmp apm32_out_str1
apm32_out_str2:
  pop ebx
  pop eax
  ret
apm32_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm32_07_suspend_str:
  .ascii "Suspend"
  db 0
apm32_07_standby_str:
  .ascii "Standby"
  db 0
_apm32_entry:
  pushf
;-----------------
; APM interface disconnect
apm32_04:
  cmp al, #0x04
  jne apm32_05
  jmp apm32_ok
;-----------------
; APM cpu idle
apm32_05:
  cmp al, #0x05
  jne apm32_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apm32_ok
;-----------------
; APM Set Power State
apm32_07:
  cmp al, #0x07
  jne apm32_08
  cmp bx, #1
  jne apm32_ok
  cmp cx, #3
  je apm32_07_poweroff
  cmp cx, #2
  je apm32_07_suspend
  cmp cx, #1
  je apm32_07_standby
  jne apm32_ok
apm32_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm32_07_poweroff_str
  call apm32_out_str
apm32_07_1:
  hlt
  jmp apm32_07_1
apm32_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_suspend_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
apm32_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_standby_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
;-----------------
; APM Enable / Disable
apm32_08:
  cmp al, #0x08
  jne apm32_0a
  jmp apm32_ok
;-----------------
; Get Power Status
apm32_0a:
  cmp al, #0x0a
  jne apm32_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm32_ok
;-----------------
; Get PM Event
apm32_0b:
  cmp al, #0x0b
  jne apm32_0e
  mov ah, #0x80
  jmp apm32_error
;-----------------
; APM Driver Version
apm32_0e:
  cmp al, #0x0e
  jne apm32_0f
  mov ah, #1
  mov al, #2
  jmp apm32_ok
;-----------------
; APM Engage / Disengage
apm32_0f:
  cmp al, #0x0f
  jne apm32_10
  jmp apm32_ok
;-----------------
; APM Get Capabilities
apm32_10:
  cmp al, #0x10
  jne apm32_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm32_ok
;-----------------
apm32_ok:
  popf
  clc
  retf
apm32_unimplemented:
apm32_error:
  popf
  stc
  retf
use16 386
apm16_out_str:
  push eax
  push ebx
  mov ebx, eax
apm16_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm16_out_str2
  outb dx, al
  inc ebx
  jmp apm16_out_str1
apm16_out_str2:
  pop ebx
  pop eax
  ret
apm16_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm16_07_suspend_str:
  .ascii "Suspend"
  db 0
apm16_07_standby_str:
  .ascii "Standby"
  db 0
_apm16_entry:
  pushf
;-----------------
; APM interface disconnect
apm16_04:
  cmp al, #0x04
  jne apm16_05
  jmp apm16_ok
;-----------------
; APM cpu idle
apm16_05:
  cmp al, #0x05
  jne apm16_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apm16_ok
;-----------------
; APM Set Power State
apm16_07:
  cmp al, #0x07
  jne apm16_08
  cmp bx, #1
  jne apm16_ok
  cmp cx, #3
  je apm16_07_poweroff
  cmp cx, #2
  je apm16_07_suspend
  cmp cx, #1
  je apm16_07_standby
  jne apm16_ok
apm16_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm16_07_poweroff_str
  call apm16_out_str
apm16_07_1:
  hlt
  jmp apm16_07_1
apm16_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_suspend_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
apm16_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_standby_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
;-----------------
; APM Enable / Disable
apm16_08:
  cmp al, #0x08
  jne apm16_0a
  jmp apm16_ok
;-----------------
; Get Power Status
apm16_0a:
  cmp al, #0x0a
  jne apm16_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm16_ok
;-----------------
; Get PM Event
apm16_0b:
  cmp al, #0x0b
  jne apm16_0e
  mov ah, #0x80
  jmp apm16_error
;-----------------
; APM Driver Version
apm16_0e:
  cmp al, #0x0e
  jne apm16_0f
  mov ah, #1
  mov al, #2
  jmp apm16_ok
;-----------------
; APM Engage / Disengage
apm16_0f:
  cmp al, #0x0f
  jne apm16_10
  jmp apm16_ok
;-----------------
; APM Get Capabilities
apm16_10:
  cmp al, #0x10
  jne apm16_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm16_ok
;-----------------
apm16_ok:
  popf
  clc
  retf
apm16_unimplemented:
apm16_error:
  popf
  stc
  retf
apmreal_out_str:
  push eax
  push ebx
  mov ebx, eax
apmreal_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apmreal_out_str2
  outb dx, al
  inc ebx
  jmp apmreal_out_str1
apmreal_out_str2:
  pop ebx
  pop eax
  ret
apmreal_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apmreal_07_suspend_str:
  .ascii "Suspend"
  db 0
apmreal_07_standby_str:
  .ascii "Standby"
  db 0
  pushf
_apmreal_entry:
;-----------------
; APM installation check
apmreal_00:
  cmp al, #0x00
  jne apmreal_01
  mov ah, #1
  mov al, #2
  mov bh, #0x50
  mov bl, #0x4d
  mov cx, #0x3
  jmp apmreal_ok
;-----------------
; APM real mode interface connect
apmreal_01:
  cmp al, #0x01
  jne apmreal_02
  jmp apmreal_ok
;-----------------
; APM 16 bit protected mode interface connect
apmreal_02:
  cmp al, #0x02
  jne apmreal_03
  mov bx, #_apm16_entry
  mov ax, #0xf000
  mov si, #0xfff0
  mov cx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM 32 bit protected mode interface connect
apmreal_03:
  cmp al, #0x03
  jne apmreal_04
  mov ax, #0xf000
  mov ebx, #_apm32_entry
  mov cx, #0xf000
  mov esi, #0xfff0fff0
  mov dx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM interface disconnect
apmreal_04:
  cmp al, #0x04
  jne apmreal_05
  jmp apmreal_ok
;-----------------
; APM cpu idle
apmreal_05:
  cmp al, #0x05
  jne apmreal_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apmreal_ok
;-----------------
; APM Set Power State
apmreal_07:
  cmp al, #0x07
  jne apmreal_08
  cmp bx, #1
  jne apmreal_ok
  cmp cx, #3
  je apmreal_07_poweroff
  cmp cx, #2
  je apmreal_07_suspend
  cmp cx, #1
  je apmreal_07_standby
  jne apmreal_ok
apmreal_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apmreal_07_poweroff_str
  call apmreal_out_str
apmreal_07_1:
  hlt
  jmp apmreal_07_1
apmreal_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_suspend_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
apmreal_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_standby_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
;-----------------
; APM Enable / Disable
apmreal_08:
  cmp al, #0x08
  jne apmreal_0a
  jmp apmreal_ok
;-----------------
; Get Power Status
apmreal_0a:
  cmp al, #0x0a
  jne apmreal_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apmreal_ok
;-----------------
; Get PM Event
apmreal_0b:
  cmp al, #0x0b
  jne apmreal_0e
  mov ah, #0x80
  jmp apmreal_error
;-----------------
; APM Driver Version
apmreal_0e:
  cmp al, #0x0e
  jne apmreal_0f
  mov ah, #1
  mov al, #2
  jmp apmreal_ok
;-----------------
; APM Engage / Disengage
apmreal_0f:
  cmp al, #0x0f
  jne apmreal_10
  jmp apmreal_ok
;-----------------
; APM Get Capabilities
apmreal_10:
  cmp al, #0x10
  jne apmreal_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apmreal_ok
;-----------------
apmreal_ok:
  popf
  clc
  jmp iret_modify_cf
apmreal_unimplemented:
apmreal_error:
  popf
  stc
  jmp iret_modify_cf
    .align 16
gdt_base:
    .word 0,0
    .byte 0,0,0,0
gdt_entry_pm_32bit_cs:
    .word 0xffff, 0x0000
    .byte 0x00, 0x9b, 0xcf, 0x00
gdt_entry_pm_16bit_cs:
    .word 0xffff, 0x0000
    .byte 0xf0000 >> 16, 0x9b, 0x8f, 0x0
gdt_entry_pm_32bit_ds:
    .word 0xffff, 0x0000
    .byte 0x0, 0x93, 0xcf, 0x0
gdt_entry_pm_16bit_ds:
    .word 0xffff, 0x0000
    .byte 0x0, 0x93, 0x8f, 0x0
gdt_entry_end:
protmode_gdtdesc:
    .word (gdt_entry_end - gdt_base) - 1
    .long gdt_base | 0xf0000
realmode_gdtdesc:
    .word 0xffff
    .long 0x0
Upcall:
    ; Do an upcall into 32 bit space
    ;
    ; Input:
    ; bx: index of function to call
    ; Ouput:
    ; dx, ax: 32 bit result of call (even if 'void' is expected)
    ; Save caller state, stack frame offsets listed below
    pushf
    cli
    push ds
    push es
    push ss
    push esp
    ; Calculate protected-mode esp from ss:sp
    and esp, #0xffff
    xor eax, eax
    mov ax, ss
    shl eax, #4
    add esp, eax
    ; Switch to protected mode
    seg cs
    lgdt protmode_gdtdesc
    mov eax, cr0
    or al, #0x1 ; protected mode on
    mov cr0, eax
    jmpf DWORD (0xf0000|upcall1), #(gdt_entry_pm_32bit_cs - gdt_base)
upcall1:
    USE32
    mov ax, #(gdt_entry_pm_32bit_ds - gdt_base)
    mov ds, ax
    mov es, ax
    mov ss, ax
    ; Marshal arguments and call 32-bit function
    mov ecx, #32/4
upcall2:
    push 32 -4+14[esp]
    loop upcall2
    mov eax, [0x000EA000 + 0]
    call eax
    add esp, #32
    mov ecx, eax ; Result in ecx
    ; Restore real-mode stack pointer
    xor eax, eax
    mov ax, 4[esp]
    mov bx, ax ; Real-mode ss in bx
    shl eax, 4
    sub esp, eax
    ; Return to real mode
    jmpf upcall3, #(gdt_entry_pm_16bit_cs - gdt_base)
upcall3:
    USE16
    mov ax, #(gdt_entry_pm_16bit_ds - gdt_base)
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov eax, cr0
    and al, #0xfe ; protected mode off
    mov cr0, eax
    jmpf upcall4, #0xf0000>>4
upcall4:
    seg cs
    lgdt realmode_gdtdesc
    ; Restore real-mode ss
    mov ss, bx
    ; Convert result into dx:ax format
    mov eax, ecx
    ror eax, #16
    mov dx, ax
    ror eax, #16
    ; Restore caller state and return
    pop esp
    pop bx ; skip ss
    pop es
    pop ds
    popf
    ret
MACRO DoUpcall
    mov bx, #?1
    jmp Upcall
MEND
_TCGInterruptHandler: DoUpcall(0)
_tcpa_acpi_init: DoUpcall(1)
_tcpa_extend_acpi_log: DoUpcall(2)
_tcpa_calling_int19h: DoUpcall(3)
_tcpa_returned_int19h: DoUpcall(4)
_tcpa_add_event_separators: DoUpcall(5)
_tcpa_wake_event: DoUpcall(6)
_tcpa_add_bootdevice: DoUpcall(7)
_tcpa_start_option_rom_scan: DoUpcall(8)
_tcpa_option_rom: DoUpcall(9)
_tcpa_ipl: DoUpcall(10)
_tcpa_measure_post: DoUpcall(11)
_tcpa_initialize_tpm: DoUpcall(12)
_get_s3_waking_vector: DoUpcall(13)
_pmm: DoUpcall(14)
! 6674 endasm
!BCC_ENDASM
! 6675 #asm
!BCC_ASM
_int70_function.ds	set	$12
_int70_function.iret_addr	set	$14
_int70_function.regs	set	2
MACRO POST_MEASURE
 push word #0x000f
 push #?2
 push word #0x000f
 push #?1
 call _tcpa_measure_post
 add sp, #8
MEND
! 6684 endasm
!BCC_ENDASM
! 6685 void
! Register BX used in function int70_function
! 6686 tcpa_do_measure_POSTs()
! 6687 {
export	_tcpa_do_measure_POSTs
_tcpa_do_measure_POSTs:
! 6688 #asm
!BCC_ASM
 POST_MEASURE(post, nmi)
 POST_MEASURE(floppy_drive_post, hard_drive_post)
 POST_MEASURE(hard_drive_post, ebda_post)
 POST_MEASURE(ebda_post, eoi_jmp_post)
 POST_MEASURE(eoi_jmp_post, timer_tick_post)
 POST_MEASURE(timer_tick_post, int76_handler)
 ret
! 6696 endasm
!BCC_ENDASM
! 6697 }
ret
! 6698   void
! 6699 int1a_function32(regs, ES, DS, FLAGS)
! 6700   pushad_regs_t regs;
export	_int1a_function32
_int1a_function32:
!BCC_EOS
! 6701   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 6702 {
! 6703  Bit16u rc;
!BCC_EOS
! 6704  ;
push	bp
mov	bp,sp
dec	sp
dec	sp
!BCC_EOS
! 6705  switch (regs.u.r8.ah) {
mov	al,$21[bp]
br 	.759
! 6706  case 0xbb:
! 6707   if (regs.u.r8.al != 0 &&
.75A:
! 6708       regs.u.r32.ebx != 0x41504354L) {
! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
mov	al,$20[bp]
test	al,al
je  	.75B
.75D:
! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$4354
mov	bx,#$4150
push	bx
push	ax
mov	ax,$14[bp]
mov	bx,$16[bp]
lea	di,-2+..FFD9[bp]
call	lcmpul
lea	sp,2+..FFD9[bp]
je  	.75B
.75C:
! 6709       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6710       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 6711   }
! 6712   switch(regs.u.r8.al) {
.75B:
mov	al,$20[bp]
jmp .760
! 6713   case 0x00:
! 6714   case 0x01:
.761:
! 6715   case 0x02:
.762:
! 6716   case 0x03:
.763:
! 6717   case 0x04:
.764:
! 6718   case 0x05:
.765:
! 6719   case 0x06:
.766:
! 6720   case 0x07:
.767:
! 6721    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
.768:
! 6722                        ES, DS,
! 6723                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
! Debug: expression subtree swapping
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
xor	bx,bx
! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
mov	di,*4
call	lslul
push	bx
push	ax
! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
mov	ax,bp
add	ax,*$28
xor	bx,bx
! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFD9[bp]
call	laddul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short DS = [S+8+$24] (used reg = )
push	$26[bp]
! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
push	$24[bp]
! Debug: expression subtree swapping
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
xor	bx,bx
! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
mov	di,*4
call	lslul
push	bx
push	ax
! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
mov	ax,bp
add	ax,*4
xor	bx,bx
! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFD9[bp]
call	laddul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
call	_TCGInterruptHandler
mov	bx,dx
add	sp,*$C
!BCC_EOS
! 6724    break;
jmp .75E
!BCC_EOS
! 6725   default:
! 6726    FLAGS |= 0x0001;
.769:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6727   }
! 6728   break;
jmp .75E
.760:
sub	al,*0
jb 	.769
cmp	al,*7
ja  	.76A
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.76B[bx]
.76B:
.word	.761
.word	.762
.word	.763
.word	.764
.word	.765
.word	.766
.word	.767
.word	.768
.76A:
jmp	.769
.75E:
jmp .757
!BCC_EOS
! 6729  default:
! 6730   FLAGS |= 0x0001;
.76C:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6731   break;
jmp .757
!BCC_EOS
! 6732  }
! 6733  ;
jmp .757
.759:
sub	al,#$BB
beq 	.75A
jmp	.76C
.757:
..FFD9	=	-4
!BCC_EOS
! 6734 }
mov	sp,bp
pop	bp
ret
! 6735 #asm
!BCC_ASM
_int1a_function32.FLAGS	set	$26
_int1a_function32.DS	set	$24
_int1a_function32.ES	set	$22
_int1a_function32.regs	set	2
;--------------------
use32 386
.align 16
bios32_structure:
  db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
  dw bios32_entry_point, 0xf ;; 32 bit physical address
  db 0 ;; revision level
  ;; length in paragraphs and checksum stored in a word to prevent errors
  dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
  db 0,0,0,0,0 ;; reserved
.align 16
bios32_entry_point:
  pushfd
  cmp eax, #0x49435024 ;; "$PCI"
  jne unknown_service
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  ;; say ok if a device is present
  cmp eax, #0xffffffff
  je unknown_service
  mov ebx, #0x000f0000
  mov ecx, #0
  mov edx, #pcibios_protected
  xor al, al
  jmp bios32_end
unknown_service:
  mov al, #0x80
bios32_end:
  popfd
  retf
.align 16
pcibios_protected:
  pushfd
  cli
  push esi
  push edi
  cmp al, #0x01 ;; installation check
  jne pci_pro_f02
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov al, #0x01
  jmp pci_pro_ok
pci_pro_f02: ;; find pci device
  cmp al, #0x02
  jne pci_pro_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_pro_devloop:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_pro_nextdev
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f03: ;; find class code
  cmp al, #0x03
  jne pci_pro_f08
  xor bx, bx
  mov di, #0x08
pci_pro_devloop2:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_pro_nextdev2
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop2
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_pro_f09
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop edx
  mov cl, al
  jmp pci_pro_ok
pci_pro_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_pro_f0a
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop edx
  mov cx, ax
  jmp pci_pro_ok
pci_pro_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_pro_f0b
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  in eax, dx
  pop edx
  mov ecx, eax
  jmp pci_pro_ok
pci_pro_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_pro_f0c
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop edx
  jmp pci_pro_ok
pci_pro_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_pro_f0d
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop edx
  jmp pci_pro_ok
pci_pro_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_pro_unknown
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop edx
  jmp pci_pro_ok
pci_pro_unknown:
  mov ah, #0x81
pci_pro_fail:
  pop edi
  pop esi
  popfd
  stc
  retf
pci_pro_ok:
  xor ah, ah
  pop edi
  pop esi
  popfd
  clc
  retf
pci_pro_select_reg:
  push edx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop edx
  ret
use16 386
pcibios_real:
  push eax
  push dx
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  ;; say ok if a device is present
  cmp eax, #0xffffffff
  jne pci_present
  pop dx
  pop eax
  mov ah, #0xff
  stc
  ret
pci_present:
  pop dx
  pop eax
  cmp al, #0x01 ;; installation check
  jne pci_real_f02
  mov ax, #0x0001
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov edi, #0xf0000
  mov di, #pcibios_protected
  clc
  ret
pci_real_f02: ;; find pci device
  push esi
  push edi
  cmp al, #0x02
  jne pci_real_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_real_devloop:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_real_nextdev
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8602
  jmp pci_real_fail
pci_real_f03: ;; find class code
  cmp al, #0x03
  jne pci_real_f08
  xor bx, bx
  mov di, #0x08
pci_real_devloop2:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_real_nextdev2
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop2
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8603
  jmp pci_real_fail
pci_real_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_real_f09
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop dx
  mov cl, al
  jmp pci_real_ok
pci_real_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_real_f0a
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop dx
  mov cx, ax
  jmp pci_real_ok
pci_real_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_real_f0b
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  in eax, dx
  pop dx
  mov ecx, eax
  jmp pci_real_ok
pci_real_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_real_f0c
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop dx
  jmp pci_real_ok
pci_real_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_real_f0d
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop dx
  jmp pci_real_ok
pci_real_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_real_f0e
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop dx
  jmp pci_real_ok
pci_real_f0e: ;; get irq routing options
  cmp al, #0x0e
  jne pci_real_unknown
  SEG ES
  cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  jb pci_real_too_small
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  pushf
  push ds
  push es
  push cx
  push si
  push di
  cld
  mov si, #pci_routing_table_structure_start
  push cs
  pop ds
  SEG ES
  mov cx, [di+2]
  SEG ES
  mov es, [di+4]
  mov di, cx
  mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
  rep
      movsb
  pop di
  pop si
  pop cx
  pop es
  pop ds
  popf
  mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
  jmp pci_real_ok
pci_real_too_small:
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  mov ah, #0x89
  jmp pci_real_fail
pci_real_unknown:
  mov ah, #0x81
pci_real_fail:
  pop edi
  pop esi
  stc
  ret
pci_real_ok:
  xor ah, ah
  pop edi
  pop esi
  clc
  ret
pci_real_select_reg:
  push dx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop dx
  ret
.align 16
pci_routing_table_structure:
  db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
  db 0, 1 ;; version
  dw 32 + (6 * 16) ;; table size
  db 0 ;; PCI interrupt router bus
  db 0x08 ;; PCI interrupt router DevFunc
  dw 0x0000 ;; PCI exclusive IRQs
  dw 0x8086 ;; compatible PCI interrupt router vendor ID
  dw 0x122e ;; compatible PCI interrupt router device ID
  dw 0,0 ;; Miniport data
  db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
  db 0x37 ;; checksum
pci_routing_table_structure_start:
  ;; first slot entry PCI-to-ISA (embedded)
  db 0 ;; pci bus number
  db 0x08 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 0 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; second slot entry: 1st PCI slot
  db 0 ;; pci bus number
  db 0x10 ;; pci device number (bit 7-3)
  db 0x62 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x63 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x60 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x61 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 1 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; third slot entry: 2nd PCI slot
  db 0 ;; pci bus number
  db 0x18 ;; pci device number (bit 7-3)
  db 0x63 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x60 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x61 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x62 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 2 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 4th slot entry: 3rd PCI slot
  db 0 ;; pci bus number
  db 0x20 ;; pci device number (bit 7-3)
  db 0x60 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x61 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x62 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x63 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 3 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 5th slot entry: 4rd PCI slot
  db 0 ;; pci bus number
  db 0x28 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 4 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 6th slot entry: 5rd PCI slot
  db 0 ;; pci bus number
  db 0x30 ;; pci device number (bit 7-3)
  db 0x62 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x63 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x60 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x61 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 5 ;; physical slot (0 = embedded)
  db 0 ;; reserved
pci_routing_table_structure_end:
; according to POST Memory Manager Specification Version 1.01
.align 16
pmm_structure:
  db 0x24,0x50,0x4d,0x4d ;; "$PMM" signature
  db 0x01 ;; revision
  db 16 ;; length
  db (-((pmm_entry_point>>8)+pmm_entry_point+0x20f))&0xff;; checksum
  dw pmm_entry_point,0xf000 ;; far call entrypoint
  db 0,0,0,0,0 ;; reserved
pmm_entry_point:
  pushf
  pushad
; Calculate protected-mode address of PMM function args
  xor eax, eax
  mov ax, sp
  xor ebx, ebx
  mov bx, ss
  shl ebx, 4
  lea ebx, [eax+ebx+38] ;; ebx=(ss<<4)+sp+4(far call)+2(pushf)+32(pushad)
  push ebx
;
; Stack layout at this point:
;
; : +0x0 +0x2 +0x4 +0x6 +0x8 +0xa +0xc +0xe
; -----------------------------------------------------------------------
; sp : [&arg1 ][edi ][esi ][ebp ]
; sp+0x10: [esp ][ebx ][edx ][ecx ]
; sp+0x20: [eax ][flags ][ip ][cs ][arg1 ][arg2, ...
;
  call _pmm
  mov bx, sp
SEG SS
  mov [bx+0x20], ax
SEG SS
  mov [bx+0x18], dx
  pop ebx
  popad
  popf
  retf
; parallel port detection: base address in DX, index in BX, timeout in CL
detect_parport:
  push dx
  add dx, #2
  in al, dx
  and al, #0xdf ; clear input mode
  out dx, al
  pop dx
  mov al, #0xaa
  out dx, al
  in al, dx
  cmp al, #0xaa
  jne no_parport
  push bx
  shl bx, #1
  mov [bx+0x408], dx ; Parallel I/O address
  pop bx
  mov [bx+0x478], cl ; Parallel printer timeout
  inc bx
no_parport:
  ret
; serial port detection: base address in DX, index in BX, timeout in CL
detect_serial:
  push dx
  inc dx
  mov al, #0x02
  out dx, al
  in al, dx
  cmp al, #0x02
  jne no_serial
  inc dx
  in al, dx
  cmp al, #0x02
  jne no_serial
  dec dx
  xor al, al
  out dx, al
  pop dx
  push bx
  shl bx, #1
  mov [bx+0x400], dx ; Serial I/O address
  pop bx
  mov [bx+0x47c], cl ; Serial timeout
  inc bx
  ret
no_serial:
  pop dx
  ret
rom_checksum:
  pusha
  push ds
  xor ax, ax
  xor bx, bx
  xor cx, cx
  xor dx, dx
  mov ch, [2]
  shl cx, #1
  jnc checksum_loop
  jz checksum_loop
  xchg dx, cx
  dec cx
checksum_loop:
  add al, [bx]
  inc bx
  loop checksum_loop
  test dx, dx
  je checksum_out
  add al, [bx]
  mov cx, dx
  mov dx, ds
  add dh, #0x10
  mov ds, dx
  xor dx, dx
  xor bx, bx
  jmp checksum_loop
checksum_out:
  and al, #0xff
  pop ds
  popa
  ret
;; We need a copy of this string, but we are not actually a PnP BIOS,
;; so make sure it is *not* aligned, so OSes will not see it if they scan.
.align 16
  db 0
pnp_string:
  .ascii "$PnP"
rom_scan:
  ;; Scan for existence of valid expansion ROMS.
  ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
  ;; General ROM: from 0xC8000..0xE9FFF in 2k increments
  ;; System ROM: only 0xF0000
  ;;
  ;; Header:
  ;; Offset Value
  ;; 0 0x55
  ;; 1 0xAA
  ;; 2 ROM length in 512-byte blocks
  ;; 3 ROM initialization entry point (FAR CALL)
rom_scan_loop:
  push ax ;; Save AX
  mov ds, cx
  mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
  cmp [0], #0xAA55 ;; look for signature
  jne rom_scan_increment
  call rom_checksum
  jnz rom_scan_increment
  mov al, [2] ;; change increment to ROM length in 512-byte blocks
  ;; We want our increment in 512-byte quantities, rounded to
  ;; the nearest 2k quantity, since we only scan at 2k intervals.
  test al, #0x03
  jz block_count_rounded
  and al, #0xfc ;; needs rounding up
  add al, #0x04
block_count_rounded:
  push ax ;; Save AX
  push di ;; Save DI
  ;; Push addr of ROM entry point
  push cx ;; Push seg
  push #0x0003 ;; Push offset
  ;; Get the BDF into ax before invoking the option ROM
  mov bl, [2]
  mov al, bl
  shr al, #7
  cmp al, #1
  jne fetch_bdf
  mov ax, ds ;; Increment the DS since rom size larger than an segment
  add ax, #0x1000
  mov ds, ax
fetch_bdf:
  shl bx, #9
  xor ax, ax
  mov al, [bx]
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  ;; That should stop it grabbing INT 19h; we will use its BEV instead.
  mov bx, #0xf000
  mov es, bx
  lea di, pnp_string
  xor bx, bx ;; Restore DS back to 0000:
  mov ds, bx
  mov bp, sp ;; Call ROM init routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
  ;; to init all the ROMs and then go back and build an IPL table of
  ;; all the bootable devices, but we can get away with one pass.
  mov ds, cx ;; ROM base
  mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
  mov ax, [bx] ;; the offset of PnP expansion header, where...
  cmp ax, #0x5024 ;; we look for signature "$PnP"
  jne no_bev
  mov ax, 2[bx]
  cmp ax, #0x506e
  jne no_bev
  mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
  cmp ax, #0x0000
  je no_bcv
  ;; Option ROM has BCV. Run it now.
  push cx ;; Push seg
  push ax ;; Push offset
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  mov bx, #0xf000
  mov es, bx
  lea di, pnp_string
  mov bp, sp ;; Call ROM BCV routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  jmp no_bev
no_bcv:
  mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
  cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
  je no_bev
  ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
  mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
  xor bx, bx
  mov ds, bx
  mov bx, word ptr [0x40E] ;; EBDA segment
  mov ds, bx ;; Go to the segment where the IPL table lives
  mov bx, 0x0380 ;; Read the number of entries so far
  cmp bx, #8
  je no_bev ;; Get out if the table is full
  shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
  mov 0x0300 +0[bx], #0x80 ;; This entry is a BEV device
  mov 0x0300 +6[bx], cx ;; Build a far pointer from the segment...
  mov 0x0300 +4[bx], ax ;; and the offset
  cmp di, #0x0000
  je no_prod_str
  mov 0xA[bx], cx ;; Build a far pointer from the segment...
  mov 8[bx], di ;; and the offset
no_prod_str:
  shr bx, #0x4 ;; Turn the offset back into a count
  inc bx ;; We have one more entry now
  mov 0x0380, bx ;; Remember that.
no_bev:
  pop di ;; Restore DI
  pop ax ;; Restore AX
rom_scan_increment:
  shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
                ;; because the segment selector is shifted left 4 bits.
  add cx, ax
  pop ax ;; Restore AX
  cmp cx, ax
  jbe rom_scan_loop
  xor ax, ax ;; Restore DS back to 0000:
  mov ds, ax
  ret
; Copy the SMBIOS entry point from where hvmloader left it.
; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
; but the tables themselves can be elsewhere.
smbios_init:
  push ax
  push cx
  push es
  push ds
  push di
  push si
  mov cx, #0x001f ; 0x1f bytes to copy
  mov ax, #0xf000
  mov es, ax ; destination segment is 0xf0000
  mov di, #smbios_entry_point ; destination offset
  mov ax, #(0x000EB000>>4)
  mov ds, ax
  mov si, #(0x000EB000&15)
  cld
  rep
    movsb
  pop si
  pop di
  pop ds
  pop es
  pop cx
  pop ax
  ret
post_init_pic:
  mov al, #0x11 ; send initialisation commands
  out 0x20, al
  out 0xa0, al
  mov al, #0x08
  out 0x21, al
  mov al, #0x70
  out 0xa1, al
  mov al, #0x04
  out 0x21, al
  mov al, #0x02
  out 0xa1, al
  mov al, #0x01
  out 0x21, al
  out 0xa1, al
  mov al, #0xb8
  out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
  mov al, #0x8f
  out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
  ret
  .align 16
smbios_entry_point:
  db 0,0,0,0,0,0,0,0 ; 8 bytes
  db 0,0,0,0,0,0,0,0 ; 16 bytes
  db 0,0,0,0,0,0,0,0 ; 24 bytes
  db 0,0,0,0,0,0,0 ; 31 bytes
;; the following area can be used to write dynamically generated tables
  .align 16
bios_table_area_start:
  db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
  dd bios_table_area_end - bios_table_area_start
;--------
;- POST -
;--------
.org 0xe05b ; POST Entry Point
post:
  xor ax, ax
  ;; first reset the DMA controllers
  out 0x0d,al
  out 0xda,al
  ;; then initialize the DMA controllers
  mov al, #0xC0
  out 0xD6, al ; cascade mode of channel 4 enabled
  mov al, #0x00
  out 0xD4, al ; unmask channel 4
  ;; Examine CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL
  in AL, 0x71
  ;; backup status
  mov bl, al
  ;; Reset CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL ; select CMOS register Fh
  mov AL, #0x00
  out 0x71, AL ; set shutdown action to normal
  ;; Examine CMOS shutdown status.
  mov al, bl
  ;; 0x00, 0x09, 0x0D+ = normal startup
  cmp AL, #0x00
  jz normal_post
  cmp AL, #0x0d
  jae normal_post
  cmp AL, #0x09
  je normal_post
  ;; 0x05 = eoi + jmp via [0x40:0x67] jump
  cmp al, #0x05
  je eoi_jmp_post
  ;; 0x0A = jmp via [0x40:0x67] jump
  cmp al, #0x0a
  je jmp_post_0x467
  ;; 0x0B = iret via [0x40:0x67]
  cmp al, #0x0b
  je iret_post_0x467
  ;; 0x0C = retf via [0x40:0x67]
  cmp al, #0x0c
  je retf_post_0x467
  ;; Examine CMOS shutdown status.
  ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08 = Unimplemented shutdown status.
  push bx
  call _shutdown_status_panic
normal_post:
  ; case 0: normal startup
  cli
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  ;; Save shutdown status
  mov 0x04b0, bl
  cmp bl, #0xfe
  jz s3_post
  ;; zero out BIOS data area (40:00..40:ff)
  mov es, ax
  mov cx, #0x0080 ;; 128 words
  mov di, #0x0400
  cld
  rep
    stosw
  call _log_bios_start
  ;; set all interrupts to default handler
  xor bx, bx ;; offset index
  mov cx, #0x0100 ;; counter (256 interrupts)
  mov ax, #dummy_iret_handler
  mov dx, #0xF000
post_default_ints:
  mov [bx], ax
  add bx, #2
  mov [bx], dx
  add bx, #2
  loop post_default_ints
  ;; set vector 0x79 to zero
  ;; this is used by 'gardian angel' protection system
  SET_INT_VECTOR(0x79, #0, #0)
  ;; base memory in K 40:13 (word)
  mov ax, #(640 - 1)
  mov 0x0413, ax
  ;; Manufacturing Test 40:12
  ;; zerod out above
  ;; Warm Boot Flag 0040:0072
  ;; value of 1234h = skip memory checks
  ;; zerod out above
  ;; Printer Services vector
  SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
  ;; Bootstrap failure vector
  SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
  ;; Bootstrap Loader vector
  SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
  ;; User Timer Tick vector
  SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
  ;; Memory Size Check vector
  SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
  ;; Equipment Configuration Check vector
  SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
  ;; System Services
  SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
  ;; EBDA setup
  call ebda_post
  ;; PIT setup
  SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
  ;; int 1C already points at dummy_iret_handler (above)
  mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
  out 0x43, al
  mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
  out 0x40, al ; lsb
  mov al, #0xe9
  out 0x40, al ; msb
  ;; Keyboard
  SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
  SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
  xor ax, ax
  mov ds, ax
  mov 0x0417, al
  mov 0x0418, al
  mov 0x0419, al
  mov 0x0471, al
  mov 0x0497, al
  mov al, #0x10
  mov 0x0496, al
  mov bx, #0x001E
  mov 0x041A, bx
  mov 0x041C, bx
  mov bx, #0x001E
  mov 0x0480, bx
  mov bx, #0x003E
  mov 0x0482, bx
  call _keyboard_init
  ;; mov CMOS Equipment Byte to BDA Equipment Word
  mov ax, 0x0410
  mov al, #0x14
  out 0x70, al
  in al, 0x71
  mov 0x0410, ax
  ;; Parallel setup
  SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
  xor ax, ax
  mov ds, ax
  xor bx, bx
  mov cl, #0x14 ; timeout value
  mov dx, #0x378 ; Parallel I/O address, port 1
  call detect_parport
  mov dx, #0x278 ; Parallel I/O address, port 2
  call detect_parport
  shl bx, #0x0e
  mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
  and ax, #0x3fff
  or ax, bx ; set number of parallel ports
  mov 0x410, ax
  ;; Serial setup
  SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
  xor bx, bx
  mov cl, #0x0a ; timeout value
  mov dx, #0x03f8 ; Serial I/O address, port 1
  call detect_serial
  mov dx, #0x02f8 ; Serial I/O address, port 2
  call detect_serial
  mov dx, #0x03e8 ; Serial I/O address, port 3
  call detect_serial
  mov dx, #0x02e8 ; Serial I/O address, port 4
  call detect_serial
  shl bx, #0x09
  mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
  and ax, #0xf1ff
  or ax, bx ; set number of serial port
  mov 0x410, ax
  ;; CMOS RTC
  SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
  SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
  ;; BIOS DATA AREA 0x4CE ???
  call timer_tick_post
  ;; PS/2 mouse setup
  SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
  ;; IRQ13 (FPU exception) setup
  SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
  ;; Video setup
  SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
  ;; PIC
  call post_init_pic
  mov cx, #0xc000 ;; init vga bios
  mov ax, #0xc780
  call rom_scan
  call _print_bios_banner
  ;;
  ;; Floppy setup
  ;;
  call floppy_drive_post
  ;;
  ;; Hard Drive setup
  ;;
  call hard_drive_post
  ;;
  ;; ATA/ATAPI driver setup
  ;;
  call _ata_init
  call _ata_detect
  ;;
  ;;
  ;; eltorito floppy/harddisk emulation from cd
  ;;
  call _cdemu_init
  ;;
  call _enable_rom_write_access
  call _clobber_entry_point
  call _fixup_base_mem_in_k
  call smbios_init
  call _init_boot_vectors
  mov cx, #(0x000C8000 >> 4) ;; init option roms
  mov ax, #(0x000EA000 >> 4)
  call rom_scan
  call _disable_rom_write_access
  call _interactive_bootkey
  sti ;; enable interrupts
  ;; Start the boot sequence. See the comments in int19_relocated
  ;; for why we use INT 18h instead of INT 19h here.
  int #0x18
.org 0xe2c3 ; NMI Handler Entry Point
nmi:
  ;; FIXME the NMI handler should not panic
  ;; but iret when called from int75 (fpu exception)
  call _nmi_handler_msg
  iret
int75_handler:
  out 0xf0, al
  call eoi_both_pics
  int 2
  iret
;-------------------------------------------
;- INT 13h Fixed Disk Services Entry Point -
;-------------------------------------------
.org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
int13_handler:
  jmp int13_relocated
.org 0xe401 ; Fixed Disk Parameter Table
;----------
;- INT19h -
;----------
.org 0xe6f2 ; INT 19h Boot Load Service Entry Point
int19_handler:
  jmp int19_relocated
;-------------------------------------------
;- System BIOS Configuration Data Table
;-------------------------------------------
.org 0xe6f5
db 0x08 ; Table size (bytes) -Lo
db 0x00 ; Table size (bytes) -Hi
db 0xFC
db 0x00
db 1
; Feature byte 1
; b7: 1=DMA channel 3 used by hard disk
; b6: 1=2 interrupt controllers present
; b5: 1=RTC present
; b4: 1=BIOS calls int 15h/4Fh every key
; b3: 1=wait for extern event supported (Int 15h/41h)
; b2: 1=extended BIOS data area used
; b1: 0=AT or ESDI bus, 1=MicroChannel
; b0: 1=Dual bus (MicroChannel + ISA)
db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
; Feature byte 2
; b7: 1=32-bit DMA supported
; b6: 1=int16h, function 9 supported
; b5: 1=int15h/C6h (get POS data) supported
; b4: 1=int15h/C7h (get mem map info) supported
; b3: 1=int15h/C8h (en/dis CPU) supported
; b2: 1=non-8042 kb controller
; b1: 1=data streaming supported
; b0: reserved
db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
; Feature byte 3
; b7: not used
; b6: reserved
; b5: reserved
; b4: POST supports ROM-to-RAM enable/disable
; b3: SCSI on system board
; b2: info panel installed
; b1: Initial Machine Load (IML) system - BIOS on disk
; b0: SCSI supported in IML
db 0x00
; Feature byte 4
; b7: IBM private
; b6: EEPROM present
; b5-3: ABIOS presence (011 = not supported)
; b2: private
; b1: memory split above 16Mb supported
; b0: POSTEXT directly supported by POST
db 0x00
; Feature byte 5 (IBM)
; b1: enhanced mouse
; b0: flash EPROM
db 0x00
.org 0xe729 ; Baud Rate Generator Table
;----------
;- INT14h -
;----------
.org 0xe739 ; INT 14h Serial Communications Service Entry Point
int14_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int14_function
  popa
  pop ds
  iret
;----------------------------------------
;- INT 16h Keyboard Service Entry Point -
;----------------------------------------
.org 0xe82e
int16_handler:
  sti
  push ds
  pushf
  pusha
  cmp ah, #0x00
  je int16_F00
  cmp ah, #0x10
  je int16_F00
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  jz int16_zero_set
int16_zero_clear:
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xbf
  pop bp
  iret
int16_zero_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x40
  pop bp
  iret
int16_F00:
  mov bx, #0x0040
  mov ds, bx
int16_wait_for_key:
  cli
  mov bx, 0x001a
  cmp bx, 0x001c
  jne int16_key_found
  sti
  hlt
  jmp int16_wait_for_key
int16_key_found:
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  iret
;-------------------------------------------------
;- INT09h : Keyboard Hardware Service Entry Point -
;-------------------------------------------------
.org 0xe987
int09_handler:
  cli
  push ax
  mov al, #0xAD ;;disable keyboard
  out #0x64, al
  mov al, #0x0B
  out #0x20, al
  in al, #0x20
  and al, #0x02
  jz int09_finish
  in al, #0x60 ;;read key from keyboard controller
  sti
  push ds
  pusha
  mov ah, #0x4f ;; allow for keyboard intercept
  stc
  int #0x15
  jnc int09_done
  ;; check for extended key
  cmp al, #0xe0
  jne int09_check_pause
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x02
  or al, #0x02
  mov BYTE [0x496], al
  jmp int09_done
int09_check_pause: ;; check for pause key
  cmp al, #0xe1
  jne int09_process_key
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x01
  or al, #0x01
  mov BYTE [0x496], al
  jmp int09_done
int09_process_key:
  mov bx, #0xf000
  mov ds, bx
  call _int09_function
int09_done:
  popa
  pop ds
  cli
  call eoi_master_pic
int09_finish:
  mov al, #0xAE ;;enable keyboard
  out #0x64, al
  pop ax
  iret
;----------------------------------------
;- INT 13h Diskette Service Entry Point -
;----------------------------------------
.org 0xec59
int13_diskette:
  jmp int13_noeltorito
;---------------------------------------------
;- INT 0Eh Diskette Hardware ISR Entry Point -
;---------------------------------------------
.org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
int0e_handler:
  push ax
  push dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_normal
  mov dx, #0x03f5
  mov al, #0x08 ; sense interrupt status
  out dx, al
int0e_loop1:
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  jne int0e_loop1
int0e_loop2:
  mov dx, #0x03f5
  in al, dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_loop2
int0e_normal:
  push ds
  xor ax, ax ;; segment 0000
  mov ds, ax
  call eoi_master_pic
  mov al, 0x043e
  or al, #0x80 ;; diskette interrupt has occurred
  mov 0x043e, al
  pop ds
  pop dx
  pop ax
  iret
.org 0xefc7 ; Diskette Controller Parameter Table
diskette_param_table:
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
;----------------------------------------
;- INT17h : Printer Service Entry Point -
;----------------------------------------
.org 0xefd2
int17_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int17_function
  popa
  pop ds
  iret
diskette_param_table2:
;; New diskette parameter table adding 3 parameters from IBM
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
db 79 ;; maximum track
db 0 ;; data transfer rate
db 4 ;; drive type in cmos
.org 0xf045 ; INT 10 Functions 0-Fh Entry Point
  HALT(11440)
  iret
;----------
;- INT10h -
;----------
.org 0xf065 ; INT 10h Video Support Service Entry Point
int10_handler:
  ;; dont do anything, since the VGA BIOS handles int10h requests
  iret
.org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
;----------
;- INT12h -
;----------
.org 0xf841 ; INT 12h Memory Size Service Entry Point
; ??? different for Pentium (machine check)?
int12_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0013
  pop ds
  iret
;----------
;- INT11h -
;----------
.org 0xf84d ; INT 11h Equipment List Service Entry Point
int11_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0010
  pop ds
  iret
;----------
;- INT15h -
;----------
.org 0xf859 ; INT 15h System Services Entry Point
int15_handler:
  pushf
  cmp ah, #0x53
  je apm_call
  push ds
  push es
  cmp ah, #0x86
  je int15_handler32
  cmp ah, #0xE8
  je int15_handler32
  pusha
  cmp ah, #0xC2
  je int15_handler_mouse
  call _int15_function
int15_handler_mouse_ret:
  popa
int15_handler32_ret:
  pop es
  pop ds
  popf
  jmp iret_modify_cf
apm_call:
  jmp _apmreal_entry
int15_handler_mouse:
  call _int15_function_mouse
  jmp int15_handler_mouse_ret
int15_handler32:
  pushad
  call _int15_function32
  popad
  jmp int15_handler32_ret
;; Protected mode IDT descriptor
;;
;; I just make the limit 0, so the machine will shutdown
;; if an exception occurs during protected mode memory
;; transfers.
;;
;; Set base to f0000 to correspond to beginning of BIOS,
;; in case I actually define an IDT later
;; Set limit to 0
pmode_IDT_info:
dw 0x0000 ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x0f ;; base 23:16
;; Real mode IDT descriptor
;;
;; Set to typical real-mode values.
;; base = 000000
;; limit = 03ff
rmode_IDT_info:
dw 0x03ff ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x00 ;; base 23:16
;----------
;- INT1Ah -
;----------
.org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
int1a_handler:
  cmp ah, #0xb1
  jne int1a_normal
  call pcibios_real
  jc pcibios_error
  retf 2
pcibios_error:
  mov bl, ah
  mov ah, #0xb1
  push ds
  pusha
  mov ax, ss ; set readable descriptor to ds, for calling pcibios
  mov ds, ax ; on 16bit protected mode.
  jmp int1a_callfunction
int1a_normal:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
int1a_callfunction:
  call _int1a_function
  popa
  pop ds
  iret
;;
;; int70h: IRQ8 - CMOS RTC
;;
int70_handler:
  push ds
  pushad
  xor ax, ax
  mov ds, ax
  call _int70_function
  popad
  pop ds
  iret
;---------
;- INT08 -
;---------
.org 0xfea5 ; INT 08h System Timer ISR Entry Point
int08_handler:
  sti
  push eax
  push ds
  xor ax, ax
  mov ds, ax
  ;; time to turn off drive(s)?
  mov al,0x0440
  or al,al
  jz int08_floppy_off
  dec al
  mov 0x0440,al
  jnz int08_floppy_off
  ;; turn motor(s) off
  push dx
  mov dx,#0x03f2
  in al,dx
  and al,#0xcf
  out dx,al
  pop dx
int08_floppy_off:
  mov eax, 0x046c ;; get ticks dword
  inc eax
  ;; compare eax to one days worth of timer ticks at 18.2 hz
  cmp eax, #0x001800B0
  jb int08_store_ticks
  ;; there has been a midnight rollover at this point
  xor eax, eax ;; zero out counter
  inc BYTE 0x0470 ;; increment rollover flag
int08_store_ticks:
  mov 0x046c, eax ;; store new ticks dword
  ;; chain to user timer tick INT #0x1c
  int #0x1c
  cli
  call eoi_master_pic
  pop ds
  pop eax
  iret
.org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
.org 0xffea ;; OEM string
.ascii "______"
.org 0xff00
.ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
;------------------------------------------------
;- IRET Instruction for Dummy Interrupt Handler -
;------------------------------------------------
.org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
dummy_iret_handler:
  iret
.org 0xff54 ; INT 05h Print Screen Service Entry Point
  HALT(11676)
  iret
.org 0xfff0 ; Power-up Entry Point
   jmp 0xf000:post
.org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
.ascii "06/23/99"
.org 0xfffe ; System Model ID
db 0xFC
db 0x00 ; filler
.org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
! 8244 endasm
!BCC_ENDASM
! 8245 static Bit8u vgafont8[128*8]=
! Register BX used in function int1a_function32
! 8246 {
.data
_vgafont8:
! 8247  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8248  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
.byte	$7E
.byte	$81
.byte	$A5
.byte	$81
.byte	$BD
.byte	$99
.byte	$81
.byte	$7E
! 8249  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
.byte	$7E
.byte	$FF
.byte	$DB
.byte	$FF
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$7E
! 8250  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$6C
.byte	$FE
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8251  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8252  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$38
.byte	$7C
.byte	$38
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8253  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$10
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8254  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	0
.byte	$18
.byte	$3C
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8255  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
.byte	$FF
.byte	$FF
.byte	$E7
.byte	$C3
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$FF
! 8256  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
.byte	0
.byte	$3C
.byte	$66
.byte	$42
.byte	$42
.byte	$66
.byte	$3C
.byte	0
! 8257  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
.byte	$FF
.byte	$C3
.byte	$99
.byte	$BD
.byte	$BD
.byte	$99
.byte	$C3
.byte	$FF
! 8258  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
.byte	$F
.byte	7
.byte	$F
.byte	$7D
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
! 8259  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
.byte	$3C
.byte	$66
.byte	$66
.byte	$66
.byte	$3C
.byte	$18
.byte	$7E
.byte	$18
! 8260  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
.byte	$3F
.byte	$33
.byte	$3F
.byte	$30
.byte	$30
.byte	$70
.byte	$F0
.byte	$E0
! 8261  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
.byte	$7F
.byte	$63
.byte	$7F
.byte	$63
.byte	$63
.byte	$67
.byte	$E6
.byte	$C0
! 8262  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
.byte	$99
.byte	$5A
.byte	$3C
.byte	$E7
.byte	$E7
.byte	$3C
.byte	$5A
.byte	$99
! 8263  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
.byte	$80
.byte	$E0
.byte	$F8
.byte	$FE
.byte	$F8
.byte	$E0
.byte	$80
.byte	0
! 8264  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
.byte	2
.byte	$E
.byte	$3E
.byte	$FE
.byte	$3E
.byte	$E
.byte	2
.byte	0
! 8265  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
! 8266  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	0
.byte	$66
.byte	0
! 8267  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
.byte	$7F
.byte	$DB
.byte	$DB
.byte	$7B
.byte	$1B
.byte	$1B
.byte	$1B
.byte	0
! 8268  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
.byte	$3E
.byte	$63
.byte	$38
.byte	$6C
.byte	$6C
.byte	$38
.byte	$CC
.byte	$78
! 8269  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$7E
.byte	$7E
.byte	$7E
.byte	0
! 8270  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	$FF
! 8271  0x18
! 8271 , 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8272  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
! 8273  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$C
.byte	$FE
.byte	$C
.byte	$18
.byte	0
.byte	0
! 8274  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$60
.byte	$FE
.byte	$60
.byte	$30
.byte	0
.byte	0
! 8275  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
.byte	0
.byte	0
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$FE
.byte	0
.byte	0
! 8276  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
.byte	0
.byte	$24
.byte	$66
.byte	$FF
.byte	$66
.byte	$24
.byte	0
.byte	0
! 8277  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$3C
.byte	$7E
.byte	$FF
.byte	$FF
.byte	0
.byte	0
! 8278  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	$FF
.byte	$FF
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8279  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8280  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
.byte	$30
.byte	$78
.byte	$78
.byte	$30
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8281  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$6C
.byte	$6C
.byte	$6C
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8282  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
.byte	$6C
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$6C
.byte	0
! 8283  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
.byte	$30
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	$30
.byte	0
! 8284  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
.byte	0
.byte	$C6
.byte	$CC
.byte	$18
.byte	$30
.byte	$66
.byte	$C6
.byte	0
! 8285  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
.byte	$38
.byte	$6C
.byte	$38
.byte	$76
.byte	$DC
.byte	$CC
.byte	$76
.byte	0
! 8286  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$60
.byte	$60
.byte	$C0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8287  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$60
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8288  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$18
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8289  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
.byte	0
.byte	$66
.byte	$3C
.byte	$FF
.byte	$3C
.byte	$66
.byte	0
.byte	0
! 8290  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$30
.byte	$FC
.byte	$30
.byte	$30
.byte	0
.byte	0
! 8291  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8292  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	0
.byte	0
! 8293  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8294  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
.byte	6
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$80
.byte	0
! 8295  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
.byte	$7C
.byte	$C6
.byte	$CE
.byte	$DE
.byte	$F6
.byte	$E6
.byte	$7C
.byte	0
! 8296  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
.byte	$30
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$FC
.byte	0
! 8297  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$60
.byte	$CC
.byte	$FC
.byte	0
! 8298  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8299  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
.byte	$1C
.byte	$3C
.byte	$6C
.byte	$CC
.byte	$FE
.byte	$C
.byte	$1E
.byte	0
! 8300  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
.byte	$FC
.byte	$C0
.byte	$F8
.byte	$C
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8301  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
.byte	$38
.byte	$60
.byte	$C0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8302  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
.byte	$FC
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	$30
.byte	$30
.byte	0
! 8303  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$78
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8304  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$18
.byte	$70
.byte	0
! 8305  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	$30
.byte	$30
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8306  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	$30
.byte	$30
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8307  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8308  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
! 8309  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8310  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8311  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
.byte	$7C
.byte	$C6
.byte	$DE
.byte	$DE
.byte	$DE
.byte	$C0
.byte	$78
.byte	0
! 8312  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0
.byte	$30
.byte	$78
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
! 8312 x00,
.byte	0
! 8313  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$66
.byte	$66
.byte	$FC
.byte	0
! 8314  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$66
.byte	$3C
.byte	0
! 8315  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
.byte	$F8
.byte	$6C
.byte	$66
.byte	$66
.byte	$66
.byte	$6C
.byte	$F8
.byte	0
! 8316  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$62
.byte	$FE
.byte	0
! 8317  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$60
.byte	$F0
.byte	0
! 8318  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$CE
.byte	$66
.byte	$3E
.byte	0
! 8319  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8320  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$78
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8321  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
.byte	$1E
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8322  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
.byte	$E6
.byte	$66
.byte	$6C
.byte	$78
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8323  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
.byte	$F0
.byte	$60
.byte	$60
.byte	$60
.byte	$62
.byte	$66
.byte	$FE
.byte	0
! 8324  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$EE
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	$C6
.byte	0
! 8325  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$E6
.byte	$F6
.byte	$DE
.byte	$CE
.byte	$C6
.byte	$C6
.byte	0
! 8326  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	0
! 8327  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8328  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$DC
.byte	$78
.byte	$1C
.byte	0
! 8329  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8330  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$E0
.byte	$70
.byte	$1C
.byte	$CC
.byte	$78
.byte	0
! 8331  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$FC
.byte	$B4
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8332  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	0
! 8333  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8334  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$EE
.byte	$C6
.byte	0
! 8335  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8336  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8337  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
.byte	$FE
.byte	$C6
.byte	$8C
.byte	$18
.byte	$32
.byte	$66
.byte	$FE
.byte	0
! 8338  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
.byte	$78
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$78
.byte	0
! 8339  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	6
.byte	2
.byte	0
! 8340  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
.byte	$78
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$78
.byte	0
! 8341  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
.byte	0
.byte	0
.byte	0
! 8342  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$FF
! 8343  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$30
.byte	$30
.byte	$18
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8344  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$C
.byte	$7C
.byte	$CC
.byte	$76
.byte	0
! 8345  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
.byte	$E0
.byte	$60
.byte	$60
.byte	$7C
.byte	$66
.byte	$66
.byte	$DC
.byte	0
! 8346  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$C0
.byte	$CC
.byte	$78
.byte	0
! 8347  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
.byte	$1C
.byte	$C
.byte	$C
.byte	$7C
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8348  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$FC
.byte	$C0
.byte	$78
.byte	0
! 8349  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
.byte	$38
.byte	$6C
.byte	$60
.byte	$F0
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8350  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8351  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
.byte	$E0
.byte	$60
.byte	$6C
.byte	$76
.byte	$66
.byte	$66
.byte	$E6
.byte	0
! 8352  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$30
.byte	0
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8353  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
.byte	$C
.byte	0
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
! 8354  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6
.byte	$E0
.byte	$60
.byte	$66
.byte	$6C
.byte	$78
! 8354 c, 0xe6, 0x00,
.byte	$6C
.byte	$E6
.byte	0
! 8355  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8356  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	0
! 8357  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	0
.byte	0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8358  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8359  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
.byte	0
.byte	0
.byte	$DC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$F0
! 8360  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$1E
! 8361  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
.byte	0
.byte	0
.byte	$DC
.byte	$76
.byte	$66
.byte	$60
.byte	$F0
.byte	0
! 8362  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
.byte	0
.byte	0
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	0
! 8363  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
.byte	$10
.byte	$30
.byte	$7C
.byte	$30
.byte	$30
.byte	$34
.byte	$18
.byte	0
! 8364  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8365  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8366  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$FE
.byte	$6C
.byte	0
! 8367  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$6C
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8368  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8369  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	$98
.byte	$30
.byte	$64
.byte	$FC
.byte	0
! 8370  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	0
! 8371  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	0
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8372  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	0
! 8373  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$76
.byte	$DC
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8374  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
.byte	0
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$FE
.byte	0
! 8375 };
!BCC_EOS
! 8376 #asm
!BCC_ASM
.org 0xcff0
bios_table_area_end:
! 8379 endasm
!BCC_ENDASM
! 8380 
.722:
.76D:
.ascii	" - success."
.byte	$A
.byte	0
.70B:
.76E:
.byte	0
.70A:
.76F:
.ascii	"Powering off in 30 seconds."
.byte	$A
.byte	0
.709:
.770:
.byte	$A
.ascii	"No bootable device."
.byte	$A
.byte	0
.6F3:
.771:
.ascii	"set_diskette_current_cyl(): drive > 1"
.byte	$A
.byte	0
.6DD:
.772:
.ascii	"floppy: int13: bad floppy type"
.byte	$A
.byte	0
.6C5:
.773:
.ascii	"int13_diskette_function: write error"
.byte	$A
.byte	0
.6BF:
.774:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6A4:
.775:
.ascii	"int13_diskette_function: read error"
.byte	$A
.byte	0
.69E:
.776:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.68C:
.777:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.5DB:
.778:
.ascii	"Int13 eltorito call with AX=%04x. Please"
.ascii	" report"
.byte	$A
.byte	0
.585:
.779:
.ascii	"int13_cdrom: function %02x. Can't use 64"
.ascii	"bits lba"
.byte	$A
.byte	0
.48D:
.77A:
.ascii	"setkbdcomm"
.byte	0
.486:
.77B:
.ascii	"sendmouse"
.byte	0
.483:
.77C:
.ascii	"enabmouse"
.byte	0
.47C:
.77D:
.ascii	"enabmouse"
.byte	0
.479:
.77E:
.ascii	"inhibmouse"
.byte	0
.472:
.77F:
.ascii	"inhibmouse"
.byte	0
.455:
.780:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.427:
.781:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.3D9:
.782:
.ascii	"INT 15h C2 AL=6, BH=%02x"
.byte	$A
.byte	0
.3C3:
.783:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3B3:
.784:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3B0:
.785:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.38E:
.786:
.ascii	"Mouse reset returned %02x (should be ack"
.ascii	")"
.byte	$A
.byte	0
.366:
.787:
.ascii	"EISA BIOS not present"
.byte	$A
.byte	0
.2D1:
.788:
.ascii	"%dMB medium detected"
.byte	$A
.byte	0
.2CC:
.789:
.ascii	"Unsupported sector size %u"
.byte	$A
.byte	0
.2C7:
.78A:
.ascii	"Waiting for device to detect medium... "
.byte	0
.2B9:
.78B:
.ascii	"not implemented for non-ATAPI device"
.byte	$A
.byte	0
.230:
.78C:
.byte	$A
.byte	0
.22E:
.78D:
.ascii	"Unknown device"
.byte	$A
.byte	0
.22C:
.78E:
.ascii	"%d             Device"
.byte	$A
.byte	0
.22A:
.78F:
.ascii	"%d             CD-Rom/DVD-Rom"
.byte	$A
.byte	0
.227:
.790:
.ascii	"XS Virtual ATAPI-"
.byte	0
.225:
.791:
.ascii	" (%uGB)"
.byte	$A
.byte	0
.223:
.792:
.ascii	" (%uMB)"
.byte	$A
.byte	0
.220:
.793:
.ascii	"XS Virtual IDE Controller      Hard Driv"
.ascii	"e"
.byte	0
.1F5:
.794:
.ascii	"ata-detect: Failed to detect ATAPI devic"
.ascii	"e"
.byte	$A
.byte	0
.1BC:
.795:
.ascii	"ata-detect: Failed to detect ATA device"
.byte	$A
.byte	0
.158:
.796:
.ascii	"INT18: BOOT FAILURE"
.byte	$A
.byte	0
.157:
.797:
.ascii	"NMI Handler called"
.byte	$A
.byte	0
.156:
.798:
.byte	$A,$A
.byte	0
.155:
.799:
.ascii	": could not read boot disk"
.byte	0
.153:
.79A:
.ascii	": disk not bootable"
.byte	0
.14E:
.79B:
.ascii	" - failure"
.byte	0
.14D:
.79C:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.149:
.79D:
.ascii	" [%S]"
.byte	0
.145:
.79E:
.ascii	"Boot device: %s"
.byte	0
.144:
.79F:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.13D:
.7A0:
.byte	$A
.byte	0
.131:
.7A1:
.byte	$A
.byte	0
.130:
.7A2:
.ascii	" [%S]"
.byte	0
.12D:
.7A3:
.ascii	"%s"
.byte	0
.12B:
.7A4:
.ascii	"%s"
.byte	$A
.byte	0
.124:
.7A5:
.ascii	"%d. "
.byte	0
.11F:
.7A6:
.ascii	"Select boot device:"
.byte	$A,$A
.byte	0
.115:
.7A7:
.byte	$A,$A
.ascii	"Press F12 for boot menu."
.byte	$A,$A
.byte	0
.10C:
.7A8:
.ascii	"Processor %d: Xen(R) Virtual CPU"
.byte	$A
.byte	0
.107:
.7A9:
.ascii	"Returned from s3_resume."
.byte	$A
.byte	0
.106:
.7AA:
.ascii	"Unimplemented shutdown status: %02x"
.byte	$A
.byte	0
.105:
.7AB:
.ascii	"Couldn't reset the machine"
.byte	$A
.byte	0
.104:
.7AC:
.ascii	"Keyboard error:%u"
.byte	$A
.byte	0
.8D:
.7AD:
.ascii	"bios_printf: unknown format"
.byte	$A
.byte	0
.41:
.7AE:
.ascii	"FATAL: "
.byte	0
.bss

! 0 errors detected

00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 struct rombios_info {
00004                                           ! 2     unsigned long bios32_entry;
00005                                           !BCC_EOS
00006                                           ! 3 };
00007                                           !BCC_EOS
00008                                           ! 4 #asm
00009                                           !BCC_ASM
00010 0000                                      .rom
00011 0000                                      .org 0x0000
00012                                           use16 386
00013                                           MACRO HALT
00014                                             ;; the HALT macro is called with the line number of the HALT call.
00015                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00016                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00017                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00018                                             ;; However, users can choose to make panics non-fatal and continue.
00019                                             mov dx,#0x400
00020                                             mov ax,#?1
00021                                             out dx,ax
00022                                           MEND
00023                                           MACRO JMP_AP
00024                                             db 0xea
00025                                             dw ?2
00026                                             dw ?1
00027                                           MEND
00028                                           MACRO SET_INT_VECTOR
00029                                             mov ax, ?3
00030                                             mov ?1*4, ax
00031                                             mov ax, ?2
00032                                             mov ?1*4+2, ax
00033                                           MEND
00034                                           ! 29 endasm
00035                                           !BCC_ENDASM
00036                                           ! 30 typedef unsigned char Bit8u;
00037                                           !BCC_EOS
00038                                           ! 31 typedef unsigned short Bit16u;
00039                                           !BCC_EOS
00040                                           ! 32 typedef unsigned short bx_bool;
00041                                           !BCC_EOS
00042                                           ! 33 typedef unsigned long Bit32u;
00043                                           !BCC_EOS
00044                                           ! 34   void memsetb(seg,offset,value,count);
00045                                           !BCC_EOS
00046                                           ! 35   void memcpyb(dseg,doffset,sseg,soffset,count);
00047                                           !BCC_EOS
00048                                           ! 36   void memcpyd(dseg,doffset,sseg,soffset,count);
00049                                           !BCC_EOS
00050                                           ! 37     void
00051                                           ! 38   memsetb(seg,offset,value,count)
00052                                           ! 39     Bit16u seg;
00053                                           export	_memsetb
00054                       00000000            _memsetb:
00055                                           !BCC_EOS
00056                                           ! 40     Bit16u offset;
00057                                           !BCC_EOS
00058                                           ! 41     Bit16u value;
00059                                           !BCC_EOS
00060                                           ! 42     Bit16u count;
00061                                           !BCC_EOS
00062                                           ! 43   {
00063                                           ! 44 #asm
00064                                           !BCC_ASM
00065                       00000008            _memsetb.count	set	8
00066                       00000002            _memsetb.seg	set	2
00067                       00000006            _memsetb.value	set	6
00068                       00000004            _memsetb.offset	set	4
00069 0000           55                             push bp
00070 0001           89E5                           mov bp, sp
00071 0003           50                               push ax
00072 0004           51                               push cx
00073 0005           06                               push es
00074 0006           57                               push di
00075 0007           8B4E         0A                  mov cx, 10[bp] ; count
00076 000A           85C9                             test cx, cx
00077 000C           74           10                  je memsetb_end
00078 000E           8B46         04                  mov ax, 4[bp] ; segment
00079 0011           8EC0                             mov es, ax
00080 0013           8B46         06                  mov ax, 6[bp] ; offset
00081 0016           89C7                             mov di, ax
00082 0018           8A46         08                  mov al, 8[bp] ; value
00083 001B           FC                               cld
00084 001C           F3                               rep
00085 001D           AA                                stosb
00086                       0000001E              memsetb_end:
00087 001E           5F                               pop di
00088 001F           07                               pop es
00089 0020           59                               pop cx
00090 0021           58                               pop ax
00091 0022           5D                             pop bp
00092                                           ! 68 endasm
00093                                           !BCC_ENDASM
00094                                           ! 69   }
00095 0023           C3                         ret
00096                                           ! 70     void
00097                                           ! 71   memcpyb(dseg,doffset,sseg,soffset,count)
00098                                           ! 72     Bit16u dseg;
00099                                           export	_memcpyb
00100                       00000024            _memcpyb:
00101                                           !BCC_EOS
00102                                           ! 73     Bit16u doffset;
00103                                           !BCC_EOS
00104                                           ! 74     Bit16u sseg;
00105                                           !BCC_EOS
00106                                           ! 75     Bit16u soffset;
00107                                           !BCC_EOS
00108                                           ! 76     Bit16u count;
00109                                           !BCC_EOS
00110                                           ! 77   {
00111                                           ! 78 #asm
00112                                           !BCC_ASM
00113                       0000000A            _memcpyb.count	set	$A
00114                       00000006            _memcpyb.sseg	set	6
00115                       00000008            _memcpyb.soffset	set	8
00116                       00000002            _memcpyb.dseg	set	2
00117                       00000004            _memcpyb.doffset	set	4
00118 0024           55                             push bp
00119 0025           89E5                           mov bp, sp
00120 0027           50                               push ax
00121 0028           51                               push cx
00122 0029           06                               push es
00123 002A           57                               push di
00124 002B           1E                               push ds
00125 002C           56                               push si
00126 002D           8B4E         0C                  mov cx, 12[bp] ; count
00127 0030           85C9                             test cx, cx
00128 0032           74           17                  je memcpyb_end
00129 0034           8B46         04                  mov ax, 4[bp] ; dsegment
00130 0037           8EC0                             mov es, ax
00131 0039           8B46         06                  mov ax, 6[bp] ; doffset
00132 003C           89C7                             mov di, ax
00133 003E           8B46         08                  mov ax, 8[bp] ; ssegment
00134 0041           8ED8                             mov ds, ax
00135 0043           8B46         0A                  mov ax, 10[bp] ; soffset
00136 0046           89C6                             mov si, ax
00137 0048           FC                               cld
00138 0049           F3                               rep
00139 004A           A4                                movsb
00140                       0000004B              memcpyb_end:
00141 004B           5E                               pop si
00142 004C           1F                               pop ds
00143 004D           5F                               pop di
00144 004E           07                               pop es
00145 004F           59                               pop cx
00146 0050           58                               pop ax
00147 0051           5D                             pop bp
00148                                           ! 109 endasm
00149                                           !BCC_ENDASM
00150                                           ! 110   }
00151 0052           C3                         ret
00152                                           ! 111     void
00153                                           ! 112   memcpyd(dseg,doffset,sseg,soffset,count)
00154                                           ! 113     Bit16u dseg;
00155                                           export	_memcpyd
00156                       00000053            _memcpyd:
00157                                           !BCC_EOS
00158                                           ! 114     Bit16u doffset;
00159                                           !BCC_EOS
00160                                           ! 115     Bit16u sseg;
00161                                           !BCC_EOS
00162                                           ! 116     Bit16u soffset;
00163                                           !BCC_EOS
00164                                           ! 117     Bit16u count;
00165                                           !BCC_EOS
00166                                           ! 118   {
00167                                           ! 119 #asm
00168                                           !BCC_ASM
00169                       0000000A            _memcpyd.count	set	$A
00170                       00000006            _memcpyd.sseg	set	6
00171                       00000008            _memcpyd.soffset	set	8
00172                       00000002            _memcpyd.dseg	set	2
00173                       00000004            _memcpyd.doffset	set	4
00174 0053           55                             push bp
00175 0054           89E5                           mov bp, sp
00176 0056           50                               push ax
00177 0057           51                               push cx
00178 0058           06                               push es
00179 0059           57                               push di
00180 005A           1E                               push ds
00181 005B           56                               push si
00182 005C           8B4E         0C                  mov cx, 12[bp] ; count
00183 005F           85C9                             test cx, cx
00184 0061           74           18                  je memcpyd_end
00185 0063           8B46         04                  mov ax, 4[bp] ; dsegment
00186 0066           8EC0                             mov es, ax
00187 0068           8B46         06                  mov ax, 6[bp] ; doffset
00188 006B           89C7                             mov di, ax
00189 006D           8B46         08                  mov ax, 8[bp] ; ssegment
00190 0070           8ED8                             mov ds, ax
00191 0072           8B46         0A                  mov ax, 10[bp] ; soffset
00192 0075           89C6                             mov si, ax
00193 0077           FC                               cld
00194 0078           F3                               rep
00195 0079     66    A5                                movsd
00196                       0000007B              memcpyd_end:
00197 007B           5E                               pop si
00198 007C           1F                               pop ds
00199 007D           5F                               pop di
00200 007E           07                               pop es
00201 007F           59                               pop cx
00202 0080           58                               pop ax
00203 0081           5D                             pop bp
00204                                           ! 150 endasm
00205                                           !BCC_ENDASM
00206                                           ! 151   }
00207 0082           C3                         ret
00208                                           ! 152   static Bit32u read_dword();
00209                                           !BCC_EOS
00210                                           ! 153   static void write_dword();
00211                                           !BCC_EOS
00212                                           ! 154     Bit32u
00213                                           ! 155   read_dword(seg, offset)
00214                                           ! 156     Bit16u seg;
00215                                           export	_read_dword
00216                       00000083            _read_dword:
00217                                           !BCC_EOS
00218                                           ! 157     Bit16u offset;
00219                                           !BCC_EOS
00220                                           ! 158   {
00221                                           ! 159 #asm
00222                                           !BCC_ASM
00223                       00000002            _read_dword.seg	set	2
00224                       00000004            _read_dword.offset	set	4
00225 0083           55                             push bp
00226 0084           89E5                           mov bp, sp
00227 0086           53                               push bx
00228 0087           1E                               push ds
00229 0088           8B46         04                  mov ax, 4[bp] ; segment
00230 008B           8ED8                             mov ds, ax
00231 008D           8B5E         06                  mov bx, 6[bp] ; offset
00232 0090           8B07                             mov ax, [bx]
00233 0092           83C3                   02        add bx, #2
00234 0095           8B17                             mov dx, [bx]
00235                                                 ;; ax = return value (word)
00236                                                 ;; dx = return value (word)
00237 0097           1F                               pop ds
00238 0098           5B                               pop bx
00239 0099           5D                             pop bp
00240                                           ! 175 endasm
00241                                           !BCC_ENDASM
00242                                           ! 176   }
00243 009A           C3                         ret
00244                                           ! 177     void
00245                                           ! 178   write_dword(seg, offset, data)
00246                                           ! 179     Bit16u seg;
00247                                           export	_write_dword
00248                       0000009B            _write_dword:
00249                                           !BCC_EOS
00250                                           ! 180     Bit16u offset;
00251                                           !BCC_EOS
00252                                           ! 181     Bit32u data;
00253                                           !BCC_EOS
00254                                           ! 182   {
00255                                           ! 183 #asm
00256                                           !BCC_ASM
00257                       00000002            _write_dword.seg	set	2
00258                       00000006            _write_dword.data	set	6
00259                       00000004            _write_dword.offset	set	4
00260 009B           55                             push bp
00261 009C           89E5                           mov bp, sp
00262 009E           50                               push ax
00263 009F           53                               push bx
00264 00A0           1E                               push ds
00265 00A1           8B46         04                  mov ax, 4[bp] ; segment
00266 00A4           8ED8                             mov ds, ax
00267 00A6           8B5E         06                  mov bx, 6[bp] ; offset
00268 00A9           8B46         08                  mov ax, 8[bp] ; data word
00269 00AC           8907                             mov [bx], ax ; write data word
00270 00AE           83C3                   02        add bx, #2
00271 00B1           8B46         0A                  mov ax, 10[bp] ; data word
00272 00B4           8907                             mov [bx], ax ; write data word
00273 00B6           1F                               pop ds
00274 00B7           5B                               pop bx
00275 00B8           58                               pop ax
00276 00B9           5D                             pop bp
00277                                           ! 201 endasm
00278                                           !BCC_ENDASM
00279                                           ! 202   }
00280 00BA           C3                         ret
00281                                           ! 203 #asm
00282                                           !BCC_ASM
00283                       00000002            _write_dword.seg	set	2
00284                       00000006            _write_dword.data	set	6
00285                       00000004            _write_dword.offset	set	4
00286                                             ;; and function
00287                       000000BB              landl:
00288                       000000BB              landul:
00289 00BB           36                             SEG SS
00290 00BC           2305                             and ax,[di]
00291 00BE           36                             SEG SS
00292 00BF           235D         02                  and bx,2[di]
00293 00C2           C3                             ret
00294                                             ;; add function
00295                       000000C3              laddl:
00296                       000000C3              laddul:
00297 00C3           36                             SEG SS
00298 00C4           0305                             add ax,[di]
00299 00C6           36                             SEG SS
00300 00C7           135D         02                  adc bx,2[di]
00301 00CA           C3                             ret
00302                                             ;; cmp function
00303                       000000CB              lcmpl:
00304                       000000CB              lcmpul:
00305 00CB     66    25               0000FFFF      and eax, #0x0000FFFF
00306 00D1     66    C1E3                   10      shl ebx, #16
00307 00D5     66    09D8                           or eax, ebx
00308 00D8     66    C1EB                   10      shr ebx, #16
00309 00DC           36                             SEG SS
00310 00DD     66    3B05                             cmp eax, dword ptr [di]
00311 00E0           C3                             ret
00312                                             ;; sub function
00313                       000000E1              lsubl:
00314                       000000E1              lsubul:
00315 00E1           36                             SEG SS
00316 00E2           2B05                           sub ax,[di]
00317 00E4           36                             SEG SS
00318 00E5           1B5D         02                sbb bx,2[di]
00319 00E8           C3                             ret
00320                                             ;; mul function
00321                       000000E9              lmull:
00322                       000000E9              lmulul:
00323 00E9     66    25               0000FFFF      and eax, #0x0000FFFF
00324 00EF     66    C1E3                   10      shl ebx, #16
00325 00F3     66    09D8                           or eax, ebx
00326 00F6           36                             SEG SS
00327 00F7     66    F725                           mul eax, dword ptr [di]
00328 00FA     66    89C3                           mov ebx, eax
00329 00FD     66    C1EB                   10      shr ebx, #16
00330 0101           C3                             ret
00331                                             ;; dec function
00332                       00000102              ldecl:
00333                       00000102              ldecul:
00334 0102           36                             SEG SS
00335 0103     66    FF0F                           dec dword ptr [bx]
00336 0106           C3                             ret
00337                                             ;; or function
00338                       00000107              lorl:
00339                       00000107              lorul:
00340 0107           36                             SEG SS
00341 0108           0B05                           or ax,[di]
00342 010A           36                             SEG SS
00343 010B           0B5D         02                or bx,2[di]
00344 010E           C3                             ret
00345                                             ;; inc function
00346                       0000010F              lincl:
00347                       0000010F              lincul:
00348 010F           36                             SEG SS
00349 0110     66    FF07                           inc dword ptr [bx]
00350 0113           C3                             ret
00351                                             ;; tst function
00352                       00000114              ltstl:
00353                       00000114              ltstul:
00354 0114     66    25               0000FFFF      and eax, #0x0000FFFF
00355 011A     66    C1E3                   10      shl ebx, #16
00356 011E     66    09D8                           or eax, ebx
00357 0121     66    C1EB                   10      shr ebx, #16
00358 0125     66    85C0                           test eax, eax
00359 0128           C3                             ret
00360                                             ;; sr function
00361                       00000129              lsrul:
00362 0129           89F9                           mov cx,di
00363 012B           E3           19                jcxz lsr_exit
00364 012D     66    25               0000FFFF      and eax, #0x0000FFFF
00365 0133     66    C1E3                   10      shl ebx, #16
00366 0137     66    09D8                           or eax, ebx
00367                       0000013A              lsr_loop:
00368 013A     66    D1E8                           shr eax, #1
00369 013D           E2           FB                loop lsr_loop
00370 013F     66    89C3                           mov ebx, eax
00371 0142     66    C1EB                   10      shr ebx, #16
00372                       00000146              lsr_exit:
00373 0146           C3                             ret
00374                                             ;; sl function
00375                       00000147              lsll:
00376                       00000147              lslul:
00377 0147           89F9                           mov cx,di
00378 0149           E3           19                jcxz lsl_exit
00379 014B     66    25               0000FFFF      and eax, #0x0000FFFF
00380 0151     66    C1E3                   10      shl ebx, #16
00381 0155     66    09D8                           or eax, ebx
00382                       00000158              lsl_loop:
00383 0158     66    D1E0                           shl eax, #1
00384 015B           E2           FB                loop lsl_loop
00385 015D     66    89C3                           mov ebx, eax
00386 0160     66    C1EB                   10      shr ebx, #16
00387                       00000164              lsl_exit:
00388 0164           C3                             ret
00389                       00000165              idiv_:
00390 0165           99                             cwd
00391 0166           F7FB                           idiv bx
00392 0168           C3                             ret
00393                       00000169              idiv_u:
00394 0169           31D2                           xor dx,dx
00395 016B           F7F3                           div bx
00396 016D           C3                             ret
00397                       0000016E              ldivul:
00398 016E     66    25               0000FFFF      and eax, #0x0000FFFF
00399 0174     66    C1E3                   10      shl ebx, #16
00400 0178     66    09D8                           or eax, ebx
00401 017B     66    31D2                           xor edx, edx
00402 017E           36                             SEG SS
00403 017F           8B5D         02                mov bx, 2[di]
00404 0182     66    C1E3                   10      shl ebx, #16
00405 0186           36                             SEG SS
00406 0187           8B1D                           mov bx, [di]
00407 0189     66    F7F3                           div ebx
00408 018C     66    89C3                           mov ebx, eax
00409 018F     66    C1EB                   10      shr ebx, #16
00410 0193           C3                             ret
00411                                           ! 329 endasm
00412                                           !BCC_ENDASM
00413                                           ! 330 typedef struct {
00414                                           ! 331   unsigned char filler1[0x400];
00415                                           !BCC_EOS
00416                                           ! 332   unsigned char filler2[0x6c];
00417                                           !BCC_EOS
00418                                           ! 333   Bit16u ticks_low;
00419                                           !BCC_EOS
00420                                           ! 334   Bit16u ticks_high;
00421                                           !BCC_EOS
00422                                           ! 335   Bit8u midnight_flag;
00423                                           !BCC_EOS
00424                                           ! 336   } bios_data_t;
00425                                           !BCC_EOS
00426                                           ! 337   typedef struct {
00427                                           ! 338     Bit16u heads;
00428                                           !BCC_EOS
00429                                           ! 339     Bit16u cylinders;
00430                                           !BCC_EOS
00431                                           ! 340     Bit16u spt;
00432                                           !BCC_EOS
00433                                           ! 341     } chs_t;
00434                                           !BCC_EOS
00435                                           ! 342   typedef struct {
00436                                           ! 343     Bit16u iobase1;
00437                                           !BCC_EOS
00438                                           ! 344     Bit16u iobase2;
00439                                           !BCC_EOS
00440                                           ! 345     Bit8u prefix;
00441                                           !BCC_EOS
00442                                           ! 346     Bit8u unused;
00443                                           !BCC_EOS
00444                                           ! 347     Bit8u irq;
00445                                           !BCC_EOS
00446                                           ! 348     Bit8u blkcount;
00447                                           !BCC_EOS
00448                                           ! 349     Bit8u dma;
00449                                           !BCC_EOS
00450                                           ! 350     Bit8u pio;
00451                                           !BCC_EOS
00452                                           ! 351     Bit16u options;
00453                                           !BCC_EOS
00454                                           ! 352     Bit16u reserved;
00455                                           !BCC_EOS
00456                                           ! 353     Bit8u revision;
00457                                           !BCC_EOS
00458                                           ! 354     Bit8u checksum;
00459                                           !BCC_EOS
00460                                           ! 355     } dpte_t;
00461                                           !BCC_EOS
00462                                           ! 356   typedef struct {
00463                                           ! 357     Bit8u iface;
00464                                           !BCC_EOS
00465                                           ! 358     Bit16u iobase1;
00466                                           !BCC_EOS
00467                                           ! 359     Bit16u iobase2;
00468                                           !BCC_EOS
00469                                           ! 360     Bit8u irq;
00470                                           !BCC_EOS
00471                                           ! 361     } ata_channel_t;
00472                                           !BCC_EOS
00473                                           ! 362   typedef struct {
00474                                           ! 363     Bit8u type;
00475                                           !BCC_EOS
00476                                           ! 364     Bit8u device;
00477                                           !BCC_EOS
00478                                           ! 365     Bit8u removab
00479                                           ! 365 le;
00480                                           !BCC_EOS
00481                                           ! 366     Bit8u lock;
00482                                           !BCC_EOS
00483                                           ! 367     Bit8u mode;
00484                                           !BCC_EOS
00485                                           ! 368     Bit16u blksize;
00486                                           !BCC_EOS
00487                                           ! 369     Bit8u translation;
00488                                           !BCC_EOS
00489                                           ! 370     chs_t lchs;
00490                                           !BCC_EOS
00491                                           ! 371     chs_t pchs;
00492                                           !BCC_EOS
00493                                           ! 372     Bit32u sectors_low;
00494                                           !BCC_EOS
00495                                           ! 373     Bit32u sectors_high;
00496                                           !BCC_EOS
00497                                           ! 374     } ata_device_t;
00498                                           !BCC_EOS
00499                                           ! 375   typedef struct {
00500                                           ! 376     ata_channel_t channels[4];
00501                                           !BCC_EOS
00502                                           ! 377     ata_device_t devices[(4*2)];
00503                                           !BCC_EOS
00504                                           ! 378     Bit8u hdcount, hdidmap[(4*2)];
00505                                           !BCC_EOS
00506                                           ! 379     Bit8u cdcount, cdidmap[(4*2)];
00507                                           !BCC_EOS
00508                                           ! 380     dpte_t dpte;
00509                                           !BCC_EOS
00510                                           ! 381     Bit16u trsfsectors;
00511                                           !BCC_EOS
00512                                           ! 382     Bit32u trsfbytes;
00513                                           !BCC_EOS
00514                                           ! 383     } ata_t;
00515                                           !BCC_EOS
00516                                           ! 384   typedef struct {
00517                                           ! 385     Bit8u active;
00518                                           !BCC_EOS
00519                                           ! 386     Bit8u media;
00520                                           !BCC_EOS
00521                                           ! 387     Bit8u emulated_drive;
00522                                           !BCC_EOS
00523                                           ! 388     Bit8u controller_index;
00524                                           !BCC_EOS
00525                                           ! 389     Bit16u device_spec;
00526                                           !BCC_EOS
00527                                           ! 390     Bit32u ilba;
00528                                           !BCC_EOS
00529                                           ! 391     Bit16u buffer_segment;
00530                                           !BCC_EOS
00531                                           ! 392     Bit16u load_segment;
00532                                           !BCC_EOS
00533                                           ! 393     Bit16u sector_count;
00534                                           !BCC_EOS
00535                                           ! 394     chs_t vdevice;
00536                                           !BCC_EOS
00537                                           ! 395     } cdemu_t;
00538                                           !BCC_EOS
00539                                           ! 396 Bit32u TCGInterruptHandler ();
00540                                           !BCC_EOS
00541                                           ! 397 void tcpa_acpi_init ();
00542                                           !BCC_EOS
00543                                           ! 398 Bit32u tcpa_extend_acpi_log ();
00544                                           !BCC_EOS
00545                                           ! 399 void tcpa_calling_int19h ();
00546                                           !BCC_EOS
00547                                           ! 400 void tcpa_returned_int19h ();
00548                                           !BCC_EOS
00549                                           ! 401 void tcpa_add_event_separators ();
00550                                           !BCC_EOS
00551                                           ! 402 void tcpa_wake_event ();
00552                                           !BCC_EOS
00553                                           ! 403 void tcpa_add_bootdevice ();
00554                                           !BCC_EOS
00555                                           ! 404 void tcpa_start_option_rom_scan ();
00556                                           !BCC_EOS
00557                                           ! 405 void tcpa_option_rom ();
00558                                           !BCC_EOS
00559                                           ! 406 void tcpa_ipl ();
00560                                           !BCC_EOS
00561                                           ! 407 void tcpa_measure_post ();
00562                                           !BCC_EOS
00563                                           ! 408 Bit32u tcpa_initialize_tpm ();
00564                                           !BCC_EOS
00565                                           ! 409 Bit32u get_s3_waking_vector ();
00566                                           !BCC_EOS
00567                                           ! 410 Bit32u pmm ();
00568                                           !BCC_EOS
00569                                           ! 411   typedef struct {
00570                                           ! 412     unsigned char ebda_size;
00571                                           !BCC_EOS
00572                                           ! 413     unsigned char cmos_shutdown_status;
00573                                           !BCC_EOS
00574                                           ! 414     unsigned char filler1[0x3B];
00575                                           !BCC_EOS
00576                                           ! 415     unsigned char fdpt0[0x10];
00577                                           !BCC_EOS
00578                                           ! 416     unsigned char fdpt1[0x10];
00579                                           !BCC_EOS
00580                                           ! 417     unsigned char filler2[0xC4];
00581                                           !BCC_EOS
00582                                           ! 418     ata_t ata;
00583                                           !BCC_EOS
00584                                           ! 419     cdemu_t cdemu;
00585                                           !BCC_EOS
00586                                           ! 420     } ebda_data_t;
00587                                           !BCC_EOS
00588                                           ! 421   typedef struct {
00589                                           ! 422     Bit8u size;
00590                                           !BCC_EOS
00591                                           ! 423     Bit8u reserved;
00592                                           !BCC_EOS
00593                                           ! 424     Bit16u count;
00594                                           !BCC_EOS
00595                                           ! 425     Bit16u offset;
00596                                           !BCC_EOS
00597                                           ! 426     Bit16u segment;
00598                                           !BCC_EOS
00599                                           ! 427     Bit32u lba1;
00600                                           !BCC_EOS
00601                                           ! 428     Bit32u lba2;
00602                                           !BCC_EOS
00603                                           ! 429     } int13ext_t;
00604                                           !BCC_EOS
00605                                           ! 430   typedef struct {
00606                                           ! 431     Bit16u size;
00607                                           !BCC_EOS
00608                                           ! 432     Bit16u infos;
00609                                           !BCC_EOS
00610                                           ! 433     Bit32u cylinders;
00611                                           !BCC_EOS
00612                                           ! 434     Bit32u heads;
00613                                           !BCC_EOS
00614                                           ! 435     Bit32u spt;
00615                                           !BCC_EOS
00616                                           ! 436     Bit32u sector_count1;
00617                                           !BCC_EOS
00618                                           ! 437     Bit32u sector_count2;
00619                                           !BCC_EOS
00620                                           ! 438     Bit16u blksize;
00621                                           !BCC_EOS
00622                                           ! 439     Bit16u dpte_offset;
00623                                           !BCC_EOS
00624                                           ! 440     Bit16u dpte_segment;
00625                                           !BCC_EOS
00626                                           ! 441     Bit16u key;
00627                                           !BCC_EOS
00628                                           ! 442     Bit8u dpi_length;
00629                                           !BCC_EOS
00630                                           ! 443     Bit8u reserved1;
00631                                           !BCC_EOS
00632                                           ! 444     Bit16u reserved2;
00633                                           !BCC_EOS
00634                                           ! 445     Bit8u host_bus[4];
00635                                           !BCC_EOS
00636                                           ! 446     Bit8u iface_type[8];
00637                                           !BCC_EOS
00638                                           ! 447     Bit8u iface_path[8];
00639                                           !BCC_EOS
00640                                           ! 448     Bit8u device_path[8];
00641                                           !BCC_EOS
00642                                           ! 449     Bit8u reserved3;
00643                                           !BCC_EOS
00644                                           ! 450     Bit8u checksum;
00645                                           !BCC_EOS
00646                                           ! 451     } dpt_t;
00647                                           !BCC_EOS
00648                                           ! 452 typedef struct {
00649                                           ! 453   union {
00650                                           ! 454     struct {
00651                                           ! 455       Bit16u di, si, b
00652                                           ! 455 p, sp;
00653                                           !BCC_EOS
00654                                           ! 456       Bit16u bx, dx, cx, ax;
00655                                           !BCC_EOS
00656                                           ! 457       } r16;
00657                                           !BCC_EOS
00658                                           ! 458     struct {
00659                                           ! 459       Bit16u filler[4];
00660                                           !BCC_EOS
00661                                           ! 460       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00662                                           !BCC_EOS
00663                                           ! 461       } r8;
00664                                           !BCC_EOS
00665                                           ! 462     } u;
00666                                           !BCC_EOS
00667                                           ! 463   } pusha_regs_t;
00668                                           !BCC_EOS
00669                                           ! 464 typedef struct {
00670                                           ! 465  union {
00671                                           ! 466   struct {
00672                                           ! 467     Bit32u edi, esi, ebp, esp;
00673                                           !BCC_EOS
00674                                           ! 468     Bit32u ebx, edx, ecx, eax;
00675                                           !BCC_EOS
00676                                           ! 469     } r32;
00677                                           !BCC_EOS
00678                                           ! 470   struct {
00679                                           ! 471     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00680                                           !BCC_EOS
00681                                           ! 472     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00682                                           !BCC_EOS
00683                                           ! 473     } r16;
00684                                           !BCC_EOS
00685                                           ! 474   struct {
00686                                           ! 475     Bit32u filler[4];
00687                                           !BCC_EOS
00688                                           ! 476     Bit8u bl, bh;
00689                                           !BCC_EOS
00690                                           ! 477     Bit16u filler1;
00691                                           !BCC_EOS
00692                                           ! 478     Bit8u dl, dh;
00693                                           !BCC_EOS
00694                                           ! 479     Bit16u filler2;
00695                                           !BCC_EOS
00696                                           ! 480     Bit8u cl, ch;
00697                                           !BCC_EOS
00698                                           ! 481     Bit16u filler3;
00699                                           !BCC_EOS
00700                                           ! 482     Bit8u al, ah;
00701                                           !BCC_EOS
00702                                           ! 483     Bit16u filler4;
00703                                           !BCC_EOS
00704                                           ! 484     } r8;
00705                                           !BCC_EOS
00706                                           ! 485   } u;
00707                                           !BCC_EOS
00708                                           ! 486 } pushad_regs_t;
00709                                           !BCC_EOS
00710                                           ! 487 typedef struct {
00711                                           ! 488   union {
00712                                           ! 489     struct {
00713                                           ! 490       Bit16u flags;
00714                                           !BCC_EOS
00715                                           ! 491       } r16;
00716                                           !BCC_EOS
00717                                           ! 492     struct {
00718                                           ! 493       Bit8u flagsl;
00719                                           !BCC_EOS
00720                                           ! 494       Bit8u flagsh;
00721                                           !BCC_EOS
00722                                           ! 495       } r8;
00723                                           !BCC_EOS
00724                                           ! 496     } u;
00725                                           !BCC_EOS
00726                                           ! 497   } flags_t;
00727                                           !BCC_EOS
00728                                           ! 498 typedef struct {
00729                                           ! 499   Bit16u ip;
00730                                           !BCC_EOS
00731                                           ! 500   Bit16u cs;
00732                                           !BCC_EOS
00733                                           ! 501   flags_t flags;
00734                                           !BCC_EOS
00735                                           ! 502   } iret_addr_t;
00736                                           !BCC_EOS
00737                                           ! 503 typedef struct {
00738                                           ! 504   Bit16u type;
00739                                           !BCC_EOS
00740                                           ! 505   Bit16u flags;
00741                                           !BCC_EOS
00742                                           ! 506   Bit32u vector;
00743                                           !BCC_EOS
00744                                           ! 507   Bit32u description;
00745                                           !BCC_EOS
00746                                           ! 508   Bit32u reserved;
00747                                           !BCC_EOS
00748                                           ! 509   } ipl_entry_t;
00749                                           !BCC_EOS
00750                                           ! 510 static Bit8u inb();
00751                                           !BCC_EOS
00752                                           ! 511 static Bit8u inb_cmos();
00753                                           !BCC_EOS
00754                                           ! 512 static void outb();
00755                                           !BCC_EOS
00756                                           ! 513 static void outb_cmos();
00757                                           !BCC_EOS
00758                                           ! 514 static Bit16u inw();
00759                                           !BCC_EOS
00760                                           ! 515 static void outw();
00761                                           !BCC_EOS
00762                                           ! 516 static void init_rtc();
00763                                           !BCC_EOS
00764                                           ! 517 static bx_bool rtc_updating();
00765                                           !BCC_EOS
00766                                           ! 518 static Bit8u read_byte();
00767                                           !BCC_EOS
00768                                           ! 519 static Bit16u read_word();
00769                                           !BCC_EOS
00770                                           ! 520 static void write_byte();
00771                                           !BCC_EOS
00772                                           ! 521 static void write_word();
00773                                           !BCC_EOS
00774                                           ! 522 static void bios_printf();
00775                                           !BCC_EOS
00776                                           ! 523 static Bit8u inhibit_mouse_int_and_events();
00777                                           !BCC_EOS
00778                                           ! 524 static void enable_mouse_int_and_events();
00779                                           !BCC_EOS
00780                                           ! 525 static Bit8u send_to_mouse_ctrl();
00781                                           !BCC_EOS
00782                                           ! 526 static Bit8u get_mouse_data();
00783                                           !BCC_EOS
00784                                           ! 527 static void set_kbd_command_byte();
00785                                           !BCC_EOS
00786                                           ! 528 static void int09_function();
00787                                           !BCC_EOS
00788                                           ! 529 static void int13_harddisk();
00789                                           !BCC_EOS
00790                                           ! 530 static void int13_cdrom();
00791                                           !BCC_EOS
00792                                           ! 531 static void int13_cdemu();
00793                                           !BCC_EOS
00794                                           ! 532 static void int13_eltorito();
00795                                           !BCC_EOS
00796                                           ! 533 static void int13_diskette_function();
00797                                           !BCC_EOS
00798                                           ! 534 static void int14_function();
00799                                           !BCC_EOS
00800                                           ! 535 static void int15_function();
00801                                           !BCC_EOS
00802                                           ! 536 static void int16_function();
00803                                           !BCC_EOS
00804                                           ! 537 static void int17_function();
00805                                           !BCC_EOS
00806                                           ! 538 static void int18_function();
00807                                           !BCC_EOS
00808                                           ! 539 static void int1a_function();
00809                                           !BCC_EOS
00810                                           ! 540 static void int70_function();
00811                                           !BCC_EOS
00812                                           ! 541 static void int74_function();
00813                                           !BCC_EOS
00814                                           ! 542 static Bit16u get_CS();
00815                                           !BCC_EOS
00816                                           ! 543 static Bit16u get_SS();
00817                                           !BCC_EOS
00818                                           ! 544 static unsigned int enqueue_key();
00819                                           !BCC_EOS
00820                                           ! 545 static unsigned int dequeue_
00821                                           ! 545 key();
00822                                           !BCC_EOS
00823                                           ! 546 static void get_hd_geometry();
00824                                           !BCC_EOS
00825                                           ! 547 static void set_diskette_ret_status();
00826                                           !BCC_EOS
00827                                           ! 548 static void set_diskette_current_cyl();
00828                                           !BCC_EOS
00829                                           ! 549 static void determine_floppy_media();
00830                                           !BCC_EOS
00831                                           ! 550 static bx_bool floppy_drive_exists();
00832                                           !BCC_EOS
00833                                           ! 551 static bx_bool floppy_drive_recal();
00834                                           !BCC_EOS
00835                                           ! 552 static bx_bool floppy_media_known();
00836                                           !BCC_EOS
00837                                           ! 553 static bx_bool floppy_media_sense();
00838                                           !BCC_EOS
00839                                           ! 554 static bx_bool set_enable_a20();
00840                                           !BCC_EOS
00841                                           ! 555 static void debugger_on();
00842                                           !BCC_EOS
00843                                           ! 556 static void debugger_off();
00844                                           !BCC_EOS
00845                                           ! 557 static void keyboard_init();
00846                                           !BCC_EOS
00847                                           ! 558 static void keyboard_panic();
00848                                           !BCC_EOS
00849                                           ! 559 static void shutdown_status_panic();
00850                                           !BCC_EOS
00851                                           ! 560 static void nmi_handler_msg();
00852                                           !BCC_EOS
00853                                           ! 561 static void delay_ticks();
00854                                           !BCC_EOS
00855                                           ! 562 static void delay_ticks_and_check_for_keystroke();
00856                                           !BCC_EOS
00857                                           ! 563 static void interactive_bootkey();
00858                                           !BCC_EOS
00859                                           ! 564 static void print_bios_banner();
00860                                           !BCC_EOS
00861                                           ! 565 static void print_boot_device();
00862                                           !BCC_EOS
00863                                           ! 566 static void print_boot_failure();
00864                                           !BCC_EOS
00865                                           ! 567 static void print_cdromboot_failure();
00866                                           !BCC_EOS
00867                                           ! 568 void ata_init();
00868                                           !BCC_EOS
00869                                           ! 569 void ata_detect();
00870                                           !BCC_EOS
00871                                           ! 570 void ata_reset();
00872                                           !BCC_EOS
00873                                           ! 571 Bit16u ata_cmd_non_data();
00874                                           !BCC_EOS
00875                                           ! 572 Bit16u ata_cmd_data_in();
00876                                           !BCC_EOS
00877                                           ! 573 Bit16u ata_cmd_data_out();
00878                                           !BCC_EOS
00879                                           ! 574 Bit16u ata_cmd_packet();
00880                                           !BCC_EOS
00881                                           ! 575 Bit16u atapi_get_sense();
00882                                           !BCC_EOS
00883                                           ! 576 Bit16u atapi_is_ready();
00884                                           !BCC_EOS
00885                                           ! 577 Bit16u atapi_is_cdrom();
00886                                           !BCC_EOS
00887                                           ! 578 void cdemu_init();
00888                                           !BCC_EOS
00889                                           ! 579 Bit8u cdemu_isactive();
00890                                           !BCC_EOS
00891                                           ! 580 Bit8u cdemu_emulated_drive();
00892                                           !BCC_EOS
00893                                           ! 581 Bit16u cdrom_boot();
00894                                           !BCC_EOS
00895                                           ! 582 static char bios_cvs_version_string[] = "$Revision: 1.221 $ $Date: 2008/12/07 17:32:29 $";
00896                                           
00897                       00000194            _bios_cvs_version_string:
00898                       00000194            .1:
00899 0194                        24            .ascii	"$Revision: 1.221 $ $Date: 2008/12/07 17:"
00900 01BC                        33            .ascii	"32:29 $"
00901 01C3                        00            .byte	0
00902                                           !BCC_EOS
00903                                           ! 583 static struct {
00904                                           ! 584   Bit16u normal;
00905                                           !BCC_EOS
00906                                           ! 585   Bit16u shift;
00907                                           !BCC_EOS
00908                                           ! 586   Bit16u control;
00909                                           !BCC_EOS
00910                                           ! 587   Bit16u alt;
00911                                           !BCC_EOS
00912                                           ! 588   Bit8u lock_flags;
00913                                           !BCC_EOS
00914                                           ! 589   } scan_to_scanascii[0x58 + 1] = {
00915                       000001C4            _scan_to_scanascii:
00916                                           ! 590       { 0, 0, 0, 0, 0 },
00917 01C4                      0000            .word	0
00918 01C6                      0000            .word	0
00919 01C8                      0000            .word	0
00920 01CA                      0000            .word	0
00921 01CC                        00            .byte	0
00922 01CD                  00000001            .blkb	1
00923                                           ! 591       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00924 01CE                      011B            .word	$11B
00925 01D0                      011B            .word	$11B
00926 01D2                      011B            .word	$11B
00927 01D4                      0100            .word	$100
00928 01D6                        00            .byte	0
00929 01D7                  00000001            .blkb	1
00930                                           ! 592       { 0x0231, 0x0221, 0, 0x7800, 0 },
00931 01D8                      0231            .word	$231
00932 01DA                      0221            .word	$221
00933 01DC                      0000            .word	0
00934 01DE                      7800            .word	$7800
00935 01E0                        00            .byte	0
00936 01E1                  00000001            .blkb	1
00937                                           ! 593       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00938 01E2                      0332            .word	$332
00939 01E4                      0340            .word	$340
00940 01E6                      0300            .word	$300
00941 01E8                      7900            .word	$7900
00942 01EA                        00            .byte	0
00943 01EB                  00000001            .blkb	1
00944                                           ! 594       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00945 01EC                      0433            .word	$433
00946 01EE                      0423            .word	$423
00947 01F0                      0000            .word	0
00948 01F2                      7A00            .word	$7A00
00949 01F4                        00            .byte	0
00950 01F5                  00000001            .blkb	1
00951                                           ! 595       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00952 01F6                      0534            .word	$534
00953 01F8                      0524            .word	$524
00954 01FA                      0000            .word	0
00955 01FC                      7B00            .word	$7B00
00956 01FE                        00            .byte	0
00957 01FF                  00000001            .blkb	1
00958                                           ! 596       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00959 0200                      0635            .word	$635
00960 0202                      0625            .word	$625
00961 0204                      0000            .word	0
00962 0206                      7C00            .word	$7C00
00963 0208                        00            .byte	0
00964 0209                  00000001            .blkb	1
00965                                           ! 597       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00966 020A                      0736            .word	$736
00967 020C                      075E            .word	$75E
00968 020E                      071E            .word	$71E
00969 0210                      7D00            .word	$7D00
00970 0212                        00            .byte	0
00971 0213                  00000001            .blkb	1
00972                                           ! 598       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00973 0214                      0837            .word	$837
00974 0216                      0826            .word	$826
00975 0218                      0000            .word	0
00976 021A                      7E00            .word	$7E00
00977 021C                        00            .byte	0
00978 021D                  00000001            .blkb	1
00979                                           ! 599       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00980 021E                      0938            .word	$938
00981 0220                      092A            .word	$92A
00982 0222                      0000            .word	0
00983 0224                      7F00            .word	$7F00
00984 0226                        00            .byte	0
00985 0227                  00000001            .blkb	1
00986                                           ! 600       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00987 0228                      0A39            .word	$A39
00988 022A                      0A28            .word	$A28
00989 022C                      0000            .word	0
00990 022E                      8000            .word	$8000
00991 0230                        00            .byte	0
00992 0231                  00000001            .blkb	1
00993                                           ! 601       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00994 0232                      0B30            .word	$B30
00995 0234                      0B29            .word	$B29
00996 0236                      0000            .word	0
00997 0238                      8100            .word	$8100
00998 023A                        00            .byte	0
00999 023B                  00000001            .blkb	1
01000                                           ! 602       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01001 023C                      0C2D            .word	$C2D
01002 023E                      0C5F            .word	$C5F
01003 0240                      0C1F            .word	$C1F
01004 0242                      8200            .word	$8200
01005 0244                        00            .byte	0
01006 0245                  00000001            .blkb	1
01007                                           ! 603       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01008 0246                      0D3D            .word	$D3D
01009 0248                      0D2B            .word	$D2B
01010 024A                      0000            .word	0
01011 024C                      8300            .word	$8300
01012 024E                        00            .byte	0
01013 024F                  00000001            .blkb	1
01014                                           ! 604       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01015 0250                      0E08            .word	$E08
01016 0252                      0E08            .word	$E08
01017 0254                      0E7F            .word	$E7F
01018 0256                      0000            .word	0
01019 0258                        00            .byte	0
01020 0259                  00000001            .blkb	1
01021                                           ! 605       { 0x0f09, 0x0f00, 0, 0, 0 },
01022 025A                      0F09            .word	$F09
01023 025C                      0F00            .word	$F00
01024 025E                      0000            .word	0
01025 0260                      0000            .word	0
01026 0262                        00            .byte	0
01027 0263                  00000001            .blkb	1
01028                                           ! 606       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01029 0264                      1071            .word	$1071
01030 0266                      1051            .word	$1051
01031 0268                      1011            .word	$1011
01032 026A                      1000            .word	$1000
01033 026C                        40            .byte	$40
01034 026D                  00000001            .blkb	1
01035                                           ! 607       { 0x1177, 0x1157, 0x1117, 
01036 026E                      1177            .word	$1177
01037 0270                      1157            .word	$1157
01038 0272                      1117            .word	$1117
01039                                           ! 607 0x1100, 0x40 },
01040 0274                      1100            .word	$1100
01041 0276                        40            .byte	$40
01042 0277                  00000001            .blkb	1
01043                                           ! 608       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01044 0278                      1265            .word	$1265
01045 027A                      1245            .word	$1245
01046 027C                      1205            .word	$1205
01047 027E                      1200            .word	$1200
01048 0280                        40            .byte	$40
01049 0281                  00000001            .blkb	1
01050                                           ! 609       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01051 0282                      1372            .word	$1372
01052 0284                      1352            .word	$1352
01053 0286                      1312            .word	$1312
01054 0288                      1300            .word	$1300
01055 028A                        40            .byte	$40
01056 028B                  00000001            .blkb	1
01057                                           ! 610       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01058 028C                      1474            .word	$1474
01059 028E                      1454            .word	$1454
01060 0290                      1414            .word	$1414
01061 0292                      1400            .word	$1400
01062 0294                        40            .byte	$40
01063 0295                  00000001            .blkb	1
01064                                           ! 611       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01065 0296                      1579            .word	$1579
01066 0298                      1559            .word	$1559
01067 029A                      1519            .word	$1519
01068 029C                      1500            .word	$1500
01069 029E                        40            .byte	$40
01070 029F                  00000001            .blkb	1
01071                                           ! 612       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01072 02A0                      1675            .word	$1675
01073 02A2                      1655            .word	$1655
01074 02A4                      1615            .word	$1615
01075 02A6                      1600            .word	$1600
01076 02A8                        40            .byte	$40
01077 02A9                  00000001            .blkb	1
01078                                           ! 613       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01079 02AA                      1769            .word	$1769
01080 02AC                      1749            .word	$1749
01081 02AE                      1709            .word	$1709
01082 02B0                      1700            .word	$1700
01083 02B2                        40            .byte	$40
01084 02B3                  00000001            .blkb	1
01085                                           ! 614       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01086 02B4                      186F            .word	$186F
01087 02B6                      184F            .word	$184F
01088 02B8                      180F            .word	$180F
01089 02BA                      1800            .word	$1800
01090 02BC                        40            .byte	$40
01091 02BD                  00000001            .blkb	1
01092                                           ! 615       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01093 02BE                      1970            .word	$1970
01094 02C0                      1950            .word	$1950
01095 02C2                      1910            .word	$1910
01096 02C4                      1900            .word	$1900
01097 02C6                        40            .byte	$40
01098 02C7                  00000001            .blkb	1
01099                                           ! 616       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01100 02C8                      1A5B            .word	$1A5B
01101 02CA                      1A7B            .word	$1A7B
01102 02CC                      1A1B            .word	$1A1B
01103 02CE                      0000            .word	0
01104 02D0                        00            .byte	0
01105 02D1                  00000001            .blkb	1
01106                                           ! 617       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01107 02D2                      1B5D            .word	$1B5D
01108 02D4                      1B7D            .word	$1B7D
01109 02D6                      1B1D            .word	$1B1D
01110 02D8                      0000            .word	0
01111 02DA                        00            .byte	0
01112 02DB                  00000001            .blkb	1
01113                                           ! 618       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01114 02DC                      1C0D            .word	$1C0D
01115 02DE                      1C0D            .word	$1C0D
01116 02E0                      1C0A            .word	$1C0A
01117 02E2                      0000            .word	0
01118 02E4                        00            .byte	0
01119 02E5                  00000001            .blkb	1
01120                                           ! 619       { 0, 0, 0, 0, 0 },
01121 02E6                      0000            .word	0
01122 02E8                      0000            .word	0
01123 02EA                      0000            .word	0
01124 02EC                      0000            .word	0
01125 02EE                        00            .byte	0
01126 02EF                  00000001            .blkb	1
01127                                           ! 620       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01128 02F0                      1E61            .word	$1E61
01129 02F2                      1E41            .word	$1E41
01130 02F4                      1E01            .word	$1E01
01131 02F6                      1E00            .word	$1E00
01132 02F8                        40            .byte	$40
01133 02F9                  00000001            .blkb	1
01134                                           ! 621       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01135 02FA                      1F73            .word	$1F73
01136 02FC                      1F53            .word	$1F53
01137 02FE                      1F13            .word	$1F13
01138 0300                      1F00            .word	$1F00
01139 0302                        40            .byte	$40
01140 0303                  00000001            .blkb	1
01141                                           ! 622       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01142 0304                      2064            .word	$2064
01143 0306                      2044            .word	$2044
01144 0308                      2004            .word	$2004
01145 030A                      2000            .word	$2000
01146 030C                        40            .byte	$40
01147 030D                  00000001            .blkb	1
01148                                           ! 623       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01149 030E                      2166            .word	$2166
01150 0310                      2146            .word	$2146
01151 0312                      2106            .word	$2106
01152 0314                      2100            .word	$2100
01153 0316                        40            .byte	$40
01154 0317                  00000001            .blkb	1
01155                                           ! 624       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01156 0318                      2267            .word	$2267
01157 031A                      2247            .word	$2247
01158 031C                      2207            .word	$2207
01159 031E                      2200            .word	$2200
01160 0320                        40            .byte	$40
01161 0321                  00000001            .blkb	1
01162                                           ! 625       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01163 0322                      2368            .word	$2368
01164 0324                      2348            .word	$2348
01165 0326                      2308            .word	$2308
01166 0328                      2300            .word	$2300
01167 032A                        40            .byte	$40
01168 032B                  00000001            .blkb	1
01169                                           ! 626       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01170 032C                      246A            .word	$246A
01171 032E                      244A            .word	$244A
01172 0330                      240A            .word	$240A
01173 0332                      2400            .word	$2400
01174 0334                        40            .byte	$40
01175 0335                  00000001            .blkb	1
01176                                           ! 627       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01177 0336                      256B            .word	$256B
01178 0338                      254B            .word	$254B
01179 033A                      250B            .word	$250B
01180 033C                      2500            .word	$2500
01181 033E                        40            .byte	$40
01182 033F                  00000001            .blkb	1
01183                                           ! 628       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01184 0340                      266C            .word	$266C
01185 0342                      264C            .word	$264C
01186 0344                      260C            .word	$260C
01187 0346                      2600            .word	$2600
01188 0348                        40            .byte	$40
01189 0349                  00000001            .blkb	1
01190                                           ! 629       { 0x273b, 0x273a, 0, 0, 0 },
01191 034A                      273B            .word	$273B
01192 034C                      273A            .word	$273A
01193 034E                      0000            .word	0
01194 0350                      0000            .word	0
01195 0352                        00            .byte	0
01196 0353                  00000001            .blkb	1
01197                                           ! 630       { 0x2827, 0x2822, 0, 0, 0 },
01198 0354                      2827            .word	$2827
01199 0356                      2822            .word	$2822
01200 0358                      0000            .word	0
01201 035A                      0000            .word	0
01202 035C                        00            .byte	0
01203 035D                  00000001            .blkb	1
01204                                           ! 631       { 0x2960, 0x297e, 0, 0, 0 },
01205 035E                      2960            .word	$2960
01206 0360                      297E            .word	$297E
01207 0362                      0000            .word	0
01208 0364                      0000            .word	0
01209 0366                        00            .byte	0
01210 0367                  00000001            .blkb	1
01211                                           ! 632       { 0, 0, 0, 0, 0 },
01212 0368                      0000            .word	0
01213 036A                      0000            .word	0
01214 036C                      0000            .word	0
01215 036E                      0000            .word	0
01216 0370                        00            .byte	0
01217 0371                  00000001            .blkb	1
01218                                           ! 633       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01219 0372                      2B5C            .word	$2B5C
01220 0374                      2B7C            .word	$2B7C
01221 0376                      2B1C            .word	$2B1C
01222 0378                      0000            .word	0
01223 037A                        00            .byte	0
01224 037B                  00000001            .blkb	1
01225                                           ! 634       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01226 037C                      2C7A            .word	$2C7A
01227 037E                      2C5A            .word	$2C5A
01228 0380                      2C1A            .word	$2C1A
01229 0382                      2C00            .word	$2C00
01230 0384                        40            .byte	$40
01231 0385                  00000001            .blkb	1
01232                                           ! 635       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01233 0386                      2D78            .word	$2D78
01234 0388                      2D58            .word	$2D58
01235 038A                      2D18            .word	$2D18
01236 038C                      2D00            .word	$2D00
01237 038E                        40            .byte	$40
01238 038F                  00000001            .blkb	1
01239                                           ! 636       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01240 0390                      2E63            .word	$2E63
01241 0392                      2E43            .word	$2E43
01242 0394                      2E03            .word	$2E03
01243 0396                      2E00            .word	$2E00
01244 0398                        40            .byte	$40
01245 0399                  00000001            .blkb	1
01246                                           ! 637       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01247 039A                      2F76            .word	$2F76
01248 039C                      2F56            .word	$2F56
01249 039E                      2F16            .word	$2F16
01250 03A0                      2F00            .word	$2F00
01251 03A2                        40            .byte	$40
01252 03A3                  00000001            .blkb	1
01253                                           ! 638       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01254 03A4                      3062            .word	$3062
01255 03A6                      3042            .word	$3042
01256 03A8                      3002            .word	$3002
01257 03AA                      3000            .word	$3000
01258 03AC                        40            .byte	$40
01259 03AD                  00000001            .blkb	1
01260                                           ! 639       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01261 03AE                      316E            .word	$316E
01262 03B0                      314E            .word	$314E
01263 03B2                      310E            .word	$310E
01264 03B4                      3100            .word	$3100
01265 03B6                        40            .byte	$40
01266 03B7                  00000001            .blkb	1
01267                                           ! 640       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01268 03B8                      326D            .word	$326D
01269 03BA                      324D            .word	$324D
01270 03BC                      320D            .word	$320D
01271 03BE                      3200            .word	$3200
01272 03C0                        40            .byte	$40
01273 03C1                  00000001            .blkb	1
01274                                           ! 641       { 0x332c, 0x333c, 0, 0, 0 },
01275 03C2                      332C            .word	$332C
01276 03C4                      333C            .word	$333C
01277 03C6                      0000            .word	0
01278 03C8                      0000            .word	0
01279 03CA                        00            .byte	0
01280 03CB                  00000001            .blkb	1
01281                                           ! 642       { 0x342e, 0x343e, 0, 0, 0 },
01282 03CC                      342E            .word	$342E
01283 03CE                      343E            .word	$343E
01284 03D0                      0000            .word	0
01285 03D2                      0000            .word	0
01286 03D4                        00            .byte	0
01287 03D5                  00000001            .blkb	1
01288                                           ! 643       { 0x352f, 0x353f, 0, 0, 0 },
01289 03D6                      352F            .word	$352F
01290 03D8                      353F            .word	$353F
01291 03DA                      0000            .word	0
01292 03DC                      0000            .word	0
01293 03DE                        00            .byte	0
01294 03DF                  00000001            .blkb	1
01295                                           ! 644       { 0, 0, 0, 0, 0 },
01296 03E0                      0000            .word	0
01297 03E2                      0000            .word	0
01298 03E4                      0000            .word	0
01299 03E6                      0000            .word	0
01300 03E8                        00            .byte	0
01301 03E9                  00000001            .blkb	1
01302                                           ! 645       { 0x372a, 0x372a, 0, 0, 0 },
01303 03EA                      372A            .word	$372A
01304 03EC                      372A            .word	$372A
01305 03EE                      0000            .word	0
01306 03F0                      0000            .word	0
01307 03F2                        00            .byte	0
01308 03F3                  00000001            .blkb	1
01309                                           ! 646       { 0, 0, 0, 0, 0 },
01310 03F4                      0000            .word	0
01311 03F6                      0000            .word	0
01312 03F8                      0000            .word	0
01313 03FA                      0000            .word	0
01314 03FC                        00            .byte	0
01315 03FD                  00000001            .blkb	1
01316                                           ! 647       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01317 03FE                      3920            .word	$3920
01318 0400                      3920            .word	$3920
01319 0402                      3920            .word	$3920
01320 0404                      3920            .word	$3920
01321 0406                        00            .byte	0
01322 0407                  00000001            .blkb	1
01323                                           ! 648       { 0, 0, 0, 0, 0 },
01324 0408                      0000            .word	0
01325 040A                      0000            .word	0
01326 040C                      0000            .word	0
01327 040E                      0000            .word	0
01328 0410                        00            .byte	0
01329 0411                  00000001            .blkb	1
01330                                           ! 649       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01331 0412                      3B00            .word	$3B00
01332 0414                      5400            .word	$5400
01333 0416                      5E00            .word	$5E00
01334 0418                      6800            .word	$6800
01335 041A                        00            .byte	0
01336 041B                  00000001            .blkb	1
01337                                           ! 650       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01338 041C                      3C00            .word	$3C00
01339 041E                      5500            .word	$5500
01340 0420                      5F00            .word	$5F00
01341 0422                      6900            .word	$6900
01342 0424                        00            .byte	0
01343 0425                  00000001            .blkb	1
01344                                           ! 651       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01345 0426                      3D00            .word	$3D00
01346 0428                      5600            .word	$5600
01347 042A                      6000            .word	$6000
01348 042C                      6A00            .word	$6A00
01349 042E                        00            .byte	0
01350 042F                  00000001            .blkb	1
01351                                           ! 652       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01352 0430                      3E00            .word	$3E00
01353 0432                      5700            .word	$5700
01354 0434                      6100            .word	$6100
01355 0436                      6B00            .word	$6B00
01356 0438                        00            .byte	0
01357 0439                  00000001            .blkb	1
01358                                           ! 653       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01359 043A                      3F00            .word	$3F00
01360 043C                      5800            .word	$5800
01361 043E                      6200            .word	$6200
01362 0440                      6C00            .word	$6C00
01363 0442                        00            .byte	0
01364 0443                  00000001            .blkb	1
01365                                           ! 654       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01366 0444                      4000            .word	$4000
01367 0446                      5900            .word	$5900
01368 0448                      6300            .word	$6300
01369 044A                      6D00            .word	$6D00
01370 044C                        00            .byte	0
01371 044D                  00000001            .blkb	1
01372                                           ! 655       { 0x4100, 0x5a00, 0x6400, 0x6
01373 044E                      4100            .word	$4100
01374 0450                      5A00            .word	$5A00
01375 0452                      6400            .word	$6400
01376                                           ! 655 e00, 0 },
01377 0454                      6E00            .word	$6E00
01378 0456                        00            .byte	0
01379 0457                  00000001            .blkb	1
01380                                           ! 656       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01381 0458                      4200            .word	$4200
01382 045A                      5B00            .word	$5B00
01383 045C                      6500            .word	$6500
01384 045E                      6F00            .word	$6F00
01385 0460                        00            .byte	0
01386 0461                  00000001            .blkb	1
01387                                           ! 657       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01388 0462                      4300            .word	$4300
01389 0464                      5C00            .word	$5C00
01390 0466                      6600            .word	$6600
01391 0468                      7000            .word	$7000
01392 046A                        00            .byte	0
01393 046B                  00000001            .blkb	1
01394                                           ! 658       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01395 046C                      4400            .word	$4400
01396 046E                      5D00            .word	$5D00
01397 0470                      6700            .word	$6700
01398 0472                      7100            .word	$7100
01399 0474                        00            .byte	0
01400 0475                  00000001            .blkb	1
01401                                           ! 659       { 0, 0, 0, 0, 0 },
01402 0476                      0000            .word	0
01403 0478                      0000            .word	0
01404 047A                      0000            .word	0
01405 047C                      0000            .word	0
01406 047E                        00            .byte	0
01407 047F                  00000001            .blkb	1
01408                                           ! 660       { 0, 0, 0, 0, 0 },
01409 0480                      0000            .word	0
01410 0482                      0000            .word	0
01411 0484                      0000            .word	0
01412 0486                      0000            .word	0
01413 0488                        00            .byte	0
01414 0489                  00000001            .blkb	1
01415                                           ! 661       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01416 048A                      4700            .word	$4700
01417 048C                      4737            .word	$4737
01418 048E                      7700            .word	$7700
01419 0490                      0000            .word	0
01420 0492                        20            .byte	$20
01421 0493                  00000001            .blkb	1
01422                                           ! 662       { 0x4800, 0x4838, 0, 0, 0x20 },
01423 0494                      4800            .word	$4800
01424 0496                      4838            .word	$4838
01425 0498                      0000            .word	0
01426 049A                      0000            .word	0
01427 049C                        20            .byte	$20
01428 049D                  00000001            .blkb	1
01429                                           ! 663       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01430 049E                      4900            .word	$4900
01431 04A0                      4939            .word	$4939
01432 04A2                      8400            .word	$8400
01433 04A4                      0000            .word	0
01434 04A6                        20            .byte	$20
01435 04A7                  00000001            .blkb	1
01436                                           ! 664       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01437 04A8                      4A2D            .word	$4A2D
01438 04AA                      4A2D            .word	$4A2D
01439 04AC                      0000            .word	0
01440 04AE                      0000            .word	0
01441 04B0                        00            .byte	0
01442 04B1                  00000001            .blkb	1
01443                                           ! 665       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01444 04B2                      4B00            .word	$4B00
01445 04B4                      4B34            .word	$4B34
01446 04B6                      7300            .word	$7300
01447 04B8                      0000            .word	0
01448 04BA                        20            .byte	$20
01449 04BB                  00000001            .blkb	1
01450                                           ! 666       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01451 04BC                      4C00            .word	$4C00
01452 04BE                      4C35            .word	$4C35
01453 04C0                      0000            .word	0
01454 04C2                      0000            .word	0
01455 04C4                        20            .byte	$20
01456 04C5                  00000001            .blkb	1
01457                                           ! 667       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01458 04C6                      4D00            .word	$4D00
01459 04C8                      4D36            .word	$4D36
01460 04CA                      7400            .word	$7400
01461 04CC                      0000            .word	0
01462 04CE                        20            .byte	$20
01463 04CF                  00000001            .blkb	1
01464                                           ! 668       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01465 04D0                      4E2B            .word	$4E2B
01466 04D2                      4E2B            .word	$4E2B
01467 04D4                      0000            .word	0
01468 04D6                      0000            .word	0
01469 04D8                        00            .byte	0
01470 04D9                  00000001            .blkb	1
01471                                           ! 669       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01472 04DA                      4F00            .word	$4F00
01473 04DC                      4F31            .word	$4F31
01474 04DE                      7500            .word	$7500
01475 04E0                      0000            .word	0
01476 04E2                        20            .byte	$20
01477 04E3                  00000001            .blkb	1
01478                                           ! 670       { 0x5000, 0x5032, 0, 0, 0x20 },
01479 04E4                      5000            .word	$5000
01480 04E6                      5032            .word	$5032
01481 04E8                      0000            .word	0
01482 04EA                      0000            .word	0
01483 04EC                        20            .byte	$20
01484 04ED                  00000001            .blkb	1
01485                                           ! 671       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01486 04EE                      5100            .word	$5100
01487 04F0                      5133            .word	$5133
01488 04F2                      7600            .word	$7600
01489 04F4                      0000            .word	0
01490 04F6                        20            .byte	$20
01491 04F7                  00000001            .blkb	1
01492                                           ! 672       { 0x5200, 0x5230, 0, 0, 0x20 },
01493 04F8                      5200            .word	$5200
01494 04FA                      5230            .word	$5230
01495 04FC                      0000            .word	0
01496 04FE                      0000            .word	0
01497 0500                        20            .byte	$20
01498 0501                  00000001            .blkb	1
01499                                           ! 673       { 0x5300, 0x532e, 0, 0, 0x20 },
01500 0502                      5300            .word	$5300
01501 0504                      532E            .word	$532E
01502 0506                      0000            .word	0
01503 0508                      0000            .word	0
01504 050A                        20            .byte	$20
01505 050B                  00000001            .blkb	1
01506                                           ! 674       { 0, 0, 0, 0, 0 },
01507 050C                      0000            .word	0
01508 050E                      0000            .word	0
01509 0510                      0000            .word	0
01510 0512                      0000            .word	0
01511 0514                        00            .byte	0
01512 0515                  00000001            .blkb	1
01513                                           ! 675       { 0, 0, 0, 0, 0 },
01514 0516                      0000            .word	0
01515 0518                      0000            .word	0
01516 051A                      0000            .word	0
01517 051C                      0000            .word	0
01518 051E                        00            .byte	0
01519 051F                  00000001            .blkb	1
01520                                           ! 676       { 0x565c, 0x567c, 0, 0, 0 },
01521 0520                      565C            .word	$565C
01522 0522                      567C            .word	$567C
01523 0524                      0000            .word	0
01524 0526                      0000            .word	0
01525 0528                        00            .byte	0
01526 0529                  00000001            .blkb	1
01527                                           ! 677       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01528 052A                      8500            .word	$8500
01529 052C                      8700            .word	$8700
01530 052E                      8900            .word	$8900
01531 0530                      8B00            .word	$8B00
01532 0532                        00            .byte	0
01533 0533                  00000001            .blkb	1
01534                                           ! 678       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01535 0534                      8600            .word	$8600
01536 0536                      8800            .word	$8800
01537 0538                      8A00            .word	$8A00
01538 053A                      8C00            .word	$8C00
01539 053C                        00            .byte	0
01540 053D                  00000001            .blkb	1
01541                                           ! 679       };
01542                                           !BCC_EOS
01543                                           ! 680   Bit8u
01544                                           ! 681 inb(port)
01545                                           ! 682   Bit16u port;
01546                                           
01547                                           export	_inb
01548                       0000053E            _inb:
01549                                           !BCC_EOS
01550                                           ! 683 {
01551                                           ! 684 #asm
01552                                           !BCC_ASM
01553                       00000002            _inb.port	set	2
01554 053E           55                           push bp
01555 053F           89E5                         mov bp, sp
01556 0541           52                             push dx
01557 0542           8B56         04                mov dx, 4[bp]
01558 0545           EC                             in al, dx
01559 0546           5A                             pop dx
01560 0547           5D                           pop bp
01561                                           ! 692 endasm
01562                                           !BCC_ENDASM
01563                                           ! 693 }
01564 0548           C3                         ret
01565                                           ! 694   Bit16u
01566                                           ! 695 inw(port)
01567                                           ! 696   Bit16u port;
01568                                           export	_inw
01569                       00000549            _inw:
01570                                           !BCC_EOS
01571                                           ! 697 {
01572                                           ! 698 #asm
01573                                           !BCC_ASM
01574                       00000002            _inw.port	set	2
01575 0549           55                           push bp
01576 054A           89E5                         mov bp, sp
01577 054C           52                             push dx
01578 054D           8B56         04                mov dx, 4[bp]
01579 0550           ED                             in ax, dx
01580 0551           5A                             pop dx
01581 0552           5D                           pop bp
01582                                           ! 706 endasm
01583                                           !BCC_ENDASM
01584                                           ! 707 }
01585 0553           C3                         ret
01586                                           ! 708   void
01587                                           ! 709 outb(port, val)
01588                                           ! 710   Bit16u port;
01589                                           export	_outb
01590                       00000554            _outb:
01591                                           !BCC_EOS
01592                                           ! 711   Bit8u val;
01593                                           !BCC_EOS
01594                                           ! 712 {
01595                                           ! 713 #asm
01596                                           !BCC_ASM
01597                       00000004            _outb.val	set	4
01598                       00000002            _outb.port	set	2
01599 0554           55                           push bp
01600 0555           89E5                         mov bp, sp
01601 0557           50                             push ax
01602 0558           52                             push dx
01603 0559           8B56         04                mov dx, 4[bp]
01604 055C           8A46         06                mov al, 6[bp]
01605 055F           EE                             out dx, al
01606 0560           5A                             pop dx
01607 0561           58                             pop ax
01608 0562           5D                           pop bp
01609                                           ! 724 endasm
01610                                           !BCC_ENDASM
01611                                           ! 725 }
01612 0563           C3                         ret
01613                                           ! 726   void
01614                                           ! 727 outw(port, val)
01615                                           ! 728   Bit16u port;
01616                                           export	_outw
01617                       00000564            _outw:
01618                                           !BCC_EOS
01619                                           ! 729   Bit16u val;
01620                                           !BCC_EOS
01621                                           ! 730 {
01622                                           ! 731 #asm
01623                                           !BCC_ASM
01624                       00000004            _outw.val	set	4
01625                       00000002            _outw.port	set	2
01626 0564           55                           push bp
01627 0565           89E5                         mov bp, sp
01628 0567           50                             push ax
01629 0568           52                             push dx
01630 0569           8B56         04                mov dx, 4[bp]
01631 056C           8B46         06                mov ax, 6[bp]
01632 056F           EF                             out dx, ax
01633 0570           5A                             pop dx
01634 0571           58                             pop ax
01635 0572           5D                           pop bp
01636                                           ! 742 endasm
01637                                           !BCC_ENDASM
01638                                           ! 743 }
01639 0573           C3                         ret
01640                                           ! 744   void
01641                                           ! 745 outb_cmos(cmos_reg, val)
01642                                           ! 746   Bit8u cmos_reg;
01643                                           export	_outb_cmos
01644                       00000574            _outb_cmos:
01645                                           !BCC_EOS
01646                                           ! 747   Bit8u val;
01647                                           !BCC_EOS
01648                                           ! 748 {
01649                                           ! 749 #asm
01650                                           !BCC_ASM
01651                       00000002            _outb_cmos.cmos_reg	set	2
01652                       00000004            _outb_cmos.val	set	4
01653 0574           55                           push bp
01654 0575           89E5                         mov bp, sp
01655 0577           8A46         04                mov al, 4[bp] ;; cmos_reg
01656 057A           E6                     70      out 0x70, al
01657 057C           8A46         06                mov al, 6[bp] ;; val
01658 057F           E6                     71      out 0x71, al
01659 0581           5D                           pop bp
01660                                           ! 757 endasm
01661                                           !BCC_ENDASM
01662                                           ! 758 }
01663 0582           C3                         ret
01664                                           ! 759   Bit8u
01665                                           ! 760 inb_cmos(cmos_reg)
01666                                           ! 761   Bit8u cmos_reg;
01667                                           export	_inb_cmos
01668                       00000583            _inb_cmos:
01669                                           !BCC_EOS
01670                                           ! 762 {
01671                                           ! 763 #asm
01672                                           !BCC_ASM
01673                       00000002            _inb_cmos.cmos_reg	set	2
01674 0583           55                           push bp
01675 0584           89E5                         mov bp, sp
01676 0586           8A46         04                mov al, 4[bp] ;; cmos_reg
01677 0589           E6                     70      out 0x70, al
01678 058B           E4                     71      in al, 0x71
01679 058D           5D                           pop bp
01680                                           ! 770 endasm
01681                                           !BCC_ENDASM
01682                                           ! 771 }
01683 058E           C3                         ret
01684                                           ! 772   void
01685                                           ! 773 init_rtc()
01686                                           ! 774 {
01687                                           export	_init_rtc
01688                       0000058F            _init_rtc:
01689                                           ! 775   outb_cmos(0x0a, 0x26);
01690 058F           55                         push	bp
01691 0590           89E5                       mov	bp,sp
01692                                           ! Debug: list int = const $26 (used reg = )
01693 0592           B8                   0026  mov	ax,*$26
01694 0595           50                         push	ax
01695                                           ! Debug: list int = const $A (used reg = )
01696 0596           B8                   000A  mov	ax,*$A
01697 0599           50                         push	ax
01698                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01699 059A           E8         FFD7            call	_outb_cmos
01700 059D           89EC                       mov	sp,bp
01701                                           !BCC_EOS
01702                                           ! 776   outb_cmos(0x0b, 0x02);
01703                                           ! Debug: list int = const 2 (used reg = )
01704 059F           B8                   0002  mov	ax,*2
01705 05A2           50                         push	ax
01706                                           ! Debug: list int = const $B (used reg = )
01707 05A3           B8                   000B  mov	ax,*$B
01708 05A6           50                         push	ax
01709                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01710 05A7           E8         FFCA            call	_outb_cmos
01711 05AA           89EC                       mov	sp,bp
01712                                           !BCC_EOS
01713                                           ! 777   inb_cmos(0x0c);
01714                                           ! Debug: list int = const $C (used reg = )
01715 05AC           B8                   000C  mov	ax,*$C
01716 05AF           50                         push	ax
01717                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01718 05B0           E8         FFD0            call	_inb_cmos
01719 05B3           89EC                       mov	sp,bp
01720                                           !BCC_EOS
01721                                           ! 778   inb_cmos(0x0d);
01722                                           ! Debug: list int = const $D (used reg = )
01723 05B5           B8                   000D  mov	ax,*$D
01724 05B8           50                         push	ax
01725                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01726 05B9           E8         FFC7            call	_inb_cmos
01727 05BC           89EC                       mov	sp,bp
01728                                           !BCC_EOS
01729                                           ! 779 }
01730 05BE           5D                         pop	bp
01731 05BF           C3                         ret
01732                                           ! 780   bx_bool
01733                                           ! 781 rtc_u
01734                                           ! 781 pdating()
01735                                           ! 782 {
01736                                           export	_rtc_updating
01737                       000005C0            _rtc_updating:
01738                                           ! 783   Bit16u count;
01739                                           !BCC_EOS
01740                                           ! 784   count = 25000;
01741 05C0           55                         push	bp
01742 05C1           89E5                       mov	bp,sp
01743 05C3           4C                         dec	sp
01744 05C4           4C                         dec	sp
01745                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01746 05C5           B8                   61A8  mov	ax,#$61A8
01747 05C8           8946         FE            mov	-2[bp],ax
01748                                           !BCC_EOS
01749                                           ! 785   while (--count != 0) {
01750 05CB           EB           15            jmp .3
01751                       000005CD            .4:
01752                                           ! 786     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01753                                           ! Debug: list int = const $A (used reg = )
01754 05CD           B8                   000A  mov	ax,*$A
01755 05D0           50                         push	ax
01756                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01757 05D1           E8         FFAF            call	_inb_cmos
01758 05D4           44                         inc	sp
01759 05D5           44                         inc	sp
01760                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01761 05D6           24                     80  and	al,#$80
01762                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01763 05D8           84C0                       test	al,al
01764 05DA           75           06            jne 	.5
01765                       000005DC            .6:
01766                                           ! 787       return(0);
01767 05DC           31C0                       xor	ax,ax
01768 05DE           89EC                       mov	sp,bp
01769 05E0           5D                         pop	bp
01770 05E1           C3                         ret
01771                                           !BCC_EOS
01772                                           ! 788     }
01773                       000005E2            .5:
01774                                           ! 789   return(1);
01775                       000005E2            .3:
01776                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01777 05E2           8B46         FE            mov	ax,-2[bp]
01778 05E5           48                         dec	ax
01779 05E6           8946         FE            mov	-2[bp],ax
01780                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01781 05E9           85C0                       test	ax,ax
01782 05EB           75           E0            jne	.4
01783                       000005ED            .7:
01784                       000005ED            .2:
01785 05ED           B8                   0001  mov	ax,*1
01786 05F0           89EC                       mov	sp,bp
01787 05F2           5D                         pop	bp
01788 05F3           C3                         ret
01789                                           !BCC_EOS
01790                                           ! 790 }
01791                                           ! 791   Bit8u
01792                                           ! 792 read_byte(seg, offset)
01793                                           ! 793   Bit16u seg;
01794                                           export	_read_byte
01795                       000005F4            _read_byte:
01796                                           !BCC_EOS
01797                                           ! 794   Bit16u offset;
01798                                           !BCC_EOS
01799                                           ! 795 {
01800                                           ! 796 #asm
01801                                           !BCC_ASM
01802                       00000002            _read_byte.seg	set	2
01803                       00000004            _read_byte.offset	set	4
01804 05F4           55                           push bp
01805 05F5           89E5                         mov bp, sp
01806 05F7           53                             push bx
01807 05F8           1E                             push ds
01808 05F9           8B46         04                mov ax, 4[bp] ; segment
01809 05FC           8ED8                           mov ds, ax
01810 05FE           8B5E         06                mov bx, 6[bp] ; offset
01811 0601           8A07                           mov al, [bx]
01812                                               ;; al = return value (byte)
01813 0603           1F                             pop ds
01814 0604           5B                             pop bx
01815 0605           5D                           pop bp
01816                                           ! 809 endasm
01817                                           !BCC_ENDASM
01818                                           ! 810 }
01819 0606           C3                         ret
01820                                           ! 811   Bit16u
01821                                           ! 812 read_word(seg, offset)
01822                                           ! 813   Bit16u seg;
01823                                           export	_read_word
01824                       00000607            _read_word:
01825                                           !BCC_EOS
01826                                           ! 814   Bit16u offset;
01827                                           !BCC_EOS
01828                                           ! 815 {
01829                                           ! 816 #asm
01830                                           !BCC_ASM
01831                       00000002            _read_word.seg	set	2
01832                       00000004            _read_word.offset	set	4
01833 0607           55                           push bp
01834 0608           89E5                         mov bp, sp
01835 060A           53                             push bx
01836 060B           1E                             push ds
01837 060C           8B46         04                mov ax, 4[bp] ; segment
01838 060F           8ED8                           mov ds, ax
01839 0611           8B5E         06                mov bx, 6[bp] ; offset
01840 0614           8B07                           mov ax, [bx]
01841                                               ;; ax = return value (word)
01842 0616           1F                             pop ds
01843 0617           5B                             pop bx
01844 0618           5D                           pop bp
01845                                           ! 829 endasm
01846                                           !BCC_ENDASM
01847                                           ! 830 }
01848 0619           C3                         ret
01849                                           ! 831   void
01850                                           ! 832 write_byte(seg, offset, data)
01851                                           ! 833   Bit16u seg;
01852                                           export	_write_byte
01853                       0000061A            _write_byte:
01854                                           !BCC_EOS
01855                                           ! 834   Bit16u offset;
01856                                           !BCC_EOS
01857                                           ! 835   Bit8u data;
01858                                           !BCC_EOS
01859                                           ! 836 {
01860                                           ! 837 #asm
01861                                           !BCC_ASM
01862                       00000002            _write_byte.seg	set	2
01863                       00000006            _write_byte.data	set	6
01864                       00000004            _write_byte.offset	set	4
01865 061A           55                           push bp
01866 061B           89E5                         mov bp, sp
01867 061D           50                             push ax
01868 061E           53                             push bx
01869 061F           1E                             push ds
01870 0620           8B46         04                mov ax, 4[bp] ; segment
01871 0623           8ED8                           mov ds, ax
01872 0625           8B5E         06                mov bx, 6[bp] ; offset
01873 0628           8A46         08                mov al, 8[bp] ; data byte
01874 062B           8807                           mov [bx], al ; write data byte
01875 062D           1F                             pop ds
01876 062E           5B                             pop bx
01877 062F           58                             pop ax
01878 0630           5D                           pop bp
01879                                           ! 852 endasm
01880                                           !BCC_ENDASM
01881                                           ! 853 }
01882 0631           C3                         ret
01883                                           ! 854   void
01884                                           ! 855 write_word(seg, offset, data)
01885                                           ! 856   Bit16u seg;
01886                                           export	_write_word
01887                       00000632            _write_word:
01888                                           !BCC_EOS
01889                                           ! 857   Bit16u offset;
01890                                           !BCC_EOS
01891                                           ! 858   Bit16u data;
01892                                           !BCC_EOS
01893                                           ! 859 {
01894                                           ! 860 #asm
01895                                           !BCC_ASM
01896                       00000002            _write_word.seg	set	2
01897                       00000006            _write_word.data	set	6
01898                       00000004            _write_word.offset	set	4
01899 0632           55                           push bp
01900 0633           89E5                         mov bp, sp
01901 0635           50                             push ax
01902 0636           53                             push bx
01903 0637           1E                             push ds
01904 0638           8B46         04                mov ax, 4[bp] ; segment
01905 063B           8ED8                           mov ds, ax
01906 063D           8B5E         06                mov bx, 6[bp] ; offset
01907 0640           8B46         08                mov ax, 8[bp] ; data word
01908 0643           8907                           mov [bx], ax ; write data word
01909 0645           1F                             pop ds
01910 0646           5B                             pop bx
01911 0647           58                             pop ax
01912 0648           5D                           pop bp
01913                                           ! 875 endasm
01914                                           !BCC_ENDASM
01915                                           ! 876 }
01916 0649           C3                         ret
01917                                           ! 877   Bit16u
01918                                           ! 878 get_CS()
01919                                           ! 879 {
01920                                           export	_get_CS
01921                       0000064A            _get_CS:
01922                                           ! 880 #asm
01923                                           !BCC_ASM
01924 064A           8CC8                         mov ax, cs
01925                                           ! 882 endasm
01926                                           !BCC_ENDASM
01927                                           ! 883 }
01928 064C           C3                         ret
01929                                           ! 884   Bit16u
01930                                           ! 885 get_SS()
01931                                           ! 886 {
01932                                           export	_get_SS
01933                       0000064D            _get_SS:
01934                                           ! 887 #asm
01935                                           !BCC_ASM
01936 064D           8CD0                         mov ax, ss
01937                                           ! 889 endasm
01938                                           !BCC_ENDASM
01939                                           ! 890 }
01940 064F           C3                         ret
01941                                           ! 891 void
01942                                           ! 892 fixup_base_mem_in_k()
01943                                           ! 893 {
01944                                           export	_fixup_base_mem_in_k
01945                       00000650            _fixup_base_mem_in_k:
01946                                           ! 894   Bit32u base_mem = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 8);
01947 0650           55                         push	bp
01948 0651           89E5                       mov	bp,sp
01949 0653           83C4                   FC  add	sp,*-4
01950                                           ! Debug: list int = const $10 (used reg = )
01951 0656           B8                   0010  mov	ax,*$10
01952 0659           50                         push	ax
01953                                           ! Debug: list unsigned short = const $EA10 (used reg = )
01954 065A           B8                   EA10  mov	ax,#$EA10
01955 065D           50                         push	ax
01956                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
01957 065E           E8         FA22            call	_read_dword
01958 0661           89D3                       mov	bx,dx
01959 0663           83C4                   04  add	sp,*4
01960                                           ! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+6-6] (used reg = )
01961 0666           8946         FC            mov	-4[bp],ax
01962 0669           895E         FE            mov	-2[bp],bx
01963                                           !BCC_EOS
01964                                           ! 895   write_word(0x40, 0x13, base_mem >> 10);
01965                                           ! Debug: sr int = const $A to unsigned long base_mem = [S+6-6] (used reg = )
01966 066C           8B46         FC            mov	ax,-4[bp]
01967 066F           8B5E         FE            mov	bx,-2[bp]
01968 0672           88E0                       mov	al,ah
01969 0674           88DC                       mov	ah,bl
01970 0676           88FB                       mov	bl,bh
01971 0678           28FF                       sub	bh,bh
01972 067A           BF                   0002  mov	di,*2
01973 067D           E8         FAA9            call	lsrul
01974                                           ! Debug: list unsigned long = bx+0 (used reg = )
01975 0680           53                         push	bx
01976 0681           50                         push	ax
01977                                           ! Debug: list int = const $13 (used reg = )
01978 0682           B8                   0013  mov	ax,*$13
01979 0685           50                         push	ax
01980                                           ! Debug: list int = const $40 (used reg = )
01981 0686           B8                   0040  mov	ax,*$40
01982 0689           50                         push	ax
01983                                           ! Debug: func () void = write_word+0 (used reg = )
01984 068A           E8         FFA5            call	_write_word
01985 068D           83C4                   08  add	sp,*8
01986                                           !BCC_EOS
01987                                           ! 896 }
01988 0690           89EC                       mov	sp,bp
01989 0692           5D                         pop	bp
01990 0693           C3                         ret
01991                                           ! 897 void enable_rom_write_access()
01992                                           ! Register BX used in function fixup_base_mem_in_k
01993                                           ! 898 {
01994                                           export	_enable_rom_write_access
01995                       00000694            _enable_rom_write_access:
01996                                           ! 899     outb(0x10, 0);
01997 0694           55                         push	bp
01998 0695           89E5                       mov	bp,sp
01999                                           ! Debug: list int = const 0 (used reg = )
02000 0697           31C0                       xor	ax,ax
02001 0699           50                         push	ax
02002                                           ! Debug: list int = const $10 (used reg = )
02003 069A           B8                   0010  mov	ax,*$10
02004 069D           50                         push	ax
02005                                           ! Debug: func () void = outb+0 (used reg = )
02006 069E           E8         FEB3            call	_outb
02007 06A1           89EC                       mov	sp,bp
02008                                           !BCC_EOS
02009                                           ! 900 }
02010 06A3           5D                         pop	bp
02011 06A4           C3                         ret
02012                                           ! 901 void disable_rom_write_access()
02013                                           ! 902 {
02014                                           export	_disable_rom_write_access
02015                       000006A5            _disable_rom_write_access:
02016                                           ! 903     outb(0x10, 1);
02017 06A5           55                         push	bp
02018 06A6           89E5                       mov	bp,sp
02019                                           ! Debug: list int = const 1 (used reg = )
02020 06A8           B8                   0001  mov	ax,*1
02021 06AB           50                         push	ax
02022                                           ! Debug: list int = const $10 (used reg = )
02023 06AC           B8                   0010  mov	ax,*$10
02024 06AF           50                         push	ax
02025                                           ! Debug: func () void = outb+0 (used reg = )
02026 06B0           E8         FEA1            call	_outb
02027 06B3           89EC                       mov	sp,bp
02028                                           !BCC_EOS
02029                                           ! 904 }
02030 06B5           5D                         pop	bp
02031 06B6           C3                         ret
02032                                           ! 905   void
02033                                           ! 906 wrch(c)
02034                                           ! 907   Bit8u c;
02035                                           export	_wrch
02036                       000006B7            _wrch:
02037                                           !BCC_EOS
02038                                           ! 908 {
02039                                           ! 909 #asm
02040                                           !BCC_ASM
02041                       00000002            _wrch.c	set	2
02042 06B7           55                           push bp
02043 06B8           89E5                         mov bp, sp
02044 06BA           53                           push bx
02045 06BB           B4                     0E    mov ah, #0x0e
02046 06BD           8A46         04              mov al, 4[bp]
02047 06C0           31DB                         xor bx,bx
02048 06C2           CD                     10    int #0x10
02049 06C4           5B                           pop bx
02050 06C5           5D                           pop bp
02051                                           ! 919 endasm
02052                                           !BCC_ENDASM
02053                                           ! 920 }
02054 06C6           C3                         ret
02055                                           ! 921   void
02056                                           ! 922 send(action, c)
02057                                           ! 923   Bit16u action;
02058                                           export	_send
02059                       000006C7            _send:
02060                                           !BCC_EOS
02061                                           ! 924   Bit8u c;
02062                                           !BCC_EOS
02063                                           ! 925 {
02064                                           ! 926   outb(0xE9, c);
02065 06C7           55                         push	bp
02066 06C8           89E5                       mov	bp,sp
02067                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02068 06CA           8A46         06            mov	al,6[bp]
02069 06CD           30E4                       xor	ah,ah
02070 06CF           50                         push	ax
02071                                           ! Debug: list int = const $E9 (used reg = )
02072 06D0           B8                   00E9  mov	ax,#$E9
02073 06D3           50                         push	ax
02074                                           ! Debug: func () void = outb+0 (used reg = )
02075 06D4           E8         FE7D            call	_outb
02076 06D7           89EC                       mov	sp,bp
02077                                           !BCC_EOS
02078                                           ! 927   if (action & 8) outb(0x403, c);
02079                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02080 06D9           8A46         04            mov	al,4[bp]
02081 06DC           24                     08  and	al,*8
02082 06DE           84C0                       test	al,al
02083 06E0           74           0F            je  	.8
02084                       000006E2            .9:
02085                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02086 06E2           8A46         06            mov	al,6[bp]
02087 06E5           30E4                       xor	ah,ah
02088 06E7           50                         push	ax
02089                                           ! Debug: list int = const $403 (used reg = )
02090 06E8           B8                   0403  mov	ax,#$403
02091 06EB           50                         push	ax
02092                                           ! Debug: func () void = outb+0 (used reg = )
02093 06EC           E8         FE65            call	_outb
02094 06EF           89EC                       mov	sp,bp
02095                                           !BCC_EOS
02096                                           ! 928   if (action & 4) outb(0x402, c);
02097                       000006F1            .8:
02098                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02099 06F1           8A46         04            mov	al,4[bp]
02100 06F4           24                     04  and	al,*4
02101 06F6           84C0                       test	al,al
02102 06F8           74           0F            je  	.A
02103                       000006FA            .B:
02104                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02105 06FA           8A46         06            mov	al,6[bp]
02106 06FD           30E4                       xor	ah,ah
02107 06FF           50                         push	ax
02108                                           ! Debug: list int = const $402 (used reg = )
02109 0700           B8                   0402  mov	ax,#$402
02110 0703           50                         push	ax
02111                                           ! Debug: func () void = outb+0 (used reg = )
02112 0704           E8         FE4D            call	_outb
02113 0707           89EC                       mov	sp,bp
02114                                           !BCC_EOS
02115                                           ! 929   if (action & 2) {
02116                       00000709            .A:
02117                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02118 0709           8A46         04            mov	al,4[bp]
02119 070C           24                     02  and	al,*2
02120 070E           84C0                       test	al,al
02121 0710           74           1B            je  	.C
02122                       00000712            .D:
02123                                           ! 930     if (c == '\n') wrc
02124                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02125 0712           8A46         06            mov	al,6[bp]
02126 0715           3C                     0A  cmp	al,*$A
02127 0717           75           09            jne 	.E
02128                       00000719            .F:
02129                                           ! 930 h('\r');
02130                                           ! Debug: list int = const $D (used reg = )
02131 0719           B8                   000D  mov	ax,*$D
02132 071C           50                         push	ax
02133                                           ! Debug: func () void = wrch+0 (used reg = )
02134 071D           E8         FF97            call	_wrch
02135 0720           89EC                       mov	sp,bp
02136                                           !BCC_EOS
02137                                           ! 931     wrch(c);
02138                       00000722            .E:
02139                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02140 0722           8A46         06            mov	al,6[bp]
02141 0725           30E4                       xor	ah,ah
02142 0727           50                         push	ax
02143                                           ! Debug: func () void = wrch+0 (used reg = )
02144 0728           E8         FF8C            call	_wrch
02145 072B           89EC                       mov	sp,bp
02146                                           !BCC_EOS
02147                                           ! 932   }
02148                                           ! 933 }
02149                       0000072D            .C:
02150 072D           5D                         pop	bp
02151 072E           C3                         ret
02152                                           ! 934   void
02153                                           ! 935 put_int(action, val, width, neg)
02154                                           ! 936   Bit16u action;
02155                                           export	_put_int
02156                       0000072F            _put_int:
02157                                           !BCC_EOS
02158                                           ! 937   short val, width;
02159                                           !BCC_EOS
02160                                           ! 938   bx_bool neg;
02161                                           !BCC_EOS
02162                                           ! 939 {
02163                                           ! 940   short nval = val / 10;
02164 072F           55                         push	bp
02165 0730           89E5                       mov	bp,sp
02166 0732           4C                         dec	sp
02167 0733           4C                         dec	sp
02168                                           ! Debug: div int = const $A to short val = [S+4+4] (used reg = )
02169 0734           8B46         06            mov	ax,6[bp]
02170 0737           BB                   000A  mov	bx,*$A
02171 073A           99                         cwd
02172 073B           F7FB                       idiv	bx
02173                                           ! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
02174 073D           8946         FE            mov	-2[bp],ax
02175                                           !BCC_EOS
02176                                           ! 941   if (nval)
02177 0740           8B46         FE            mov	ax,-2[bp]
02178 0743           85C0                       test	ax,ax
02179 0745         0F84         0016            beq 	.10
02180                       00000749            .11:
02181                                           ! 942     put_int(action, nval, width - 1, neg);
02182                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02183 0749           FF76         0A            push	$A[bp]
02184                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02185 074C           8B46         08            mov	ax,8[bp]
02186                                           ! Debug: list int = ax-1 (used reg = )
02187 074F           48                         dec	ax
02188 0750           50                         push	ax
02189                                           ! Debug: list short nval = [S+8-4] (used reg = )
02190 0751           FF76         FE            push	-2[bp]
02191                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02192 0754           FF76         04            push	4[bp]
02193                                           ! Debug: func () void = put_int+0 (used reg = )
02194 0757           E8         FFD5            call	_put_int
02195 075A           83C4                   08  add	sp,*8
02196                                           !BCC_EOS
02197                                           ! 943   else {
02198 075D           EB           2E            jmp .12
02199                       0000075F            .10:
02200                                           ! 944     while (--width > 0) send(action, ' ');
02201 075F           EB           0D            jmp .14
02202                       00000761            .15:
02203                                           ! Debug: list int = const $20 (used reg = )
02204 0761           B8                   0020  mov	ax,*$20
02205 0764           50                         push	ax
02206                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02207 0765           FF76         04            push	4[bp]
02208                                           ! Debug: func () void = send+0 (used reg = )
02209 0768           E8         FF5C            call	_send
02210 076B           83C4                   04  add	sp,*4
02211                                           !BCC_EOS
02212                                           ! 945     if (neg) send(action, '-');
02213                       0000076E            .14:
02214                                           ! Debug: predec short width = [S+4+6] (used reg = )
02215 076E           8B46         08            mov	ax,8[bp]
02216 0771           48                         dec	ax
02217 0772           8946         08            mov	8[bp],ax
02218                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02219 0775           85C0                       test	ax,ax
02220 0777           7F           E8            jg 	.15
02221                       00000779            .16:
02222                       00000779            .13:
02223 0779           8B46         0A            mov	ax,$A[bp]
02224 077C           85C0                       test	ax,ax
02225 077E           74           0D            je  	.17
02226                       00000780            .18:
02227                                           ! Debug: list int = const $2D (used reg = )
02228 0780           B8                   002D  mov	ax,*$2D
02229 0783           50                         push	ax
02230                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02231 0784           FF76         04            push	4[bp]
02232                                           ! Debug: func () void = send+0 (used reg = )
02233 0787           E8         FF3D            call	_send
02234 078A           83C4                   04  add	sp,*4
02235                                           !BCC_EOS
02236                                           ! 946   }
02237                       0000078D            .17:
02238                                           ! 947   send(action, val - (nval * 10) + '0');
02239                       0000078D            .12:
02240                                           ! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
02241 078D           8B46         FE            mov	ax,-2[bp]
02242 0790           89C2                       mov	dx,ax
02243 0792           D1E0                       shl	ax,*1
02244 0794           D1E0                       shl	ax,*1
02245 0796           01D0                       add	ax,dx
02246 0798           D1E0                       shl	ax,*1
02247                                           ! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
02248 079A           50                         push	ax
02249 079B           8B46         06            mov	ax,6[bp]
02250 079E           2B46         FC            sub	ax,-4[bp]
02251 07A1           44                         inc	sp
02252 07A2           44                         inc	sp
02253                                           ! Debug: add int = const $30 to int = ax+0 (used reg = )
02254                                           ! Debug: list int = ax+$30 (used reg = )
02255 07A3           05                   0030  add	ax,*$30
02256 07A6           50                         push	ax
02257                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02258 07A7           FF76         04            push	4[bp]
02259                                           ! Debug: func () void = send+0 (used reg = )
02260 07AA           E8         FF1A            call	_send
02261 07AD           83C4                   04  add	sp,*4
02262                                           !BCC_EOS
02263                                           ! 948 }
02264 07B0           89EC                       mov	sp,bp
02265 07B2           5D                         pop	bp
02266 07B3           C3                         ret
02267                                           ! 949   void
02268                                           ! Register BX used in function put_int
02269                                           ! 950 put_uint(action, val, width, neg)
02270                                           ! 951   Bit16u action;
02271                                           export	_put_uint
02272                       000007B4            _put_uint:
02273                                           !BCC_EOS
02274                                           ! 952   unsigned short val;
02275                                           !BCC_EOS
02276                                           ! 953   short width;
02277                                           !BCC_EOS
02278                                           ! 954   bx_bool neg;
02279                                           !BCC_EOS
02280                                           ! 955 {
02281                                           ! 956   unsigned short nval = val / 10;
02282 07B4           55                         push	bp
02283 07B5           89E5                       mov	bp,sp
02284 07B7           4C                         dec	sp
02285 07B8           4C                         dec	sp
02286                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02287 07B9           8B46         06            mov	ax,6[bp]
02288 07BC           BB                   000A  mov	bx,*$A
02289 07BF           E8         F9A7            call	idiv_u
02290                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02291 07C2           8946         FE            mov	-2[bp],ax
02292                                           !BCC_EOS
02293                                           ! 957   if (nval)
02294 07C5           8B46         FE            mov	ax,-2[bp]
02295 07C8           85C0                       test	ax,ax
02296 07CA           74           16            je  	.19
02297                       000007CC            .1A:
02298                                           ! 958     put_uint(action, nval, width - 1, neg);
02299                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02300 07CC           FF76         0A            push	$A[bp]
02301                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02302 07CF           8B46         08            mov	ax,8[bp]
02303                                           ! Debug: list int = ax-1 (used reg = )
02304 07D2           48                         dec	ax
02305 07D3           50                         push	ax
02306                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02307 07D4           FF76         FE            push	-2[bp]
02308                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02309 07D7           FF76         04            push	4[bp]
02310                                           ! Debug: func () void = put_uint+0 (used reg = )
02311 07DA           E8         FFD7            call	_put_uint
02312 07DD           83C4                   08  add	sp,*8
02313                                           !BCC_EOS
02314                                           ! 959   else {
02315 07E0           EB           2E            jmp .1B
02316                       000007E2            .19:
02317                                           ! 960     while (--width > 0) send(action, ' ');
02318 07E2           EB           0D            jmp .1D
02319                       000007E4            .1E:
02320                                           ! Debug: list int = const $20 (used reg = )
02321 07E4           B8                   0020  mov	ax,*$20
02322 07E7           50                         push	ax
02323                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02324 07E8           FF76         04            push	4[bp]
02325                                           ! Debug: func () void = send+0 (used reg = )
02326 07EB           E8         FED9            call	_send
02327 07EE           83C4                   04  add	sp,*4
02328                                           !BCC_EOS
02329                                           ! 961     if (neg) send(action, '-');
02330                       000007F1            .1D:
02331                                           ! Debug: predec short width = [S+4+6] (used reg = )
02332 07F1           8B46         08            mov	ax,8[bp]
02333 07F4           48                         dec	ax
02334 07F5           8946         08            mov	8[bp],ax
02335                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02336 07F8           85C0                       test	ax,ax
02337 07FA           7F           E8            jg 	.1E
02338                       000007FC            .1F:
02339                       000007FC            .1C:
02340 07FC           8B46         0A            mov	ax,$A[bp]
02341 07FF           85C0                       test	ax,ax
02342 0801           74           0D            je  	.20
02343                       00000803            .21:
02344                                           ! Debug: list int = const $2D (used reg = )
02345 0803           B8                   002D  mov	ax,*$2D
02346 0806           50                         push	ax
02347                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02348 0807           FF76         04            push	4[bp]
02349                                           ! Debug: func () void = send+0 (used reg = )
02350 080A           E8         FEBA            call	_send
02351 080D           83C4                   04  add	sp,*4
02352                                           !BCC_EOS
02353                                           ! 962   }
02354                       00000810            .20:
02355                                           ! 963   send(action, val - (nval * 10) + '0');
02356                       00000810            .1B:
02357                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02358 0810           8B46         FE            mov	ax,-2[bp]
02359 0813           89C2                       mov	dx,ax
02360 0815           D1E0                       shl	ax,*1
02361 0817           D1E0                       shl	ax,*1
02362 0819           01D0                       add	ax,dx
02363 081B           D1E0                       shl	ax,*1
02364                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02365 081D           50                         push	ax
02366 081E           8B46         06            mov	ax,6[bp]
02367 0821           2B46         FC            sub	ax,-4[bp]
02368 0824           44                         inc	sp
02369 0825           44                         inc	sp
02370                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02371                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02372 0826           05                   0030  add	ax,*$30
02373 0829           50                         push	ax
02374                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02375 082A           FF76         04            push	4[bp]
02376                                           ! Debug: func () void = send+0 (used reg = )
02377 082D           E8         FE97            call	_send
02378 0830           83C4                   04  add	sp,*4
02379                                           !BCC_EOS
02380                                           ! 964 }
02381 0833           89EC                       mov	sp,bp
02382 0835           5D                         pop	bp
02383 0836           C3                         ret
02384                                           ! 965   void
02385                                           ! Register BX used in function put_uint
02386                                           ! 966 put_luint(action, val, width, neg)
02387                                           ! 967   Bit16u action;
02388                                           export	_put_luint
02389                       00000837            _put_luint:
02390                                           !BCC_EOS
02391                                           ! 968   unsigned long val;
02392                                           !BCC_EOS
02393                                           ! 969   short width;
02394                                           !BCC_EOS
02395                                           ! 970   bx_bool neg;
02396                                           !BCC_EOS
02397                                           ! 971 {
02398                                           ! 972   unsigned long nval = val / 10;
02399 0837           55                         push	bp
02400 0838           89E5                       mov	bp,sp
02401 083A           83C4                   FC  add	sp,*-4
02402                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02403 083D           B8                   000A  mov	ax,*$A
02404 0840           31DB                       xor	bx,bx
02405 0842           53                         push	bx
02406 0843           50                         push	ax
02407 0844           8B46         06            mov	ax,6[bp]
02408 0847           8B5E         08            mov	bx,8[bp]
02409 084A           8D7E         F8            lea	di,-8[bp]
02410 084D           E8         F91E            call	ldivul
02411 0850           83C4                   04  add	sp,*4
02412                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02413 0853           8946         FC            mov	-4[bp],ax
02414 0856           895E         FE            mov	-2[bp],bx
02415                                           !BCC_EOS
02416                                           ! 973   if (nval)
02417 0859           8B46         FC            mov	ax,-4[bp]
02418 085C           8B5E         FE            mov	bx,-2[bp]
02419 085F           E8         F8B2            call	ltstl
02420 0862           74           19            je  	.22
02421                       00000864            .23:
02422                                           ! 974     put_luint(action, nval, width - 1, neg);
02423                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02424 0864           FF76         0C            push	$C[bp]
02425                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02426 0867           8B46         0A            mov	ax,$A[bp]
02427                                           ! Debug: list int = ax-1 (used reg = )
02428 086A           48                         dec	ax
02429 086B           50                         push	ax
02430                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02431 086C           FF76         FE            push	-2[bp]
02432 086F           FF76         FC            push	-4[bp]
02433                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02434 0872           FF76         04            push	4[bp]
02435                                           ! Debug: func () void = put_luint+0 (used reg = )
02436 0875           E8         FFBF            call	_put_luint
02437 0878           83C4                   0A  add	sp,*$A
02438                                           !BCC_EOS
02439                                           ! 975   else {
02440 087B           EB           2E            jmp .24
02441                       0000087D            .22:
02442                                           ! 976     while (--width > 0) send(action, ' ');
02443 087D           EB           0D            jmp .26
02444                       0000087F            .27:
02445                                           ! Debug: list int = const $20 (used reg = )
02446 087F           B8                   0020  mov	ax,*$20
02447 0882           50                         push	ax
02448                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02449 0883           FF76         04            push	4[bp]
02450                                           ! Debug: func () void = send+0 (used reg = )
02451 0886           E8         FE3E            call	_send
02452 0889           83C4                   04  add	sp,*4
02453                                           !BCC_EOS
02454                                           ! 977     if (neg) send(action, '-');
02455                       0000088C            .26:
02456                                           ! Debug: predec short width = [S+6+8] (used reg = )
02457 088C           8B46         0A            mov	ax,$A[bp]
02458 088F           48                         dec	ax
02459 0890           8946         0A            mov	$A[bp],ax
02460                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02461 0893           85C0                       test	ax,ax
02462 0895           7F           E8            jg 	.27
02463                       00000897            .28:
02464                       00000897            .25:
02465 0897           8B46         0C            mov	ax,$C[bp]
02466 089A           85C0                       test	ax,ax
02467 089C           74           0D            je  	.29
02468                       0000089E            .2A:
02469                                           ! Debug: list int = const $2D (used reg = )
02470 089E           B8                   002D  mov	ax,*$2D
02471 08A1           50                         push	ax
02472                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02473 08A2           FF76         04            push	4[bp]
02474                                           ! Debug: func () void = send+0 (used reg = )
02475 08A5           E8         FE1F            call	_send
02476 08A8           83C4                   04  add	sp,*4
02477                                           !BCC_EOS
02478                                           ! 978   }
02479                       000008AB            .29:
02480                                           ! 979   send(action, val - (nval * 10) + '0');
02481                       000008AB            .24:
02482                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02483                                           ! Debug: expression subtree swapping
02484 08AB           B8                   000A  mov	ax,*$A
02485 08AE           31DB                       xor	bx,bx
02486 08B0           8D7E         FC            lea	di,-4[bp]
02487 08B3           E8         F833            call	lmulul
02488                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02489 08B6           53                         push	bx
02490 08B7           50                         push	ax
02491 08B8           8B46         06            mov	ax,6[bp]
02492 08BB           8B5E         08            mov	bx,8[bp]
02493 08BE           8D7E         F8            lea	di,-8[bp]
02494 08C1           E8         F81D            call	lsubul
02495 08C4           83C4                   04  add	sp,*4
02496                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02497 08C7           53                         push	bx
02498 08C8           50                         push	ax
02499 08C9           B8                   0030  mov	ax,*$30
02500 08CC           31DB                       xor	bx,bx
02501 08CE           53                         push	bx
02502 08CF           50                         push	ax
02503 08D0           8B46         F8            mov	ax,-8[bp]
02504 08D3           8B5E         FA            mov	bx,-6[bp]
02505 08D6           8D7E         F4            lea	di,-$C[bp]
02506 08D9           E8         F7E7            call	laddul
02507 08DC           83C4                   08  add	sp,*8
02508                                           ! Debug: list unsigned long = bx+0 (used reg = )
02509 08DF           53                         push	bx
02510 08E0           50                         push	ax
02511                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02512 08E1           FF76         04            push	4[bp]
02513                                           ! Debug: func () void = send+0 (used reg = )
02514 08E4           E8         FDE0            call	_send
02515 08E7           83C4                   06  add	sp,*6
02516                                           !BCC_EOS
02517                                           ! 980 }
02518 08EA           89EC                       mov	sp,bp
02519 08EC           5D                         pop	bp
02520 08ED           C3                         ret
02521                                           ! 981 void put_str(action, segment, offset)
02522                                           ! Register BX used in function put_luint
02523                                           ! 982   Bit16u action;
02524                                           export	_put_str
02525                       000008EE            _put_str:
02526                                           !BCC_EOS
02527                                           ! 983   Bit16u segment;
02528                                           !BCC_EOS
02529                                           ! 984   Bit16u offset;
02530                                           !BCC_EOS
02531                                           ! 985 {
02532                                           ! 986   Bit8u c;
02533                                           !BCC_EOS
02534                                           ! 987   while (c = read_byte(segment, offset)) {
02535 08EE           55                         push	bp
02536 08EF           89E5                       mov	bp,sp
02537 08F1           4C                         dec	sp
02538 08F2           4C                         dec	sp
02539 08F3           EB           16            jmp .2C
02540                       000008F5            .2D:
02541                                           ! 988     send(action, c);
02542                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02543 08F5           8A46         FF            mov	al,-1[bp]
02544 08F8           30E4                       xor	ah,ah
02545 08FA           50                         push	ax
02546                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02547 08FB           FF76         04            push	4[bp]
02548                                           ! Debug: func () void = send+0 (used reg = )
02549 08FE           E8         FDC6            call	_send
02550 0901           83C4                   04  add	sp,*4
02551                                           !BCC_EOS
02552                                           ! 989     offset++;
02553                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02554 0904           8B46         08            mov	ax,8[bp]
02555 0907           40                         inc	ax
02556 0908           8946         08            mov	8[bp],ax
02557                                           !BCC_EOS
02558                                           ! 990   }
02559                                           ! 991 }
02560                       0000090B            .2C:
02561                                           ! Debug: list unsigned short offset = [S+4+6] (used reg = )
02562 090B           FF76         08            push	8[bp]
02563                                           ! Debug: list unsigned short segment = [S+6+4] (used reg = )
02564 090E           FF76         06            push	6[bp]
02565                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
02566 0911           E8         FCE0            call	_read_byte
02567 0914           83C4                   04  add	sp,*4
02568                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02569 0917           8846         FF            mov	-1[bp],al
02570 091A           84C0                       test	al,al
02571 091C           75           D7            jne	.2D
02572                       0000091E            .2E:
02573                       0000091E            .2B:
02574 091E           89EC                       mov	sp,bp
02575 0920           5D                         pop	bp
02576 0921           C3                         ret
02577                                           ! 992   void
02578                                           ! 993 delay_ticks(ticks)
02579                                           ! 994   Bit16u ticks;
02580                                           export	_delay_ticks
02581                       00000922            _delay_ticks:
02582                                           !BCC_EOS
02583                                           ! 995 {
02584                                           ! 996   long ticks_to_wait, delta;
02585                                           !BCC_EOS
02586                                           ! 997   Bit32u prev_ticks, t;
02587                                           !BCC_EOS
02588                                           ! 998 #asm
02589 0922           55                         push	bp
02590 0923           89E5                       mov	bp,sp
02591 0925           83C4                   F0  add	sp,*-$10
02592                                           !BCC_EOS
02593                                           !BCC_ASM
02594                       00000014            _delay_ticks.ticks	set	$14
02595                       00000004            .delay_ticks.ticks	set	4
02596                       00000000            _delay_ticks.t	set	0
02597                       FFFFFFF0            .delay_ticks.t	set	-$10
02598                       00000004            _delay_ticks.prev_ticks	set	4
02599                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02600                       00000008            _delay_ticks.delta	set	8
02601                       FFFFFFF8            .delay_ticks.delta	set	-8
02602                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02603                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02604 0928           9C                           pushf
02605 0929           FB                           sti
02606                                           ! 1001 endasm
02607                                           !BCC_ENDASM
02608                                           !BCC_EOS
02609                                           ! 1002   ticks_to_wait = ticks;
02610                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02611 092A           8B46         04            mov	ax,4[bp]
02612 092D           31DB                       xor	bx,bx
02613 092F           8946         FC            mov	-4[bp],ax
02614 0932           895E         FE            mov	-2[bp],bx
02615                                           !BCC_EOS
02616                                           ! 1003   prev_ticks = read_dword(0x0, 0x46c);
02617                                           ! Debug: list int = const $46C (used reg = )
02618 0935           B8                   046C  mov	ax,#$46C
02619 0938           50                         push	ax
02620                                           ! Debug: list int = const 0 (used reg = )
02621 0939           31C0                       xor	ax,ax
02622 093B           50                         push	ax
02623                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02624 093C           E8         F744            call	_read_dword
02625 093F           89D3                       mov	bx,dx
02626 0941           83C4                   04  add	sp,*4
02627                                           ! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02628 0944           8946         F4            mov	-$C[bp],ax
02629 0947           895E         F6            mov	-$A[bp],bx
02630                                           !BCC_EOS
02631                                           ! 1004   do
02632                                           ! 1005   {
02633                       0000094A            .31:
02634                                           ! 1006 #asm
02635                                           !BCC_EOS
02636                                           !BCC_ASM
02637                       00000014            _delay_ticks.ticks	set	$14
02638                       00000004            .delay_ticks.ticks	set	4
02639                       00000000            _delay_ticks.t	set	0
02640                       FFFFFFF0            .delay_ticks.t	set	-$10
02641                       00000004            _delay_ticks.prev_ticks	set	4
02642                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02643                       00000008            _delay_ticks.delta	set	8
02644                       FFFFFFF8            .delay_ticks.delta	set	-8
02645                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02646                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02647 094A           F4                             hlt
02648                                           ! 1008 endasm
02649                                           !BCC_ENDASM
02650                                           !BCC_EOS
02651                                           ! 1009     t = read_dword(0x0, 0x46c);
02652                                           ! Debug: list int = const $46C (used reg = )
02653 094B           B8                   046C  mov	ax,#$46C
02654 094E           50                         push	ax
02655                                           ! Debug: list int = const 0 (used reg = )
02656 094F           31C0                       xor	ax,ax
02657 0951           50                         push	ax
02658                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02659 0952           E8         F72E            call	_read_dword
02660 0955           89D3                       mov	bx,dx
02661 0957           83C4                   04  add	sp,*4
02662                                           ! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
02663 095A           8946         F0            mov	-$10[bp],ax
02664 095D           895E         F2            mov	-$E[bp],bx
02665                                           !BCC_EOS
02666                                           ! 1010     if (t > prev_ticks)
02667                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02668 0960           8B46         F4            mov	ax,-$C[bp]
02669 0963           8B5E         F6            mov	bx,-$A[bp]
02670 0966           8D7E         F0            lea	di,-$10[bp]
02671 0969           E8         F75F            call	lcmpul
02672 096C           73           26            jae 	.32
02673                       0000096E            .33:
02674                                           ! 1011     {
02675                                           ! 1012       delta = t - prev_ticks;
02676                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02677 096E           8B46         F0            mov	ax,-$10[bp]
02678 0971           8B5E         F2            mov	bx,-$E[bp]
02679 0974           8D7E         F4            lea	di,-$C[bp]
02680 0977           E8         F767            call	lsubul
02681                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02682 097A           8946         F8            mov	-8[bp],ax
02683 097D           895E         FA            mov	-6[bp],bx
02684                                           !BCC_EOS
02685                                           ! 1013       ticks_to_wait -= delta;
02686                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02687 0980           8B46         FC            mov	ax,-4[bp]
02688 0983           8B5E         FE            mov	bx,-2[bp]
02689 0986           8D7E         F8            lea	di,-8[bp]
02690 0989           E8         F755            call	lsubl
02691 098C           8946         FC            mov	-4[bp],ax
02692 098F           895E         FE            mov	-2[bp],bx
02693                                           !BCC_EOS
02694                                           ! 1014     }
02695                                           ! 1015     else if (t < prev_ticks)
02696 0992           EB           20            jmp .34
02697                       00000994            .32:
02698                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02699 0994           8B46         F4            mov	ax,-$C[bp]
02700 0997           8B5E         F6            mov	bx,-$A[bp]
02701 099A           8D7E         F0            lea	di,-$10[bp]
02702 099D           E8         F72B            call	lcmpul
02703 09A0           76           12            jbe 	.35
02704                       000009A2            .36:
02705                                           ! 1016     {
02706                                           ! 1017       ticks_to_wait -= t;
02707                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02708 09A2           8B46         FC            mov	ax,-4[bp]
02709 09A5           8B5E         FE            mov	bx,-2[bp]
02710 09A8           8D7E         F0            lea	di,-$10[bp]
02711 09AB           E8         F733            call	lsubul
02712 09AE           8946         FC            mov	-4[bp],ax
02713 09B1           895E         FE            mov	-2[bp],bx
02714                                           !BCC_EOS
02715                                           ! 1018     }
02716                                           ! 1019     prev_ticks = t;
02717                       000009B4            .35:
02718                       000009B4            .34:
02719                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02720 09B4           8B46         F0            mov	ax,-$10[bp]
02721 09B7           8B5E         F2            mov	bx,-$E[bp]
02722 09BA           8946         F4            mov	-$C[bp],ax
02723 09BD           895E         F6            mov	-$A[bp],bx
02724                                           !BCC_EOS
02725                                           ! 1020   } while (ticks_to_wait > 0);
02726                       000009C0            .30:
02727                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02728 09C0           31C0                       xor	ax,ax
02729 09C2           31DB                       xor	bx,bx
02730 09C4           8D7E         FC            lea	di,-4[bp]
02731 09C7           E8         F701            call	lcmpl
02732 09CA         0F8C         FF7C            blt 	.31
02733                       000009CE            .37:
02734                                           !BCC_EOS
02735                                           ! 1021 #asm
02736                       000009CE            .2F:
02737                                           !BCC_EOS
02738                                           !BCC_ASM
02739                       00000014            _delay_ticks.ticks	set	$14
02740                       00000004            .delay_ticks.ticks	set	4
02741                       00000000            _delay_ticks.t	set	0
02742                       FFFFFFF0            .delay_ticks.t	set	-$10
02743                       00000004            _delay_ticks.prev_ticks	set	4
02744                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02745                       00000008            _delay_ticks.delta	set	8
02746                       FFFFFFF8            .delay_ticks.delta	set	-8
02747                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02748                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02749 09CE           FA                           cli
02750 09CF           9D                           popf
02751                                           ! 1024 endasm
02752                                           !BCC_ENDASM
02753                                           !BCC_EOS
02754                                           ! 1025 }
02755 09D0           89EC                       mov	sp,bp
02756 09D2           5D                         pop	bp
02757 09D3           C3                         ret
02758                                           ! 1026   Bit8u
02759                                           ! Register BX used in function delay_ticks
02760                                           ! 1027 check_for_keystroke()
02761                                           ! 1028 {
02762                                           export	_check_for_keystroke
02763                       000009D4            _check_for_keystroke:
02764                                           ! 1029 #asm
02765                                           !BCC_ASM
02766 09D4           B8                   0100    mov ax, #0x100
02767 09D7           CD                     16    int #0x16
02768 09D9           74           04              jz no_key
02769 09DB           B0                     01    mov al, #1
02770 09DD           EB           02              jmp done
02771                       000009DF            no_key:
02772 09DF           30C0                         xor al, al
02773                       000009E1            done:
02774                                           ! 1038 endasm
02775                                           !BCC_ENDASM
02776                                           ! 1039 }
02777 09E1           C3                         ret
02778                                           ! 1040   Bit8u
02779                                           ! 1041 get_keystroke()
02780                                           ! 1042 {
02781                                           export	_get_keystroke
02782                       000009E2            _get_keystroke:
02783                                           ! 1043 #asm
02784                                           !BCC_ASM
02785 09E2           B8                   0000    mov ax, #0x0
02786 09E5           CD                     16    int #0x16
02787 09E7           86C4                         xchg ah, al
02788                                           ! 1047 endasm
02789                                           !BCC_ENDASM
02790                                           ! 1048 }
02791 09E9           C3                         ret
02792                                           ! 1049   void
02793                                           ! 1050 delay_ticks_and_check_for_keystroke(ticks, count)
02794                                           ! 1051   Bit16u ticks, count;
02795                                           export	_delay_ticks_and_check_for_keystroke
02796                       000009EA            _delay_ticks_and_check_for_keystroke:
02797                                           !BCC_EOS
02798                                           ! 1052 {
02799                                           ! 1053   Bit16u i;
02800                                           !BCC_EOS
02801                                           ! 1054   for (i = 1; i <= count; i++) {
02802 09EA           55                         push	bp
02803 09EB           89E5                       mov	bp,sp
02804 09ED           4C                         dec	sp
02805 09EE           4C                         dec	sp
02806                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02807 09EF           B8                   0001  mov	ax,*1
02808 09F2           8946         FE            mov	-2[bp],ax
02809                                           !BCC_EOS
02810                                           !BCC_EOS
02811 09F5           EB           18            jmp .3A
02812                       000009F7            .3B:
02813                                           ! 1055     delay_ticks(ticks)
02814                                           ! 1055 ;
02815                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02816 09F7           FF76         04            push	4[bp]
02817                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02818 09FA           E8         FF25            call	_delay_ticks
02819 09FD           44                         inc	sp
02820 09FE           44                         inc	sp
02821                                           !BCC_EOS
02822                                           ! 1056     if (check_for_keystroke())
02823                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02824 09FF           E8         FFD2            call	_check_for_keystroke
02825 0A02           84C0                       test	al,al
02826 0A04           74           02            je  	.3C
02827                       00000A06            .3D:
02828                                           ! 1057       break;
02829 0A06           EB           0F            jmp .38
02830                                           !BCC_EOS
02831                                           ! 1058   }
02832                       00000A08            .3C:
02833                                           ! 1059 }
02834                       00000A08            .39:
02835                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02836 0A08           8B46         FE            mov	ax,-2[bp]
02837 0A0B           40                         inc	ax
02838 0A0C           8946         FE            mov	-2[bp],ax
02839                       00000A0F            .3A:
02840                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02841 0A0F           8B46         FE            mov	ax,-2[bp]
02842 0A12           3B46         06            cmp	ax,6[bp]
02843 0A15           76           E0            jbe	.3B
02844                       00000A17            .3E:
02845                       00000A17            .38:
02846 0A17           89EC                       mov	sp,bp
02847 0A19           5D                         pop	bp
02848 0A1A           C3                         ret
02849                                           ! 1060   void
02850                                           ! 1061 bios_printf(action, s)
02851                                           ! 1062   Bit16u action;
02852                                           export	_bios_printf
02853                       00000A1B            _bios_printf:
02854                                           !BCC_EOS
02855                                           ! 1063   Bit8u *s;
02856                                           !BCC_EOS
02857                                           ! 1064 {
02858                                           ! 1065   Bit8u c, format_char;
02859                                           !BCC_EOS
02860                                           ! 1066   bx_bool in_format;
02861                                           !BCC_EOS
02862                                           ! 1067   short i;
02863                                           !BCC_EOS
02864                                           ! 1068   Bit16u *arg_ptr;
02865                                           !BCC_EOS
02866                                           ! 1069   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
02867                                           !BCC_EOS
02868                                           ! 1070   arg_ptr = &s;
02869 0A1B           55                         push	bp
02870 0A1C           89E5                       mov	bp,sp
02871 0A1E           83C4                   EA  add	sp,*-$16
02872                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02873 0A21           8D5E         06            lea	bx,6[bp]
02874 0A24           895E         F8            mov	-8[bp],bx
02875                                           !BCC_EOS
02876                                           ! 1071   arg_seg = get_SS();
02877                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
02878 0A27           E8         FC23            call	_get_SS
02879                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
02880 0A2A           8946         F6            mov	-$A[bp],ax
02881                                           !BCC_EOS
02882                                           ! 1072   in_format = 0;
02883                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02884 0A2D           31C0                       xor	ax,ax
02885 0A2F           8946         FC            mov	-4[bp],ax
02886                                           !BCC_EOS
02887                                           ! 1073   format_width = 0;
02888                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02889 0A32           31C0                       xor	ax,ax
02890 0A34           8946         EC            mov	-$14[bp],ax
02891                                           !BCC_EOS
02892                                           ! 1074   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02893                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02894 0A37           8A46         04            mov	al,4[bp]
02895 0A3A           24                     07  and	al,*7
02896                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02897 0A3C           3C                     07  cmp	al,*7
02898 0A3E           75           1B            jne 	.3F
02899                       00000A40            .40:
02900                                           ! 1075     outb(0x401, 0x00);
02901                                           ! Debug: list int = const 0 (used reg = )
02902 0A40           31C0                       xor	ax,ax
02903 0A42           50                         push	ax
02904                                           ! Debug: list int = const $401 (used reg = )
02905 0A43           B8                   0401  mov	ax,#$401
02906 0A46           50                         push	ax
02907                                           ! Debug: func () void = outb+0 (used reg = )
02908 0A47           E8         FB0A            call	_outb
02909 0A4A           83C4                   04  add	sp,*4
02910                                           !BCC_EOS
02911                                           ! 1076     bios_printf (2, "FATAL: ");
02912                                           ! Debug: list * char = .41+0 (used reg = )
02913 0A4D           BB                   D5E9  mov	bx,#.41
02914 0A50           53                         push	bx
02915                                           ! Debug: list int = const 2 (used reg = )
02916 0A51           B8                   0002  mov	ax,*2
02917 0A54           50                         push	ax
02918                                           ! Debug: func () void = bios_printf+0 (used reg = )
02919 0A55           E8         FFC3            call	_bios_printf
02920 0A58           83C4                   04  add	sp,*4
02921                                           !BCC_EOS
02922                                           ! 1077   }
02923                                           ! 1078   while (c = read_byte(get_CS(), s)) {
02924                       00000A5B            .3F:
02925 0A5B           E9         0369            br 	.43
02926                       00000A5E            .44:
02927                                           ! 1079     if ( c == '%' ) {
02928                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02929 0A5E           8A46         FF            mov	al,-1[bp]
02930 0A61           3C                     25  cmp	al,*$25
02931 0A63           75           0E            jne 	.45
02932                       00000A65            .46:
02933                                           ! 1080       in_format = 1;
02934                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02935 0A65           B8                   0001  mov	ax,*1
02936 0A68           8946         FC            mov	-4[bp],ax
02937                                           !BCC_EOS
02938                                           ! 1081       format_width = 0;
02939                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02940 0A6B           31C0                       xor	ax,ax
02941 0A6D           8946         EC            mov	-$14[bp],ax
02942                                           !BCC_EOS
02943                                           ! 1082       }
02944                                           ! 1083     else if (in_format) {
02945 0A70           E9         034D            br 	.47
02946                       00000A73            .45:
02947 0A73           8B46         FC            mov	ax,-4[bp]
02948 0A76           85C0                       test	ax,ax
02949 0A78         0F84         0335            beq 	.48
02950                       00000A7C            .49:
02951                                           ! 1084       if ( (c>='0') && (c<='9') ) {
02952                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02953 0A7C           8A46         FF            mov	al,-1[bp]
02954 0A7F           3C                     30  cmp	al,*$30
02955 0A81           72           28            jb  	.4A
02956                       00000A83            .4C:
02957                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02958 0A83           8A46         FF            mov	al,-1[bp]
02959 0A86           3C                     39  cmp	al,*$39
02960 0A88           77           21            ja  	.4A
02961                       00000A8A            .4B:
02962                                           ! 1085         format_width = (format_width * 10) + (c - '0');
02963                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02964 0A8A           8A46         FF            mov	al,-1[bp]
02965 0A8D           30E4                       xor	ah,ah
02966 0A8F           05                   FFD0  add	ax,*-$30
02967 0A92           50                         push	ax
02968                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
02969 0A93           8B46         EC            mov	ax,-$14[bp]
02970 0A96           89C2                       mov	dx,ax
02971 0A98           D1E0                       shl	ax,*1
02972 0A9A           D1E0                       shl	ax,*1
02973 0A9C           01D0                       add	ax,dx
02974 0A9E           D1E0                       shl	ax,*1
02975                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02976 0AA0           0346         E8            add	ax,-$18[bp]
02977 0AA3           44                         inc	sp
02978 0AA4           44                         inc	sp
02979                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
02980 0AA5           8946         EC            mov	-$14[bp],ax
02981                                           !BCC_EOS
02982                                           ! 1086         }
02983                                           ! 1087       else {
02984 0AA8           E9         0304            br 	.4D
02985                       00000AAB            .4A:
02986                                           ! 1088         arg_ptr++;
02987                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02988 0AAB           8B5E         F8            mov	bx,-8[bp]
02989 0AAE           43                         inc	bx
02990 0AAF           43                         inc	bx
02991 0AB0           895E         F8            mov	-8[bp],bx
02992                                           !BCC_EOS
02993                                           ! 1089         arg = read_word(arg_seg, arg_ptr);
02994                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02995 0AB3           FF76         F8            push	-8[bp]
02996                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
02997 0AB6           FF76         F6            push	-$A[bp]
02998                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
02999 0AB9           E8         FB4B            call	_read_word
03000 0ABC           83C4                   04  add	sp,*4
03001                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03002 0ABF           8946         F4            mov	-$C[bp],ax
03003                                           !BCC_EOS
03004                                           ! 1090         if (c == 'x' || c == 'X') {
03005                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03006 0AC2           8A46         FF            mov	al,-1[bp]
03007 0AC5           3C                     78  cmp	al,*$78
03008 0AC7           74           07            je  	.4F
03009                       00000AC9            .50:
03010                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03011 0AC9           8A46         FF            mov	al,-1[bp]
03012 0ACC           3C                     58  cmp	al,*$58
03013 0ACE           75           76            jne 	.4E
03014                       00000AD0            .4F:
03015                                           ! 1091           if (format_width == 0)
03016                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03017 0AD0           8B46         EC            mov	ax,-$14[bp]
03018 0AD3           85C0                       test	ax,ax
03019 0AD5           75           06            jne 	.51
03020                       00000AD7            .52:
03021                                           ! 1092             format_width = 4;
03022                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
03023 0AD7           B8                   0004  mov	ax,*4
03024 0ADA           8946         EC            mov	-$14[bp],ax
03025                                           !BCC_EOS
03026                                           ! 1093           if (c == 'x')
03027                       00000ADD            .51:
03028                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03029 0ADD           8A46         FF            mov	al,-1[bp]
03030 0AE0           3C                     78  cmp	al,*$78
03031 0AE2           75           08            jne 	.53
03032                       00000AE4            .54:
03033                                           ! 1094             hexadd = 'a';
03034                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03035 0AE4           B8                   0061  mov	ax,*$61
03036 0AE7           8946         EA            mov	-$16[bp],ax
03037                                           !BCC_EOS
03038                                           ! 1095           else
03039                                           ! 1096             hexadd = 'A';
03040 0AEA           EB           06            jmp .55
03041                       00000AEC            .53:
03042                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03043 0AEC           B8                   0041  mov	ax,*$41
03044 0AEF           8946         EA            mov	-$16[bp],ax
03045                                           !BCC_EOS
03046                                           ! 1097           for (i=format_width-1; i>=0; i--) {
03047                       00000AF2            .55:
03048                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03049 0AF2           8B46         EC            mov	ax,-$14[bp]
03050                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03051 0AF5           48                         dec	ax
03052 0AF6           8946         FA            mov	-6[bp],ax
03053                                           !BCC_EOS
03054                                           !BCC_EOS
03055 0AF9           EB           41            jmp .58
03056                       00000AFB            .59:
03057                                           ! 1098             nibble = (arg >> (4 * i)) & 0x000f;
03058                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03059                                           ! Debug: expression subtree swapping
03060 0AFB           8B46         FA            mov	ax,-6[bp]
03061 0AFE           D1E0                       shl	ax,*1
03062 0B00           D1E0                       shl	ax,*1
03063                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03064 0B02           89C3                       mov	bx,ax
03065 0B04           8B46         F4            mov	ax,-$C[bp]
03066 0B07           89D9                       mov	cx,bx
03067 0B09           D3E8                       shr	ax,cl
03068                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
03069 0B0B           24                     0F  and	al,*$F
03070                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03071 0B0D           30E4                       xor	ah,ah
03072 0B0F           8946         F2            mov	-$E[bp],ax
03073                                           !BCC_EOS
03074                                           ! 1099             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03075                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03076 0B12           8B46         F2            mov	ax,-$E[bp]
03077 0B15           3D                   0009  cmp	ax,*9
03078 0B18           77           08            ja  	.5A
03079                       00000B1A            .5B:
03080                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03081 0B1A           8B46         F2            mov	ax,-$E[bp]
03082 0B1D           05                   0030  add	ax,*$30
03083 0B20           EB           09            jmp .5C
03084                       00000B22            .5A:
03085                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03086 0B22           8B46         F2            mov	ax,-$E[bp]
03087                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03088 0B25           05                   FFF6  add	ax,*-$A
03089 0B28           0346         EA            add	ax,-$16[bp]
03090                       00000B2B            .5C:
03091                                           ! Debug: list unsigned int = ax+0 (used reg = )
03092 0B2B           50                         push	ax
03093                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03094 0B2C           FF76         04            push	4[bp]
03095                                           ! Debug: func () void = send+0 (used reg = )
03096 0B2F           E8         FB95            call	_send
03097 0B32           83C4                   04  add	sp,*4
03098                                           !BCC_EOS
03099                                           ! 1100             }
03100                                           ! 1101           }
03101                       00000B35            .57:
03102                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03103 0B35           8B46         FA            mov	ax,-6[bp]
03104 0B38           48                         dec	ax
03105 0B39           8946         FA            mov	-6[bp],ax
03106                       00000B3C            .58:
03107                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03108 0B3C           8B46         FA            mov	ax,-6[bp]
03109 0B3F           85C0                       test	ax,ax
03110 0B41           7D           B8            jge	.59
03111                       00000B43            .5D:
03112                       00000B43            .56:
03113                                           ! 1102         else if (c == 'u') {
03114 0B43           E9         0264            br 	.5E
03115                       00000B46            .4E:
03116                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03117 0B46           8A46         FF            mov	al,-1[bp]
03118 0B49           3C                     75  cmp	al,*$75
03119 0B4B           75           15            jne 	.5F
03120                       00000B4D            .60:
03121                                           ! 1103           put_uint(action, arg, format_width, 0);
03122                                           ! Debug: list int = const 0 (used reg = )
03123 0B4D           31C0                       xor	ax,ax
03124 0B4F           50                         push	ax
03125                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03126 0B50           FF76         EC            push	-$14[bp]
03127                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03128 0B53           FF76         F4            push	-$C[bp]
03129                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03130 0B56           FF76         04            push	4[bp]
03131                                           ! Debug: func () void = put_uint+0 (used reg = )
03132 0B59           E8         FC58            call	_put_uint
03133 0B5C           83C4                   08  add	sp,*8
03134                                           !BCC_EOS
03135                                           ! 1104           }
03136                                           ! 1105         else if (c == 'l') {
03137 0B5F           E9         0248            br 	.61
03138                       00000B62            .5F:
03139                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03140 0B62           8A46         FF            mov	al,-1[bp]
03141 0B65           3C                     6C  cmp	al,*$6C
03142 0B67         0F85         018F            bne 	.62
03143                       00000B6B            .63:
03144                                           ! 1106           s++;
03145                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03146 0B6B           8B5E         06            mov	bx,6[bp]
03147 0B6E           43                         inc	bx
03148 0B6F           895E         06            mov	6[bp],bx
03149                                           !BCC_EOS
03150                                           ! 1107           c = read_byte(get_CS(), s);
03151                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03152 0B72           FF76         06            push	6[bp]
03153                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03154 0B75           E8         FAD2            call	_get_CS
03155                                           ! Debug: list unsigned short = ax+0 (used reg = )
03156 0B78           50                         push	ax
03157                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03158 0B79           E8         FA78            call	_read_byte
03159 0B7C           83C4                   04  add	sp,*4
03160                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03161 0B7F           8846         FF            mov	-1[bp],al
03162                                           !BCC_EOS
03163                                           ! 1108           arg_ptr++;
03164                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03165 0B82           8B5E         F8            mov	bx,-8[bp]
03166 0B85           43                         inc	bx
03167 0B86           43                         inc	bx
03168 0B87           895E         F8            mov	-8[bp],bx
03169                                           !BCC_EOS
03170                                           ! 1109           hibyte = read_word(arg_seg, arg_ptr);
03171                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03172 0B8A           FF76         F8            push	-8[bp]
03173                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03174 0B8D           FF76         F6            push	-$A[bp]
03175                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03176 0B90           E8         FA74            call	_read_word
03177 0B93           83C4                   04  add	sp,*4
03178                                           ! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
03179 0B96           8946         F0            mov	-$10[bp],ax
03180                                           !BCC_EOS
03181                                           ! 1110           if (c == 'd') {
03182                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03183 0B99           8A46         FF            mov	al,-1[bp]
03184 0B9C           3C                     64  cmp	al,*$64
03185 0B9E         0F85         0073            bne 	.64
03186                       00000BA2            .65:
03187                                           ! 1111             if (hibyte & 0x8000)
03188                                           ! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
03189 0BA2           8B46         F0            mov	ax,-$10[bp]
03190 0BA5           25                   8000  and	ax,#$8000
03191 0BA8           85C0                       test	ax,ax
03192 0BAA           74           3D            je  	.66
03193                       00000BAC            .67:
03194                                           ! 1112               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
03195                                           ! Debug: list int = const 1 (used reg = )
03196 0BAC           B8                   0001  mov	ax,*1
03197 0BAF           50                         push	ax
03198                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03199 0BB0           8B46         EC            mov	ax,-$14[bp]
03200                                           ! Debug: list unsigned int = ax-1 (used reg = )
03201 0BB3           48                         dec	ax
03202 0BB4           50                         push	ax
03203                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03204 0BB5           8B46         F4            mov	ax,-$C[bp]
03205 0BB8           31DB                       xor	bx,bx
03206 0BBA           53                         push	bx
03207 0BBB           50                         push	ax
03208                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03209 0BBC           8B46         F0            mov	ax,-$10[bp]
03210 0BBF           31DB                       xor	bx,bx
03211                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03212 0BC1           93                         xchg	bx,ax
03213 0BC2           31C0                       xor	ax,ax
03214                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03215 0BC4           8D7E         E2            lea	di,-$1E[bp]
03216 0BC7           E8         F53D            call	lorul
03217 0BCA           83C4                   04  add	sp,*4
03218                                           ! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
03219 0BCD           53                         push	bx
03220 0BCE           50                         push	ax
03221 0BCF           31C0                       xor	ax,ax
03222 0BD1           31DB                       xor	bx,bx
03223 0BD3           8D7E         E2            lea	di,-$1E[bp]
03224 0BD6           E8         F508            call	lsubul
03225 0BD9           83C4                   04  add	sp,*4
03226                                           ! Debug: list unsigned long = bx+0 (used reg = )
03227 0BDC           53                         push	bx
03228 0BDD           50                         push	ax
03229                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03230 0BDE           FF76         04            push	4[bp]
03231                                           ! Debug: func () void = put_luint+0 (used reg = )
03232 0BE1           E8         FC53            call	_put_luint
03233 0BE4           83C4                   0A  add	sp,*$A
03234                                           !BCC_EOS
03235                                           ! 1113             else
03236                                           ! 1114               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03237 0BE7           EB           29            jmp .68
03238                       00000BE9            .66:
03239                                           ! Debug: list int = const 0 (used reg = )
03240 0BE9           31C0                       xor	ax,ax
03241 0BEB           50                         push	ax
03242                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03243 0BEC           FF76         EC            push	-$14[bp]
03244                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03245 0BEF           8B46         F4            mov	ax,-$C[bp]
03246 0BF2           31DB                       xor	bx,bx
03247 0BF4           53                         push	bx
03248 0BF5           50                         push	ax
03249                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03250 0BF6           8B46         F0            mov	ax,-$10[bp]
03251 0BF9           31DB                       xor	bx,bx
03252                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03253 0BFB           93                         xchg	bx,ax
03254 0BFC           31C0                       xor	ax,ax
03255                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03256 0BFE           8D7E         E2            lea	di,-$1E[bp]
03257 0C01           E8         F503            call	lorul
03258 0C04           83C4                   04  add	sp,*4
03259                                           ! Debug: list unsigned long = bx+0 (used reg = )
03260 0C07           53                         push	bx
03261 0C08           50                         push	ax
03262                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03263 0C09           FF76         04            push	4[bp]
03264                                           ! Debug: func () void = put_luint+0 (used reg = )
03265 0C0C           E8         FC28            call	_put_luint
03266 0C0F           83C4                   0A  add	sp,*$A
03267                                           !BCC_EOS
03268                                           ! 1115            }
03269                       00000C12            .68:
03270                                           ! 1116           else if (c == 'u') {
03271 0C12           E9         00E2            br 	.69
03272                       00000C15            .64:
03273                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03274 0C15           8A46         FF            mov	al,-1[bp]
03275 0C18           3C                     75  cmp	al,*$75
03276 0C1A           75           2C            jne 	.6A
03277                       00000C1C            .6B:
03278                                           ! 1117             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03279                                           ! Debug: list int = const 0 (used reg = )
03280 0C1C           31C0                       xor	ax,ax
03281 0C1E           50                         push	ax
03282                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03283 0C1F           FF76         EC            push	-$14[bp]
03284                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03285 0C22           8B46         F4            mov	ax,-$C[bp]
03286 0C25           31DB                       xor	bx,bx
03287 0C27           53                         push	bx
03288 0C28           50                         push	ax
03289                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03290 0C29           8B46         F0            mov	ax,-$10[bp]
03291 0C2C           31DB                       xor	bx,bx
03292                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03293 0C2E           93                         xchg	bx,ax
03294 0C2F           31C0                       xor	ax,ax
03295                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03296 0C31           8D7E         E2            lea	di,-$1E[bp]
03297 0C34           E8         F4D0            call	lorul
03298 0C37           83C4                   04  add	sp,*4
03299                                           ! Debug: list unsigned long = bx+0 (used reg = )
03300 0C3A           53                         push	bx
03301 0C3B           50                         push	ax
03302                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03303 0C3C           FF76         04            push	4[bp]
03304                                           ! Debug: func () void = put_luint+0 (used reg = )
03305 0C3F           E8         FBF5            call	_put_luint
03306 0C42           83C4                   0A  add	sp,*$A
03307                                           !BCC_EOS
03308                                           ! 1118            }
03309                                           ! 1119           else if (c == 'x' || c == 'X')
03310 0C45           E9         00AF            br 	.6C
03311                       00000C48            .6A:
03312                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03313 0C48           8A46         FF            mov	al,-1[bp]
03314 0C4B           3C                     78  cmp	al,*$78
03315 0C4D           74           09            je  	.6E
03316                       00000C4F            .6F:
03317                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03318 0C4F           8A46         FF            mov	al,-1[bp]
03319 0C52           3C                     58  cmp	al,*$58
03320 0C54         0F85         009F            bne 	.6D
03321                       00000C58            .6E:
03322                                           ! 1120            {
03323                                           ! 1121             if (format_width == 0)
03324                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03325 0C58           8B46         EC            mov	ax,-$14[bp]
03326 0C5B           85C0                       test	ax,ax
03327 0C5D           75           06            jne 	.70
03328                       00000C5F            .71:
03329                                           ! 1122               format_width = 8;
03330                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
03331 0C5F           B8                   0008  mov	ax,*8
03332 0C62           8946         EC            mov	-$14[bp],ax
03333                                           !BCC_EOS
03334                                           ! 1123             if (c == 'x')
03335                       00000C65            .70:
03336                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03337 0C65           8A46         FF            mov	al,-1[bp]
03338 0C68           3C                     78  cmp	al,*$78
03339 0C6A           75           08            jne 	.72
03340                       00000C6C            .73:
03341                                           ! 1124               hexadd = 'a';
03342                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03343 0C6C           B8                   0061  mov	ax,*$61
03344 0C6F           8946         EA            mov	-$16[bp],ax
03345                                           !BCC_EOS
03346                                           ! 1125             else
03347                                           ! 1126               hexadd = 'A';
03348 0C72           EB           06            jmp .74
03349                       00000C74            .72:
03350                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03351 0C74           B8                   0041  mov	ax,*$41
03352 0C77           8946         EA            mov	-$16[bp],ax
03353                                           !BCC_EOS
03354                                           ! 1127             for (i=format_width-1; i>=0; i--) {
03355                       00000C7A            .74:
03356                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03357 0C7A           8B46         EC            mov	ax,-$14[bp]
03358                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03359 0C7D           48                         dec	ax
03360 0C7E           8946         FA            mov	-6[bp],ax
03361                                           !BCC_EOS
03362                                           !BCC_EOS
03363 0C81           EB           6D            jmp .77
03364                       00000C83            .78:
03365                                           ! 1128             
03366                                           ! 1128   nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
03367                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03368                                           ! Debug: expression subtree swapping
03369 0C83           8B46         FA            mov	ax,-6[bp]
03370 0C86           D1E0                       shl	ax,*1
03371 0C88           D1E0                       shl	ax,*1
03372 0C8A           50                         push	ax
03373                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
03374 0C8B           8B46         F4            mov	ax,-$C[bp]
03375 0C8E           31DB                       xor	bx,bx
03376 0C90           53                         push	bx
03377 0C91           50                         push	ax
03378                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
03379 0C92           8B46         F0            mov	ax,-$10[bp]
03380 0C95           31DB                       xor	bx,bx
03381                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03382 0C97           93                         xchg	bx,ax
03383 0C98           31C0                       xor	ax,ax
03384                                           ! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
03385 0C9A           8D7E         E4            lea	di,-$1C[bp]
03386 0C9D           E8         F467            call	lorul
03387 0CA0           83C4                   04  add	sp,*4
03388                                           ! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
03389 0CA3           8B7E         E8            mov	di,-$18[bp]
03390 0CA6           E8         F480            call	lsrul
03391 0CA9           44                         inc	sp
03392 0CAA           44                         inc	sp
03393                                           ! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
03394 0CAB           53                         push	bx
03395 0CAC           50                         push	ax
03396 0CAD           B8                   000F  mov	ax,*$F
03397 0CB0           31DB                       xor	bx,bx
03398 0CB2           53                         push	bx
03399 0CB3           50                         push	ax
03400 0CB4           8B46         E6            mov	ax,-$1A[bp]
03401 0CB7           8B5E         E8            mov	bx,-$18[bp]
03402 0CBA           8D7E         E2            lea	di,-$1E[bp]
03403 0CBD           E8         F3FB            call	landul
03404 0CC0           83C4                   08  add	sp,*8
03405                                           ! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03406 0CC3           8946         F2            mov	-$E[bp],ax
03407                                           !BCC_EOS
03408                                           ! 1129               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03409                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03410 0CC6           8B46         F2            mov	ax,-$E[bp]
03411 0CC9           3D                   0009  cmp	ax,*9
03412 0CCC           77           08            ja  	.79
03413                       00000CCE            .7A:
03414                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03415 0CCE           8B46         F2            mov	ax,-$E[bp]
03416 0CD1           05                   0030  add	ax,*$30
03417 0CD4           EB           09            jmp .7B
03418                       00000CD6            .79:
03419                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03420 0CD6           8B46         F2            mov	ax,-$E[bp]
03421                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03422 0CD9           05                   FFF6  add	ax,*-$A
03423 0CDC           0346         EA            add	ax,-$16[bp]
03424                       00000CDF            .7B:
03425                                           ! Debug: list unsigned int = ax+0 (used reg = )
03426 0CDF           50                         push	ax
03427                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03428 0CE0           FF76         04            push	4[bp]
03429                                           ! Debug: func () void = send+0 (used reg = )
03430 0CE3           E8         F9E1            call	_send
03431 0CE6           83C4                   04  add	sp,*4
03432                                           !BCC_EOS
03433                                           ! 1130               }
03434                                           ! 1131            }
03435                       00000CE9            .76:
03436                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03437 0CE9           8B46         FA            mov	ax,-6[bp]
03438 0CEC           48                         dec	ax
03439 0CED           8946         FA            mov	-6[bp],ax
03440                       00000CF0            .77:
03441                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03442 0CF0           8B46         FA            mov	ax,-6[bp]
03443 0CF3           85C0                       test	ax,ax
03444 0CF5           7D           8C            jge	.78
03445                       00000CF7            .7C:
03446                       00000CF7            .75:
03447                                           ! 1132           }
03448                       00000CF7            .6D:
03449                       00000CF7            .6C:
03450                       00000CF7            .69:
03451                                           ! 1133         else if (c == 'd') {
03452 0CF7           E9         00B0            br 	.7D
03453                       00000CFA            .62:
03454                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03455 0CFA           8A46         FF            mov	al,-1[bp]
03456 0CFD           3C                     64  cmp	al,*$64
03457 0CFF           75           38            jne 	.7E
03458                       00000D01            .7F:
03459                                           ! 1134           if (arg & 0x8000)
03460                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
03461 0D01           8B46         F4            mov	ax,-$C[bp]
03462 0D04           25                   8000  and	ax,#$8000
03463 0D07           85C0                       test	ax,ax
03464 0D09           74           1A            je  	.80
03465                       00000D0B            .81:
03466                                           ! 1135             put_int(action, -arg, format_width - 1, 1);
03467                                           ! Debug: list int = const 1 (used reg = )
03468 0D0B           B8                   0001  mov	ax,*1
03469 0D0E           50                         push	ax
03470                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03471 0D0F           8B46         EC            mov	ax,-$14[bp]
03472                                           ! Debug: list unsigned int = ax-1 (used reg = )
03473 0D12           48                         dec	ax
03474 0D13           50                         push	ax
03475                                           ! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
03476 0D14           31C0                       xor	ax,ax
03477 0D16           2B46         F4            sub	ax,-$C[bp]
03478                                           ! Debug: list unsigned int = ax+0 (used reg = )
03479 0D19           50                         push	ax
03480                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03481 0D1A           FF76         04            push	4[bp]
03482                                           ! Debug: func () void = put_int+0 (used reg = )
03483 0D1D           E8         FA0F            call	_put_int
03484 0D20           83C4                   08  add	sp,*8
03485                                           !BCC_EOS
03486                                           ! 1136           else
03487                                           ! 1137             put_int(action, arg, format_width, 0);
03488 0D23           EB           12            jmp .82
03489                       00000D25            .80:
03490                                           ! Debug: list int = const 0 (used reg = )
03491 0D25           31C0                       xor	ax,ax
03492 0D27           50                         push	ax
03493                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03494 0D28           FF76         EC            push	-$14[bp]
03495                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03496 0D2B           FF76         F4            push	-$C[bp]
03497                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03498 0D2E           FF76         04            push	4[bp]
03499                                           ! Debug: func () void = put_int+0 (used reg = )
03500 0D31           E8         F9FB            call	_put_int
03501 0D34           83C4                   08  add	sp,*8
03502                                           !BCC_EOS
03503                                           ! 1138           }
03504                       00000D37            .82:
03505                                           ! 1139         else if (c == 's') {
03506 0D37           EB           71            jmp .83
03507                       00000D39            .7E:
03508                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03509 0D39           8A46         FF            mov	al,-1[bp]
03510 0D3C           3C                     73  cmp	al,*$73
03511 0D3E           75           12            jne 	.84
03512                       00000D40            .85:
03513                                           ! 1140           put_str(action, get_CS(), arg);
03514                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03515 0D40           FF76         F4            push	-$C[bp]
03516                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03517 0D43           E8         F904            call	_get_CS
03518                                           ! Debug: list unsigned short = ax+0 (used reg = )
03519 0D46           50                         push	ax
03520                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03521 0D47           FF76         04            push	4[bp]
03522                                           ! Debug: func () void = put_str+0 (used reg = )
03523 0D4A           E8         FBA1            call	_put_str
03524 0D4D           83C4                   06  add	sp,*6
03525                                           !BCC_EOS
03526                                           ! 1141           }
03527                                           ! 1142         else if (c == 'S') {
03528 0D50           EB           58            jmp .86
03529                       00000D52            .84:
03530                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03531 0D52           8A46         FF            mov	al,-1[bp]
03532 0D55           3C                     53  cmp	al,*$53
03533 0D57           75           2E            jne 	.87
03534                       00000D59            .88:
03535                                           ! 1143           hibyte = arg;
03536                                           ! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
03537 0D59           8B46         F4            mov	ax,-$C[bp]
03538 0D5C           8946         F0            mov	-$10[bp],ax
03539                                           !BCC_EOS
03540                                           ! 1144           arg_ptr++;
03541                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03542 0D5F           8B5E         F8            mov	bx,-8[bp]
03543 0D62           43                         inc	bx
03544 0D63           43                         inc	bx
03545 0D64           895E         F8            mov	-8[bp],bx
03546                                           !BCC_EOS
03547                                           ! 1145           arg = read_word(arg_seg, arg_ptr);
03548                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03549 0D67           FF76         F8            push	-8[bp]
03550                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03551 0D6A           FF76         F6            push	-$A[bp]
03552                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03553 0D6D           E8         F897            call	_read_word
03554 0D70           83C4                   04  add	sp,*4
03555                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03556 0D73           8946         F4            mov	-$C[bp],ax
03557                                           !BCC_EOS
03558                                           ! 1146           put_str(action, hibyte, arg);
03559                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03560 0D76           FF76         F4            push	-$C[bp]
03561                                           ! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
03562 0D79           FF76         F0            push	-$10[bp]
03563                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03564 0D7C           FF76         04            push	4[bp]
03565                                           ! Debug: func () void = put_str+0 (used reg = )
03566 0D7F           E8         FB6C            call	_put_str
03567 0D82           83C4                   06  add	sp,*6
03568                                           !BCC_EOS
03569                                           ! 1147           }
03570                                           ! 1148         else if (c == 'c') {
03571 0D85           EB           23            jmp .89
03572                       00000D87            .87:
03573                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03574 0D87           8A46         FF            mov	al,-1[bp]
03575 0D8A           3C                     63  cmp	al,*$63
03576 0D8C           75           0E            jne 	.8A
03577                       00000D8E            .8B:
03578                                           ! 1149           send(action, arg);
03579                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03580 0D8E           FF76         F4            push	-$C[bp]
03581                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03582 0D91           FF76         04            push	4[bp]
03583                                           ! Debug: func () void = send+0 (used reg = )
03584 0D94           E8         F930            call	_send
03585 0D97           83C4                   04  add	sp,*4
03586                                           !BCC_EOS
03587                                           ! 1150           }
03588                                           ! 1151         else
03589                                           ! 1152           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03590 0D9A           EB           0E            jmp .8C
03591                       00000D9C            .8A:
03592                                           ! Debug: list * char = .8D+0 (used reg = )
03593 0D9C           BB                   D5CC  mov	bx,#.8D
03594 0D9F           53                         push	bx
03595                                           ! Debug: list int = const 7 (used reg = )
03596 0DA0           B8                   0007  mov	ax,*7
03597 0DA3           50                         push	ax
03598                                           ! Debug: func () void = bios_printf+0 (used reg = )
03599 0DA4           E8         FC74            call	_bios_printf
03600 0DA7           83C4                   04  add	sp,*4
03601                                           !BCC_EOS
03602                                           ! 1153           in_format = 0;
03603                       00000DAA            .8C:
03604                       00000DAA            .89:
03605                       00000DAA            .86:
03606                       00000DAA            .83:
03607                       00000DAA            .7D:
03608                       00000DAA            .61:
03609                       00000DAA            .5E:
03610                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03611 0DAA           31C0                       xor	ax,ax
03612 0DAC           8946         FC            mov	-4[bp],ax
03613                                           !BCC_EOS
03614                                           ! 1154         }
03615                                           ! 1155       }
03616                       00000DAF            .4D:
03617                                           ! 1156     else {
03618 0DAF           EB           0F            jmp .8E
03619                       00000DB1            .48:
03620                                           ! 1157       send(action, c);
03621                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03622 0DB1           8A46         FF            mov	al,-1[bp]
03623 0DB4           30E4                       xor	ah,ah
03624 0DB6           50                         push	ax
03625                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03626 0DB7           FF76         04            push	4[bp]
03627                                           ! Debug: func () void = send+0 (used reg = )
03628 0DBA           E8         F90A            call	_send
03629 0DBD           83C4                   04  add	sp,*4
03630                                           !BCC_EOS
03631                                           ! 1158       }
03632                                           ! 1159     s ++;
03633                       00000DC0            .8E:
03634                       00000DC0            .47:
03635                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03636 0DC0           8B5E         06            mov	bx,6[bp]
03637 0DC3           43                         inc	bx
03638 0DC4           895E         06            mov	6[bp],bx
03639                                           !BCC_EOS
03640                                           ! 1160     }
03641                                           ! 1161   if (action & 1) {
03642                       00000DC7            .43:
03643                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03644 0DC7           FF76         06            push	6[bp]
03645                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03646 0DCA           E8         F87D            call	_get_CS
03647                                           ! Debug: list unsigned short = ax+0 (used reg = )
03648 0DCD           50                         push	ax
03649                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03650 0DCE           E8         F823            call	_read_byte
03651 0DD1           83C4                   04  add	sp,*4
03652                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03653 0DD4           8846         FF            mov	-1[bp],al
03654 0DD7           84C0                       test	al,al
03655 0DD9         0F85         FC81            bne 	.44
03656                       00000DDD            .8F:
03657                       00000DDD            .42:
03658                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03659 0DDD           8A46         04            mov	al,4[bp]
03660 0DE0           24                     01  and	al,*1
03661 0DE2           84C0                       test	al,al
03662 0DE4           74           04            je  	.90
03663                       00000DE6            .91:
03664                                           ! 1162 #asm
03665                                           !BCC_EOS
03666                                           !BCC_ASM
03667                       00000002            _bios_printf.format_width	set	2
03668                       FFFFFFEC            .bios_printf.format_width	set	-$14
03669                       00000014            _bios_printf.format_char	set	$14
03670                       FFFFFFFE            .bios_printf.format_char	set	-2
03671                       00000006            _bios_printf.hibyte	set	6
03672                       FFFFFFF0            .bios_printf.hibyte	set	-$10
03673                       0000000E            _bios_printf.arg_ptr	set	$E
03674                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03675                       0000001A            _bios_printf.action	set	$1A
03676                       00000004            .bios_printf.action	set	4
03677                       00000010            _bios_printf.i	set	$10
03678                       FFFFFFFA            .bios_printf.i	set	-6
03679                       0000000C            _bios_printf.arg_seg	set	$C
03680                       FFFFFFF6            .bios_printf.arg_seg	set	-$A
03681                       00000004            _bios_printf.shift_count	set	4
03682                       FFFFFFEE            .bios_printf.shift_count	set	-$12
03683                       00000012            _bios_printf.in_format	set	$12
03684                       FFFFFFFC            .bios_printf.in_format	set	-4
03685                       0000001C            _bios_printf.s	set	$1C
03686                       00000006            .bios_printf.s	set	6
03687                       00000008            _bios_printf.nibble	set	8
03688                       FFFFFFF2            .bios_printf.nibble	set	-$E
03689                       00000015            _bios_printf.c	set	$15
03690                       FFFFFFFF            .bios_printf.c	set	-1
03691                       00000000            _bios_printf.hexadd	set	0
03692                       FFFFFFEA            .bios_printf.hexadd	set	-$16
03693                       0000000A            _bios_printf.arg	set	$A
03694                       FFFFFFF4            .bios_printf.arg	set	-$C
03695 0DE6           FA                             cli
03696                       00000DE7             halt2_loop:
03697 0DE7           F4                             hlt
03698 0DE8           EB           FD                jmp halt2_loop
03699                                           ! 1167 endasm
03700                                           !BCC_ENDASM
03701                                           !BCC_EOS
03702                                           ! 1168     }
03703                                           ! 1169 }
03704                       00000DEA            .90:
03705 0DEA           89EC                       mov	sp,bp
03706 0DEC           5D                         pop	bp
03707 0DED           C3                         ret
03708                                           ! 1170   void
03709                                           ! Register BX used in function bios_printf
03710                                           ! 1171 keyboard_init()
03711                                           ! 1172 {
03712                                           export	_keyboard_init
03713                       00000DEE            _keyboard_init:
03714                                           ! 1173     Bit16u max;
03715                                           !BCC_EOS
03716                                           ! 1174     max=0xffff;
03717 0DEE           55                         push	bp
03718 0DEF           89E5                       mov	bp,sp
03719 0DF1           4C                         dec	sp
03720 0DF2           4C                         dec	sp
03721                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03722 0DF3           B8                   FFFF  mov	ax,#$FFFF
03723 0DF6           8946         FE            mov	-2[bp],ax
03724                                           !BCC_EOS
03725                                           ! 1175     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03726 0DF9           EB           0D            jmp .93
03727                       00000DFB            .94:
03728                                           ! Debug: list int = const 0 (used reg = )
03729 0DFB           31C0                       xor	ax,ax
03730 0DFD           50                         push	ax
03731                                           ! Debug: list int = const $80 (used reg = )
03732 0DFE           B8                   0080  mov	ax,#$80
03733 0E01           50                         push	ax
03734                                           ! Debug: func () void = outb+0 (used reg = )
03735 0E02           E8         F74F            call	_outb
03736 0E05           83C4                   04  add	sp,*4
03737                                           !BCC_EOS
03738                                           ! 1176     max=2;
03739                       00000E08            .93:
03740                                           ! Debug: list int = const $64 (used reg = )
03741 0E08           B8                   0064  mov	ax,*$64
03742 0E0B           50                         push	ax
03743                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03744 0E0C           E8         F72F            call	_inb
03745 0E0F           44                         inc	sp
03746 0E10           44                         inc	sp
03747                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03748 0E11           24                     02  and	al,*2
03749 0E13           84C0                       test	al,al
03750 0E15           74           0B            je  	.95
03751                       00000E17            .96:
03752                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03753 0E17           8B46         FE            mov	ax,-2[bp]
03754 0E1A           48                         dec	ax
03755 0E1B           8946         FE            mov	-2[bp],ax
03756                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03757 0E1E           85C0                       test	ax,ax
03758 0E20           75           D9            jne	.94
03759                       00000E22            .95:
03760                       00000E22            .92:
03761                                           ! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
03762 0E22           B8                   0002  mov	ax,*2
03763 0E25           8946         FE            mov	-2[bp],ax
03764                                           !BCC_EOS
03765                                           ! 1177     while (--max > 0) {
03766 0E28           EB           2B            jmp .98
03767                       00000E2A            .99:
03768                                           ! 1178         outb(0x80, 0x00);
03769                                           ! Debug: list int = const 0 (used reg = )
03770 0E2A           31C0                       xor	ax,ax
03771 0E2C           50                         push	ax
03772                                           ! Debug: list int = const $80 (used reg = )
03773 0E2D           B8                   0080  mov	ax,#$80
03774 0E30           50                         push	ax
03775                                           ! Debug: func () void = outb+0 (used reg = )
03776 0E31           E8         F720            call	_outb
03777 0E34           83C4                   04  add	sp,*4
03778                                           !BCC_EOS
03779                                           ! 1179         if (inb(0x64) & 0x01) {
03780                                           ! Debug: list int = const $64 (used reg = )
03781 0E37           B8                   0064  mov	ax,*$64
03782 0E3A           50                         push	ax
03783                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03784 0E3B           E8         F700            call	_inb
03785 0E3E           44                         inc	sp
03786 0E3F           44                         inc	sp
03787                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03788 0E40           24                     01  and	al,*1
03789 0E42           84C0                       test	al,al
03790 0E44           74           0F            je  	.9A
03791                       00000E46            .9B:
03792                                           ! 1180             inb(0x60);
03793                                           ! Debug: list int = const $60 (used reg = )
03794 0E46           B8                   0060  mov	ax,*$60
03795 0E49           50                         push	ax
03796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03797 0E4A           E8         F6F1            call	_inb
03798 0E4D           44                         inc	sp
03799 0E4E           44                         inc	sp
03800                                           !BCC_EOS
03801                                           ! 1181             max = 2;
03802                                           ! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
03803 0E4F           B8                   0002  mov	ax,*2
03804 0E52           8946         FE            mov	-2[bp],ax
03805                                           !BCC_EOS
03806                                           ! 1182             }
03807                                           ! 1183         }
03808                       00000E55            .9A:
03809                                           ! 1184     outb(0x64, 0xaa);
03810                       00000E55            .98:
03811                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03812 0E55           8B46         FE            mov	ax,-2[bp]
03813 0E58           48                         dec	ax
03814 0E59           8946         FE            mov	-2[bp],ax
03815                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03816 0E5C           85C0                       test	ax,ax
03817 0E5E           75           CA            jne	.99
03818                       00000E60            .9C:
03819                       00000E60            .97:
03820                                           ! Debug: list int = const $AA (used reg = )
03821 0E60           B8                   00AA  mov	ax,#$AA
03822 0E63           50                         push	ax
03823                                           ! Debug: list int = const $64 (used reg = )
03824 0E64           B8                   0064  mov	ax,*$64
03825 0E67           50                         push	ax
03826                                           ! Debug: func () void = outb+0 (used reg = )
03827 0E68           E8         F6E9            call	_outb
03828 0E6B           83C4                   04  add	sp,*4
03829                                           !BCC_EOS
03830                                           ! 1185     max=0xffff;
03831                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03832 0E6E           B8                   FFFF  mov	ax,#$FFFF
03833 0E71           8946         FE            mov	-2[bp],ax
03834                                           !BCC_EOS
03835                                           ! 1186     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03836 0E74           EB           0D            jmp .9E
03837                       00000E76            .9F:
03838                                           ! Debug: list int = const 0 (used reg = )
03839 0E76           31C0                       xor	ax,ax
03840 0E78           50                         push	ax
03841                                           ! Debug: list int = const $80 (used reg = )
03842 0E79           B8                   0080  mov	ax,#$80
03843 0E7C           50                         push	ax
03844                                           ! Debug: func () void = outb+0 (used reg = )
03845 0E7D           E8         F6D4            call	_outb
03846 0E80           83C4                   04  add	sp,*4
03847                                           !BCC_EOS
03848                                           ! 1187     if (max==0x0) keyboard_panic(00);
03849                       00000E83            .9E:
03850                                           ! Debug: list int = const $64 (used reg = )
03851 0E83           B8                   0064  mov	ax,*$64
03852 0E86           50                         push	ax
03853                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03854 0E87           E8         F6B4            call	_inb
03855 0E8A           44                         inc	sp
03856 0E8B           44                         inc	sp
03857                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03858 0E8C           24                     02  and	al,*2
03859 0E8E           84C0                       test	al,al
03860 0E90           74           0B            je  	.A0
03861                       00000E92            .A1:
03862                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03863 0E92           8B46         FE            mov	ax,-2[bp]
03864 0E95           48                         dec	ax
03865 0E96           8946         FE            mov	-2[bp],ax
03866                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03867 0E99           85C0                       test	ax,ax
03868 0E9B           75           D9            jne	.9F
03869                       00000E9D            .A0:
03870                       00000E9D            .9D:
03871                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03872 0E9D           8B46         FE            mov	ax,-2[bp]
03873 0EA0           85C0                       test	ax,ax
03874 0EA2           75           08            jne 	.A2
03875                       00000EA4            .A3:
03876                                           ! Debug: list int = const 0 (used reg = )
03877 0EA4           31C0                       xor	ax,ax
03878 0EA6           50                         push	ax
03879                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03880 0EA7           E8         0408            call	_keyboard_panic
03881 0EAA           44                         inc	sp
03882 0EAB           44                         inc	sp
03883                                           !BCC_EOS
03884                                           ! 1188     max=0xffff;
03885                       00000EAC            .A2:
03886                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03887 0EAC           B8                   FFFF  mov	ax,#$FFFF
03888 0EAF           8946         FE            mov	-2[bp],ax
03889                                           !BCC_EOS
03890                                           ! 1189     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
03891 0EB2           EB           0E            jmp .A5
03892                       00000EB4            .A6:
03893                                           ! Debug: list int = const 1 (used reg = )
03894 0EB4           B8                   0001  mov	ax,*1
03895 0EB7           50                         push	ax
03896                                           ! Debug: list int = const $80 (used reg = )
03897 0EB8           B8                   0080  mov	ax,#$80
03898 0EBB           50                         push	ax
03899                                           ! Debug: func () void = outb+0 (used reg = )
03900 0EBC           E8         F695            call	_outb
03901 0EBF           83C4                   04  add	sp,*4
03902                                           !BCC_EOS
03903                                           ! 1190     if (max==0x0) keyboard_panic(01);
03904                       00000EC2            .A5:
03905                                           ! Debug: list int = const $64 (used reg = )
03906 0EC2           B8                   0064  mov	ax,*$64
03907 0EC5           50                         push	ax
03908                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03909 0EC6           E8         F675            call	_inb
03910 0EC9           44                         inc	sp
03911 0ECA           44                         inc	sp
03912                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03913 0ECB           24                     01  and	al,*1
03914                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03915 0ECD           84C0                       test	al,al
03916 0ECF           75           0B            jne 	.A7
03917                       00000ED1            .A8:
03918                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03919 0ED1           8B46         FE            mov	ax,-2[bp]
03920 0ED4           48                         dec	ax
03921 0ED5           8946         FE            mov	-2[bp],ax
03922                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03923 0ED8           85C0                       test	ax,ax
03924 0EDA           75           D8            jne	.A6
03925                       00000EDC            .A7:
03926                       00000EDC            .A4:
03927                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03928 0EDC           8B46         FE            mov	ax,-2[bp]
03929 0EDF           85C0                       test	ax,ax
03930 0EE1           75           09            jne 	.A9
03931                       00000EE3            .AA:
03932                                           ! Debug: list int = const 1 (used reg = )
03933 0EE3           B8                   0001  mov	ax,*1
03934 0EE6           50                         push	ax
03935                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03936 0EE7           E8         03C8            call	_keyboard_panic
03937 0EEA           44                         inc	sp
03938 0EEB           44                         inc	sp
03939                                           !BCC_EOS
03940                                           ! 1191     if ((inb(0x60) != 0x55)){
03941                       00000EEC            .A9:
03942                                           ! Debug: list int = const $60 (used reg = )
03943 0EEC           B8                   0060  mov	ax,*$60
03944 0EEF           50                         push	ax
03945                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03946 0EF0           E8         F64B            call	_inb
03947 0EF3           44                         inc	sp
03948 0EF4           44                         inc	sp
03949                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03950 0EF5           3C                     55  cmp	al,*$55
03951 0EF7           74           09            je  	.AB
03952                       00000EF9            .AC:
03953                                           ! 1192         keyboard_panic(991);
03954                                           ! Debug: list int = const $3DF (used reg = )
03955 0EF9           B8                   03DF  mov	ax,#$3DF
03956 0EFC           50                         push	ax
03957                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03958 0EFD           E8         03B2            call	_keyboard_panic
03959 0F00           44                         inc	sp
03960 0F01           44                         inc	sp
03961                                           !BCC_EOS
03962                                           ! 1193     }
03963                                           ! 1194     outb(0x64,0xab);
03964                       00000F02            .AB:
03965                                           ! Debug: list int = const $AB (used reg = )
03966 0F02           B8                   00AB  mov	ax,#$AB
03967 0F05           50                         push	ax
03968                                           ! Debug: list int = const $64 (used reg = )
03969 0F06           B8                   0064  mov	ax,*$64
03970 0F09           50                         push	ax
03971                                           ! Debug: func () void = outb+0 (used reg = )
03972 0F0A           E8         F647            call	_outb
03973 0F0D           83C4                   04  add	sp,*4
03974                                           !BCC_EOS
03975                                           ! 1195     max=0xffff;
03976                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03977 0F10           B8                   FFFF  mov	ax,#$FFFF
03978 0F13           8946         FE            mov	-2[bp],ax
03979                                           !BCC_EOS
03980                                           ! 1196     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
03981 0F16           EB           0E            jmp .AE
03982                       00000F18            .AF:
03983                                           ! Debug: list int = const $10 (used reg = )
03984 0F18           B8                   0010  mov	ax,*$10
03985 0F1B           50                         push	ax
03986                                           ! Debug: list int = const $80 (used reg = )
03987 0F1C           B8                   0080  mov	ax,#$80
03988 0F1F           50                         push	ax
03989                                           ! Debug: func () void = outb+0 (used reg = )
03990 0F20           E8         F631            call	_outb
03991 0F23           83C4                   04  add	sp,*4
03992                                           !BCC_EOS
03993                                           ! 1197     if (max==0x0) keyboard_panic(10);
03994                       00000F26            .AE:
03995                                           ! Debug: list int = const $64 (used reg = )
03996 0F26           B8                   0064  mov	ax,*$64
03997 0F29           50                         push	ax
03998                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03999 0F2A           E8         F611            call	_inb
04000 0F2D           44                         inc	sp
04001 0F2E           44                         inc	sp
04002                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04003 0F2F           24                     02  and	al,*2
04004 0F31           84C0                       test	al,al
04005 0F33           74           0B            je  	.B0
04006                       00000F35            .B1:
04007                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04008 0F35           8B46         FE            mov	ax,-2[bp]
04009 0F38           48                         dec	ax
04010 0F39           8946         FE            mov	-2[bp],ax
04011                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04012 0F3C           85C0                       test	ax,ax
04013 0F3E           75           D8            jne	.AF
04014                       00000F40            .B0:
04015                       00000F40            .AD:
04016                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04017 0F40           8B46         FE            mov	ax,-2[bp]
04018 0F43           85C0                       test	ax,ax
04019 0F45           75           09            jne 	.B2
04020                       00000F47            .B3:
04021                                           ! Debug: list int = const $A (used reg = )
04022 0F47           B8                   000A  mov	ax,*$A
04023 0F4A           50                         push	ax
04024                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04025 0F4B           E8         0364            call	_keyboard_panic
04026 0F4E           44                         inc	sp
04027 0F4F           44                         inc	sp
04028                                           !BCC_EOS
04029                                           ! 1198     max=0xffff;
04030                       00000F50            .B2:
04031                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04032 0F50           B8                   FFFF  mov	ax,#$FFFF
04033 0F53           8946         FE            mov	-2[bp],ax
04034                                           !BCC_EOS
04035                                           ! 1199     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
04036 0F56           EB           0E            jmp .B5
04037                       00000F58            .B6:
04038                                           ! Debug: list int = const $11 (used reg = )
04039 0F58           B8                   0011  mov	ax,*$11
04040 0F5B           50                         push	ax
04041                                           ! Debug: list int = const $80 (used reg = )
04042 0F5C           B8                   0080  mov	ax,#$80
04043 0F5F           50                         push	ax
04044                                           ! Debug: func () void = outb+0 (used reg = )
04045 0F60           E8         F5F1            call	_outb
04046 0F63           83C4                   04  add	sp,*4
04047                                           !BCC_EOS
04048                                           ! 1200     if (max==0x0) keyboard_panic(11);
04049                       00000F66            .B5:
04050                                           ! Debug: list int = const $64 (used reg = )
04051 0F66           B8                   0064  mov	ax,*$64
04052 0F69           50                         push	ax
04053                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04054 0F6A           E8         F5D1            call	_inb
04055 0F6D           44                         inc	sp
04056 0F6E           44                         inc	sp
04057                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04058 0F6F           24                     01  and	al,*1
04059                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04060 0F71           84C0                       test	al,al
04061 0F73           75           0B            jne 	.B7
04062                       00000F75            .B8:
04063                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04064 0F75           8B46         FE            mov	ax,-2[bp]
04065 0F78           48                         dec	ax
04066 0F79           8946         FE            mov	-2[bp],ax
04067                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04068 0F7C           85C0                       test	ax,ax
04069 0F7E           75           D8            jne	.B6
04070                       00000F80            .B7:
04071                       00000F80            .B4:
04072                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04073 0F80           8B46         FE            mov	ax,-2[bp]
04074 0F83           85C0                       test	ax,ax
04075 0F85           75           09            jne 	.B9
04076                       00000F87            .BA:
04077                                           ! Debug: list int = const $B (used reg = )
04078 0F87           B8                   000B  mov	ax,*$B
04079 0F8A           50                         push	ax
04080                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04081 0F8B           E8         0324            call	_keyboard_panic
04082 0F8E           44                         inc	sp
04083 0F8F           44                         inc	sp
04084                                           !BCC_EOS
04085                                           ! 1201     if ((inb(0x60) != 0x00)) {
04086                       00000F90            .B9:
04087                                           ! Debug: list int = const $60 (used reg = )
04088 0F90           B8                   0060  mov	ax,*$60
04089 0F93           50                         push	ax
04090                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04091 0F94           E8         F5A7            call	_inb
04092 0F97           44                         inc	sp
04093 0F98           44                         inc	sp
04094                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
04095 0F99           84C0                       test	al,al
04096 0F9B           74           09            je  	.BB
04097                       00000F9D            .BC:
04098                                           ! 1202         keyboard_panic(992);
04099                                           ! Debug: list int = const $3E0 (used reg = )
04100 0F9D           B8                   03E0  mov	ax,#$3E0
04101 0FA0           50                         push	ax
04102                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04103 0FA1           E8         030E            call	_keyboard_panic
04104 0FA4           44                         inc	sp
04105 0FA5           44                         inc	sp
04106                                           !BCC_EOS
04107                                           ! 1203     }
04108                                           ! 1204     outb(0x64,0xae);
04109                       00000FA6            .BB:
04110                                           ! Debug: list int = const $AE (used reg = )
04111 0FA6           B8                   00AE  mov	ax,#$AE
04112 0FA9           50                         push	ax
04113                                           ! Debug: list int = const $64 (used reg = )
04114 0FAA           B8                   0064  mov	ax,*$64
04115 0FAD           50                         push	ax
04116                                           ! Debug: func () void = outb+0 (used reg = )
04117 0FAE           E8         F5A3            call	_outb
04118 0FB1           83C4                   04  add	sp,*4
04119                                           !BCC_EOS
04120                                           ! 1205     outb(0x64,0xa8);
04121                                           ! Debug: list int = const $A8 (used reg = )
04122 0FB4           B8                   00A8  mov	ax,#$A8
04123 0FB7           50                         push	ax
04124                                           ! Debug: list int = const $64 (used reg = )
04125 0FB8           B8                   0064  mov	ax,*$64
04126 0FBB           50                         push	ax
04127                                           ! Debug: func () void = outb+0 (used reg = )
04128 0FBC           E8         F595            call	_outb
04129 0FBF           83C4                   04  add	sp,*4
04130                                           !BCC_EOS
04131                                           ! 1206     outb(0x60, 0xff);
04132                                           ! Debug: list int = const $FF (used reg = )
04133 0FC2           B8                   00FF  mov	ax,#$FF
04134 0FC5           50                         push	ax
04135                                           ! Debug: list int = const $60 (used reg = )
04136 0FC6           B8                   0060  mov	ax,*$60
04137 0FC9           50                         push	ax
04138                                           ! Debug: func () void = outb+0 (used reg = )
04139 0FCA           E8         F587            call	_outb
04140 0FCD           83C4                   04  add	sp,*4
04141                                           !BCC_EOS
04142                                           ! 1207     max=0xffff;
04143                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04144 0FD0           B8                   FFFF  mov	ax,#$FFFF
04145 0FD3           8946         FE            mov	-2[bp],ax
04146                                           !BCC_EOS
04147                                           ! 1208     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20)
04148 0FD6           EB           0E            jmp .BE
04149                       00000FD8            .BF:
04150                                           ! 1208 ;
04151                                           ! Debug: list int = const $20 (used reg = )
04152 0FD8           B8                   0020  mov	ax,*$20
04153 0FDB           50                         push	ax
04154                                           ! Debug: list int = const $80 (used reg = )
04155 0FDC           B8                   0080  mov	ax,#$80
04156 0FDF           50                         push	ax
04157                                           ! Debug: func () void = outb+0 (used reg = )
04158 0FE0           E8         F571            call	_outb
04159 0FE3           83C4                   04  add	sp,*4
04160                                           !BCC_EOS
04161                                           ! 1209     if (max==0x0) keyboard_panic(20);
04162                       00000FE6            .BE:
04163                                           ! Debug: list int = const $64 (used reg = )
04164 0FE6           B8                   0064  mov	ax,*$64
04165 0FE9           50                         push	ax
04166                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04167 0FEA           E8         F551            call	_inb
04168 0FED           44                         inc	sp
04169 0FEE           44                         inc	sp
04170                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04171 0FEF           24                     02  and	al,*2
04172 0FF1           84C0                       test	al,al
04173 0FF3           74           0B            je  	.C0
04174                       00000FF5            .C1:
04175                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04176 0FF5           8B46         FE            mov	ax,-2[bp]
04177 0FF8           48                         dec	ax
04178 0FF9           8946         FE            mov	-2[bp],ax
04179                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04180 0FFC           85C0                       test	ax,ax
04181 0FFE           75           D8            jne	.BF
04182                       00001000            .C0:
04183                       00001000            .BD:
04184                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04185 1000           8B46         FE            mov	ax,-2[bp]
04186 1003           85C0                       test	ax,ax
04187 1005           75           09            jne 	.C2
04188                       00001007            .C3:
04189                                           ! Debug: list int = const $14 (used reg = )
04190 1007           B8                   0014  mov	ax,*$14
04191 100A           50                         push	ax
04192                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04193 100B           E8         02A4            call	_keyboard_panic
04194 100E           44                         inc	sp
04195 100F           44                         inc	sp
04196                                           !BCC_EOS
04197                                           ! 1210     max=0xffff;
04198                       00001010            .C2:
04199                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04200 1010           B8                   FFFF  mov	ax,#$FFFF
04201 1013           8946         FE            mov	-2[bp],ax
04202                                           !BCC_EOS
04203                                           ! 1211     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
04204 1016           EB           0E            jmp .C5
04205                       00001018            .C6:
04206                                           ! Debug: list int = const $21 (used reg = )
04207 1018           B8                   0021  mov	ax,*$21
04208 101B           50                         push	ax
04209                                           ! Debug: list int = const $80 (used reg = )
04210 101C           B8                   0080  mov	ax,#$80
04211 101F           50                         push	ax
04212                                           ! Debug: func () void = outb+0 (used reg = )
04213 1020           E8         F531            call	_outb
04214 1023           83C4                   04  add	sp,*4
04215                                           !BCC_EOS
04216                                           ! 1212     if (max==0x0) keyboard_panic(21);
04217                       00001026            .C5:
04218                                           ! Debug: list int = const $64 (used reg = )
04219 1026           B8                   0064  mov	ax,*$64
04220 1029           50                         push	ax
04221                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04222 102A           E8         F511            call	_inb
04223 102D           44                         inc	sp
04224 102E           44                         inc	sp
04225                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04226 102F           24                     01  and	al,*1
04227                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04228 1031           84C0                       test	al,al
04229 1033           75           0B            jne 	.C7
04230                       00001035            .C8:
04231                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04232 1035           8B46         FE            mov	ax,-2[bp]
04233 1038           48                         dec	ax
04234 1039           8946         FE            mov	-2[bp],ax
04235                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04236 103C           85C0                       test	ax,ax
04237 103E           75           D8            jne	.C6
04238                       00001040            .C7:
04239                       00001040            .C4:
04240                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04241 1040           8B46         FE            mov	ax,-2[bp]
04242 1043           85C0                       test	ax,ax
04243 1045           75           09            jne 	.C9
04244                       00001047            .CA:
04245                                           ! Debug: list int = const $15 (used reg = )
04246 1047           B8                   0015  mov	ax,*$15
04247 104A           50                         push	ax
04248                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04249 104B           E8         0264            call	_keyboard_panic
04250 104E           44                         inc	sp
04251 104F           44                         inc	sp
04252                                           !BCC_EOS
04253                                           ! 1213     if ((inb(0x60) != 0xfa)) {
04254                       00001050            .C9:
04255                                           ! Debug: list int = const $60 (used reg = )
04256 1050           B8                   0060  mov	ax,*$60
04257 1053           50                         push	ax
04258                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04259 1054           E8         F4E7            call	_inb
04260 1057           44                         inc	sp
04261 1058           44                         inc	sp
04262                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04263 1059           3C                     FA  cmp	al,#$FA
04264 105B           74           09            je  	.CB
04265                       0000105D            .CC:
04266                                           ! 1214         keyboard_panic(993);
04267                                           ! Debug: list int = const $3E1 (used reg = )
04268 105D           B8                   03E1  mov	ax,#$3E1
04269 1060           50                         push	ax
04270                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04271 1061           E8         024E            call	_keyboard_panic
04272 1064           44                         inc	sp
04273 1065           44                         inc	sp
04274                                           !BCC_EOS
04275                                           ! 1215     }
04276                                           ! 1216     max=0xffff;
04277                       00001066            .CB:
04278                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04279 1066           B8                   FFFF  mov	ax,#$FFFF
04280 1069           8946         FE            mov	-2[bp],ax
04281                                           !BCC_EOS
04282                                           ! 1217     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
04283 106C           EB           0E            jmp .CE
04284                       0000106E            .CF:
04285                                           ! Debug: list int = const $31 (used reg = )
04286 106E           B8                   0031  mov	ax,*$31
04287 1071           50                         push	ax
04288                                           ! Debug: list int = const $80 (used reg = )
04289 1072           B8                   0080  mov	ax,#$80
04290 1075           50                         push	ax
04291                                           ! Debug: func () void = outb+0 (used reg = )
04292 1076           E8         F4DB            call	_outb
04293 1079           83C4                   04  add	sp,*4
04294                                           !BCC_EOS
04295                                           ! 1218     if (max==0x0) keyboard_panic(31);
04296                       0000107C            .CE:
04297                                           ! Debug: list int = const $64 (used reg = )
04298 107C           B8                   0064  mov	ax,*$64
04299 107F           50                         push	ax
04300                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04301 1080           E8         F4BB            call	_inb
04302 1083           44                         inc	sp
04303 1084           44                         inc	sp
04304                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04305 1085           24                     01  and	al,*1
04306                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04307 1087           84C0                       test	al,al
04308 1089           75           0B            jne 	.D0
04309                       0000108B            .D1:
04310                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04311 108B           8B46         FE            mov	ax,-2[bp]
04312 108E           48                         dec	ax
04313 108F           8946         FE            mov	-2[bp],ax
04314                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04315 1092           85C0                       test	ax,ax
04316 1094           75           D8            jne	.CF
04317                       00001096            .D0:
04318                       00001096            .CD:
04319                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04320 1096           8B46         FE            mov	ax,-2[bp]
04321 1099           85C0                       test	ax,ax
04322 109B           75           09            jne 	.D2
04323                       0000109D            .D3:
04324                                           ! Debug: list int = const $1F (used reg = )
04325 109D           B8                   001F  mov	ax,*$1F
04326 10A0           50                         push	ax
04327                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04328 10A1           E8         020E            call	_keyboard_panic
04329 10A4           44                         inc	sp
04330 10A5           44                         inc	sp
04331                                           !BCC_EOS
04332                                           ! 1219     if ((inb(0x60) != 0xaa)) {
04333                       000010A6            .D2:
04334                                           ! Debug: list int = const $60 (used reg = )
04335 10A6           B8                   0060  mov	ax,*$60
04336 10A9           50                         push	ax
04337                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04338 10AA           E8         F491            call	_inb
04339 10AD           44                         inc	sp
04340 10AE           44                         inc	sp
04341                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04342 10AF           3C                     AA  cmp	al,#$AA
04343 10B1           74           09            je  	.D4
04344                       000010B3            .D5:
04345                                           ! 1220         keyboard_panic(994);
04346                                           ! Debug: list int = const $3E2 (used reg = )
04347 10B3           B8                   03E2  mov	ax,#$3E2
04348 10B6           50                         push	ax
04349                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04350 10B7           E8         01F8            call	_keyboard_panic
04351 10BA           44                         inc	sp
04352 10BB           44                         inc	sp
04353                                           !BCC_EOS
04354                                           ! 1221     }
04355                                           ! 1222     outb(0x60, 0xf5);
04356                       000010BC            .D4:
04357                                           ! Debug: list int = const $F5 (used reg = )
04358 10BC           B8                   00F5  mov	ax,#$F5
04359 10BF           50                         push	ax
04360                                           ! Debug: list int = const $60 (used reg = )
04361 10C0           B8                   0060  mov	ax,*$60
04362 10C3           50                         push	ax
04363                                           ! Debug: func () void = outb+0 (used reg = )
04364 10C4           E8         F48D            call	_outb
04365 10C7           83C4                   04  add	sp,*4
04366                                           !BCC_EOS
04367                                           ! 1223     max=0xffff;
04368                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04369 10CA           B8                   FFFF  mov	ax,#$FFFF
04370 10CD           8946         FE            mov	-2[bp],ax
04371                                           !BCC_EOS
04372                                           ! 1224     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
04373 10D0           EB           0E            jmp .D7
04374                       000010D2            .D8:
04375                                           ! Debug: list int = const $40 (used reg = )
04376 10D2           B8                   0040  mov	ax,*$40
04377 10D5           50                         push	ax
04378                                           ! Debug: list int = const $80 (used reg = )
04379 10D6           B8                   0080  mov	ax,#$80
04380 10D9           50                         push	ax
04381                                           ! Debug: func () void = outb+0 (used reg = )
04382 10DA           E8         F477            call	_outb
04383 10DD           83C4                   04  add	sp,*4
04384                                           !BCC_EOS
04385                                           ! 1225     if (max==0x0) keyboard_panic(40);
04386                       000010E0            .D7:
04387                                           ! Debug: list int = const $64 (used reg = )
04388 10E0           B8                   0064  mov	ax,*$64
04389 10E3           50                         push	ax
04390                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04391 10E4           E8         F457            call	_inb
04392 10E7           44                         inc	sp
04393 10E8           44                         inc	sp
04394                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04395 10E9           24                     02  and	al,*2
04396 10EB           84C0                       test	al,al
04397 10ED           74           0B            je  	.D9
04398                       000010EF            .DA:
04399                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04400 10EF           8B46         FE            mov	ax,-2[bp]
04401 10F2           48                         dec	ax
04402 10F3           8946         FE            mov	-2[bp],ax
04403                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04404 10F6           85C0                       test	ax,ax
04405 10F8           75           D8            jne	.D8
04406                       000010FA            .D9:
04407                       000010FA            .D6:
04408                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04409 10FA           8B46         FE            mov	ax,-2[bp]
04410 10FD           85C0                       test	ax,ax
04411 10FF           75           09            jne 	.DB
04412                       00001101            .DC:
04413                                           ! Debug: list int = const $28 (used reg = )
04414 1101           B8                   0028  mov	ax,*$28
04415 1104           50                         push	ax
04416                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04417 1105           E8         01AA            call	_keyboard_panic
04418 1108           44                         inc	sp
04419 1109           44                         inc	sp
04420                                           !BCC_EOS
04421                                           ! 1226     max=0xffff;
04422                       0000110A            .DB:
04423                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04424 110A           B8                   FFFF  mov	ax,#$FFFF
04425 110D           8946         FE            mov	-2[bp],ax
04426                                           !BCC_EOS
04427                                           ! 1227     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
04428 1110           EB           0E            jmp .DE
04429                       00001112            .DF:
04430                                           ! Debug: list int = const $41 (used reg = )
04431 1112           B8                   0041  mov	ax,*$41
04432 1115           50                         push	ax
04433                                           ! Debug: list int = const $80 (used reg = )
04434 1116           B8                   0080  mov	ax,#$80
04435 1119           50                         push	ax
04436                                           ! Debug: func () void = outb+0 (used reg = )
04437 111A           E8         F437            call	_outb
04438 111D           83C4                   04  add	sp,*4
04439                                           !BCC_EOS
04440                                           ! 1228     if (max==0x0) keyboard_panic(41);
04441                       00001120            .DE:
04442                                           ! Debug: list int = const $64 (used reg = )
04443 1120           B8                   0064  mov	ax,*$64
04444 1123           50                         push	ax
04445                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04446 1124           E8         F417            call	_inb
04447 1127           44                         inc	sp
04448 1128           44                         inc	sp
04449                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04450 1129           24                     01  and	al,*1
04451                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04452 112B           84C0                       test	al,al
04453 112D           75           0B            jne 	.E0
04454                       0000112F            .E1:
04455                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04456 112F           8B46         FE            mov	ax,-2[bp]
04457 1132           48                         dec	ax
04458 1133           8946         FE            mov	-2[bp],ax
04459                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04460 1136           85C0                       test	ax,ax
04461 1138           75           D8            jne	.DF
04462                       0000113A            .E0:
04463                       0000113A            .DD:
04464                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04465 113A           8B46         FE            mov	ax,-2[bp]
04466 113D           85C0                       test	ax,ax
04467 113F           75           09            jne 	.E2
04468                       00001141            .E3:
04469                                           ! Debug: list int = const $29 (used reg = )
04470 1141           B8                   0029  mov	ax,*$29
04471 1144           50                         push	ax
04472                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04473 1145           E8         016A            call	_keyboard_panic
04474 1148           44                         inc	sp
04475 1149           44                         inc	sp
04476                                           !BCC_EOS
04477                                           ! 1229     if ((inb(0x60) != 0xfa)) {
04478                       0000114A            .E2:
04479                                           ! Debug: list int = const $60 (used reg = )
04480 114A           B8                   0060  mov	ax,*$60
04481 114D           50                         push	ax
04482                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04483 114E           E8         F3ED            call	_inb
04484 1151           44                         inc	sp
04485 1152           44                         inc	sp
04486                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04487 1153           3C                     FA  cmp	al,#$FA
04488 1155           74           09            je  	.E4
04489                       00001157            .E5:
04490                                           ! 1230         keyboard_panic(995);
04491                                           ! Debug: list int = const $3E3 (used reg = )
04492 1157           B8                   03E3  mov	ax,#$3E3
04493 115A           50                         push	ax
04494                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04495 115B           E8         0154            call	_keyboard_panic
04496 115E           44                         inc	sp
04497 115F           44                         inc	sp
04498                                           !BCC_EOS
04499                                           ! 1231     }
04500                                           ! 1232     outb(0x64, 0x60);
04501                       00001160            .E4:
04502                                           ! Debug: list int = const $60 (used reg = )
04503 1160           B8                   0060  mov	ax,*$60
04504 1163           50                         push	ax
04505                                           ! Debug: list int = const $64 (used reg = )
04506 1164           B8                   0064  mov	ax,*$64
04507 1167           50                         push	ax
04508                                           ! Debug: func () void = outb+0 (used reg = )
04509 1168           E8         F3E9            call	_outb
04510 116B           83C4                   04  add	sp,*4
04511                                           !BCC_EOS
04512                                           ! 1233     max=0xffff;
04513                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04514 116E           B8                   FFFF  mov	ax,#$FFFF
04515 1171           8946         FE            mov	-2[bp],ax
04516                                           !BCC_EOS
04517                                           ! 1234     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
04518 1174           EB           0E            jmp .E7
04519                       00001176            .E8:
04520                                           ! Debug: list int = const $50 (used reg = )
04521 1176           B8                   0050  mov	ax,*$50
04522 1179           50                         push	ax
04523                                           ! Debug: list int = const $80 (used reg = )
04524 117A           B8                   0080  mov	ax,#$80
04525 117D           50                         push	ax
04526                                           ! Debug: func () void = outb+0 (used reg = )
04527 117E           E8         F3D3            call	_outb
04528 1181           83C4                   04  add	sp,*4
04529                                           !BCC_EOS
04530                                           ! 1235     if (max==0x0) keyboard_panic(50);
04531                       00001184            .E7:
04532                                           ! Debug: list int = const $64 (used reg = )
04533 1184           B8                   0064  mov	ax,*$64
04534 1187           50                         push	ax
04535                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04536 1188           E8         F3B3            call	_inb
04537 118B           44                         inc	sp
04538 118C           44                         inc	sp
04539                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04540 118D           24                     02  and	al,*2
04541 118F           84C0                       test	al,al
04542 1191           74           0B            je  	.E9
04543                       00001193            .EA:
04544                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04545 1193           8B46         FE            mov	ax,-2[bp]
04546 1196           48                         dec	ax
04547 1197           8946         FE            mov	-2[bp],ax
04548                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04549 119A           85C0                       test	ax,ax
04550 119C           75           D8            jne	.E8
04551                       0000119E            .E9:
04552                       0000119E            .E6:
04553                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04554 119E           8B46         FE            mov	ax,-2[bp]
04555 11A1           85C0                       test	ax,ax
04556 11A3           75           09            jne 	.EB
04557                       000011A5            .EC:
04558                                           ! Debug: list int = const $32 (used reg = )
04559 11A5           B8                   0032  mov	ax,*$32
04560 11A8           50                         push	ax
04561                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04562 11A9           E8         0106            call	_keyboard_panic
04563 11AC           44                         inc	sp
04564 11AD           44                         inc	sp
04565                                           !BCC_EOS
04566                                           ! 1236     outb(0x60, 0x61);
04567                       000011AE            .EB:
04568                                           ! Debug: list int = const $61 (used reg = )
04569 11AE           B8                   0061  mov	ax,*$61
04570 11B1           50                         push	ax
04571                                           ! Debug: list int = const $60 (used reg = )
04572 11B2           B8                   0060  mov	ax,*$60
04573 11B5           50                         push	ax
04574                                           ! Debug: func () void = outb+0 (used reg = )
04575 11B6           E8         F39B            call	_outb
04576 11B9           83C4                   04  add	sp,*4
04577                                           !BCC_EOS
04578                                           ! 1237     max=0xffff;
04579                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04580 11BC           B8                   FFFF  mov	ax,#$FFFF
04581 11BF           8946         FE            mov	-2[bp],ax
04582                                           !BCC_EOS
04583                                           ! 1238     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
04584 11C2           EB           0E            jmp .EE
04585                       000011C4            .EF:
04586                                           ! Debug: list int = const $60 (used reg = )
04587 11C4           B8                   0060  mov	ax,*$60
04588 11C7           50                         push	ax
04589                                           ! Debug: list int = const $80 (used reg = )
04590 11C8           B8                   0080  mov	ax,#$80
04591 11CB           50                         push	ax
04592                                           ! Debug: func () void = outb+0 (used reg = )
04593 11CC           E8         F385            call	_outb
04594 11CF           83C4                   04  add	sp,*4
04595                                           !BCC_EOS
04596                                           ! 1239     if (max==0x0) keyboard_panic(60);
04597                       000011D2            .EE:
04598                                           ! Debug: list int = const $64 (used reg = )
04599 11D2           B8                   0064  mov	ax,*$64
04600 11D5           50                         push	ax
04601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04602 11D6           E8         F365            call	_inb
04603 11D9           44                         inc	sp
04604 11DA           44                         inc	sp
04605                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04606 11DB           24                     02  and	al,*2
04607 11DD           84C0                       test	al,al
04608 11DF           74           0B            je  	.F0
04609                       000011E1            .F1:
04610                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04611 11E1           8B46         FE            mov	ax,-2[bp]
04612 11E4           48                         dec	ax
04613 11E5           8946         FE            mov	-2[bp],ax
04614                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04615 11E8           85C0                       test	ax,ax
04616 11EA           75           D8            jne	.EF
04617                       000011EC            .F0:
04618                       000011EC            .ED:
04619                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04620 11EC           8B46         FE            mov	ax,-2[bp]
04621 11EF           85C0                       test	ax,ax
04622 11F1           75           09            jne 	.F2
04623                       000011F3            .F3:
04624                                           ! Debug: list int = const $3C (used reg = )
04625 11F3           B8                   003C  mov	ax,*$3C
04626 11F6           50                         push	ax
04627                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04628 11F7           E8         00B8            call	_keyboard_panic
04629 11FA           44                         inc	sp
04630 11FB           44                         inc	sp
04631                                           !BCC_EOS
04632                                           ! 1240     outb(0x60, 0xf4);
04633                       000011FC            .F2:
04634                                           ! Debug: list int = const $F4 (used reg = )
04635 11FC           B8                   00F4  mov	ax,#$F4
04636 11FF           50                         push	ax
04637                                           ! Debug: list int = const $60 (used reg = )
04638 1200           B8                   0060  mov	ax,*$60
04639 1203           50                         push	ax
04640                                           ! Debug: func () void = outb+0 (used reg = )
04641 1204           E8         F34D            call	_outb
04642 1207           83C4                   04  add	sp,*4
04643                                           !BCC_EOS
04644                                           ! 1241     max=0xffff;
04645                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04646 120A           B8                   FFFF  mov	ax,#$FFFF
04647 120D           8946         FE            mov	-2[bp],ax
04648                                           !BCC_EOS
04649                                           ! 1242     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
04650 1210           EB           0E            jmp .F5
04651                       00001212            .F6:
04652                                           ! Debug: list int = const $70 (used reg = )
04653 1212           B8                   0070  mov	ax,*$70
04654 1215           50                         push	ax
04655                                           ! Debug: list int = const $80 (used reg = )
04656 1216           B8                   0080  mov	ax,#$80
04657 1219           50                         push	ax
04658                                           ! Debug: func () void = outb+0 (used reg = )
04659 121A           E8         F337            call	_outb
04660 121D           83C4                   04  add	sp,*4
04661                                           !BCC_EOS
04662                                           ! 1243     if (max==0x0) keyboard_panic(70);
04663                       00001220            .F5:
04664                                           ! Debug: list int = const $64 (used reg = )
04665 1220           B8                   0064  mov	ax,*$64
04666 1223           50                         push	ax
04667                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04668 1224           E8         F317            call	_inb
04669 1227           44                         inc	sp
04670 1228           44                         inc	sp
04671                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04672 1229           24                     02  and	al,*2
04673 122B           84C0                       test	al,al
04674 122D           74           0B            je  	.F7
04675                       0000122F            .F8:
04676                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04677 122F           8B46         FE            mov	ax,-2[bp]
04678 1232           48                         dec	ax
04679 1233           8946         FE            mov	-2[bp],ax
04680                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04681 1236           85C0                       test	ax,ax
04682 1238           75           D8            jne	.F6
04683                       0000123A            .F7:
04684                       0000123A            .F4:
04685                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04686 123A           8B46         FE            mov	ax,-2[bp]
04687 123D           85C0                       test	ax,ax
04688 123F           75           09            jne 	.F9
04689                       00001241            .FA:
04690                                           ! Debug: list int = const $46 (used reg = )
04691 1241           B8                   0046  mov	ax,*$46
04692 1244           50                         push	ax
04693                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04694 1245           E8         006A            call	_keyboard_panic
04695 1248           44                         inc	sp
04696 1249           44                         inc	sp
04697                                           !BCC_EOS
04698                                           ! 1244     max=0xffff;
04699                       0000124A            .F9:
04700                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04701 124A           B8                   FFFF  mov	ax,#$FFFF
04702 124D           8946         FE            mov	-2[bp],ax
04703                                           !BCC_EOS
04704                                           ! 1245     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
04705 1250           EB           0E            jmp .FC
04706                       00001252            .FD:
04707                                           ! Debug: list int = const $71 (used reg = )
04708 1252           B8                   0071  mov	ax,*$71
04709 1255           50                         push	ax
04710                                           ! Debug: list int = const $80 (used reg = )
04711 1256           B8                   0080  mov	ax,#$80
04712 1259           50                         push	ax
04713                                           ! Debug: func () void = outb+0 (used reg = )
04714 125A           E8         F2F7            call	_outb
04715 125D           83C4                   04  add	sp,*4
04716                                           !BCC_EOS
04717                                           ! 1246     if (max==0x0) keyboard_panic(70);
04718                       00001260            .FC:
04719                                           ! Debug: list int = const $64 (used reg = )
04720 1260           B8                   0064  mov	ax,*$64
04721 1263           50                         push	ax
04722                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04723 1264           E8         F2D7            call	_inb
04724 1267           44                         inc	sp
04725 1268           44                         inc	sp
04726                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04727 1269           24                     01  and	al,*1
04728                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04729 126B           84C0                       test	al,al
04730 126D           75           0B            jne 	.FE
04731                       0000126F            .FF:
04732                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04733 126F           8B46         FE            mov	ax,-2[bp]
04734 1272           48                         dec	ax
04735 1273           8946         FE            mov	-2[bp],ax
04736                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04737 1276           85C0                       test	ax,ax
04738 1278           75           D8            jne	.FD
04739                       0000127A            .FE:
04740                       0000127A            .FB:
04741                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04742 127A           8B46         FE            mov	ax,-2[bp]
04743 127D           85C0                       test	ax,ax
04744 127F           75           09            jne 	.100
04745                       00001281            .101:
04746                                           ! Debug: list int = const $46 (used reg = )
04747 1281           B8                   0046  mov	ax,*$46
04748 1284           50                         push	ax
04749                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04750 1285           E8         002A            call	_keyboard_panic
04751 1288           44                         inc	sp
04752 1289           44                         inc	sp
04753                                           !BCC_EOS
04754                                           ! 1247     if ((inb(0x60) != 0xfa)) {
04755                       0000128A            .100:
04756                                           ! Debug: list int = const $60 (used reg = )
04757 128A           B8                   0060  mov	ax,*$60
04758 128D           50                         push	ax
04759                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04760 128E           E8         F2AD            call	_inb
04761 1291           44                         inc	sp
04762 1292           44                         inc	sp
04763                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04764 1293           3C                     FA  cmp	al,#$FA
04765 1295           74           09            je  	.102
04766                       00001297            .103:
04767                                           ! 1248         keyboard_panic(996);
04768                                           ! Debug: list int = const $3E4 (used reg = )
04769 1297           B8                   03E4  mov	ax,#$3E4
04770 129A           50                         push	ax
04771                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04772 129B           E8         0014            call	_keyboard_panic
04773 129E           44                         inc	sp
04774 129F           44                         inc	sp
04775                                           !BCC_EOS
04776                                           ! 1249     }
04777                                           ! 1250     outb(0x80, 0x77);
04778                       000012A0            .102:
04779                                           ! Debug: list int = const $77 (used reg = )
04780 12A0           B8                   0077  mov	ax,*$77
04781 12A3           50                         push	ax
04782                                           ! Debug: list int = const $80 (used reg = )
04783 12A4           B8                   0080  mov	ax,#$80
04784 12A7           50                         push	ax
04785                                           ! Debug: func () void = outb+0 (used reg = )
04786 12A8           E8         F2A9            call	_outb
04787 12AB           83C4                   04  add	sp,*4
04788                                           !BCC_EOS
04789                                           ! 1251 }
04790 12AE           89EC                       mov	sp,bp
04791 12B0           5D                         pop	bp
04792 12B1           C3                         ret
04793                                           ! 1252   void
04794                                           ! 1253 keyboard_panic(status)
04795                                           ! 1254   Bit16u status;
04796                                           export	_keyboard_panic
04797                       000012B2            _keyboard_panic:
04798                                           !BCC_EOS
04799                                           ! 1255 {
04800                                           ! 1256   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04801 12B2           55                         push	bp
04802 12B3           89E5                       mov	bp,sp
04803                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04804 12B5           FF76         04            push	4[bp]
04805                                           ! Debug: list * char = .104+0 (used reg = )
04806 12B8           BB                   D5B9  mov	bx,#.104
04807 12BB           53                         push	bx
04808                                           ! Debug: list int = const 7 (used reg = )
04809 12BC           B8                   0007  mov	ax,*7
04810 12BF           50                         push	ax
04811                                           ! Debug: func () void = bios_printf+0 (used reg = )
04812 12C0           E8         F758            call	_bios_printf
04813 12C3           89EC                       mov	sp,bp
04814                                           !BCC_EOS
04815                                           ! 1257 }
04816 12C5           5D                         pop	bp
04817 12C6           C3                         ret
04818                                           ! 1258   void
04819                                           ! Register BX used in function keyboard_panic
04820                                           ! 1259 machine_reset()
04821                                           ! 1260 {
04822                                           export	_machine_reset
04823                       000012C7            _machine_reset:
04824                                           ! 1261 #asm
04825                                           !BCC_ASM
04826                                           ;we must check whether 0xFE is set or not
04827                                           ;if it is s3 resume, just jmp back to normal Post Entry
04828                                           ;below port io will prevent s3 resume
04829 12C7           B0                     0F    mov al, #0x0f
04830 12C9           E6                     70    out 0x70, al
04831 12CB           E4                     71    in al, 0x71
04832 12CD           3C                     FE    cmp al, #0xFE
04833 12CF   7503    E9         CD87              jz post
04834                                           ! 1270 endasm
04835                                           !BCC_ENDASM
04836                                           ! 1271   outb(0x64, 0x60);
04837 12D4           55                         push	bp
04838 12D5           89E5                       mov	bp,sp
04839                                           ! Debug: list int = const $60 (used reg = )
04840 12D7           B8                   0060  mov	ax,*$60
04841 12DA           50                         push	ax
04842                                           ! Debug: list int = const $64 (used reg = )
04843 12DB           B8                   0064  mov	ax,*$64
04844 12DE           50                         push	ax
04845                                           ! Debug: func () void = outb+0 (used reg = )
04846 12DF           E8         F272            call	_outb
04847 12E2           89EC                       mov	sp,bp
04848                                           !BCC_EOS
04849                                           ! 1272   outb(0x60, 0x14);
04850                                           ! Debug: list int = const $14 (used reg = )
04851 12E4           B8                   0014  mov	ax,*$14
04852 12E7           50                         push	ax
04853                                           ! Debug: list int = const $60 (used reg = )
04854 12E8           B8                   0060  mov	ax,*$60
04855 12EB           50                         push	ax
04856                                           ! Debug: func () void = outb+0 (used reg = )
04857 12EC           E8         F265            call	_outb
04858 12EF           89EC                       mov	sp,bp
04859                                           !BCC_EOS
04860                                           ! 1273   outb(0x64, 0xfe);
04861                                           ! Debug: list int = const $FE (used reg = )
04862 12F1           B8                   00FE  mov	ax,#$FE
04863 12F4           50                         push	ax
04864                                           ! Debug: list int = const $64 (used reg = )
04865 12F5           B8                   0064  mov	ax,*$64
04866 12F8           50                         push	ax
04867                                           ! Debug: func () void = outb+0 (used reg = )
04868 12F9           E8         F258            call	_outb
04869 12FC           89EC                       mov	sp,bp
04870                                           !BCC_EOS
04871                                           ! 1274   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
04872                                           ! Debug: list * char = .105+0 (used reg = )
04873 12FE           BB                   D59D  mov	bx,#.105
04874 1301           53                         push	bx
04875                                           ! Debug: list int = const 7 (used reg = )
04876 1302           B8                   0007  mov	ax,*7
04877 1305           50                         push	ax
04878                                           ! Debug: func () void = bios_printf+0 (used reg = )
04879 1306           E8         F712            call	_bios_printf
04880 1309           89EC                       mov	sp,bp
04881                                           !BCC_EOS
04882                                           ! 1275 }
04883 130B           5D                         pop	bp
04884 130C           C3                         ret
04885                                           ! 1276   void
04886                                           ! Register BX used in function machine_reset
04887                                           ! 1277 clobber_entry_point()
04888                                           ! 1278 {
04889                                           export	_clobber_entry_point
04890                       0000130D            _clobber_entry_point:
04891                                           ! 1279     write_word(0xffff, 0x0001, machine_reset);
04892 130D           55                         push	bp
04893 130E           89E5                       mov	bp,sp
04894                                           ! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
04895                                           ! Debug: list * () void = machine_reset+0 (used reg = )
04896 1310           BB                   12C7  mov	bx,#_machine_reset
04897 1313           53                         push	bx
04898                                           ! Debug: list int = const 1 (used reg = )
04899 1314           B8                   0001  mov	ax,*1
04900 1317           50                         push	ax
04901                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04902 1318           B8                   FFFF  mov	ax,#$FFFF
04903 131B           50                         push	ax
04904                                           ! Debug: func () void = write_word+0 (used reg = )
04905 131C           E8         F313            call	_write_word
04906 131F           89EC                       mov	sp,bp
04907                                           !BCC_EOS
04908                                           ! 1280 }
04909 1321           5D                         pop	bp
04910 1322           C3                         ret
04911                                           ! 1281   void
04912                                           ! Register BX used in function clobber_entry_point
04913                                           ! 1282 shutdown_status_panic(status)
04914                                           ! 1283   Bit16u status;
04915                                           export	_shutdown_status_panic
04916                       00001323            _shutdown_status_panic:
04917                                           !BCC_EOS
04918                                           ! 1284 {
04919                                           ! 1285   bios_printf((2 | 4 | 1), "Unimplemented shutdown statu
04920 1323           55                         push	bp
04921 1324           89E5                       mov	bp,sp
04922                                           ! 1285 s: %02x\n",(Bit8u)status);
04923                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04924 1326           8A46         04            mov	al,4[bp]
04925 1329           30E4                       xor	ah,ah
04926 132B           50                         push	ax
04927                                           ! Debug: list * char = .106+0 (used reg = )
04928 132C           BB                   D578  mov	bx,#.106
04929 132F           53                         push	bx
04930                                           ! Debug: list int = const 7 (used reg = )
04931 1330           B8                   0007  mov	ax,*7
04932 1333           50                         push	ax
04933                                           ! Debug: func () void = bios_printf+0 (used reg = )
04934 1334           E8         F6E4            call	_bios_printf
04935 1337           89EC                       mov	sp,bp
04936                                           !BCC_EOS
04937                                           ! 1286 }
04938 1339           5D                         pop	bp
04939 133A           C3                         ret
04940                                           ! 1287 void s3_resume_panic()
04941                                           ! Register BX used in function shutdown_status_panic
04942                                           ! 1288 {
04943                                           export	_s3_resume_panic
04944                       0000133B            _s3_resume_panic:
04945                                           ! 1289   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04946 133B           55                         push	bp
04947 133C           89E5                       mov	bp,sp
04948                                           ! Debug: list * char = .107+0 (used reg = )
04949 133E           BB                   D55E  mov	bx,#.107
04950 1341           53                         push	bx
04951                                           ! Debug: list int = const 7 (used reg = )
04952 1342           B8                   0007  mov	ax,*7
04953 1345           50                         push	ax
04954                                           ! Debug: func () void = bios_printf+0 (used reg = )
04955 1346           E8         F6D2            call	_bios_printf
04956 1349           89EC                       mov	sp,bp
04957                                           !BCC_EOS
04958                                           ! 1290 }
04959 134B           5D                         pop	bp
04960 134C           C3                         ret
04961                                           ! 1291 void
04962                                           ! Register BX used in function s3_resume_panic
04963                                           ! 1292 print_bios_banner()
04964                                           ! 1293 {
04965                                           export	_print_bios_banner
04966                       0000134D            _print_bios_banner:
04967                                           ! 1294   int i = 0;
04968 134D           55                         push	bp
04969 134E           89E5                       mov	bp,sp
04970 1350           4C                         dec	sp
04971 1351           4C                         dec	sp
04972                                           ! Debug: eq int = const 0 to int i = [S+4-4] (used reg = )
04973 1352           31C0                       xor	ax,ax
04974 1354           8946         FE            mov	-2[bp],ax
04975                                           !BCC_EOS
04976                                           ! 1295   for (; i < 1; i++)
04977                                           !BCC_EOS
04978                                           !BCC_EOS
04979                                           ! 1296     bios_printf(2, "Processor %d: Xen(R) Virtual CPU\n", i+1);
04980 1357           EB           1A            jmp .10A
04981                       00001359            .10B:
04982                                           ! Debug: add int = const 1 to int i = [S+4-4] (used reg = )
04983 1359           8B46         FE            mov	ax,-2[bp]
04984                                           ! Debug: list int = ax+1 (used reg = )
04985 135C           40                         inc	ax
04986 135D           50                         push	ax
04987                                           ! Debug: list * char = .10C+0 (used reg = )
04988 135E           BB                   D53C  mov	bx,#.10C
04989 1361           53                         push	bx
04990                                           ! Debug: list int = const 2 (used reg = )
04991 1362           B8                   0002  mov	ax,*2
04992 1365           50                         push	ax
04993                                           ! Debug: func () void = bios_printf+0 (used reg = )
04994 1366           E8         F6B2            call	_bios_printf
04995 1369           83C4                   06  add	sp,*6
04996                                           !BCC_EOS
04997                                           ! 1297 }
04998                       0000136C            .109:
04999                                           ! Debug: postinc int i = [S+4-4] (used reg = )
05000 136C           8B46         FE            mov	ax,-2[bp]
05001 136F           40                         inc	ax
05002 1370           8946         FE            mov	-2[bp],ax
05003                       00001373            .10A:
05004                                           ! Debug: lt int = const 1 to int i = [S+4-4] (used reg = )
05005 1373           8B46         FE            mov	ax,-2[bp]
05006 1376           3D                   0001  cmp	ax,*1
05007 1379           7C           DE            jl 	.10B
05008                       0000137B            .10D:
05009                       0000137B            .108:
05010 137B           89EC                       mov	sp,bp
05011 137D           5D                         pop	bp
05012 137E           C3                         ret
05013                                           ! 1298 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
05014                                           ! Register BX used in function print_bios_banner
05015                                           
05016                       0000137F            _drivetypes:
05017                       0000137F            .10E:
05018 137F                        00            .byte	0
05019 1380                  00000009            .blkb	9
05020                       00001389            .10F:
05021 1389                        46            .ascii	"Floppy"
05022 138F                        00            .byte	0
05023 1390                  00000003            .blkb	3
05024                       00001393            .110:
05025 1393                        48            .ascii	"Hard Disk"
05026 139C                        00            .byte	0
05027                       0000139D            .111:
05028 139D                        43            .ascii	"CD-Rom"
05029 13A3                        00            .byte	0
05030 13A4                  00000003            .blkb	3
05031                       000013A7            .112:
05032 13A7                        4E            .ascii	"Network"
05033 13AE                        00            .byte	0
05034 13AF                  00000002            .blkb	2
05035                                           !BCC_EOS
05036                                           ! 1299 static void
05037                                           ! 1300 init_boot_vectors()
05038                                           ! 1301 {
05039                                           
05040                       000013B1            _init_boot_vectors:
05041                                           ! 1302   ipl_entry_t e;
05042                                           !BCC_EOS
05043                                           ! 1303   Bit16u count = 0;
05044 13B1           55                         push	bp
05045 13B2           89E5                       mov	bp,sp
05046 13B4           83C4                   EE  add	sp,*-$12
05047                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
05048 13B7           31C0                       xor	ax,ax
05049 13B9           8946         EE            mov	-$12[bp],ax
05050                                           !BCC_EOS
05051                                           ! 1304   Bit16u ss = get_SS();
05052 13BC           4C                         dec	sp
05053 13BD           4C                         dec	sp
05054                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05055 13BE           E8         F28C            call	_get_SS
05056                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
05057 13C1           8946         EC            mov	-$14[bp],ax
05058                                           !BCC_EOS
05059                                           ! 1305   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05060 13C4           4C                         dec	sp
05061 13C5           4C                         dec	sp
05062                                           ! Debug: list int = const $E (used reg = )
05063 13C6           B8                   000E  mov	ax,*$E
05064 13C9           50                         push	ax
05065                                           ! Debug: list int = const $40 (used reg = )
05066 13CA           B8                   0040  mov	ax,*$40
05067 13CD           50                         push	ax
05068                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05069 13CE           E8         F236            call	_read_word
05070 13D1           83C4                   04  add	sp,*4
05071                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$18-$18] (used reg = )
05072 13D4           8946         EA            mov	-$16[bp],ax
05073                                           !BCC_EOS
05074                                           ! 1306   memsetb(ebda_seg, 0x0300, 0, 0xff);
05075                                           ! Debug: list int = const $FF (used reg = )
05076 13D7           B8                   00FF  mov	ax,#$FF
05077 13DA           50                         push	ax
05078                                           ! Debug: list int = const 0 (used reg = )
05079 13DB           31C0                       xor	ax,ax
05080 13DD           50                         push	ax
05081                                           ! Debug: list int = const $300 (used reg = )
05082 13DE           B8                   0300  mov	ax,#$300
05083 13E1           50                         push	ax
05084                                           ! Debug: list unsigned short ebda_seg = [S+$1E-$18] (used reg = )
05085 13E2           FF76         EA            push	-$16[bp]
05086                                           ! Debug: func () void = memsetb+0 (used reg = )
05087 13E5           E8         EC18            call	_memsetb
05088 13E8           83C4                   08  add	sp,*8
05089                                           !BCC_EOS
05090                                           ! 1307   write_word(ebda_seg, 0x0384, 0xFFFF);
05091                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05092 13EB           B8                   FFFF  mov	ax,#$FFFF
05093 13EE           50                         push	ax
05094                                           ! Debug: list int = const $384 (used reg = )
05095 13EF           B8                   0384  mov	ax,#$384
05096 13F2           50                         push	ax
05097                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05098 13F3           FF76         EA            push	-$16[bp]
05099                                           ! Debug: func () void = write_word+0 (used reg = )
05100 13F6           E8         F239            call	_write_word
05101 13F9           83C4                   06  add	sp,*6
05102                                           !BCC_EOS
05103                                           ! 1308   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05104                                           ! Debug: eq int = const 1 to unsigned short e = [S+$18-$12] (used reg = )
05105 13FC           B8                   0001  mov	ax,*1
05106 13FF           8946         F0            mov	-$10[bp],ax
05107                                           !BCC_EOS
05108                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05109 1402           31C0                       xor	ax,ax
05110 1404           8946         F2            mov	-$E[bp],ax
05111                                           !BCC_EOS
05112                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05113 1407           31C0                       xor	ax,ax
05114 1409           31DB                       xor	bx,bx
05115 140B           8946         F4            mov	-$C[bp],ax
05116 140E           895E         F6            mov	-$A[bp],bx
05117                                           !BCC_EOS
05118                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05119 1411           31C0                       xor	ax,ax
05120 1413           31DB                       xor	bx,bx
05121 1415           8946         F8            mov	-8[bp],ax
05122 1418           895E         FA            mov	-6[bp],bx
05123                                           !BCC_EOS
05124                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05125 141B           31C0                       xor	ax,ax
05126 141D           31DB                       xor	bx,bx
05127 141F           8946         FC            mov	-4[bp],ax
05128 1422           895E         FE            mov	-2[bp],bx
05129                                           !BCC_EOS
05130                                           ! 1309   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05131                                           ! Debug: list int = const $10 (used reg = )
05132 1425           B8                   0010  mov	ax,*$10
05133 1428           50                         push	ax
05134                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05135 1429           8D5E         F0            lea	bx,-$10[bp]
05136 142C           53                         push	bx
05137                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05138 142D           FF76         EC            push	-$14[bp]
05139                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05140 1430           8B46         EE            mov	ax,-$12[bp]
05141 1433           B1                     04  mov	cl,*4
05142 1435           D3E0                       shl	ax,cl
05143                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05144                                           ! Debug: expression subtree swapping
05145                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05146 1437           05                   0300  add	ax,#$300
05147 143A           50                         push	ax
05148                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05149 143B           FF76         EA            push	-$16[bp]
05150                                           ! Debug: func () void = memcpyb+0 (used reg = )
05151 143E           E8         EBE3            call	_memcpyb
05152 1441           83C4                   0A  add	sp,*$A
05153                                           !BCC_EOS
05154                                           ! 1310   count++;
05155                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05156 1444           8B46         EE            mov	ax,-$12[bp]
05157 1447           40                         inc	ax
05158 1448           8946         EE            mov	-$12[bp],ax
05159                                           !BCC_EOS
05160                                           ! 1311   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05161                                           ! Debug: eq int = const 2 to unsigned short e = [S+$18-$12] (used reg = )
05162 144B           B8                   0002  mov	ax,*2
05163 144E           8946         F0            mov	-$10[bp],ax
05164                                           !BCC_EOS
05165                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05166 1451           31C0                       xor	ax,ax
05167 1453           8946         F2            mov	-$E[bp],ax
05168                                           !BCC_EOS
05169                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05170 1456           31C0                       xor	ax,ax
05171 1458           31DB                       xor	bx,bx
05172 145A           8946         F4            mov	-$C[bp],ax
05173 145D           895E         F6            mov	-$A[bp],bx
05174                                           !BCC_EOS
05175                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05176 1460           31C0                       xor	ax,ax
05177 1462           31DB                       xor	bx,bx
05178 1464           8946         F8            mov	-8[bp],ax
05179 1467           895E         FA            mov	-6[bp],bx
05180                                           !BCC_EOS
05181                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05182 146A           31C0                       xor	ax,ax
05183 146C           31DB                       xor	bx,bx
05184 146E           8946         FC            mov	-4[bp],ax
05185 1471           895E         FE            mov	-2[bp],bx
05186                                           !BCC_EOS
05187                                           ! 1312   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05188                                           ! Debug: list int = const $10 (used reg = )
05189 1474           B8                   0010  mov	ax,*$10
05190 1477           50                         push	ax
05191                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05192 1478           8D5E         F0            lea	bx,-$10[bp]
05193 147B           53                         push	bx
05194                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05195 147C           FF76         EC            push	-$14[bp]
05196                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05197 147F           8B46         EE            mov	ax,-$12[bp]
05198 1482           B1                     04  mov	cl,*4
05199 1484           D3E0                       shl	ax,cl
05200                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05201                                           ! Debug: expression subtree swapping
05202                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05203 1486           05                   0300  add	ax,#$300
05204 1489           50                         push	ax
05205                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05206 148A           FF76         EA            push	-$16[bp]
05207                                           ! Debug: func () void = memcpyb+0 (used reg = )
05208 148D           E8         EB94            call	_memcpyb
05209 1490           83C4                   0A  add	sp,*$A
05210                                           !BCC_EOS
05211                                           ! 1313   count++;
05212                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05213 1493           8B46         EE            mov	ax,-$12[bp]
05214 1496           40                         inc	ax
05215 1497           8946         EE            mov	-$12[bp],ax
05216                                           !BCC_EOS
05217                                           ! 1314   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05218                                           ! Debug: eq int = const 3 to unsigned short e = [S+$18-$12] (used reg = )
05219 149A           B8                   0003  mov	ax,*3
05220 149D           8946         F0            mov	-$10[bp],ax
05221                                           !BCC_EOS
05222                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05223 14A0           31C0                       xor	ax,ax
05224 14A2           8946         F2            mov	-$E[bp],ax
05225                                           !BCC_EOS
05226                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05227 14A5           31C0                       xor	ax,ax
05228 14A7           31DB                       xor	bx,bx
05229 14A9           8946         F4            mov	-$C[bp],ax
05230 14AC           895E         F6            mov	-$A[bp],bx
05231                                           !BCC_EOS
05232                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05233 14AF           31C0                       xor	ax,ax
05234 14B1           31DB                       xor	bx,bx
05235 14B3           8946         F8            mov	-8[bp],ax
05236 14B6           895E         FA            mov	-6[bp],bx
05237                                           !BCC_EOS
05238                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05239 14B9           31C0                       xor	ax,ax
05240 14BB           31DB                       xor	bx,bx
05241 14BD           8946         FC            mov	-4[bp],ax
05242 14C0           895E         FE            mov	-2[bp],bx
05243                                           !BCC_EOS
05244                                           ! 1315   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05245                                           ! Debug: list int = const $10 (used reg = )
05246 14C3           B8                   0010  mov	ax,*$10
05247 14C6           50                         push	ax
05248                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05249 14C7           8D5E         F0            lea	bx,-$10[bp]
05250 14CA           53                         push	bx
05251                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05252 14CB           FF76         EC            push	-$14[bp]
05253                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05254 14CE           8B46         EE            mov	ax,-$12[bp]
05255 14D1           B1                     04  mov	cl,*4
05256 14D3           D3E0                       shl	ax,cl
05257                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05258                                           ! Debug: expression subtree swapping
05259                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05260 14D5           05                   0300  add	ax,#$300
05261 14D8           50                         push	ax
05262                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05263 14D9           FF76         EA            push	-$16[bp]
05264                                           ! Debug: func () void = memcpyb+0 (used reg = )
05265 14DC           E8         EB45            call	_memcpyb
05266 14DF           83C4                   0A  add	sp,*$A
05267                                           !BCC_EOS
05268                                           ! 1316   count++;
05269                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05270 14E2           8B46         EE            mov	ax,-$12[bp]
05271 14E5           40                         inc	ax
05272 14E6           8946         EE            mov	-$12[bp],ax
05273                                           !BCC_EOS
05274                                           ! 1317   write_word(ebda_seg, 0x0380, count);
05275                                           ! Debug: list unsigned short count = [S+$18-$14] (used reg = )
05276 14E9           FF76         EE            push	-$12[bp]
05277                                           ! Debug: list int = const $380 (used reg = )
05278 14EC           B8                   0380  mov	ax,#$380
05279 14EF           50                         push	ax
05280                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05281 14F0           FF76         EA            push	-$16[bp]
05282                                           ! Debug: func () void = write_word+0 (used reg = )
05283 14F3           E8         F13C            call	_write_word
05284 14F6           83C4                   06  add	sp,*6
05285                                           !BCC_EOS
05286                                           ! 1318   write_word(ebda_seg, 0x0382, 0xffff);
05287                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05288 14F9           B8                   FFFF  mov	ax,#$FFFF
05289 14FC           50                         push	ax
05290                                           ! Debug: list int = const $382 (used reg = )
05291 14FD           B8                   0382  mov	ax,#$382
05292 1500           50                         push	ax
05293                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05294 1501           FF76         EA            push	-$16[bp]
05295                                           ! Debug: func () void = write_word+0 (used reg = )
05296 1504           E8         F12B            call	_write_word
05297 1507           83C4                   06  add	sp,*6
05298                                           !BCC_EOS
05299                                           ! 1319 }
05300 150A           89EC                       mov	sp,bp
05301 150C           5D                         pop	bp
05302 150D           C3                         ret
05303                                           ! 1320 static Bit8u
05304                                           ! Register BX used in function init_boot_vectors
05305                                           ! 1321 get_boot_vector(i, e)
05306                                           ! 1322 Bit16u i; ipl_entry_t *e;
05307                       0000150E            _get_boot_vector:
05308                                           !BCC_EOS
05309                                           !BCC_EOS
05310                                           ! 1323 {
05311                                           ! 1324   Bit16u count;
05312                                           !BCC_EOS
05313                                           ! 1325   Bit16u ss = get_SS();
05314 150E           55                         push	bp
05315 150F           89E5                       mov	bp,sp
05316 1511           83C4                   FC  add	sp,*-4
05317                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05318 1514           E8         F136            call	_get_SS
05319                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05320 1517           8946         FC            mov	-4[bp],ax
05321                                           !BCC_EOS
05322                                           ! 1326   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05323 151A           4C                         dec	sp
05324 151B           4C                         dec	sp
05325                                           ! Debug: list int = const $E (used reg = )
05326 151C           B8                   000E  mov	ax,*$E
05327 151F           50                         push	ax
05328                                           ! Debug: list int = const $40 (used reg = )
05329 1520           B8                   0040  mov	ax,*$40
05330 1523           50                         push	ax
05331                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05332 1524           E8         F0E0            call	_read_word
05333 1527           83C4                   04  add	sp,*4
05334                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
05335 152A           8946         FA            mov	-6[bp],ax
05336                                           !BCC_EOS
05337                                           ! 1327   count = read_word(ebda_seg, 0x0380);
05338                                           ! Debug: list int = const $380 (used reg = )
05339 152D           B8                   0380  mov	ax,#$380
05340 1530           50                         push	ax
05341                                           ! Debug: list unsigned short ebda_seg = [S+$A-8] (used reg = )
05342 1531           FF76         FA            push	-6[bp]
05343                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05344 1534           E8         F0D0            call	_read_word
05345 1537           83C4                   04  add	sp,*4
05346                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+8-4] (used reg = )
05347 153A           8946         FE            mov	-2[bp],ax
05348                                           !BCC_EOS
05349                                           ! 1328   if (i >= count) return 0;
05350                                           ! Debug: ge unsigned short count = [S+8-4] to unsigned short i = [S+8+2] (used reg = )
05351 153D           8B46         04            mov	ax,4[bp]
05352 1540           3B46         FE            cmp	ax,-2[bp]
05353 1543           72           06            jb  	.113
05354                       00001545            .114:
05355 1545           30C0                       xor	al,al
05356 1547           89EC                       mov	sp,bp
05357 1549           5D                         pop	bp
05358 154A           C3                         ret
05359                                           !BCC_EOS
05360                                           ! 1329   memcpyb(ss, e, ebda_seg, 0x0300 + i * sizeof (*e), sizeof (*e));
05361                       0000154B            .113:
05362                                           ! Debug: list int = const $10 (used reg = )
05363 154B           B8                   0010  mov	ax,*$10
05364 154E           50                         push	ax
05365                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05366 154F           8B46         04            mov	ax,4[bp]
05367 1552           B1                     04  mov	cl,*4
05368 1554           D3E0                       shl	ax,cl
05369                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05370                                           ! Debug: expression subtree swapping
05371                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05372 1556           05                   0300  add	ax,#$300
05373 1559           50                         push	ax
05374                                           ! Debug: list unsigned short ebda_seg = [S+$C-8] (used reg = )
05375 155A           FF76         FA            push	-6[bp]
05376                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05377 155D           FF76         06            push	6[bp]
05378                                           ! Debug: list unsigned short ss = [S+$10-6] (used reg = )
05379 1560           FF76         FC            push	-4[bp]
05380                                           ! Debug: func () void = memcpyb+0 (used reg = )
05381 1563           E8         EABE            call	_memcpyb
05382 1566           83C4                   0A  add	sp,*$A
05383                                           !BCC_EOS
05384                                           ! 1330   return 1;
05385 1569           B0                     01  mov	al,*1
05386 156B           89EC                       mov	sp,bp
05387 156D           5D                         pop	bp
05388 156E           C3                         ret
05389                                           !BCC_EOS
05390                                           ! 1331 }
05391                                           ! 1332   void
05392                                           ! 1333 interactive_bootkey()
05393                                           ! 1334 {
05394                                           export	_interactive_bootkey
05395                       0000156F            _interactive_bootkey:
05396                                           ! 1335   ipl_entry_t e;
05397                                           !BCC_EOS
05398                                           ! 1336   Bit16u count;
05399                                           !BCC_EOS
05400                                           ! 1337   char description[33];
05401                                           !BCC_EOS
05402                                           ! 1338   Bit8u scan_code;
05403                                           !BCC_EOS
05404                                           ! 1339   Bit8u i;
05405                                           !BCC_EOS
05406                                           ! 1340   Bit16u ss = get_SS();
05407 156F           55                         push	bp
05408 1570           89E5                       mov	bp,sp
05409 1572           83C4                   C8  add	sp,*-$38
05410                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05411 1575           E8         F0D5            call	_get_SS
05412                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05413 1578           8946         C8            mov	-$38[bp],ax
05414                                           !BCC_EOS
05415                                           ! 1341   Bit16u valid_choice = 0;
05416 157B           4C                         dec	sp
05417 157C           4C                         dec	sp
05418                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05419 157D           31C0                       xor	ax,ax
05420 157F           8946         C6            mov	-$3A[bp],ax
05421                                           !BCC_EOS
05422                                           ! 1342   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05423 1582           4C                         dec	sp
05424 1583           4C                         dec	sp
05425                                           ! Debug: list int = const $E (used reg = )
05426 1584           B8                   000E  mov	ax,*$E
05427 1587           50                         push	ax
05428                                           ! Debug: list int = const $40 (used reg = )
05429 1588           B8                   0040  mov	ax,*$40
05430 158B           50                         push	ax
05431                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05432 158C           E8         F078            call	_read_word
05433 158F           83C4                   04  add	sp,*4
05434                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$3E-$3E] (used reg = )
05435 1592           8946         C4            mov	-$3C[bp],ax
05436                                           !BCC_EOS
05437                                           ! 1343   bios_printf(2, "\n\nPress F12 for boot menu.\n\n");
05438                                           ! Debug: list * char = .115+0 (used reg = )
05439 1595           BB                   D51F  mov	bx,#.115
05440 1598           53                         push	bx
05441                                           ! Debug: list int = const 2 (used reg = )
05442 1599           B8                   0002  mov	ax,*2
05443 159C           50                         push	ax
05444                                           ! Debug: func () void = bios_printf+0 (used reg = )
05445 159D           E8         F47B            call	_bios_printf
05446 15A0           83C4                   04  add	sp,*4
05447                                           !BCC_EOS
05448                                           ! 1344   while (check_for_keystroke())
05449                                           ! 1345   {
05450 15A3           E9         01B4            br 	.117
05451                       000015A6            .118:
05452                                           ! 1346     scan_code = get_keystroke();
05453                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05454 15A6           E8         F439            call	_get_keystroke
05455                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05456 15A9           8846         CC            mov	-$34[bp],al
05457                                           !BCC_EOS
05458                                           ! 1347     if (scan_code != 0x86)
05459                                           ! Debug: ne int = const $86 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05460 15AC           8A46         CC            mov	al,-$34[bp]
05461 15AF           3C                     86  cmp	al,#$86
05462 15B1           74           03            je  	.119
05463                       000015B3            .11A:
05464                                           ! 1348       continue;
05465 15B3           E9         01A4            br 	.117
05466                                           !BCC_EOS
05467                                           ! 1349     while (check_for_keystroke())
05468                       000015B6            .119:
05469                                           ! 1350       get_keystroke();
05470 15B6           EB           03            jmp .11C
05471                       000015B8            .11D:
05472                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05473 15B8           E8         F427            call	_get_keystroke
05474                                           !BCC_EOS
05475                                           ! 1351     bios_printf(2, "Select boot device:\n\n");
05476                       000015BB            .11C:
05477                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05478 15BB           E8         F416            call	_check_for_keystroke
05479 15BE           84C0                       test	al,al
05480 15C0           75           F6            jne	.11D
05481                       000015C2            .11E:
05482                       000015C2            .11B:
05483                                           ! Debug: list * char = .11F+0 (used reg = )
05484 15C2           BB                   D509  mov	bx,#.11F
05485 15C5           53                         push	bx
05486                                           ! Debug: list int = const 2 (used reg = )
05487 15C6           B8                   0002  mov	ax,*2
05488 15C9           50                         push	ax
05489                                           ! Debug: func () void = bios_printf+0 (used reg = )
05490 15CA           E8         F44E            call	_bios_printf
05491 15CD           83C4                   04  add	sp,*4
05492                                           !BCC_EOS
05493                                           ! 1352     count = read_word(ebda_seg, 0x0380);
05494                                           ! Debug: list int = const $380 (used reg = )
05495 15D0           B8                   0380  mov	ax,#$380
05496 15D3           50                         push	ax
05497                                           ! Debug: list unsigned short ebda_seg = [S+$40-$3E] (used reg = )
05498 15D4           FF76         C4            push	-$3C[bp]
05499                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05500 15D7           E8         F02D            call	_read_word
05501 15DA           83C4                   04  add	sp,*4
05502                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3E-$14] (used reg = )
05503 15DD           8946         EE            mov	-$12[bp],ax
05504                                           !BCC_EOS
05505                                           ! 1353     for (i = 0; i < count; i++)
05506                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3E-$37] (used reg = )
05507 15E0           30C0                       xor	al,al
05508 15E2           8846         CB            mov	-$35[bp],al
05509                                           !BCC_EOS
05510                                           !BCC_EOS
05511                                           ! 1354     {
05512 15E5           E9         00FE            br 	.122
05513                       000015E8            .123:
05514                                           ! 1355       memcpyb(ss, &e, ebda_seg, 0x0300 + i * sizeof (e), sizeof (e));
05515                                           ! Debug: list int = const $10 (used reg = )
05516 15E8           B8                   0010  mov	ax,*$10
05517 15EB           50                         push	ax
05518                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05519 15EC           8A46         CB            mov	al,-$35[bp]
05520 15EF           30E4                       xor	ah,ah
05521 15F1           B1                     04  mov	cl,*4
05522 15F3           D3E0                       shl	ax,cl
05523                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05524                                           ! Debug: expression subtree swapping
05525                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05526 15F5           05                   0300  add	ax,#$300
05527 15F8           50                         push	ax
05528                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05529 15F9           FF76         C4            push	-$3C[bp]
05530                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05531 15FC           8D5E         F0            lea	bx,-$10[bp]
05532 15FF           53                         push	bx
05533                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05534 1600           FF76         C8            push	-$38[bp]
05535                                           ! Debug: func () void = memcpyb+0 (used reg = )
05536 1603           E8         EA1E            call	_memcpyb
05537 1606           83C4                   0A  add	sp,*$A
05538                                           !BCC_EOS
05539                                           ! 1356       bios_printf
05540                                           ! 1356 (2, "%d. ", i+1);
05541                                           ! Debug: add int = const 1 to unsigned char i = [S+$3E-$37] (used reg = )
05542 1609           8A46         CB            mov	al,-$35[bp]
05543 160C           30E4                       xor	ah,ah
05544                                           ! Debug: list unsigned int = ax+1 (used reg = )
05545 160E           40                         inc	ax
05546 160F           50                         push	ax
05547                                           ! Debug: list * char = .124+0 (used reg = )
05548 1610           BB                   D504  mov	bx,#.124
05549 1613           53                         push	bx
05550                                           ! Debug: list int = const 2 (used reg = )
05551 1614           B8                   0002  mov	ax,*2
05552 1617           50                         push	ax
05553                                           ! Debug: func () void = bios_printf+0 (used reg = )
05554 1618           E8         F400            call	_bios_printf
05555 161B           83C4                   06  add	sp,*6
05556                                           !BCC_EOS
05557                                           ! 1357       switch(e.type)
05558 161E           8B46         F0            mov	ax,-$10[bp]
05559                                           ! 1358       {
05560 1621           E9         009F            br 	.127
05561                                           ! 1359         case 0x01:
05562                                           ! 1360         case 0x02:
05563                       00001624            .128:
05564                                           ! 1361         case 0x03:
05565                       00001624            .129:
05566                                           ! 1362           bios_printf(2, "%s\n", drivetypes[e.type]);
05567                       00001624            .12A:
05568                                           ! Debug: ptradd unsigned short e = [S+$3E-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05569 1624           8B5E         F0            mov	bx,-$10[bp]
05570 1627           89DA                       mov	dx,bx
05571 1629           D1E3                       shl	bx,*1
05572 162B           D1E3                       shl	bx,*1
05573 162D           01D3                       add	bx,dx
05574 162F           D1E3                       shl	bx,*1
05575                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05576                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05577 1631           81C3                 137F  add	bx,#_drivetypes
05578 1635           53                         push	bx
05579                                           ! Debug: list * char = .12B+0 (used reg = )
05580 1636           BB                   D500  mov	bx,#.12B
05581 1639           53                         push	bx
05582                                           ! Debug: list int = const 2 (used reg = )
05583 163A           B8                   0002  mov	ax,*2
05584 163D           50                         push	ax
05585                                           ! Debug: func () void = bios_printf+0 (used reg = )
05586 163E           E8         F3DA            call	_bios_printf
05587 1641           83C4                   06  add	sp,*6
05588                                           !BCC_EOS
05589                                           ! 1363           break;
05590 1644           E9         0098            br 	.125
05591                                           !BCC_EOS
05592                                           ! 1364         case 0x80:
05593                                           ! 1365           bios_printf(2, "%s", drivetypes[4]);
05594                       00001647            .12C:
05595                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05596 1647           BB                   13A7  mov	bx,#_drivetypes+$28
05597 164A           53                         push	bx
05598                                           ! Debug: list * char = .12D+0 (used reg = )
05599 164B           BB                   D4FD  mov	bx,#.12D
05600 164E           53                         push	bx
05601                                           ! Debug: list int = const 2 (used reg = )
05602 164F           B8                   0002  mov	ax,*2
05603 1652           50                         push	ax
05604                                           ! Debug: func () void = bios_printf+0 (used reg = )
05605 1653           E8         F3C5            call	_bios_printf
05606 1656           83C4                   06  add	sp,*6
05607                                           !BCC_EOS
05608                                           ! 1366           if (e.description != 0)
05609                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3E-$A] (used reg = )
05610                                           ! Debug: expression subtree swapping
05611 1659           31C0                       xor	ax,ax
05612 165B           31DB                       xor	bx,bx
05613 165D           53                         push	bx
05614 165E           50                         push	ax
05615 165F           8B46         F8            mov	ax,-8[bp]
05616 1662           8B5E         FA            mov	bx,-6[bp]
05617 1665           8D7E         C0            lea	di,-2+..FFFF[bp]
05618 1668           E8         EA60            call	lcmpul
05619 166B           8D66         C4            lea	sp,2+..FFFF[bp]
05620 166E           74           41            je  	.12E
05621                       00001670            .12F:
05622                                           ! 1367           {
05623                                           ! 1368             memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
05624                                           ! Debug: list int = const $20 (used reg = )
05625 1670           B8                   0020  mov	ax,*$20
05626 1673           50                         push	ax
05627                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$40-$A] (used reg = )
05628                                           ! Debug: expression subtree swapping
05629 1674           B8                   FFFF  mov	ax,#$FFFF
05630 1677           31DB                       xor	bx,bx
05631 1679           8D7E         F8            lea	di,-8[bp]
05632 167C           E8         EA3C            call	landul
05633                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05634                                           ! Debug: list unsigned short = ax+0 (used reg = )
05635 167F           50                         push	ax
05636                                           ! Debug: sr int = const $10 to unsigned long e = [S+$42-$A] (used reg = )
05637 1680           8B46         F8            mov	ax,-8[bp]
05638 1683           8B5E         FA            mov	bx,-6[bp]
05639 1686           93                         xchg	bx,ax
05640 1687           31DB                       xor	bx,bx
05641                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05642                                           ! Debug: list unsigned short = ax+0 (used reg = )
05643 1689           50                         push	ax
05644                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05645 168A           8D5E         CD            lea	bx,-$33[bp]
05646 168D           53                         push	bx
05647                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05648 168E           FF76         C8            push	-$38[bp]
05649                                           ! Debug: func () void = memcpyb+0 (used reg = )
05650 1691           E8         E990            call	_memcpyb
05651 1694           83C4                   0A  add	sp,*$A
05652                                           !BCC_EOS
05653                                           ! 1369             description[32] = 0;
05654                                           ! Debug: eq int = const 0 to char description = [S+$3E-$15] (used reg = )
05655 1697           30C0                       xor	al,al
05656 1699           8846         ED            mov	-$13[bp],al
05657                                           !BCC_EOS
05658                                           ! 1370             bios_printf(2, " [%S]", ss, description);
05659                                           ! Debug: list * char description = S+$3E-$35 (used reg = )
05660 169C           8D5E         CD            lea	bx,-$33[bp]
05661 169F           53                         push	bx
05662                                           ! Debug: list unsigned short ss = [S+$40-$3A] (used reg = )
05663 16A0           FF76         C8            push	-$38[bp]
05664                                           ! Debug: list * char = .130+0 (used reg = )
05665 16A3           BB                   D4F7  mov	bx,#.130
05666 16A6           53                         push	bx
05667                                           ! Debug: list int = const 2 (used reg = )
05668 16A7           B8                   0002  mov	ax,*2
05669 16AA           50                         push	ax
05670                                           ! Debug: func () void = bios_printf+0 (used reg = )
05671 16AB           E8         F36D            call	_bios_printf
05672 16AE           83C4                   08  add	sp,*8
05673                                           !BCC_EOS
05674                                           ! 1371          }
05675                                           ! 1372          bios_printf(2, "\n");
05676                       000016B1            .12E:
05677                                           ! Debug: list * char = .131+0 (used reg = )
05678 16B1           BB                   D4F5  mov	bx,#.131
05679 16B4           53                         push	bx
05680                                           ! Debug: list int = const 2 (used reg = )
05681 16B5           B8                   0002  mov	ax,*2
05682 16B8           50                         push	ax
05683                                           ! Debug: func () void = bios_printf+0 (used reg = )
05684 16B9           E8         F35F            call	_bios_printf
05685 16BC           83C4                   04  add	sp,*4
05686                                           !BCC_EOS
05687                                           ! 1373          break;
05688 16BF           EB           1E            jmp .125
05689                                           !BCC_EOS
05690                                           ! 1374       }
05691                                           ! 1375     }
05692 16C1           EB           1C            jmp .125
05693                       000016C3            .127:
05694 16C3           2D                   0001  sub	ax,*1
05695 16C6         0F84         FF5A            beq 	.128
05696 16CA           2D                   0001  sub	ax,*1
05697 16CD         0F84         FF53            beq 	.129
05698 16D1           2D                   0001  sub	ax,*1
05699 16D4         0F84         FF4C            beq 	.12A
05700 16D8           2D                   007D  sub	ax,*$7D
05701 16DB         0F84         FF68            beq 	.12C
05702                       000016DF            .125:
05703                       FFFFFFC2            ..FFFF	=	-$3E
05704                                           ! 1376     count++;
05705                       000016DF            .121:
05706                                           ! Debug: postinc unsigned char i = [S+$3E-$37] (used reg = )
05707 16DF           8A46         CB            mov	al,-$35[bp]
05708 16E2           40                         inc	ax
05709 16E3           8846         CB            mov	-$35[bp],al
05710                       000016E6            .122:
05711                                           ! Debug: lt unsigned short count = [S+$3E-$14] to unsigned char i = [S+$3E-$37] (used reg = )
05712 16E6           8A46         CB            mov	al,-$35[bp]
05713 16E9           30E4                       xor	ah,ah
05714 16EB           3B46         EE            cmp	ax,-$12[bp]
05715 16EE         0F82         FEF6            blo 	.123
05716                       000016F2            .132:
05717                       000016F2            .120:
05718                                           ! Debug: postinc unsigned short count = [S+$3E-$14] (used reg = )
05719 16F2           8B46         EE            mov	ax,-$12[bp]
05720 16F5           40                         inc	ax
05721 16F6           8946         EE            mov	-$12[bp],ax
05722                                           !BCC_EOS
05723                                           ! 1377     while (!valid_choice) {
05724 16F9           EB           48            jmp .134
05725                       000016FB            .135:
05726                                           ! 1378       scan_code = get_keystroke();
05727                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05728 16FB           E8         F2E4            call	_get_keystroke
05729                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05730 16FE           8846         CC            mov	-$34[bp],al
05731                                           !BCC_EOS
05732                                           ! 1379       if (scan_code == 0x01 || scan_code == 0x58)
05733                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05734 1701           8A46         CC            mov	al,-$34[bp]
05735 1704           3C                     01  cmp	al,*1
05736 1706           74           07            je  	.137
05737                       00001708            .138:
05738                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05739 1708           8A46         CC            mov	al,-$34[bp]
05740 170B           3C                     58  cmp	al,*$58
05741 170D           75           08            jne 	.136
05742                       0000170F            .137:
05743                                           ! 1380       {
05744                                           ! 1381         valid_choice = 1;
05745                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05746 170F           B8                   0001  mov	ax,*1
05747 1712           8946         C6            mov	-$3A[bp],ax
05748                                           !BCC_EOS
05749                                           ! 1382       }
05750                                           ! 1383       else if (scan_code <= count)
05751 1715           EB           2C            jmp .139
05752                       00001717            .136:
05753                                           ! Debug: le unsigned short count = [S+$3E-$14] to unsigned char scan_code = [S+$3E-$36] (used reg = )
05754 1717           8A46         CC            mov	al,-$34[bp]
05755 171A           30E4                       xor	ah,ah
05756 171C           3B46         EE            cmp	ax,-$12[bp]
05757 171F           77           22            ja  	.13A
05758                       00001721            .13B:
05759                                           ! 1384       {
05760                                           ! 1385         valid_choice = 1;
05761                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05762 1721           B8                   0001  mov	ax,*1
05763 1724           8946         C6            mov	-$3A[bp],ax
05764                                           !BCC_EOS
05765                                           ! 1386         scan_code -= 1;
05766                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05767 1727           8A46         CC            mov	al,-$34[bp]
05768 172A           30E4                       xor	ah,ah
05769 172C           48                         dec	ax
05770 172D           8846         CC            mov	-$34[bp],al
05771                                           !BCC_EOS
05772                                           ! 1387         write_word(ebda_seg, 0x0384, scan_code);
05773                                           ! Debug: list unsigned char scan_code = [S+$3E-$36] (used reg = )
05774 1730           8A46         CC            mov	al,-$34[bp]
05775 1733           30E4                       xor	ah,ah
05776 1735           50                         push	ax
05777                                           ! Debug: list int = const $384 (used reg = )
05778 1736           B8                   0384  mov	ax,#$384
05779 1739           50                         push	ax
05780                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05781 173A           FF76         C4            push	-$3C[bp]
05782                                           ! Debug: func () void = write_word+0 (used reg = )
05783 173D           E8         EEF2            call	_write_word
05784 1740           83C4                   06  add	sp,*6
05785                                           !BCC_EOS
05786                                           ! 1388       }
05787                                           ! 1389     }
05788                       00001743            .13A:
05789                       00001743            .139:
05790                                           ! 1390     bios_printf(2, "\n");
05791                       00001743            .134:
05792 1743           8B46         C6            mov	ax,-$3A[bp]
05793 1746           85C0                       test	ax,ax
05794 1748           74           B1            je 	.135
05795                       0000174A            .13C:
05796                       0000174A            .133:
05797                                           ! Debug: list * char = .13D+0 (used reg = )
05798 174A           BB                   D4F3  mov	bx,#.13D
05799 174D           53                         push	bx
05800                                           ! Debug: list int = const 2 (used reg = )
05801 174E           B8                   0002  mov	ax,*2
05802 1751           50                         push	ax
05803                                           ! Debug: func () void = bios_printf+0 (used reg = )
05804 1752           E8         F2C6            call	_bios_printf
05805 1755           83C4                   04  add	sp,*4
05806                                           !BCC_EOS
05807                                           ! 1391     break;
05808 1758           EB           09            jmp .116
05809                                           !BCC_EOS
05810                                           ! 1392   }
05811                                           ! 1393 }
05812                       0000175A            .117:
05813                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05814 175A           E8         F277            call	_check_for_keystroke
05815 175D           84C0                       test	al,al
05816 175F         0F85         FE43            bne 	.118
05817                       00001763            .13E:
05818                       00001763            .116:
05819 1763           89EC                       mov	sp,bp
05820 1765           5D                         pop	bp
05821 1766           C3                         ret
05822                                           ! 1394 void
05823                                           ! Register BX used in function interactive_bootkey
05824                                           ! 1395 print_boot_device(type, desc)
05825                                           ! 1396   Bit16u type; Bit32u desc;
05826                                           export	_print_boot_device
05827                       00001767            _print_boot_device:
05828                                           !BCC_EOS
05829                                           !BCC_EOS
05830                                           ! 1397 {
05831                                           ! 1398   char description[33];
05832                                           !BCC_EOS
05833                                           ! 1399   Bit16u ss = get_SS();
05834 1767           55                         push	bp
05835 1768           89E5                       mov	bp,sp
05836 176A           83C4                   DC  add	sp,*-$24
05837                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05838 176D           E8         EEDD            call	_get_SS
05839                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$26-$26] (used reg = )
05840 1770           8946         DC            mov	-$24[bp],ax
05841                                           !BCC_EOS
05842                                           ! 1400   if (type == 0x80) type = 0x4;
05843                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$26+2] (used reg = )
05844 1773           8B46         04            mov	ax,4[bp]
05845 1776           3D                   0080  cmp	ax,#$80
05846 1779           75           06            jne 	.13F
05847                       0000177B            .140:
05848                                           ! Debug: eq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05849 177B           B8                   0004  mov	ax,*4
05850 177E           8946         04            mov	4[bp],ax
05851                                           !BCC_EOS
05852                                           ! 1401   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05853                       00001781            .13F:
05854                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$26+2] (used reg = )
05855 1781           8B46         04            mov	ax,4[bp]
05856 1784           85C0                       test	ax,ax
05857 1786           74           08            je  	.142
05858                       00001788            .143:
05859                                           ! Debug: gt int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05860 1788           8B46         04            mov	ax,4[bp]
05861 178B           3D                   0004  cmp	ax,*4
05862 178E           76           0E            jbe 	.141
05863                       00001790            .142:
05864                                           ! Debug: list * char = .144+0 (used reg = )
05865 1790           BB                   D4E3  mov	bx,#.144
05866 1793           53                         push	bx
05867                                           ! Debug: list int = const 7 (used reg = )
05868 1794           B8                   0007  mov	ax,*7
05869 1797           50                         push	ax
05870                                           ! Debug: func () void = bios_printf+0 (used reg = )
05871 1798           E8         F280            call	_bios_printf
05872 179B           83C4                   04  add	sp,*4
05873                                           !BCC_EOS
05874                                           ! 1402   bios_printf(2, "Boot device: %s", drivetypes[type]);
05875                       0000179E            .141:
05876                                           ! Debug: ptradd unsigned short type = [S+$26+2] to [5] [$A] char = drivetypes+0 (used reg = )
05877 179E           8B5E         04            mov	bx,4[bp]
05878 17A1           89DA                       mov	dx,bx
05879 17A3           D1E3                       shl	bx,*1
05880 17A5           D1E3                       shl	bx,*1
05881 17A7           01D3                       add	bx,dx
05882 17A9           D1E3                       shl	bx,*1
05883                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05884                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05885 17AB           81C3                 137F  add	bx,#_drivetypes
05886 17AF           53                         push	bx
05887                                           ! Debug: list * char = .145+0 (used reg = )
05888 17B0           BB                   D4D3  mov	bx,#.145
05889 17B3           53                         push	bx
05890                                           ! Debug: list int = const 2 (used reg = )
05891 17B4           B8                   0002  mov	ax,*2
05892 17B7           50                         push	ax
05893                                           ! Debug: func () void = bios_printf+0 (used reg = )
05894 17B8           E8         F260            call	_bios_printf
05895 17BB           83C4                   06  add	sp,*6
05896                                           !BCC_EOS
05897                                           ! 1403   if (type == 4 && desc != 0) {
05898                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05899 17BE           8B46         04            mov	ax,4[bp]
05900 17C1           3D                   0004  cmp	ax,*4
05901 17C4           75           58            jne 	.146
05902                       000017C6            .148:
05903                                           ! Debug: ne unsigned long = const 0 to unsigned long desc = [S+$26+4] (used reg = )
05904                                           ! Debug: expression subtree swapping
05905 17C6           31C0                       xor	ax,ax
05906 17C8           31DB                       xor	bx,bx
05907 17CA           53                         push	bx
05908 17CB           50                         push	ax
05909 17CC           8B46         06            mov	ax,6[bp]
05910 17CF           8B5E         08            mov	bx,8[bp]
05911 17D2           8D7E         D8            lea	di,-$28[bp]
05912 17D5           E8         E8F3            call	lcmpul
05913 17D8           8D66         DC            lea	sp,-$24[bp]
05914 17DB           74           41            je  	.146
05915                       000017DD            .147:
05916                                           ! 1404     memcpyb(ss, &description, (Bit16u)(desc >> 16), (Bit16u)(desc & 0xffff), 32);
05917                                           ! Debug: list int = const $20 (used reg = )
05918 17DD           B8                   0020  mov	ax,*$20
05919 17E0           50                         push	ax
05920                                           ! Debug: and unsigned long = const $FFFF to unsigned long desc = [S+$28+4] (used reg = )
05921                                           ! Debug: expression subtree swapping
05922 17E1           B8                   FFFF  mov	ax,#$FFFF
05923 17E4           31DB                       xor	bx,bx
05924 17E6           8D7E         06            lea	di,6[bp]
05925 17E9           E8         E8CF            call	landul
05926                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05927                                           ! Debug: list unsigned short = ax+0 (used reg = )
05928 17EC           50                         push	ax
05929                                           ! Debug: sr int = const $10 to unsigned long desc = [S+$2A+4] (used reg = )
05930 17ED           8B46         06            mov	ax,6[bp]
05931 17F0           8B5E         08            mov	bx,8[bp]
05932 17F3           93                         xchg	bx,ax
05933 17F4           31DB                       xor	bx,bx
05934                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05935                                           ! Debug: list unsigned short = ax+0 (used reg = )
05936 17F6           50                         push	ax
05937                                           ! Debug: list * [$21] char description = S+$2C-$23 (used reg = )
05938 17F7           8D5E         DF            lea	bx,-$21[bp]
05939 17FA           53                         push	bx
05940                                           ! Debug: list unsigned short ss = [S+$2E-$26] (used reg = )
05941 17FB           FF76         DC            push	-$24[bp]
05942                                           ! Debug: func () void = memcpyb+0 (used reg = )
05943 17FE           E8         E823            call	_memcpyb
05944 1801           83C4                   0A  add	sp,*$A
05945                                           !BCC_EOS
05946                                           ! 1405     description[32] = 0;
05947                                           ! Debug: eq int = const 0 to char description = [S+$26-3] (used reg = )
05948 1804           30C0                       xor	al,al
05949 1806           8846         FF            mov	-1[bp],al
05950                                           !BCC_EOS
05951                                           ! 1406     bios_printf(2, " [%S]", ss, description);
05952                                           ! Debug: list * char description = S+$26-$23 (used reg = )
05953 1809           8D5E         DF            lea	bx,-$21[bp]
05954 180C           53                         push	bx
05955                                           ! Debug: list unsigned short ss = [S+$28-$26] (used reg = )
05956 180D           FF76         DC            push	-$24[bp]
05957                                           ! Debug: list * char = .149+0 (used reg = )
05958 1810           BB                   D4CD  mov	bx,#.149
05959 1813           53                         push	bx
05960                                           ! Debug: list int = const 2 (used reg = )
05961 1814           B8                   0002  mov	ax,*2
05962 1817           50                         push	ax
05963                                           ! Debug: func () void = bios_printf+0 (used reg = )
05964 1818           E8         F200            call	_bios_printf
05965 181B           83C4                   08  add	sp,*8
05966                                           !BCC_EOS
05967                                           ! 1407   }
05968                                           ! 1408 }
05969                       0000181E            .146:
05970 181E           89EC                       mov	sp,bp
05971 1820           5D                         pop	bp
05972 1821           C3                         ret
05973                                           ! 1409   void
05974                                           ! Register BX used in function print_boot_device
05975                                           ! 1410 print_boot_failure(type, reason)
05976                                           ! 1411   Bit16u type; Bit8u reason;
05977                                           export	_print_boot_failure
05978                       00001822            _print_boot_failure:
05979                                           !BCC_EOS
05980                                           !BCC_EOS
05981                                           ! 1412 {
05982                                           ! 1413   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05983 1822           55                         push	bp
05984 1823           89E5                       mov	bp,sp
05985                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05986 1825           8B46         04            mov	ax,4[bp]
05987 1828           85C0                       test	ax,ax
05988 182A           74           08            je  	.14B
05989                       0000182C            .14C:
05990                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05991 182C           8B46         04            mov	ax,4[bp]
05992 182F           3D                   0003  cmp	ax,*3
05993 1832           76           0D            jbe 	.14A
05994                       00001834            .14B:
05995                                           ! Debug: list * char = .14D+0 (used reg = )
05996 1834           BB                   D4BD  mov	bx,#.14D
05997 1837           53                         push	bx
05998                                           ! Debug: list int = const 7 (used reg = )
05999 1838           B8                   0007  mov	ax,*7
06000 183B           50                         push	ax
06001                                           ! Debug: func () void = bios_printf+0 (used reg = )
06002 183C           E8         F1DC            call	_bios_printf
06003 183F           89EC                       mov	sp,bp
06004                                           !BCC_EOS
06005                                           ! 1414   bios_printf(2, " - failure", drivetypes[type]);
06006                       00001841            .14A:
06007                                           ! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
06008 1841           8B5E         04            mov	bx,4[bp]
06009 1844           89DA                       mov	dx,bx
06010 1846           D1E3                       shl	bx,*1
06011 1848           D1E3                       shl	bx,*1
06012 184A           01D3                       add	bx,dx
06013 184C           D1E3                       shl	bx,*1
06014                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
06015                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
06016 184E           81C3                 137F  add	bx,#_drivetypes
06017 1852           53                         push	bx
06018                                           ! Debug: list * char = .14E+0 (used reg = )
06019 1853           BB                   D4B2  mov	bx,#.14E
06020 1856           53                         push	bx
06021                                           ! Debug: list int = const 2 (used reg = )
06022 1857           B8                   0002  mov	ax,*2
06023 185A           50                         push	ax
06024                                           ! Debug: func () void = bios_printf+0 (used reg = )
06025 185B           E8         F1BD            call	_bios_printf
06026 185E           89EC                       mov	sp,bp
06027                                           !BCC_EOS
06028                                           ! 1415   if (type < 4) {
06029                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
06030 1860           8B46         04            mov	ax,4[bp]
06031 1863           3D                   0004  cmp	ax,*4
06032 1866           73           23            jae 	.14F
06033                       00001868            .150:
06034                                           ! 1416     if (reason==0)
06035                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
06036 1868           8A46         06            mov	al,6[bp]
06037 186B           84C0                       test	al,al
06038 186D           75           0F            jne 	.151
06039                       0000186F            .152:
06040                                           ! 1417       bios_printf(2, ": disk not bootable");
06041                                           ! Debug: list * char = .153+0 (used reg = )
06042 186F           BB                   D49E  mov	bx,#.153
06043 1872           53                         push	bx
06044                                           ! Debug: list int = const 2 (used reg = )
06045 1873           B8                   0002  mov	ax,*2
06046 1876           50                         push	ax
06047                                           ! Debug: func () void = bios_printf+0 (used reg = )
06048 1877           E8         F1A1            call	_bios_printf
06049 187A           89EC                       mov	sp,bp
06050                                           !BCC_EOS
06051                                           ! 1418     else
06052                                           ! 1419       bios_printf(2, ": could not read boot disk");
06053 187C           EB           0D            jmp .154
06054                       0000187E            .151:
06055                                           ! Debug: list * char = .155+0 (used reg = )
06056 187E           BB                   D483  mov	bx,#.155
06057 1881           53                         push	bx
06058                                           ! Debug: list int = const 2 (used reg = )
06059 1882           B8                   0002  mov	ax,*2
06060 1885           50                         push	ax
06061                                           ! Debug: func () void = bios_printf+0 (used reg = )
06062 1886           E8         F192            call	_bios_printf
06063 1889           89EC                       mov	sp,bp
06064                                           !BCC_EOS
06065                                           ! 1420   }
06066                       0000188B            .154:
06067                                           ! 1421   bios_printf(2, "\n\n");
06068                       0000188B            .14F:
06069                                           ! Debug: list * char = .156+0 (used reg = )
06070 188B           BB                   D480  mov	bx,#.156
06071 188E           53                         push	bx
06072                                           ! Debug: list int = const 2 (used reg = )
06073 188F           B8                   0002  mov	ax,*2
06074 1892           50                         push	ax
06075                                           ! Debug: func () void = bios_printf+0 (used reg = )
06076 1893           E8         F185            call	_bios_printf
06077 1896           89EC                       mov	sp,bp
06078                                           !BCC_EOS
06079                                           ! 1422 }
06080 1898           5D                         pop	bp
06081 1899           C3                         ret
06082                                           ! 1423   void
06083                                           ! Register BX used in function print_boot_failure
06084                                           ! 1424 print_cdromboot_failure( code )
06085                                           ! 1425   Bit16u code;
06086                                           export	_print_cdromboot_failure
06087                       0000189A            _print_cdromboot_failure:
06088                                           !BCC_EOS
06089                                           ! 1426 {
06090                                           ! 1427   return;
06091 189A           55                         push	bp
06092 189B           89E5                       mov	bp,sp
06093 189D           5D                         pop	bp
06094 189E           C3                         ret
06095                                           !BCC_EOS
06096                                           ! 1428 }
06097                                           ! 1429 void
06098                                           ! 1430 nmi_handler_msg()
06099                                           ! 1431 {
06100                                           export	_nmi_handler_msg
06101                       0000189F            _nmi_handler_msg:
06102                                           ! 1432   bios_printf((2 | 4 | 1), "NMI Handler called\n");
06103 189F           55                         push	bp
06104 18A0           89E5                       mov	bp,sp
06105                                           ! Debug: list * char = .157+0 (used reg = )
06106 18A2           BB                   D46C  mov	bx,#.157
06107 18A5           53                         push	bx
06108                                           ! Debug: list int = const 7 (used reg = )
06109 18A6           B8                   0007  mov	ax,*7
06110 18A9           50                         push	ax
06111                                           ! Debug: func () void = bios_printf+0 (used reg = )
06112 18AA           E8         F16E            call	_bios_printf
06113 18AD           89EC                       mov	sp,bp
06114                                           !BCC_EOS
06115                                           ! 1433 }
06116 18AF           5D                         pop	bp
06117 18B0           C3                         ret
06118                                           ! 1434 void
06119                                           ! Register BX used in function nmi_handler_msg
06120                                           ! 1435 int18_panic_msg()
06121                                           ! 1436 {
06122                                           export	_int18_panic_msg
06123                       000018B1            _int18_panic_msg:
06124                                           ! 1437   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
06125 18B1           55                         push	bp
06126 18B2           89E5                       mov	bp,sp
06127                                           ! Debug: list * char = .158+0 (used reg = )
06128 18B4           BB                   D457  mov	bx,#.158
06129 18B7           53                         push	bx
06130                                           ! Debug: list int = const 7 (used reg = )
06131 18B8           B8                   0007  mov	ax,*7
06132 18BB           50                         push	ax
06133                                           ! Debug: func () void = bios_printf+0 (used reg = )
06134 18BC           E8         F15C            call	_bios_printf
06135 18BF           89EC                       mov	sp,bp
06136                                           !BCC_EOS
06137                                           ! 1438 }
06138 18C1           5D                         pop	bp
06139 18C2           C3                         ret
06140                                           ! 1439 void
06141                                           ! Register BX used in function int18_panic_msg
06142                                           ! 1440 log_bios_start()
06143                                           ! 1441 {
06144                                           export	_log_bios_start
06145                       000018C3            _log_bios_start:
06146                                           ! 1442   ;
06147 18C3           55                         push	bp
06148 18C4           89E5                       mov	bp,sp
06149                                           !BCC_EOS
06150                                           ! 1443 }
06151 18C6           5D                         pop	bp
06152 18C7           C3                         ret
06153                                           ! 1444   bx_bool
06154                                           ! 1445 set_enable_a20(val)
06155                                           ! 1445 
06156                                           ! 1446   bx_bool val;
06157                                           export	_set_enable_a20
06158                       000018C8            _set_enable_a20:
06159                                           !BCC_EOS
06160                                           ! 1447 {
06161                                           ! 1448   Bit8u oldval;
06162                                           !BCC_EOS
06163                                           ! 1449   oldval = inb(0x92);
06164 18C8           55                         push	bp
06165 18C9           89E5                       mov	bp,sp
06166 18CB           4C                         dec	sp
06167 18CC           4C                         dec	sp
06168                                           ! Debug: list int = const $92 (used reg = )
06169 18CD           B8                   0092  mov	ax,#$92
06170 18D0           50                         push	ax
06171                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06172 18D1           E8         EC6A            call	_inb
06173 18D4           44                         inc	sp
06174 18D5           44                         inc	sp
06175                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
06176 18D6           8846         FF            mov	-1[bp],al
06177                                           !BCC_EOS
06178                                           ! 1450   if (val)
06179 18D9           8B46         04            mov	ax,4[bp]
06180 18DC           85C0                       test	ax,ax
06181 18DE           74           14            je  	.159
06182                       000018E0            .15A:
06183                                           ! 1451     outb(0x92, oldval | 0x02);
06184                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06185 18E0           8A46         FF            mov	al,-1[bp]
06186 18E3           0C                     02  or	al,*2
06187                                           ! Debug: list unsigned char = al+0 (used reg = )
06188 18E5           30E4                       xor	ah,ah
06189 18E7           50                         push	ax
06190                                           ! Debug: list int = const $92 (used reg = )
06191 18E8           B8                   0092  mov	ax,#$92
06192 18EB           50                         push	ax
06193                                           ! Debug: func () void = outb+0 (used reg = )
06194 18EC           E8         EC65            call	_outb
06195 18EF           83C4                   04  add	sp,*4
06196                                           !BCC_EOS
06197                                           ! 1452   else
06198                                           ! 1453     outb(0x92, oldval & 0xfd);
06199 18F2           EB           12            jmp .15B
06200                       000018F4            .159:
06201                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06202 18F4           8A46         FF            mov	al,-1[bp]
06203 18F7           24                     FD  and	al,#$FD
06204                                           ! Debug: list unsigned char = al+0 (used reg = )
06205 18F9           30E4                       xor	ah,ah
06206 18FB           50                         push	ax
06207                                           ! Debug: list int = const $92 (used reg = )
06208 18FC           B8                   0092  mov	ax,#$92
06209 18FF           50                         push	ax
06210                                           ! Debug: func () void = outb+0 (used reg = )
06211 1900           E8         EC51            call	_outb
06212 1903           83C4                   04  add	sp,*4
06213                                           !BCC_EOS
06214                                           ! 1454   return((oldval & 0x02) != 0);
06215                       00001906            .15B:
06216                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06217 1906           8A46         FF            mov	al,-1[bp]
06218 1909           24                     02  and	al,*2
06219                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06220 190B           84C0                       test	al,al
06221 190D           74           04            je 	.15C
06222 190F           B0                     01  mov	al,*1
06223 1911           EB           02            jmp	.15D
06224                       00001913            .15C:
06225 1913           30C0                       xor	al,al
06226                       00001915            .15D:
06227                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06228 1915           30E4                       xor	ah,ah
06229 1917           89EC                       mov	sp,bp
06230 1919           5D                         pop	bp
06231 191A           C3                         ret
06232                                           !BCC_EOS
06233                                           ! 1455 }
06234                                           ! 1456   void
06235                                           ! 1457 debugger_on()
06236                                           ! 1458 {
06237                                           export	_debugger_on
06238                       0000191B            _debugger_on:
06239                                           ! 1459   outb(0xfedc, 0x01);
06240 191B           55                         push	bp
06241 191C           89E5                       mov	bp,sp
06242                                           ! Debug: list int = const 1 (used reg = )
06243 191E           B8                   0001  mov	ax,*1
06244 1921           50                         push	ax
06245                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06246 1922           B8                   FEDC  mov	ax,#$FEDC
06247 1925           50                         push	ax
06248                                           ! Debug: func () void = outb+0 (used reg = )
06249 1926           E8         EC2B            call	_outb
06250 1929           89EC                       mov	sp,bp
06251                                           !BCC_EOS
06252                                           ! 1460 }
06253 192B           5D                         pop	bp
06254 192C           C3                         ret
06255                                           ! 1461   void
06256                                           ! 1462 debugger_off()
06257                                           ! 1463 {
06258                                           export	_debugger_off
06259                       0000192D            _debugger_off:
06260                                           ! 1464   outb(0xfedc, 0x00);
06261 192D           55                         push	bp
06262 192E           89E5                       mov	bp,sp
06263                                           ! Debug: list int = const 0 (used reg = )
06264 1930           31C0                       xor	ax,ax
06265 1932           50                         push	ax
06266                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06267 1933           B8                   FEDC  mov	ax,#$FEDC
06268 1936           50                         push	ax
06269                                           ! Debug: func () void = outb+0 (used reg = )
06270 1937           E8         EC1A            call	_outb
06271 193A           89EC                       mov	sp,bp
06272                                           !BCC_EOS
06273                                           ! 1465 }
06274 193C           5D                         pop	bp
06275 193D           C3                         ret
06276                                           ! 1466 int
06277                                           ! 1467 s3_resume()
06278                                           ! 1468 {
06279                                           export	_s3_resume
06280                       0000193E            _s3_resume:
06281                                           ! 1469     Bit32u s3_wakeup_vector;
06282                                           !BCC_EOS
06283                                           ! 1470     Bit8u s3_resume_flag;
06284                                           !BCC_EOS
06285                                           ! 1471     s3_resume_flag = read_byte(0x40, 0xb0);
06286 193E           55                         push	bp
06287 193F           89E5                       mov	bp,sp
06288 1941           83C4                   FA  add	sp,*-6
06289                                           ! Debug: list int = const $B0 (used reg = )
06290 1944           B8                   00B0  mov	ax,#$B0
06291 1947           50                         push	ax
06292                                           ! Debug: list int = const $40 (used reg = )
06293 1948           B8                   0040  mov	ax,*$40
06294 194B           50                         push	ax
06295                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
06296 194C           E8         ECA5            call	_read_byte
06297 194F           83C4                   04  add	sp,*4
06298                                           ! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06299 1952           8846         FB            mov	-5[bp],al
06300                                           !BCC_EOS
06301                                           ! 1472     s3_wakeup_vector = get_s3_waking_vector();
06302                                           ! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
06303 1955           E8         95A3            call	_get_s3_waking_vector
06304 1958           89D3                       mov	bx,dx
06305                                           ! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06306 195A           8946         FC            mov	-4[bp],ax
06307 195D           895E         FE            mov	-2[bp],bx
06308                                           !BCC_EOS
06309                                           ! 1473     ;
06310                                           !BCC_EOS
06311                                           ! 1474     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06312                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06313 1960           8A46         FB            mov	al,-5[bp]
06314 1963           3C                     FE  cmp	al,#$FE
06315 1965           75           0B            jne 	.15F
06316                       00001967            .160:
06317 1967           8B46         FC            mov	ax,-4[bp]
06318 196A           8B5E         FE            mov	bx,-2[bp]
06319 196D           E8         E7A4            call	ltstl
06320 1970           75           06            jne 	.15E
06321                       00001972            .15F:
06322                                           ! 1475      return 0;
06323 1972           31C0                       xor	ax,ax
06324 1974           89EC                       mov	sp,bp
06325 1976           5D                         pop	bp
06326 1977           C3                         ret
06327                                           !BCC_EOS
06328                                           ! 1476     write_byte(0x40, 0xb0, 0);
06329                       00001978            .15E:
06330                                           ! Debug: list int = const 0 (used reg = )
06331 1978           31C0                       xor	ax,ax
06332 197A           50                         push	ax
06333                                           ! Debug: list int = const $B0 (used reg = )
06334 197B           B8                   00B0  mov	ax,#$B0
06335 197E           50                         push	ax
06336                                           ! Debug: list int = const $40 (used reg = )
06337 197F           B8                   0040  mov	ax,*$40
06338 1982           50                         push	ax
06339                                           ! Debug: func () void = write_byte+0 (used reg = )
06340 1983           E8         EC94            call	_write_byte
06341 1986           83C4                   06  add	sp,*6
06342                                           !BCC_EOS
06343                                           ! 1477     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
06344                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06345                                           ! Debug: expression subtree swapping
06346 1989           B8                   000F  mov	ax,*$F
06347 198C           31DB                       xor	bx,bx
06348 198E           8D7E         FC            lea	di,-4[bp]
06349 1991           E8         E727            call	landul
06350                                           ! Debug: list unsigned long = bx+0 (used reg = )
06351 1994           53                         push	bx
06352 1995           50                         push	ax
06353                                           ! Debug: list int = const $B6 (used reg = )
06354 1996           B8                   00B6  mov	ax,#$B6
06355 1999           50                         push	ax
06356                                           ! Debug: list int = const $40 (used reg = )
06357 199A           B8                   0040  mov	ax,*$40
06358 199D           50                         push	ax
06359                                           ! Debug: func () void = write_word+0 (used reg = )
06360 199E           E8         EC91            call	_write_word
06361 19A1           83C4                   08  add	sp,*8
06362                                           !BCC_EOS
06363                                           ! 1478     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
06364                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06365 19A4           8B46         FC            mov	ax,-4[bp]
06366 19A7           8B5E         FE            mov	bx,-2[bp]
06367 19AA           BF                   0004  mov	di,*4
06368 19AD           E8         E779            call	lsrul
06369                                           ! Debug: list unsigned long = bx+0 (used reg = )
06370 19B0           53                         push	bx
06371 19B1           50                         push	ax
06372                                           ! Debug: list int = const $B8 (used reg = )
06373 19B2           B8                   00B8  mov	ax,#$B8
06374 19B5           50                         push	ax
06375                                           ! Debug: list int = const $40 (used reg = )
06376 19B6           B8                   0040  mov	ax,*$40
06377 19B9           50                         push	ax
06378                                           ! Debug: func () void = write_word+0 (used reg = )
06379 19BA           E8         EC75            call	_write_word
06380 19BD           83C4                   08  add	sp,*8
06381                                           !BCC_EOS
06382                                           ! 1479     ;
06383                                           !BCC_EOS
06384                                           ! 1480 #asm
06385                                           !BCC_EOS
06386                                           !BCC_ASM
06387                       00000001            _s3_resume.s3_resume_flag	set	1
06388                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06389                       00000002            _s3_resume.s3_wakeup_vector	set	2
06390                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06391 19C0           FF2E       04B6                jmpf [0x04b6]
06392                                           ! 1482 endasm
06393                                           !BCC_ENDASM
06394                                           !BCC_EOS
06395                                           ! 1483     return 1;
06396 19C4           B8                   0001  mov	ax,*1
06397 19C7           89EC                       mov	sp,bp
06398 19C9           5D                         pop	bp
06399 19CA           C3                         ret
06400                                           !BCC_EOS
06401                                           ! 1484 }
06402                                           ! 1485 void ata_init( )
06403                                           ! Register BX used in function s3_resume
06404                                           ! 1486 {
06405                                           export	_ata_init
06406                       000019CB            _ata_init:
06407                                           ! 1487   Bit16u ebda_seg=read_word(0x0040,0x000E);
06408 19CB           55                         push	bp
06409 19CC           89E5                       mov	bp,sp
06410 19CE           4C                         dec	sp
06411 19CF           4C                         dec	sp
06412                                           ! Debug: list int = const $E (used reg = )
06413 19D0           B8                   000E  mov	ax,*$E
06414 19D3           50                         push	ax
06415                                           ! Debug: list int = const $40 (used reg = )
06416 19D4           B8                   0040  mov	ax,*$40
06417 19D7           50                         push	ax
06418                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06419 19D8           E8         EC2C            call	_read_word
06420 19DB           83C4                   04  add	sp,*4
06421                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
06422 19DE           8946         FE            mov	-2[bp],ax
06423                                           !BCC_EOS
06424                                           ! 1488   Bit8u channel, device;
06425                                           !BCC_EOS
06426                                           ! 1489   for (channel=0; channel<4; channel++) {
06427 19E1           4C                         dec	sp
06428 19E2           4C                         dec	sp
06429                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
06430 19E3           30C0                       xor	al,al
06431 19E5           8846         FD            mov	-3[bp],al
06432                                           !BCC_EOS
06433                                           !BCC_EOS
06434 19E8           EB           77            jmp .163
06435                       000019EA            .164:
06436                                           ! 1490     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
06437                                           ! Debug: list int = const 0 (used reg = )
06438 19EA           31C0                       xor	ax,ax
06439 19EC           50                         push	ax
06440                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06441 19ED           8A46         FD            mov	al,-3[bp]
06442 19F0           30E4                       xor	ah,ah
06443 19F2           B1                     03  mov	cl,*3
06444 19F4           D3E0                       shl	ax,cl
06445 19F6           89C3                       mov	bx,ax
06446                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06447                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
06448 19F8           81C3                 0122  add	bx,#$122
06449 19FC           53                         push	bx
06450                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06451 19FD           FF76         FE            push	-2[bp]
06452                                           ! Debug: func () void = write_byte+0 (used reg = )
06453 1A00           E8         EC17            call	_write_byte
06454 1A03           83C4                   06  add	sp,*6
06455                                           !BCC_EOS
06456                                           ! 1491     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
06457                                           ! Debug: list int = const 0 (used reg = )
06458 1A06           31C0                       xor	ax,ax
06459 1A08           50                         push	ax
06460                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06461 1A09           8A46         FD            mov	al,-3[bp]
06462 1A0C           30E4                       xor	ah,ah
06463 1A0E           B1                     03  mov	cl,*3
06464 1A10           D3E0                       shl	ax,cl
06465 1A12           89C3                       mov	bx,ax
06466                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06467                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
06468 1A14           81C3                 0124  add	bx,#$124
06469 1A18           53                         push	bx
06470                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06471 1A19           FF76         FE            push	-2[bp]
06472                                           ! Debug: func () void = write_word+0 (used reg = )
06473 1A1C           E8         EC13            call	_write_word
06474 1A1F           83C4                   06  add	sp,*6
06475                                           !BCC_EOS
06476                                           ! 1492     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
06477                                           ! Debug: list int = const 0 (used reg = )
06478 1A22           31C0                       xor	ax,ax
06479 1A24           50                         push	ax
06480                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06481 1A25           8A46         FD            mov	al,-3[bp]
06482 1A28           30E4                       xor	ah,ah
06483 1A2A           B1                     03  mov	cl,*3
06484 1A2C           D3E0                       shl	ax,cl
06485 1A2E           89C3                       mov	bx,ax
06486                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06487                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
06488 1A30           81C3                 0126  add	bx,#$126
06489 1A34           53                         push	bx
06490                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06491 1A35           FF76         FE            push	-2[bp]
06492                                           ! Debug: func () void = write_word+0 (used reg = )
06493 1A38           E8         EBF7            call	_write_word
06494 1A3B           83C4                   06  add	sp,*6
06495                                           !BCC_EOS
06496                                           ! 1493     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
06497                                           ! Debug: list int = const 0 (used reg = )
06498 1A3E           31C0                       xor	ax,ax
06499 1A40           50                         push	ax
06500                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06501 1A41           8A46         FD            mov	al,-3[bp]
06502 1A44           30E4                       xor	ah,ah
06503 1A46           B1                     03  mov	cl,*3
06504 1A48           D3E0                       shl	ax,cl
06505 1A4A           89C3                       mov	bx,ax
06506                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06507                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
06508 1A4C           81C3                 0128  add	bx,#$128
06509 1A50           53                         push	bx
06510                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06511 1A51           FF76         FE            push	-2[bp]
06512                                           ! Debug: func () void = write_byte+0 (used reg = )
06513 1A54           E8         EBC3            call	_write_byte
06514 1A57           83C4                   06  add	sp,*6
06515                                           !BCC_EOS
06516                                           ! 1494     }
06517                                           ! 1495   for (device=0; device<(4*2); device++) {
06518                       00001A5A            .162:
06519                                           ! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
06520 1A5A           8A46         FD            mov	al,-3[bp]
06521 1A5D           40                         inc	ax
06522 1A5E           8846         FD            mov	-3[bp],al
06523                       00001A61            .163:
06524                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
06525 1A61           8A46         FD            mov	al,-3[bp]
06526 1A64           3C                     04  cmp	al,*4
06527 1A66           72           82            jb 	.164
06528                       00001A68            .165:
06529                       00001A68            .161:
06530                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06531 1A68           30C0                       xor	al,al
06532 1A6A           8846         FC            mov	-4[bp],al
06533                                           !BCC_EOS
06534                                           !BCC_EOS
06535 1A6D           E9         01C0            br 	.168
06536                       00001A70            .169:
06537                                           ! 1496     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
06538                                           ! Debug: list int = const 0 (used reg = )
06539 1A70           31C0                       xor	ax,ax
06540 1A72           50                         push	ax
06541                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06542 1A73           8A46         FC            mov	al,-4[bp]
06543 1A76           30E4                       xor	ah,ah
06544 1A78           B9                   001E  mov	cx,*$1E
06545 1A7B           F7E9                       imul	cx
06546 1A7D           89C3                       mov	bx,ax
06547                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06548                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06549 1A7F           81C3                 0142  add	bx,#$142
06550 1A83           53                         push	bx
06551                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06552 1A84           FF76         FE            push	-2[bp]
06553                                           ! Debug: func () void = write_byte+0 (used reg = )
06554 1A87           E8         EB90            call	_write_byte
06555 1A8A           83C4                   06  add	sp,*6
06556                                           !BCC_EOS
06557                                           ! 1497     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
06558                                           ! Debug: list int = const 0 (used reg = )
06559 1A8D           31C0                       xor	ax,ax
06560 1A8F           50                         push	ax
06561                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06562 1A90           8A46         FC            mov	al,-4[bp]
06563 1A93           30E4                       xor	ah,ah
06564 1A95           B9                   001E  mov	cx,*$1E
06565 1A98           F7E9                       imul	cx
06566 1A9A           89C3                       mov	bx,ax
06567                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06568                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
06569 1A9C           81C3                 0143  add	bx,#$143
06570 1AA0           53                         push	bx
06571                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06572 1AA1           FF76         FE            push	-2[bp]
06573                                           ! Debug: func () void = write_byte+0 (used reg = )
06574 1AA4           E8         EB73            call	_write_byte
06575 1AA7           83C4                   06  add	sp,*6
06576                                           !BCC_EOS
06577                                           ! 1498     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
06578                                           ! Debug: list int = const 0 (used reg = )
06579 1AAA           31C0                       xor	ax,ax
06580 1AAC           50                         push	ax
06581                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06582 1AAD           8A46         FC            mov	al,-4[bp]
06583 1AB0           30E4                       xor	ah,ah
06584 1AB2           B9                   001E  mov	cx,*$1E
06585 1AB5           F7E9                       imul	cx
06586 1AB7           89C3                       mov	bx,ax
06587                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06588                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
06589 1AB9           81C3                 0144  add	bx,#$144
06590 1ABD           53                         push	bx
06591                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06592 1ABE           FF76         FE            push	-2[bp]
06593                                           ! Debug: func () void = write_byte+0 (used reg = )
06594 1AC1           E8         EB56            call	_write_byte
06595 1AC4           83C4                   06  add	sp,*6
06596                                           !BCC_EOS
06597                                           ! 1499     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
06598                                           ! Debug: list int = const 0 (used reg = )
06599 1AC7           31C0                       xor	ax,ax
06600 1AC9           50                         push	ax
06601                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06602 1ACA           8A46         FC            mov	al,-4[bp]
06603 1ACD           30E4                       xor	ah,ah
06604 1ACF           B9                   001E  mov	cx,*$1E
06605 1AD2           F7E9                       imul	cx
06606 1AD4           89C3                       mov	bx,ax
06607                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06608                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
06609 1AD6           81C3                 0145  add	bx,#$145
06610 1ADA           53                         push	bx
06611                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06612 1ADB           FF76         FE            push	-2[bp]
06613                                           ! Debug: func () void = write_byte+0 (used reg = )
06614 1ADE           E8         EB39            call	_write_byte
06615 1AE1           83C4                   06  add	sp,*6
06616                                           !BCC_EOS
06617                                           ! 1500     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
06618                                           ! Debug: list int = const 0 (used reg = )
06619 1AE4           31C0                       xor	ax,ax
06620 1AE6           50                         push	ax
06621                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06622 1AE7           8A46         FC            mov	al,-4[bp]
06623 1AEA           30E4                       xor	ah,ah
06624 1AEC           B9                   001E  mov	cx,*$1E
06625 1AEF           F7E9                       imul	cx
06626 1AF1           89C3                       mov	bx,ax
06627                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06628                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
06629 1AF3           81C3                 0146  add	bx,#$146
06630 1AF7           53                         push	bx
06631                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06632 1AF8           FF76         FE            push	-2[bp]
06633                                           ! Debug: func () void = write_byte+0 (used reg = )
06634 1AFB           E8         EB1C            call	_write_byte
06635 1AFE           83C4                   06  add	sp,*6
06636                                           !BCC_EOS
06637                                           ! 1501     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
06638                                           ! Debug: list int = const 0 (used reg = )
06639 1B01           31C0                       xor	ax,ax
06640 1B03           50                         push	ax
06641                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06642 1B04           8A46         FC            mov	al,-4[bp]
06643 1B07           30E4                       xor	ah,ah
06644 1B09           B9                   001E  mov	cx,*$1E
06645 1B0C           F7E9                       imul	cx
06646 1B0E           89C3                       mov	bx,ax
06647                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06648                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
06649 1B10           81C3                 0148  add	bx,#$148
06650 1B14           53                         push	bx
06651                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06652 1B15           FF76         FE            push	-2[bp]
06653                                           ! Debug: func () void = write_word+0 (used reg = )
06654 1B18           E8         EB17            call	_write_word
06655 1B1B           83C4                   06  add	sp,*6
06656                                           !BCC_EOS
06657                                           ! 1502     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
06658                                           ! Debug: list int = const 0 (used reg = )
06659 1B1E           31C0                       xor	ax,ax
06660 1B20           50                         push	ax
06661                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06662 1B21           8A46         FC            mov	al,-4[bp]
06663 1B24           30E4                       xor	ah,ah
06664 1B26           B9                   001E  mov	cx,*$1E
06665 1B29           F7E9                       imul	cx
06666 1B2B           89C3                       mov	bx,ax
06667                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06668                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
06669 1B2D           81C3                 014A  add	bx,#$14A
06670 1B31           53                         push	bx
06671                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06672 1B32           FF76         FE            push	-2[bp]
06673                                           ! Debug: func () void = write_byte+0 (used reg = )
06674 1B35           E8         EAE2            call	_write_byte
06675 1B38           83C4                   06  add	sp,*6
06676                                           !BCC_EOS
06677                                           ! 1503     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
06678                                           ! Debug: list int = const 0 (used reg = )
06679 1B3B           31C0                       xor	ax,ax
06680 1B3D           50                         push	ax
06681                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06682 1B3E           8A46         FC            mov	al,-4[bp]
06683 1B41           30E4                       xor	ah,ah
06684 1B43           B9                   001E  mov	cx,*$1E
06685 1B46           F7E9                       imul	cx
06686 1B48           89C3                       mov	bx,ax
06687                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06688                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
06689 1B4A           81C3                 014C  add	bx,#$14C
06690 1B4E           53                         push	bx
06691                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06692 1B4F           FF76         FE            push	-2[bp]
06693                                           ! Debug: func () void = write_word+0 (used reg = )
06694 1B52           E8         EADD            call	_write_word
06695 1B55           83C4                   06  add	sp,*6
06696                                           !BCC_EOS
06697                                           ! 1504     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
06698                                           ! Debug: list int = const 0 (used reg = )
06699 1B58           31C0                       xor	ax,ax
06700 1B5A           50                         push	ax
06701                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06702 1B5B           8A46         FC            mov	al,-4[bp]
06703 1B5E           30E4                       xor	ah,ah
06704 1B60           B9                   001E  mov	cx,*$1E
06705 1B63           F7E9                       imul	cx
06706 1B65           89C3                       mov	bx,ax
06707                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06708                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
06709 1B67           81C3                 014E  add	bx,#$14E
06710 1B6B           53                         push	bx
06711                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06712 1B6C           FF76         FE            push	-2[bp]
06713                                           ! Debug: func () void = write_word+0 (used reg = )
06714 1B6F           E8         EAC0            call	_write_word
06715 1B72           83C4                   06  add	sp,*6
06716                                           !BCC_EOS
06717                                           ! 1505     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
06718                                           ! Debug: list int = const 0 (used reg = )
06719 1B75           31C0                       xor	ax,ax
06720 1B77           50                         push	ax
06721                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06722 1B78           8A46         FC            mov	al,-4[bp]
06723 1B7B           30E4                       xor	ah,ah
06724 1B7D           B9                   001E  mov	cx,*$1E
06725 1B80           F7E9                       imul	cx
06726 1B82           89C3                       mov	bx,ax
06727                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06728                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
06729 1B84           81C3                 0150  add	bx,#$150
06730 1B88           53                         push	bx
06731                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06732 1B89           FF76         FE            push	-2[bp]
06733                                           ! Debug: func () void = write_word+0 (used reg = )
06734 1B8C           E8         EAA3            call	_write_word
06735 1B8F           83C4                   06  add	sp,*6
06736                                           !BCC_EOS
06737                                           ! 1506     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[
06738                                           ! 1506 device].pchs.heads,0);
06739                                           ! Debug: list int = const 0 (used reg = )
06740 1B92           31C0                       xor	ax,ax
06741 1B94           50                         push	ax
06742                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06743 1B95           8A46         FC            mov	al,-4[bp]
06744 1B98           30E4                       xor	ah,ah
06745 1B9A           B9                   001E  mov	cx,*$1E
06746 1B9D           F7E9                       imul	cx
06747 1B9F           89C3                       mov	bx,ax
06748                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06749                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
06750 1BA1           81C3                 0152  add	bx,#$152
06751 1BA5           53                         push	bx
06752                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06753 1BA6           FF76         FE            push	-2[bp]
06754                                           ! Debug: func () void = write_word+0 (used reg = )
06755 1BA9           E8         EA86            call	_write_word
06756 1BAC           83C4                   06  add	sp,*6
06757                                           !BCC_EOS
06758                                           ! 1507     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
06759                                           ! Debug: list int = const 0 (used reg = )
06760 1BAF           31C0                       xor	ax,ax
06761 1BB1           50                         push	ax
06762                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06763 1BB2           8A46         FC            mov	al,-4[bp]
06764 1BB5           30E4                       xor	ah,ah
06765 1BB7           B9                   001E  mov	cx,*$1E
06766 1BBA           F7E9                       imul	cx
06767 1BBC           89C3                       mov	bx,ax
06768                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06769                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
06770 1BBE           81C3                 0154  add	bx,#$154
06771 1BC2           53                         push	bx
06772                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06773 1BC3           FF76         FE            push	-2[bp]
06774                                           ! Debug: func () void = write_word+0 (used reg = )
06775 1BC6           E8         EA69            call	_write_word
06776 1BC9           83C4                   06  add	sp,*6
06777                                           !BCC_EOS
06778                                           ! 1508     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
06779                                           ! Debug: list int = const 0 (used reg = )
06780 1BCC           31C0                       xor	ax,ax
06781 1BCE           50                         push	ax
06782                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06783 1BCF           8A46         FC            mov	al,-4[bp]
06784 1BD2           30E4                       xor	ah,ah
06785 1BD4           B9                   001E  mov	cx,*$1E
06786 1BD7           F7E9                       imul	cx
06787 1BD9           89C3                       mov	bx,ax
06788                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06789                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
06790 1BDB           81C3                 0156  add	bx,#$156
06791 1BDF           53                         push	bx
06792                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06793 1BE0           FF76         FE            push	-2[bp]
06794                                           ! Debug: func () void = write_word+0 (used reg = )
06795 1BE3           E8         EA4C            call	_write_word
06796 1BE6           83C4                   06  add	sp,*6
06797                                           !BCC_EOS
06798                                           ! 1509     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
06799                                           ! Debug: list long = const 0 (used reg = )
06800 1BE9           31C0                       xor	ax,ax
06801 1BEB           31DB                       xor	bx,bx
06802 1BED           53                         push	bx
06803 1BEE           50                         push	ax
06804                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06805 1BEF           8A46         FC            mov	al,-4[bp]
06806 1BF2           30E4                       xor	ah,ah
06807 1BF4           B9                   001E  mov	cx,*$1E
06808 1BF7           F7E9                       imul	cx
06809 1BF9           89C3                       mov	bx,ax
06810                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06811                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
06812 1BFB           81C3                 0158  add	bx,#$158
06813 1BFF           53                         push	bx
06814                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06815 1C00           FF76         FE            push	-2[bp]
06816                                           ! Debug: func () void = write_dword+0 (used reg = )
06817 1C03           E8         E495            call	_write_dword
06818 1C06           83C4                   08  add	sp,*8
06819                                           !BCC_EOS
06820                                           ! 1510     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
06821                                           ! Debug: list long = const 0 (used reg = )
06822 1C09           31C0                       xor	ax,ax
06823 1C0B           31DB                       xor	bx,bx
06824 1C0D           53                         push	bx
06825 1C0E           50                         push	ax
06826                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06827 1C0F           8A46         FC            mov	al,-4[bp]
06828 1C12           30E4                       xor	ah,ah
06829 1C14           B9                   001E  mov	cx,*$1E
06830 1C17           F7E9                       imul	cx
06831 1C19           89C3                       mov	bx,ax
06832                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06833                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
06834 1C1B           81C3                 015C  add	bx,#$15C
06835 1C1F           53                         push	bx
06836                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06837 1C20           FF76         FE            push	-2[bp]
06838                                           ! Debug: func () void = write_dword+0 (used reg = )
06839 1C23           E8         E475            call	_write_dword
06840 1C26           83C4                   08  add	sp,*8
06841                                           !BCC_EOS
06842                                           ! 1511     }
06843                                           ! 1512   for (device=0; device<(4*2); device++) {
06844                       00001C29            .167:
06845                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06846 1C29           8A46         FC            mov	al,-4[bp]
06847 1C2C           40                         inc	ax
06848 1C2D           8846         FC            mov	-4[bp],al
06849                       00001C30            .168:
06850                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06851 1C30           8A46         FC            mov	al,-4[bp]
06852 1C33           3C                     08  cmp	al,*8
06853 1C35         0F82         FE37            blo 	.169
06854                       00001C39            .16A:
06855                       00001C39            .166:
06856                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06857 1C39           30C0                       xor	al,al
06858 1C3B           8846         FC            mov	-4[bp],al
06859                                           !BCC_EOS
06860                                           !BCC_EOS
06861 1C3E           EB           39            jmp .16D
06862                       00001C40            .16E:
06863                                           ! 1513     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
06864                                           ! Debug: list int = const 8 (used reg = )
06865 1C40           B8                   0008  mov	ax,*8
06866 1C43           50                         push	ax
06867                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
06868 1C44           8A46         FC            mov	al,-4[bp]
06869 1C47           30E4                       xor	ah,ah
06870 1C49           89C3                       mov	bx,ax
06871                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06872                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
06873 1C4B           81C3                 0233  add	bx,#$233
06874 1C4F           53                         push	bx
06875                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06876 1C50           FF76         FE            push	-2[bp]
06877                                           ! Debug: func () void = write_byte+0 (used reg = )
06878 1C53           E8         E9C4            call	_write_byte
06879 1C56           83C4                   06  add	sp,*6
06880                                           !BCC_EOS
06881                                           ! 1514     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
06882                                           ! Debug: list int = const 8 (used reg = )
06883 1C59           B8                   0008  mov	ax,*8
06884 1C5C           50                         push	ax
06885                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
06886 1C5D           8A46         FC            mov	al,-4[bp]
06887 1C60           30E4                       xor	ah,ah
06888 1C62           89C3                       mov	bx,ax
06889                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06890                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
06891 1C64           81C3                 023C  add	bx,#$23C
06892 1C68           53                         push	bx
06893                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06894 1C69           FF76         FE            push	-2[bp]
06895                                           ! Debug: func () void = write_byte+0 (used reg = )
06896 1C6C           E8         E9AB            call	_write_byte
06897 1C6F           83C4                   06  add	sp,*6
06898                                           !BCC_EOS
06899                                           ! 1515     }
06900                                           ! 1516   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
06901                       00001C72            .16C:
06902                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06903 1C72           8A46         FC            mov	al,-4[bp]
06904 1C75           40                         inc	ax
06905 1C76           8846         FC            mov	-4[bp],al
06906                       00001C79            .16D:
06907                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06908 1C79           8A46         FC            mov	al,-4[bp]
06909 1C7C           3C                     08  cmp	al,*8
06910 1C7E           72           C0            jb 	.16E
06911                       00001C80            .16F:
06912                       00001C80            .16B:
06913                                           ! Debug: list int = const 0 (used reg = )
06914 1C80           31C0                       xor	ax,ax
06915 1C82           50                         push	ax
06916                                           ! Debug: list * unsigned char = const $232 (used reg = )
06917 1C83           B8                   0232  mov	ax,#$232
06918 1C86           50                         push	ax
06919                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06920 1C87           FF76         FE            push	-2[bp]
06921                                           ! Debug: func () void = write_byte+0 (used reg = )
06922 1C8A           E8         E98D            call	_write_byte
06923 1C8D           83C4                   06  add	sp,*6
06924                                           !BCC_EOS
06925                                           ! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
06926                                           ! Debug: list int = const 0 (used reg = )
06927 1C90           31C0                       xor	ax,ax
06928 1C92           50                         push	ax
06929                                           ! Debug: list * unsigned char = const $23B (used reg = )
06930 1C93           B8                   023B  mov	ax,#$23B
06931 1C96           50                         push	ax
06932                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06933 1C97           FF76         FE            push	-2[bp]
06934                                           ! Debug: func () void = write_byte+0 (used reg = )
06935 1C9A           E8         E97D            call	_write_byte
06936 1C9D           83C4                   06  add	sp,*6
06937                                           !BCC_EOS
06938                                           ! 1518 }
06939 1CA0           89EC                       mov	sp,bp
06940 1CA2           5D                         pop	bp
06941 1CA3           C3                         ret
06942                                           ! 1519 Bit8u await_ide();
06943                                           ! Register BX used in function ata_init
06944                                           !BCC_EOS
06945                                           ! 1520 static Bit8u await_ide(when_done,base,timeout)
06946                                           ! 1521   Bit8u when_done;
06947                       00001CA4            _await_ide:
06948                                           !BCC_EOS
06949                                           ! 1522   Bit16u base;
06950                                           !BCC_EOS
06951                                           ! 1523   Bit16u timeout;
06952                                           !BCC_EOS
06953                                           ! 1524 {
06954                                           ! 1525   Bit32u time=0,last=0;
06955 1CA4           55                         push	bp
06956 1CA5           89E5                       mov	bp,sp
06957 1CA7           83C4                   FC  add	sp,*-4
06958                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06959 1CAA           31C0                       xor	ax,ax
06960 1CAC           31DB                       xor	bx,bx
06961 1CAE           8946         FC            mov	-4[bp],ax
06962 1CB1           895E         FE            mov	-2[bp],bx
06963 1CB4           83C4                   FC  add	sp,*-4
06964                                           ! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
06965 1CB7           31C0                       xor	ax,ax
06966 1CB9           31DB                       xor	bx,bx
06967 1CBB           8946         F8            mov	-8[bp],ax
06968 1CBE           895E         FA            mov	-6[bp],bx
06969                                           !BCC_EOS
06970                                           ! 1526   Bit8u status;
06971                                           !BCC_EOS
06972                                           ! 1527   Bit8u result;
06973                                           !BCC_EOS
06974                                           ! 1528   for(;;) {
06975 1CC1           4C                         dec	sp
06976 1CC2           4C                         dec	sp
06977                                           !BCC_EOS
06978                                           !BCC_EOS
06979                       00001CC3            .172:
06980                                           ! 1529     status = inb(base+7);
06981                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06982 1CC3           8B46         06            mov	ax,6[bp]
06983                                           ! Debug: list unsigned int = ax+7 (used reg = )
06984 1CC6           05                   0007  add	ax,*7
06985 1CC9           50                         push	ax
06986                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06987 1CCA           E8         E871            call	_inb
06988 1CCD           44                         inc	sp
06989 1CCE           44                         inc	sp
06990                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$C-$B] (used reg = )
06991 1CCF           8846         F7            mov	-9[bp],al
06992                                           !BCC_EOS
06993                                           ! 1530     time++;
06994                                           ! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
06995 1CD2           8B46         FC            mov	ax,-4[bp]
06996 1CD5           8B76         FE            mov	si,-2[bp]
06997 1CD8           8D5E         FC            lea	bx,-4[bp]
06998 1CDB           E8         E431            call	lincl
06999                                           !BCC_EOS
07000                                           ! 1531     if (when_done == 1)
07001                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
07002 1CDE           8A46         04            mov	al,4[bp]
07003 1CE1           3C                     01  cmp	al,*1
07004 1CE3           75           0B            jne 	.173
07005                       00001CE5            .174:
07006                                           ! 1532       result = status & 0x80;
07007                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07008 1CE5           8A46         F7            mov	al,-9[bp]
07009 1CE8           24                     80  and	al,#$80
07010                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07011 1CEA           8846         F6            mov	-$A[bp],al
07012                                           !BCC_EOS
07013                                           ! 1533     else if (when_done == 2)
07014 1CED           E9         0094            br 	.175
07015                       00001CF0            .173:
07016                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
07017 1CF0           8A46         04            mov	al,4[bp]
07018 1CF3           3C                     02  cmp	al,*2
07019 1CF5           75           15            jne 	.176
07020                       00001CF7            .177:
07021                                           ! 1534       result = !(status & 0x80);
07022                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07023 1CF7           8A46         F7            mov	al,-9[bp]
07024 1CFA           24                     80  and	al,#$80
07025 1CFC           84C0                       test	al,al
07026 1CFE           75           04            jne 	.178
07027                       00001D00            .179:
07028 1D00           B0                     01  mov	al,*1
07029 1D02           EB           02            jmp	.17A
07030                       00001D04            .178:
07031 1D04           30C0                       xor	al,al
07032                       00001D06            .17A:
07033                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07034 1D06           8846         F6            mov	-$A[bp],al
07035                                           !BCC_EOS
07036                                           ! 1535     else if (when_done == 3)
07037 1D09           E9         0078            br 	.17B
07038                       00001D0C            .176:
07039                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
07040 1D0C           8A46         04            mov	al,4[bp]
07041 1D0F           3C                     03  cmp	al,*3
07042 1D11           75           1D            jne 	.17C
07043                       00001D13            .17D:
07044                                           ! 1536       result = !(status & 0x80) && (status & 0x08);
07045                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07046 1D13           8A46         F7            mov	al,-9[bp]
07047 1D16           24                     80  and	al,#$80
07048 1D18           84C0                       test	al,al
07049 1D1A           75           0D            jne 	.17E
07050                       00001D1C            .180:
07051                                           ! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
07052 1D1C           8A46         F7            mov	al,-9[bp]
07053 1D1F           24                     08  and	al,*8
07054 1D21           84C0                       test	al,al
07055 1D23           74           04            je  	.17E
07056                       00001D25            .17F:
07057 1D25           B0                     01  mov	al,*1
07058 1D27           EB           02            jmp	.181
07059                       00001D29            .17E:
07060 1D29           30C0                       xor	al,al
07061                       00001D2B            .181:
07062                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07063 1D2B           8846         F6            mov	-$A[bp],al
07064                                           !BCC_EOS
07065                                           ! 1537     else if (when_done == 4)
07066 1D2E           EB           54            jmp .182
07067                       00001D30            .17C:
07068                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
07069 1D30           8A46         04            mov	al,4[bp]
07070 1D33           3C                     04  cmp	al,*4
07071 1D35           75           1D            jne 	.183
07072                       00001D37            .184:
07073                                           ! 1538       result = !(status & 0x80) && !(status & 0x08);
07074                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07075 1D37           8A46         F7            mov	al,-9[bp]
07076 1D3A           24                     80  and	al,#$80
07077 1D3C           84C0                       test	al,al
07078 1D3E           75           0D            jne 	.185
07079                       00001D40            .187:
07080                                           ! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
07081 1D40           8A46         F7            mov	al,-9[bp]
07082 1D43           24                     08  and	al,*8
07083 1D45           84C0                       test	al,al
07084 1D47           75           04            jne 	.185
07085                       00001D49            .186:
07086 1D49           B0                     01  mov	al,*1
07087 1D4B           EB           02            jmp	.188
07088                       00001D4D            .185:
07089 1D4D           30C0                       xor	al,al
07090                       00001D4F            .188:
07091                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07092 1D4F           8846         F6            mov	-$A[bp],al
07093                                           !BCC_EOS
07094                                           ! 1539     else if (when_done == 5)
07095 1D52           EB           30            jmp .189
07096                       00001D54            .183:
07097                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
07098 1D54           8A46         04            mov	al,4[bp]
07099 1D57           3C                     05  cmp	al,*5
07100 1D59           75           1D            jne 	.18A
07101                       00001D5B            .18B:
07102                                           ! 1540       result = !(status & 0x80) && (status & 0x40);
07103                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07104 1D5B           8A46         F7            mov	al,-9[bp]
07105 1D5E           24                     80  and	al,#$80
07106 1D60           84C0                       test	al,al
07107 1D62           75           0D            jne 	.18C
07108                       00001D64            .18E:
07109                                           ! Debug: and int = const $40 to unsigned char status = [S+$C-$B] (used reg = )
07110 1D64           8A46         F7            mov	al,-9[bp]
07111 1D67           24                     40  and	al,*$40
07112 1D69           84C0                       test	al,al
07113 1D6B           74           04            je  	.18C
07114                       00001D6D            .18D:
07115 1D6D           B0                     01  mov	al,*1
07116 1D6F           EB           02            jmp	.18F
07117                       00001D71            .18C:
07118 1D71           30C0                       xor	al,al
07119                       00001D73            .18F:
07120                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07121 1D73           8846         F6            mov	-$A[bp],al
07122                                           !BCC_EOS
07123                                           ! 1541     else if (when_done == 0)
07124 1D76           EB           0C            jmp .190
07125                       00001D78            .18A:
07126                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
07127 1D78           8A46         04            mov	al,4[bp]
07128 1D7B           84C0                       test	al,al
07129 1D7D           75           05            jne 	.191
07130                       00001D7F            .192:
07131                                           ! 1542       result = 0;
07132                                           ! Debug: eq int = const 0 to unsigned char result = [S+$C-$C] (used reg = )
07133 1D7F           30C0                       xor	al,al
07134 1D81           8846         F6            mov	-$A[bp],al
07135                                           !BCC_EOS
07136                                           ! 1543     if (result) return status;
07137                       00001D84            .191:
07138                       00001D84            .190:
07139                       00001D84            .189:
07140                       00001D84            .182:
07141                       00001D84            .17B:
07142                       00001D84            .175:
07143 1D84           8A46         F6            mov	al,-$A[bp]
07144 1D87           84C0                       test	al,al
07145 1D89           74           07            je  	.193
07146                       00001D8B            .194:
07147 1D8B           8A46         F7            mov	al,-9[bp]
07148 1D8E           89EC                       mov	sp,bp
07149 1D90           5D                         pop	bp
07150 1D91           C3                         ret
07151                                           !BCC_EOS
07152                                           ! 1544     if (time>>16 != last)
07153                       00001D92            .193:
07154                                           ! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
07155 1D92           8B46         FC            mov	ax,-4[bp]
07156 1D95           8B5E         FE            mov	bx,-2[bp]
07157 1D98           93                         xchg	bx,ax
07158 1D99           31DB                       xor	bx,bx
07159                                           ! Debug: ne unsigned long last = [S+$C-$A] to unsigned long = bx+0 (used reg = )
07160 1D9B           8D7E         F8            lea	di,-8[bp]
07161 1D9E           E8         E32A            call	lcmpul
07162 1DA1           74           0F            je  	.195
07163                       00001DA3            .196:
07164                                           ! 1545     {
07165                                           ! 1546       last = time >>16;
07166                                           ! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
07167 1DA3           8B46         FC            mov	ax,-4[bp]
07168 1DA6           8B5E         FE            mov	bx,-2[bp]
07169 1DA9           93                         xchg	bx,ax
07170 1DAA           31DB                       xor	bx,bx
07171                                           ! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$C-$A] (used reg = )
07172 1DAC           8946         F8            mov	-8[bp],ax
07173 1DAF           895E         FA            mov	-6[bp],bx
07174                                           !BCC_EOS
07175                                           ! 1547       ;
07176                                           !BCC_EOS
07177                                           ! 1548     }
07178                                           ! 1549     if (status & 0x01)
07179                       00001DB2            .195:
07180                                           ! Debug: and int = const 1 to unsigned char status = [S+$C-$B] (used reg = )
07181 1DB2           8A46         F7            mov	al,-9[bp]
07182 1DB5           24                     01  and	al,*1
07183 1DB7           84C0                       test	al,al
07184 1DB9           74           07            je  	.197
07185                       00001DBB            .198:
07186                                           ! 1550     {
07187                                           ! 1551       ;
07188                                           !BCC_EOS
07189                                           ! 1552       return status;
07190 1DBB           8A46         F7            mov	al,-9[bp]
07191 1DBE           89EC                       mov	sp,bp
07192 1DC0           5D                         pop	bp
07193 1DC1           C3                         ret
07194                                           !BCC_EOS
07195                                           ! 1553     }
07196                                           ! 1554     if ((timeout == 0) || ((time>>11) > timeout)) break;
07197                       00001DC2            .197:
07198                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
07199 1DC2           8B46         08            mov	ax,8[bp]
07200 1DC5           85C0                       test	ax,ax
07201 1DC7           74           26            je  	.19A
07202                       00001DC9            .19B:
07203                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
07204 1DC9           8B46         08            mov	ax,8[bp]
07205 1DCC           31DB                       xor	bx,bx
07206 1DCE           53                         push	bx
07207 1DCF           50                         push	ax
07208                                           ! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
07209 1DD0           8B46         FC            mov	ax,-4[bp]
07210 1DD3           8B5E         FE            mov	bx,-2[bp]
07211 1DD6           88E0                       mov	al,ah
07212 1DD8           88DC                       mov	ah,bl
07213 1DDA           88FB                       mov	bl,bh
07214 1DDC           28FF                       sub	bh,bh
07215 1DDE           BF                   0003  mov	di,*3
07216 1DE1           E8         E345            call	lsrul
07217                                           ! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
07218 1DE4           8D7E         F2            lea	di,-$E[bp]
07219 1DE7           E8         E2E1            call	lcmpul
07220 1DEA           8D66         F6            lea	sp,-$A[bp]
07221 1DED           76           02            jbe 	.199
07222                       00001DEF            .19A:
07223 1DEF           EB           03            jmp .170
07224                                           !BCC_EOS
07225                                           ! 1555   }
07226                       00001DF1            .199:
07227                                           ! 1556   ;
07228                       00001DF1            .171:
07229 1DF1           E9         FECF            br 	.172
07230                       00001DF4            .170:
07231                                           !BCC_EOS
07232                                           ! 1557   return status;
07233 1DF4           8A46         F7            mov	al,-9[bp]
07234 1DF7           89EC                       mov	sp,bp
07235 1DF9           5D                         pop	bp
07236 1DFA           C3                         ret
07237                                           !BCC_EOS
07238                                           ! 1558 }
07239                                           ! 1559 void ata_detect( )
07240                                           ! Register BX used in function await_ide
07241                                           ! 1560 {
07242                                           export	_ata_detect
07243                       00001DFB            _ata_detect:
07244                                           ! 1561   Bit16u ebda_seg=read_word(0x0040,0x000E);
07245 1DFB           55                         push	bp
07246 1DFC           89E5                       mov	bp,sp
07247 1DFE           4C                         dec	sp
07248 1DFF           4C                         dec	sp
07249                                           ! Debug: list int = const $E (used reg = )
07250 1E00           B8                   000E  mov	ax,*$E
07251 1E03           50                         push	ax
07252                                           ! Debug: list int = const $40 (used reg = )
07253 1E04           B8                   0040  mov	ax,*$40
07254 1E07           50                         push	ax
07255                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07256 1E08           E8         E7FC            call	_read_word
07257 1E0B           83C4                   04  add	sp,*4
07258                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
07259 1E0E           8946         FE            mov	-2[bp],ax
07260                                           !BCC_EOS
07261                                           ! 1562   Bit8u hdcount, cdcount, device, type;
07262                                           !BCC_EOS
07263                                           ! 1563   Bit8u buffer[0x0200];
07264                                           !BCC_EOS
07265                                           ! 1564   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
07266 1E11           81C4                 FDFC  add	sp,#-$204
07267                                           ! Debug: list int = const 0 (used reg = )
07268 1E15           31C0                       xor	ax,ax
07269 1E17           50                         push	ax
07270                                           ! Debug: list * unsigned char = const $122 (used reg = )
07271 1E18           B8                   0122  mov	ax,#$122
07272 1E1B           50                         push	ax
07273                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07274 1E1C           FF76         FE            push	-2[bp]
07275                                           ! Debug: func () void = write_byte+0 (used reg = )
07276 1E1F           E8         E7F8            call	_write_byte
07277 1E22           83C4                   06  add	sp,*6
07278                                           !BCC_EOS
07279                                           ! 1565   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
07280                                           ! Debug: list int = const $1F0 (used reg = )
07281 1E25           B8                   01F0  mov	ax,#$1F0
07282 1E28           50                         push	ax
07283                                           ! Debug: list * unsigned short = const $124 (used reg = )
07284 1E29           B8                   0124  mov	ax,#$124
07285 1E2C           50                         push	ax
07286                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07287 1E2D           FF76         FE            push	-2[bp]
07288                                           ! Debug: func () void = write_word+0 (used reg = )
07289 1E30           E8         E7FF            call	_write_word
07290 1E33           83C4                   06  add	sp,*6
07291                                           !BCC_EOS
07292                                           ! 1566   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
07293                                           ! Debug: list int = const $3F0 (used reg = )
07294 1E36           B8                   03F0  mov	ax,#$3F0
07295 1E39           50                         push	ax
07296                                           ! Debug: list * unsigned short = const $126 (used reg = )
07297 1E3A           B8                   0126  mov	ax,#$126
07298 1E3D           50                         push	ax
07299                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07300 1E3E           FF76         FE            push	-2[bp]
07301                                           ! Debug: func () void = write_word+0 (used reg = )
07302 1E41           E8         E7EE            call	_write_word
07303 1E44           83C4                   06  add	sp,*6
07304                                           !BCC_EOS
07305                                           ! 1567   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
07306                                           ! Debug: list int = const $E (used reg = )
07307 1E47           B8                   000E  mov	ax,*$E
07308 1E4A           50                         push	ax
07309                                           ! Debug: list * unsigned char = const $128 (used reg = )
07310 1E4B           B8                   0128  mov	ax,#$128
07311 1E4E           50                         push	ax
07312                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07313 1E4F           FF76         FE            push	-2[bp]
07314                                           ! Debug: func () void = write_byte+0 (used reg = )
07315 1E52           E8         E7C5            call	_write_byte
07316 1E55           83C4                   06  add	sp,*6
07317                                           !BCC_EOS
07318                                           ! 1568   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].if
07319                                           ! 1568 ace,0x00);
07320                                           ! Debug: list int = const 0 (used reg = )
07321 1E58           31C0                       xor	ax,ax
07322 1E5A           50                         push	ax
07323                                           ! Debug: list * unsigned char = const $12A (used reg = )
07324 1E5B           B8                   012A  mov	ax,#$12A
07325 1E5E           50                         push	ax
07326                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07327 1E5F           FF76         FE            push	-2[bp]
07328                                           ! Debug: func () void = write_byte+0 (used reg = )
07329 1E62           E8         E7B5            call	_write_byte
07330 1E65           83C4                   06  add	sp,*6
07331                                           !BCC_EOS
07332                                           ! 1569   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
07333                                           ! Debug: list int = const $170 (used reg = )
07334 1E68           B8                   0170  mov	ax,#$170
07335 1E6B           50                         push	ax
07336                                           ! Debug: list * unsigned short = const $12C (used reg = )
07337 1E6C           B8                   012C  mov	ax,#$12C
07338 1E6F           50                         push	ax
07339                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07340 1E70           FF76         FE            push	-2[bp]
07341                                           ! Debug: func () void = write_word+0 (used reg = )
07342 1E73           E8         E7BC            call	_write_word
07343 1E76           83C4                   06  add	sp,*6
07344                                           !BCC_EOS
07345                                           ! 1570   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
07346                                           ! Debug: list int = const $370 (used reg = )
07347 1E79           B8                   0370  mov	ax,#$370
07348 1E7C           50                         push	ax
07349                                           ! Debug: list * unsigned short = const $12E (used reg = )
07350 1E7D           B8                   012E  mov	ax,#$12E
07351 1E80           50                         push	ax
07352                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07353 1E81           FF76         FE            push	-2[bp]
07354                                           ! Debug: func () void = write_word+0 (used reg = )
07355 1E84           E8         E7AB            call	_write_word
07356 1E87           83C4                   06  add	sp,*6
07357                                           !BCC_EOS
07358                                           ! 1571   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
07359                                           ! Debug: list int = const $F (used reg = )
07360 1E8A           B8                   000F  mov	ax,*$F
07361 1E8D           50                         push	ax
07362                                           ! Debug: list * unsigned char = const $130 (used reg = )
07363 1E8E           B8                   0130  mov	ax,#$130
07364 1E91           50                         push	ax
07365                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07366 1E92           FF76         FE            push	-2[bp]
07367                                           ! Debug: func () void = write_byte+0 (used reg = )
07368 1E95           E8         E782            call	_write_byte
07369 1E98           83C4                   06  add	sp,*6
07370                                           !BCC_EOS
07371                                           ! 1572   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
07372                                           ! Debug: list int = const 0 (used reg = )
07373 1E9B           31C0                       xor	ax,ax
07374 1E9D           50                         push	ax
07375                                           ! Debug: list * unsigned char = const $132 (used reg = )
07376 1E9E           B8                   0132  mov	ax,#$132
07377 1EA1           50                         push	ax
07378                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07379 1EA2           FF76         FE            push	-2[bp]
07380                                           ! Debug: func () void = write_byte+0 (used reg = )
07381 1EA5           E8         E772            call	_write_byte
07382 1EA8           83C4                   06  add	sp,*6
07383                                           !BCC_EOS
07384                                           ! 1573   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
07385                                           ! Debug: list int = const $1E8 (used reg = )
07386 1EAB           B8                   01E8  mov	ax,#$1E8
07387 1EAE           50                         push	ax
07388                                           ! Debug: list * unsigned short = const $134 (used reg = )
07389 1EAF           B8                   0134  mov	ax,#$134
07390 1EB2           50                         push	ax
07391                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07392 1EB3           FF76         FE            push	-2[bp]
07393                                           ! Debug: func () void = write_word+0 (used reg = )
07394 1EB6           E8         E779            call	_write_word
07395 1EB9           83C4                   06  add	sp,*6
07396                                           !BCC_EOS
07397                                           ! 1574   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
07398                                           ! Debug: list int = const $3E0 (used reg = )
07399 1EBC           B8                   03E0  mov	ax,#$3E0
07400 1EBF           50                         push	ax
07401                                           ! Debug: list * unsigned short = const $136 (used reg = )
07402 1EC0           B8                   0136  mov	ax,#$136
07403 1EC3           50                         push	ax
07404                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07405 1EC4           FF76         FE            push	-2[bp]
07406                                           ! Debug: func () void = write_word+0 (used reg = )
07407 1EC7           E8         E768            call	_write_word
07408 1ECA           83C4                   06  add	sp,*6
07409                                           !BCC_EOS
07410                                           ! 1575   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
07411                                           ! Debug: list int = const $C (used reg = )
07412 1ECD           B8                   000C  mov	ax,*$C
07413 1ED0           50                         push	ax
07414                                           ! Debug: list * unsigned char = const $138 (used reg = )
07415 1ED1           B8                   0138  mov	ax,#$138
07416 1ED4           50                         push	ax
07417                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07418 1ED5           FF76         FE            push	-2[bp]
07419                                           ! Debug: func () void = write_byte+0 (used reg = )
07420 1ED8           E8         E73F            call	_write_byte
07421 1EDB           83C4                   06  add	sp,*6
07422                                           !BCC_EOS
07423                                           ! 1576   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
07424                                           ! Debug: list int = const 0 (used reg = )
07425 1EDE           31C0                       xor	ax,ax
07426 1EE0           50                         push	ax
07427                                           ! Debug: list * unsigned char = const $13A (used reg = )
07428 1EE1           B8                   013A  mov	ax,#$13A
07429 1EE4           50                         push	ax
07430                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07431 1EE5           FF76         FE            push	-2[bp]
07432                                           ! Debug: func () void = write_byte+0 (used reg = )
07433 1EE8           E8         E72F            call	_write_byte
07434 1EEB           83C4                   06  add	sp,*6
07435                                           !BCC_EOS
07436                                           ! 1577   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
07437                                           ! Debug: list int = const $168 (used reg = )
07438 1EEE           B8                   0168  mov	ax,#$168
07439 1EF1           50                         push	ax
07440                                           ! Debug: list * unsigned short = const $13C (used reg = )
07441 1EF2           B8                   013C  mov	ax,#$13C
07442 1EF5           50                         push	ax
07443                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07444 1EF6           FF76         FE            push	-2[bp]
07445                                           ! Debug: func () void = write_word+0 (used reg = )
07446 1EF9           E8         E736            call	_write_word
07447 1EFC           83C4                   06  add	sp,*6
07448                                           !BCC_EOS
07449                                           ! 1578   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
07450                                           ! Debug: list int = const $360 (used reg = )
07451 1EFF           B8                   0360  mov	ax,#$360
07452 1F02           50                         push	ax
07453                                           ! Debug: list * unsigned short = const $13E (used reg = )
07454 1F03           B8                   013E  mov	ax,#$13E
07455 1F06           50                         push	ax
07456                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07457 1F07           FF76         FE            push	-2[bp]
07458                                           ! Debug: func () void = write_word+0 (used reg = )
07459 1F0A           E8         E725            call	_write_word
07460 1F0D           83C4                   06  add	sp,*6
07461                                           !BCC_EOS
07462                                           ! 1579   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
07463                                           ! Debug: list int = const $B (used reg = )
07464 1F10           B8                   000B  mov	ax,*$B
07465 1F13           50                         push	ax
07466                                           ! Debug: list * unsigned char = const $140 (used reg = )
07467 1F14           B8                   0140  mov	ax,#$140
07468 1F17           50                         push	ax
07469                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07470 1F18           FF76         FE            push	-2[bp]
07471                                           ! Debug: func () void = write_byte+0 (used reg = )
07472 1F1B           E8         E6FC            call	_write_byte
07473 1F1E           83C4                   06  add	sp,*6
07474                                           !BCC_EOS
07475                                           ! 1580   hdcount=cdcount=0;
07476                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
07477 1F21           30C0                       xor	al,al
07478 1F23           8846         FC            mov	-4[bp],al
07479                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
07480 1F26           8846         FD            mov	-3[bp],al
07481                                           !BCC_EOS
07482                                           ! 1581   for(device=0; device<(4*2); device++) {
07483                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
07484 1F29           30C0                       xor	al,al
07485 1F2B           8846         FB            mov	-5[bp],al
07486                                           !BCC_EOS
07487                                           !BCC_EOS
07488 1F2E           E9         0C5D            br 	.19E
07489                       00001F31            .19F:
07490                                           ! 1582     Bit16u iobase1, iobase2;
07491                                           !BCC_EOS
07492                                           ! 1583     Bit8u channel, slave, shift;
07493                                           !BCC_EOS
07494                                           ! 1584     Bit8u sc, sn, cl, ch, st;
07495                                           !BCC_EOS
07496                                           ! 1585     channel = device / 2;
07497 1F31           83C4                   F4  add	sp,*-$C
07498                                           ! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07499 1F34           8A46         FB            mov	al,-5[bp]
07500 1F37           30E4                       xor	ah,ah
07501 1F39           D1E8                       shr	ax,*1
07502                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
07503 1F3B           8886       FDF5            mov	-$20B[bp],al
07504                                           !BCC_EOS
07505                                           ! 1586     slave = device % 2;
07506                                           ! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07507 1F3F           8A46         FB            mov	al,-5[bp]
07508 1F42           30E4                       xor	ah,ah
07509 1F44           24                     01  and	al,*1
07510                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
07511 1F46           8886       FDF4            mov	-$20C[bp],al
07512                                           !BCC_EOS
07513                                           ! 1587     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
07514                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07515 1F4A           8A86       FDF5            mov	al,-$20B[bp]
07516 1F4E           30E4                       xor	ah,ah
07517 1F50           B1                     03  mov	cl,*3
07518 1F52           D3E0                       shl	ax,cl
07519 1F54           89C3                       mov	bx,ax
07520                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07521                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
07522 1F56           81C3                 0124  add	bx,#$124
07523 1F5A           53                         push	bx
07524                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07525 1F5B           FF76         FE            push	-2[bp]
07526                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07527 1F5E           E8         E6A6            call	_read_word
07528 1F61           83C4                   04  add	sp,*4
07529                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07530 1F64           8986       FDF8            mov	-$208[bp],ax
07531                                           !BCC_EOS
07532                                           ! 1588     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
07533                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07534 1F68           8A86       FDF5            mov	al,-$20B[bp]
07535 1F6C           30E4                       xor	ah,ah
07536 1F6E           B1                     03  mov	cl,*3
07537 1F70           D3E0                       shl	ax,cl
07538 1F72           89C3                       mov	bx,ax
07539                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07540                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
07541 1F74           81C3                 0126  add	bx,#$126
07542 1F78           53                         push	bx
07543                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07544 1F79           FF76         FE            push	-2[bp]
07545                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07546 1F7C           E8         E688            call	_read_word
07547 1F7F           83C4                   04  add	sp,*4
07548                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
07549 1F82           8986       FDF6            mov	-$20A[bp],ax
07550                                           !BCC_EOS
07551                                           ! 1589     outb(iobase2+6, 0x08 | 0x02);
07552                                           ! Debug: list int = const $A (used reg = )
07553 1F86           B8                   000A  mov	ax,*$A
07554 1F89           50                         push	ax
07555                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07556 1F8A           8B86       FDF6            mov	ax,-$20A[bp]
07557                                           ! Debug: list unsigned int = ax+6 (used reg = )
07558 1F8E           05                   0006  add	ax,*6
07559 1F91           50                         push	ax
07560                                           ! Debug: func () void = outb+0 (used reg = )
07561 1F92           E8         E5BF            call	_outb
07562 1F95           83C4                   04  add	sp,*4
07563                                           !BCC_EOS
07564                                           ! 1590     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07565 1F98           8A86       FDF4            mov	al,-$20C[bp]
07566 1F9C           84C0                       test	al,al
07567 1F9E           74           04            je  	.1A0
07568                       00001FA0            .1A1:
07569 1FA0           B0                     B0  mov	al,#$B0
07570 1FA2           EB           02            jmp .1A2
07571                       00001FA4            .1A0:
07572 1FA4           B0                     A0  mov	al,#$A0
07573                       00001FA6            .1A2:
07574                                           ! Debug: list char = al+0 (used reg = )
07575 1FA6           30E4                       xor	ah,ah
07576 1FA8           50                         push	ax
07577                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07578 1FA9           8B86       FDF8            mov	ax,-$208[bp]
07579                                           ! Debug: list unsigned int = ax+6 (used reg = )
07580 1FAD           05                   0006  add	ax,*6
07581 1FB0           50                         push	ax
07582                                           ! Debug: func () void = outb+0 (used reg = )
07583 1FB1           E8         E5A0            call	_outb
07584 1FB4           83C4                   04  add	sp,*4
07585                                           !BCC_EOS
07586                                           ! 1591     outb(iobase1+2, 0x55);
07587                                           ! Debug: list int = const $55 (used reg = )
07588 1FB7           B8                   0055  mov	ax,*$55
07589 1FBA           50                         push	ax
07590                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07591 1FBB           8B86       FDF8            mov	ax,-$208[bp]
07592                                           ! Debug: list unsigned int = ax+2 (used reg = )
07593 1FBF           40                         inc	ax
07594 1FC0           40                         inc	ax
07595 1FC1           50                         push	ax
07596                                           ! Debug: func () void = outb+0 (used reg = )
07597 1FC2           E8         E58F            call	_outb
07598 1FC5           83C4                   04  add	sp,*4
07599                                           !BCC_EOS
07600                                           ! 1592     outb(iobase1+3, 0xaa);
07601                                           ! Debug: list int = const $AA (used reg = )
07602 1FC8           B8                   00AA  mov	ax,#$AA
07603 1FCB           50                         push	ax
07604                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07605 1FCC           8B86       FDF8            mov	ax,-$208[bp]
07606                                           ! Debug: list unsigned int = ax+3 (used reg = )
07607 1FD0           05                   0003  add	ax,*3
07608 1FD3           50                         push	ax
07609                                           ! Debug: func () void = outb+0 (used reg = )
07610 1FD4           E8         E57D            call	_outb
07611 1FD7           83C4                   04  add	sp,*4
07612                                           !BCC_EOS
07613                                           ! 1593     outb(iobase1+2, 0xaa);
07614                                           ! Debug: list int = const $AA (used reg = )
07615 1FDA           B8                   00AA  mov	ax,#$AA
07616 1FDD           50                         push	ax
07617                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07618 1FDE           8B86       FDF8            mov	ax,-$208[bp]
07619                                           ! Debug: list unsigned int = ax+2 (used reg = )
07620 1FE2           40                         inc	ax
07621 1FE3           40                         inc	ax
07622 1FE4           50                         push	ax
07623                                           ! Debug: func () void = outb+0 (used reg = )
07624 1FE5           E8         E56C            call	_outb
07625 1FE8           83C4                   04  add	sp,*4
07626                                           !BCC_EOS
07627                                           ! 1594     outb(iobase1+3, 0x55);
07628                                           ! Debug: list int = const $55 (used reg = )
07629 1FEB           B8                   0055  mov	ax,*$55
07630 1FEE           50                         push	ax
07631                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07632 1FEF           8B86       FDF8            mov	ax,-$208[bp]
07633                                           ! Debug: list unsigned int = ax+3 (used reg = )
07634 1FF3           05                   0003  add	ax,*3
07635 1FF6           50                         push	ax
07636                                           ! Debug: func () void = outb+0 (used reg = )
07637 1FF7           E8         E55A            call	_outb
07638 1FFA           83C4                   04  add	sp,*4
07639                                           !BCC_EOS
07640                                           ! 1595     outb(iobase1+2, 0x55);
07641                                           ! Debug: list int = const $55 (used reg = )
07642 1FFD           B8                   0055  mov	ax,*$55
07643 2000           50                         push	ax
07644                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07645 2001           8B86       FDF8            mov	ax,-$208[bp]
07646                                           ! Debug: list unsigned int = ax+2 (used reg = )
07647 2005           40                         inc	ax
07648 2006           40                         inc	ax
07649 2007           50                         push	ax
07650                                           ! Debug: func () void = outb+0 (used reg = )
07651 2008           E8         E549            call	_outb
07652 200B           83C4                   04  add	sp,*4
07653                                           !BCC_EOS
07654                                           ! 1596     outb(iobase1+3, 0xaa);
07655                                           ! Debug: list int = const $AA (used reg = )
07656 200E           B8                   00AA  mov	ax,#$AA
07657 2011           50                         push	ax
07658                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07659 2012           8B86       FDF8            mov	ax,-$208[bp]
07660                                           ! Debug: list unsigned int = ax+3 (used reg = )
07661 2016           05                   0003  add	ax,*3
07662 2019           50                         push	ax
07663                                           ! Debug: func () void = outb+0 (used reg = )
07664 201A           E8         E537            call	_outb
07665 201D           83C4                   04  add	sp,*4
07666                                           !BCC_EOS
07667                                           ! 1597     sc = inb(iobase1+2);
07668                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07669 2020           8B86       FDF8            mov	ax,-$208[bp]
07670                                           ! Debug: list unsigned int = ax+2 (used reg = )
07671 2024           40                         inc	ax
07672 2025           40                         inc	ax
07673 2026           50                         push	ax
07674                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07675 2027           E8         E514            call	_inb
07676 202A           44                         inc	sp
07677 202B           44                         inc	sp
07678                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07679 202C           8886       FDF2            mov	-$20E[bp],al
07680                                           !BCC_EOS
07681                                           ! 1598     sn = inb(iobase1+3);
07682                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07683 2030           8B86       FDF8            mov	ax,-$208[bp]
07684                                           ! Debug: list unsigned int = ax+3 (used reg = )
07685 2034           05                   0003  add	ax,*3
07686 2037           50                         push	ax
07687                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07688 2038           E8         E503            call	_inb
07689 203B           44                         inc	sp
07690 203C           44                         inc	sp
07691                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07692 203D           8886       FDF1            mov	-$20F[bp],al
07693                                           !BCC_EOS
07694                                           ! 1599     if ( (sc == 0x55) && (sn == 0xaa) ) {
07695                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
07696 2041           8A86       FDF2            mov	al,-$20E[bp]
07697 2045           3C                     55  cmp	al,*$55
07698 2047         0F85         014F            bne 	.1A3
07699                       0000204B            .1A5:
07700                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
07701 204B           8A86       FDF1            mov	al,-$20F[bp]
07702 204F           3C                     AA  cmp	al,#$AA
07703 2051         0F85         0145            bne 	.1A3
07704                       00002055            .1A4:
07705                                           ! 1600       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
07706                                           ! Debug: list int = const 1 (used reg = )
07707 2055           B8                   0001  mov	ax,*1
07708 2058           50                         push	ax
07709                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07710 2059           8A46         FB            mov	al,-5[bp]
07711 205C           30E4                       xor	ah,ah
07712 205E           B9                   001E  mov	cx,*$1E
07713 2061           F7E9                       imul	cx
07714 2063           89C3                       mov	bx,ax
07715                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07716                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07717 2065           81C3                 0142  add	bx,#$142
07718 2069           53                         push	bx
07719                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07720 206A           FF76         FE            push	-2[bp]
07721                                           ! Debug: func () void = write_byte+0 (used reg = )
07722 206D           E8         E5AA            call	_write_byte
07723 2070           83C4                   06  add	sp,*6
07724                                           !BCC_EOS
07725                                           ! 1601       ata_reset(device);
07726                                           ! Debug: list unsigned char device = [S+$214-7] (used reg = )
07727 2073           8A46         FB            mov	al,-5[bp]
07728 2076           30E4                       xor	ah,ah
07729 2078           50                         push	ax
07730                                           ! Debug: func () void = ata_reset+0 (used reg = )
07731 2079           E8         0B67            call	_ata_reset
07732 207C           44                         inc	sp
07733 207D           44                         inc	sp
07734                                           !BCC_EOS
07735                                           ! 1602       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07736 207E           8A86       FDF4            mov	al,-$20C[bp]
07737 2082           84C0                       test	al,al
07738 2084           74           04            je  	.1A6
07739                       00002086            .1A7:
07740 2086           B0                     B0  mov	al,#$B0
07741 2088           EB           02            jmp .1A8
07742                       0000208A            .1A6:
07743 208A           B0                     A0  mov	al,#$A0
07744                       0000208C            .1A8:
07745                                           ! Debug: list char = al+0 (used reg = )
07746 208C           30E4                       xor	ah,ah
07747 208E           50                         push	ax
07748                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07749 208F           8B86       FDF8            mov	ax,-$208[bp]
07750                                           ! Debug: list unsigned int = ax+6 (used reg = )
07751 2093           05                   0006  add	ax,*6
07752 2096           50                         push	ax
07753                                           ! Debug: func () void = outb+0 (used reg = )
07754 2097           E8         E4BA            call	_outb
07755 209A           83C4                   04  add	sp,*4
07756                                           !BCC_EOS
07757                                           ! 1603       sc = inb(iobase1+2);
07758                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07759 209D           8B86       FDF8            mov	ax,-$208[bp]
07760                                           ! Debug: list unsigned int = ax+2 (used reg = )
07761 20A1           40                         inc	ax
07762 20A2           40                         inc	ax
07763 20A3           50                         push	ax
07764                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07765 20A4           E8         E497            call	_inb
07766 20A7           44                         inc	sp
07767 20A8           44                         inc	sp
07768                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07769 20A9           8886       FDF2            mov	-$20E[bp],al
07770                                           !BCC_EOS
07771                                           ! 1604       sn = inb(iobase1+3);
07772                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07773 20AD           8B86       FDF8            mov	ax,-$208[bp]
07774                                           ! Debug: list unsigned int = ax+3 (used reg = )
07775 20B1           05                   0003  add	ax,*3
07776 20B4           50                         push	ax
07777                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07778 20B5           E8         E486            call	_inb
07779 20B8           44                         inc	sp
07780 20B9           44                         inc	sp
07781                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07782 20BA           8886       FDF1            mov	-$20F[bp],al
07783                                           !BCC_EOS
07784                                           ! 1605       if ((sc==0x01) && (sn==0x01)) {
07785                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
07786 20BE           8A86       FDF2            mov	al,-$20E[bp]
07787 20C2           3C                     01  cmp	al,*1
07788 20C4         0F85         00D2            bne 	.1A9
07789                       000020C8            .1AB:
07790                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
07791 20C8           8A86       FDF1            mov	al,-$20F[bp]
07792 20CC           3C                     01  cmp	al,*1
07793 20CE         0F85         00C8            bne 	.1A9
07794                       000020D2            .1AA:
07795                                           ! 1606         cl = inb(iobase1+4);
07796                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07797 20D2           8B86       FDF8            mov	ax,-$208[bp]
07798                                           ! Debug: list unsigned int = ax+4 (used reg = )
07799 20D6           05                   0004  add	ax,*4
07800 20D9           50                         push	ax
07801                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07802 20DA           E8         E461            call	_inb
07803 20DD           44                         inc	sp
07804 20DE           44                         inc	sp
07805                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
07806 20DF           8886       FDF0            mov	-$210[bp],al
07807                                           !BCC_EOS
07808                                           ! 1607         ch = inb(iobase1+5);
07809                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07810 20E3           8B86       FDF8            mov	ax,-$208[bp]
07811                                           ! Debug: list unsigned int = ax+5 (used reg = )
07812 20E7           05                   0005  add	ax,*5
07813 20EA           50                         push	ax
07814                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07815 20EB           E8         E450            call	_inb
07816 20EE           44                         inc	sp
07817 20EF           44                         inc	sp
07818                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
07819 20F0           8886       FDEF            mov	-$211[bp],al
07820                                           !BCC_EOS
07821                                           ! 1608         st = inb(iobase1+7);
07822                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07823 20F4           8B86       FDF8            mov	ax,-$208[bp]
07824                                           ! Debug: list unsigned int = ax+7 (used reg = )
07825 20F8           05                   0007  add	ax,*7
07826 20FB           50                         push	ax
07827                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07828 20FC           E8         E43F            call	_inb
07829 20FF           44                         inc	sp
07830 2100           44                         inc	sp
07831                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
07832 2101           8886       FDEE            mov	-$212[bp],al
07833                                           !BCC_EOS
07834                                           ! 1609         if ((cl==0x14) && (ch==0xeb)) {
07835                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
07836 2105           8A86       FDF0            mov	al,-$210[bp]
07837 2109           3C                     14  cmp	al,*$14
07838 210B           75           28            jne 	.1AC
07839                       0000210D            .1AE:
07840                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
07841 210D           8A86       FDEF            mov	al,-$211[bp]
07842 2111           3C                     EB  cmp	al,#$EB
07843 2113           75           20            jne 	.1AC
07844                       00002115            .1AD:
07845                                           ! 1610           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
07846                                           ! Debug: list int = const 3 (used reg = )
07847 2115           B8                   0003  mov	ax,*3
07848 2118           50                         push	ax
07849                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07850 2119           8A46         FB            mov	al,-5[bp]
07851 211C           30E4                       xor	ah,ah
07852 211E           B9                   001E  mov	cx,*$1E
07853 2121           F7E9                       imul	cx
07854 2123           89C3                       mov	bx,ax
07855                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07856                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07857 2125           81C3                 0142  add	bx,#$142
07858 2129           53                         push	bx
07859                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07860 212A           FF76         FE            push	-2[bp]
07861                                           ! Debug: func () void = write_byte+0 (used reg = )
07862 212D           E8         E4EA            call	_write_byte
07863 2130           83C4                   06  add	sp,*6
07864                                           !BCC_EOS
07865                                           ! 1611         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07866 2133           EB           65            jmp .1AF
07867                       00002135            .1AC:
07868                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
07869 2135           8A86       FDF0            mov	al,-$210[bp]
07870 2139           84C0                       test	al,al
07871 213B           75           30            jne 	.1B0
07872                       0000213D            .1B3:
07873                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
07874 213D           8A86       FDEF            mov	al,-$211[bp]
07875 2141           84C0                       test	al,al
07876 2143           75           28            jne 	.1B0
07877                       00002145            .1B2:
07878                                           ! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
07879 2145           8A86       FDEE            mov	al,-$212[bp]
07880 2149           84C0                       test	al,al
07881 214B           74           20            je  	.1B0
07882                       0000214D            .1B1:
07883                                           ! 1612         
07884                                           ! 1612   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
07885                                           ! Debug: list int = const 2 (used reg = )
07886 214D           B8                   0002  mov	ax,*2
07887 2150           50                         push	ax
07888                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07889 2151           8A46         FB            mov	al,-5[bp]
07890 2154           30E4                       xor	ah,ah
07891 2156           B9                   001E  mov	cx,*$1E
07892 2159           F7E9                       imul	cx
07893 215B           89C3                       mov	bx,ax
07894                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07895                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07896 215D           81C3                 0142  add	bx,#$142
07897 2161           53                         push	bx
07898                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07899 2162           FF76         FE            push	-2[bp]
07900                                           ! Debug: func () void = write_byte+0 (used reg = )
07901 2165           E8         E4B2            call	_write_byte
07902 2168           83C4                   06  add	sp,*6
07903                                           !BCC_EOS
07904                                           ! 1613         } else if ((cl==0xff) && (ch==0xff)) {
07905 216B           EB           2D            jmp .1B4
07906                       0000216D            .1B0:
07907                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
07908 216D           8A86       FDF0            mov	al,-$210[bp]
07909 2171           3C                     FF  cmp	al,#$FF
07910 2173           75           25            jne 	.1B5
07911                       00002175            .1B7:
07912                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
07913 2175           8A86       FDEF            mov	al,-$211[bp]
07914 2179           3C                     FF  cmp	al,#$FF
07915 217B           75           1D            jne 	.1B5
07916                       0000217D            .1B6:
07917                                           ! 1614           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
07918                                           ! Debug: list int = const 0 (used reg = )
07919 217D           31C0                       xor	ax,ax
07920 217F           50                         push	ax
07921                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07922 2180           8A46         FB            mov	al,-5[bp]
07923 2183           30E4                       xor	ah,ah
07924 2185           B9                   001E  mov	cx,*$1E
07925 2188           F7E9                       imul	cx
07926 218A           89C3                       mov	bx,ax
07927                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07928                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07929 218C           81C3                 0142  add	bx,#$142
07930 2190           53                         push	bx
07931                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07932 2191           FF76         FE            push	-2[bp]
07933                                           ! Debug: func () void = write_byte+0 (used reg = )
07934 2194           E8         E483            call	_write_byte
07935 2197           83C4                   06  add	sp,*6
07936                                           !BCC_EOS
07937                                           ! 1615         }
07938                                           ! 1616       }
07939                       0000219A            .1B5:
07940                       0000219A            .1B4:
07941                       0000219A            .1AF:
07942                                           ! 1617     }
07943                       0000219A            .1A9:
07944                                           ! 1618     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
07945                       0000219A            .1A3:
07946                                           ! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
07947 219A           8A46         FB            mov	al,-5[bp]
07948 219D           30E4                       xor	ah,ah
07949 219F           B9                   001E  mov	cx,*$1E
07950 21A2           F7E9                       imul	cx
07951 21A4           89C3                       mov	bx,ax
07952                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07953                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07954 21A6           81C3                 0142  add	bx,#$142
07955 21AA           53                         push	bx
07956                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07957 21AB           FF76         FE            push	-2[bp]
07958                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07959 21AE           E8         E443            call	_read_byte
07960 21B1           83C4                   04  add	sp,*4
07961                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
07962 21B4           8846         FA            mov	-6[bp],al
07963                                           !BCC_EOS
07964                                           ! 1619     if(type == 0x02) {
07965                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
07966 21B7           8A46         FA            mov	al,-6[bp]
07967 21BA           3C                     02  cmp	al,*2
07968 21BC         0F85         0534            bne 	.1B8
07969                       000021C0            .1B9:
07970                                           ! 1620       Bit32u sectors_low, sectors_high;
07971                                           !BCC_EOS
07972                                           ! 1621       Bit16u cylinders, heads, spt, blksize;
07973                                           !BCC_EOS
07974                                           ! 1622       Bit8u translation, removable, mode;
07975                                           !BCC_EOS
07976                                           ! 1623       mode = 0x00;
07977 21C0           83C4                   EC  add	sp,*-$14
07978                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$228-$227] (used reg = )
07979 21C3           30C0                       xor	al,al
07980 21C5           8886       FDDB            mov	-$225[bp],al
07981                                           !BCC_EOS
07982                                           ! 1624       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
07983                                           ! Debug: list int = const $FF (used reg = )
07984 21C9           B8                   00FF  mov	ax,#$FF
07985 21CC           50                         push	ax
07986                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
07987 21CD           8A46         FB            mov	al,-5[bp]
07988 21D0           30E4                       xor	ah,ah
07989 21D2           B9                   001E  mov	cx,*$1E
07990 21D5           F7E9                       imul	cx
07991 21D7           89C3                       mov	bx,ax
07992                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07993                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
07994 21D9           81C3                 0143  add	bx,#$143
07995 21DD           53                         push	bx
07996                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
07997 21DE           FF76         FE            push	-2[bp]
07998                                           ! Debug: func () void = write_byte+0 (used reg = )
07999 21E1           E8         E436            call	_write_byte
08000 21E4           83C4                   06  add	sp,*6
08001                                           !BCC_EOS
08002                                           ! 1625       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08003                                           ! Debug: list int = const 0 (used reg = )
08004 21E7           31C0                       xor	ax,ax
08005 21E9           50                         push	ax
08006                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08007 21EA           8A46         FB            mov	al,-5[bp]
08008 21ED           30E4                       xor	ah,ah
08009 21EF           B9                   001E  mov	cx,*$1E
08010 21F2           F7E9                       imul	cx
08011 21F4           89C3                       mov	bx,ax
08012                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08013                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08014 21F6           81C3                 0146  add	bx,#$146
08015 21FA           53                         push	bx
08016                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08017 21FB           FF76         FE            push	-2[bp]
08018                                           ! Debug: func () void = write_byte+0 (used reg = )
08019 21FE           E8         E419            call	_write_byte
08020 2201           83C4                   06  add	sp,*6
08021                                           !BCC_EOS
08022                                           ! 1626       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
08023                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08024 2204           8D9E       FDFA            lea	bx,-$206[bp]
08025 2208           53                         push	bx
08026                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08027 2209           E8         E441            call	_get_SS
08028                                           ! Debug: list unsigned short = ax+0 (used reg = )
08029 220C           50                         push	ax
08030                                           ! Debug: list long = const 0 (used reg = )
08031 220D           31C0                       xor	ax,ax
08032 220F           31DB                       xor	bx,bx
08033 2211           53                         push	bx
08034 2212           50                         push	ax
08035                                           ! Debug: list long = const 0 (used reg = )
08036 2213           31C0                       xor	ax,ax
08037 2215           31DB                       xor	bx,bx
08038 2217           53                         push	bx
08039 2218           50                         push	ax
08040                                           ! Debug: list int = const 0 (used reg = )
08041 2219           31C0                       xor	ax,ax
08042 221B           50                         push	ax
08043                                           ! Debug: list int = const 0 (used reg = )
08044 221C           31C0                       xor	ax,ax
08045 221E           50                         push	ax
08046                                           ! Debug: list int = const 0 (used reg = )
08047 221F           31C0                       xor	ax,ax
08048 2221           50                         push	ax
08049                                           ! Debug: list int = const 1 (used reg = )
08050 2222           B8                   0001  mov	ax,*1
08051 2225           50                         push	ax
08052                                           ! Debug: list int = const $EC (used reg = )
08053 2226           B8                   00EC  mov	ax,#$EC
08054 2229           50                         push	ax
08055                                           ! Debug: list unsigned char device = [S+$23E-7] (used reg = )
08056 222A           8A46         FB            mov	al,-5[bp]
08057 222D           30E4                       xor	ah,ah
08058 222F           50                         push	ax
08059                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08060 2230           E8         0B04            call	_ata_cmd_data_in
08061 2233           83C4                   18  add	sp,*$18
08062                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08063 2236           85C0                       test	ax,ax
08064 2238           74           0E            je  	.1BA
08065                       0000223A            .1BB:
08066                                           ! 1627         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
08067                                           ! Debug: list * char = .1BC+0 (used reg = )
08068 223A           BB                   D42E  mov	bx,#.1BC
08069 223D           53                         push	bx
08070                                           ! Debug: list int = const 7 (used reg = )
08071 223E           B8                   0007  mov	ax,*7
08072 2241           50                         push	ax
08073                                           ! Debug: func () void = bios_printf+0 (used reg = )
08074 2242           E8         E7D6            call	_bios_printf
08075 2245           83C4                   04  add	sp,*4
08076                                           !BCC_EOS
08077                                           ! 1628       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
08078                       00002248            .1BA:
08079                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08080 2248           8D9E       FDFA            lea	bx,-$206[bp]
08081 224C           53                         push	bx
08082                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08083 224D           E8         E3FD            call	_get_SS
08084                                           ! Debug: list unsigned short = ax+0 (used reg = )
08085 2250           50                         push	ax
08086                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08087 2251           E8         E3A0            call	_read_byte
08088 2254           83C4                   04  add	sp,*4
08089                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08090 2257           24                     80  and	al,#$80
08091 2259           84C0                       test	al,al
08092 225B           74           04            je  	.1BD
08093                       0000225D            .1BE:
08094 225D           B0                     01  mov	al,*1
08095 225F           EB           02            jmp .1BF
08096                       00002261            .1BD:
08097 2261           30C0                       xor	al,al
08098                       00002263            .1BF:
08099                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
08100 2263           8886       FDDC            mov	-$224[bp],al
08101                                           !BCC_EOS
08102                                           ! 1629       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
08103                                           ! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
08104 2267           8D9E       FE5A            lea	bx,-$1A6[bp]
08105 226B           53                         push	bx
08106                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08107 226C           E8         E3DE            call	_get_SS
08108                                           ! Debug: list unsigned short = ax+0 (used reg = )
08109 226F           50                         push	ax
08110                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08111 2270           E8         E381            call	_read_byte
08112 2273           83C4                   04  add	sp,*4
08113 2276           84C0                       test	al,al
08114 2278           74           04            je  	.1C0
08115                       0000227A            .1C1:
08116 227A           B0                     01  mov	al,*1
08117 227C           EB           02            jmp .1C2
08118                       0000227E            .1C0:
08119 227E           30C0                       xor	al,al
08120                       00002280            .1C2:
08121                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
08122 2280           8886       FDDB            mov	-$225[bp],al
08123                                           !BCC_EOS
08124                                           ! 1630       blksize = read_word(get_SS(),buffer+10);
08125                                           ! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
08126 2284           8D9E       FE04            lea	bx,-$1FC[bp]
08127 2288           53                         push	bx
08128                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08129 2289           E8         E3C1            call	_get_SS
08130                                           ! Debug: list unsigned short = ax+0 (used reg = )
08131 228C           50                         push	ax
08132                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08133 228D           E8         E377            call	_read_word
08134 2290           83C4                   04  add	sp,*4
08135                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
08136 2293           8986       FDDE            mov	-$222[bp],ax
08137                                           !BCC_EOS
08138                                           ! 1631       cylinders = read_word(get_SS(),buffer+(1*2));
08139                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
08140 2297           8D9E       FDFC            lea	bx,-$204[bp]
08141 229B           53                         push	bx
08142                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08143 229C           E8         E3AE            call	_get_SS
08144                                           ! Debug: list unsigned short = ax+0 (used reg = )
08145 229F           50                         push	ax
08146                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08147 22A0           E8         E364            call	_read_word
08148 22A3           83C4                   04  add	sp,*4
08149                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08150 22A6           8986       FDE4            mov	-$21C[bp],ax
08151                                           !BCC_EOS
08152                                           ! 1632       heads = read_word(get_SS(),buffer+(3*2));
08153                                           ! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
08154 22AA           8D9E       FE00            lea	bx,-$200[bp]
08155 22AE           53                         push	bx
08156                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08157 22AF           E8         E39B            call	_get_SS
08158                                           ! Debug: list unsigned short = ax+0 (used reg = )
08159 22B2           50                         push	ax
08160                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08161 22B3           E8         E351            call	_read_word
08162 22B6           83C4                   04  add	sp,*4
08163                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
08164 22B9           8986       FDE2            mov	-$21E[bp],ax
08165                                           !BCC_EOS
08166                                           ! 1633       spt = read_word(get_SS(),buffer+(6*2));
08167                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
08168 22BD           8D9E       FE06            lea	bx,-$1FA[bp]
08169 22C1           53                         push	bx
08170                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08171 22C2           E8         E388            call	_get_SS
08172                                           ! Debug: list unsigned short = ax+0 (used reg = )
08173 22C5           50                         push	ax
08174                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08175 22C6           E8         E33E            call	_read_word
08176 22C9           83C4                   04  add	sp,*4
08177                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
08178 22CC           8986       FDE0            mov	-$220[bp],ax
08179                                           !BCC_EOS
08180                                           ! 1634       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
08181                                           ! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
08182 22D0           8D9E       FEA0            lea	bx,-$160[bp]
08183 22D4           53                         push	bx
08184                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08185 22D5           E8         E375            call	_get_SS
08186                                           ! Debug: list unsigned short = ax+0 (used reg = )
08187 22D8           50                         push	ax
08188                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08189 22D9           E8         E32B            call	_read_word
08190 22DC           83C4                   04  add	sp,*4
08191                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
08192 22DF           25                   0400  and	ax,#$400
08193 22E2           85C0                       test	ax,ax
08194 22E4           74           34            je  	.1C3
08195                       000022E6            .1C4:
08196                                           ! 1635         sectors_low = read_dword(get_SS(),buffer+(100*2));
08197                                           ! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
08198 22E6           8D9E       FEC2            lea	bx,-$13E[bp]
08199 22EA           53                         push	bx
08200                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08201 22EB           E8         E35F            call	_get_SS
08202                                           ! Debug: list unsigned short = ax+0 (used reg = )
08203 22EE           50                         push	ax
08204                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08205 22EF           E8         DD91            call	_read_dword
08206 22F2           89D3                       mov	bx,dx
08207 22F4           83C4                   04  add	sp,*4
08208                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08209 22F7           8986       FDEA            mov	-$216[bp],ax
08210 22FB           899E       FDEC            mov	-$214[bp],bx
08211                                           !BCC_EOS
08212                                           ! 1636         sectors_high = read_dword(get_SS(),buffer+(102*2));
08213                                           ! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
08214 22FF           8D9E       FEC6            lea	bx,-$13A[bp]
08215 2303           53                         push	bx
08216                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08217 2304           E8         E346            call	_get_SS
08218                                           ! Debug: list unsigned short = ax+0 (used reg = )
08219 2307           50                         push	ax
08220                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08221 2308           E8         DD78            call	_read_dword
08222 230B           89D3                       mov	bx,dx
08223 230D           83C4                   04  add	sp,*4
08224                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08225 2310           8986       FDE6            mov	-$21A[bp],ax
08226 2314           899E       FDE8            mov	-$218[bp],bx
08227                                           !BCC_EOS
08228                                           ! 1637       } else {
08229 2318           EB           25            jmp .1C5
08230                       0000231A            .1C3:
08231                                           ! 1638         sectors_low = read_dword(get_SS(),buffer+(60*2));
08232                                           ! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
08233 231A           8D9E       FE72            lea	bx,-$18E[bp]
08234 231E           53                         push	bx
08235                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08236 231F           E8         E32B            call	_get_SS
08237                                           ! Debug: list unsigned short = ax+0 (used reg = )
08238 2322           50                         push	ax
08239                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08240 2323           E8         DD5D            call	_read_dword
08241 2326           89D3                       mov	bx,dx
08242 2328           83C4                   04  add	sp,*4
08243                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08244 232B           8986       FDEA            mov	-$216[bp],ax
08245 232F           899E       FDEC            mov	-$214[bp],bx
08246                                           !BCC_EOS
08247                                           ! 1639         sectors_high = 0;
08248                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08249 2333           31C0                       xor	ax,ax
08250 2335           31DB                       xor	bx,bx
08251 2337           8986       FDE6            mov	-$21A[bp],ax
08252 233B           899E       FDE8            mov	-$218[bp],bx
08253                                           !BCC_EOS
08254                                           ! 1640       }
08255                                           ! 1641       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
08256                       0000233F            .1C5:
08257                                           ! Debug: list int = const $FF (used reg = )
08258 233F           B8                   00FF  mov	ax,#$FF
08259 2342           50                         push	ax
08260                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08261 2343           8A46         FB            mov	al,-5[bp]
08262 2346           30E4                       xor	ah,ah
08263 2348           B9                   001E  mov	cx,*$1E
08264 234B           F7E9                       imul	cx
08265 234D           89C3                       mov	bx,ax
08266                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08267                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08268 234F           81C3                 0143  add	bx,#$143
08269 2353           53                         push	bx
08270                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08271 2354           FF76         FE            push	-2[bp]
08272                                           ! Debug: func () void = write_byte+0 (used reg = )
08273 2357           E8         E2C0            call	_write_byte
08274 235A           83C4                   06  add	sp,*6
08275                                           !BCC_EOS
08276                                           ! 1642       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
08277                                           ! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
08278 235D           8A86       FDDC            mov	al,-$224[bp]
08279 2361           30E4                       xor	ah,ah
08280 2363           50                         push	ax
08281                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08282 2364           8A46         FB            mov	al,-5[bp]
08283 2367           30E4                       xor	ah,ah
08284 2369           B9                   001E  mov	cx,*$1E
08285 236C           F7E9                       imul	cx
08286 236E           89C3                       mov	bx,ax
08287                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08288                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
08289 2370           81C3                 0144  add	bx,#$144
08290 2374           53                         push	bx
08291                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08292 2375           FF76         FE            push	-2[bp]
08293                                           ! Debug: func () void = write_byte+0 (used reg = )
08294 2378           E8         E29F            call	_write_byte
08295 237B           83C4                   06  add	sp,*6
08296                                           !BCC_EOS
08297                                           ! 1643       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
08298                                           ! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
08299 237E           8A86       FDDB            mov	al,-$225[bp]
08300 2382           30E4                       xor	ah,ah
08301 2384           50                         push	ax
08302                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08303 2385           8A46         FB            mov	al,-5[bp]
08304 2388           30E4                       xor	ah,ah
08305 238A           B9                   001E  mov	cx,*$1E
08306 238D           F7E9                       imul	cx
08307 238F           89C3                       mov	bx,ax
08308                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08309                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08310 2391           81C3                 0146  add	bx,#$146
08311 2395           53                         push	bx
08312                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08313 2396           FF76         FE            push	-2[bp]
08314                                           ! Debug: func () void = write_byte+0 (used reg = )
08315 2399           E8         E27E            call	_write_byte
08316 239C           83C4                   06  add	sp,*6
08317                                           !BCC_EOS
08318                                           ! 1644       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
08319                                           ! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
08320 239F           FFB6       FDDE            push	-$222[bp]
08321                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08322 23A3           8A46         FB            mov	al,-5[bp]
08323 23A6           30E4                       xor	ah,ah
08324 23A8           B9                   001E  mov	cx,*$1E
08325 23AB           F7E9                       imul	cx
08326 23AD           89C3                       mov	bx,ax
08327                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08328                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
08329 23AF           81C3                 0148  add	bx,#$148
08330 23B3           53                         push	bx
08331                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08332 23B4           FF76         FE            push	-2[bp]
08333                                           ! Debug: func () void = write_word+0 (used reg = )
08334 23B7           E8         E278            call	_write_word
08335 23BA           83C4                   06  add	sp,*6
08336                                           !BCC_EOS
08337                                           ! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
08338                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08339 23BD           FFB6       FDE2            push	-$21E[bp]
08340                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08341 23C1           8A46         FB            mov	al,-5[bp]
08342 23C4           30E4                       xor	ah,ah
08343 23C6           B9                   001E  mov	cx,*$1E
08344 23C9           F7E9                       imul	cx
08345 23CB           89C3                       mov	bx,ax
08346                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
08347                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
08348 23CD           81C3                 0152  add	bx,#$152
08349 23D1           53                         push	bx
08350                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08351 23D2           FF76         FE            push	-2[bp]
08352                                           ! Debug: func () void = write_word+0 (used reg = )
08353 23D5           E8         E25A            call	_write_word
08354 23D8           83C4                   06  add	sp,*6
08355                                           !BCC_EOS
08356                                           ! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
08357                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08358 23DB           FFB6       FDE4            push	-$21C[bp]
08359                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08360 23DF           8A46         FB            mov	al,-5[bp]
08361 23E2           30E4                       xor	ah,ah
08362 23E4           B9                   001E  mov	cx,*$1E
08363 23E7           F7E9                       imul	cx
08364 23E9           89C3                       mov	bx,ax
08365                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
08366                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
08367 23EB           81C3                 0154  add	bx,#$154
08368 23EF           53                         push	bx
08369                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08370 23F0           FF76         FE            push	-2[bp]
08371                                           ! Debug: func () void = write_word+0 (used reg = )
08372 23F3           E8         E23C            call	_write_word
08373 23F6           83C4                   06  add	sp,*6
08374                                           !BCC_EOS
08375                                           ! 1647       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
08376                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08377 23F9           FFB6       FDE0            push	-$220[bp]
08378                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08379 23FD           8A46         FB            mov	al,-5[bp]
08380 2400           30E4                       xor	ah,ah
08381 2402           B9                   001E  mov	cx,*$1E
08382 2405           F7E9                       imul	cx
08383 2407           89C3                       mov	bx,ax
08384                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
08385                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
08386 2409           81C3                 0156  add	bx,#$156
08387 240D           53                         push	bx
08388                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08389 240E           FF76         FE            push	-2[bp]
08390                                           ! Debug: func () void = write_word+0 (used reg = )
08391 2411           E8         E21E            call	_write_word
08392 2414           83C4                   06  add	sp,*6
08393                                           !BCC_EOS
08394                                           ! 1648       write_dword(ebda_seg,&((ebda_da
08395                                           ! 1648 ta_t *) 0)->ata.devices[device].sectors_low, sectors_low);
08396                                           ! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
08397 2417           FFB6       FDEC            push	-$214[bp]
08398 241B           FFB6       FDEA            push	-$216[bp]
08399                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08400 241F           8A46         FB            mov	al,-5[bp]
08401 2422           30E4                       xor	ah,ah
08402 2424           B9                   001E  mov	cx,*$1E
08403 2427           F7E9                       imul	cx
08404 2429           89C3                       mov	bx,ax
08405                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08406                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
08407 242B           81C3                 0158  add	bx,#$158
08408 242F           53                         push	bx
08409                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08410 2430           FF76         FE            push	-2[bp]
08411                                           ! Debug: func () void = write_dword+0 (used reg = )
08412 2433           E8         DC65            call	_write_dword
08413 2436           83C4                   08  add	sp,*8
08414                                           !BCC_EOS
08415                                           ! 1649       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
08416                                           ! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
08417 2439           FFB6       FDE8            push	-$218[bp]
08418 243D           FFB6       FDE6            push	-$21A[bp]
08419                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08420 2441           8A46         FB            mov	al,-5[bp]
08421 2444           30E4                       xor	ah,ah
08422 2446           B9                   001E  mov	cx,*$1E
08423 2449           F7E9                       imul	cx
08424 244B           89C3                       mov	bx,ax
08425                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08426                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
08427 244D           81C3                 015C  add	bx,#$15C
08428 2451           53                         push	bx
08429                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08430 2452           FF76         FE            push	-2[bp]
08431                                           ! Debug: func () void = write_dword+0 (used reg = )
08432 2455           E8         DC43            call	_write_dword
08433 2458           83C4                   08  add	sp,*8
08434                                           !BCC_EOS
08435                                           ! 1650       ;
08436                                           !BCC_EOS
08437                                           ! 1651       translation = inb_cmos(0x39 + channel/2);
08438                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
08439 245B           8A86       FDF5            mov	al,-$20B[bp]
08440 245F           30E4                       xor	ah,ah
08441 2461           D1E8                       shr	ax,*1
08442                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
08443                                           ! Debug: expression subtree swapping
08444                                           ! Debug: list unsigned int = ax+$39 (used reg = )
08445 2463           05                   0039  add	ax,*$39
08446 2466           50                         push	ax
08447                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
08448 2467           E8         E119            call	_inb_cmos
08449 246A           44                         inc	sp
08450 246B           44                         inc	sp
08451                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
08452 246C           8886       FDDD            mov	-$223[bp],al
08453                                           !BCC_EOS
08454                                           ! 1652       for (shift=device%4; shift>0; shift--) translation >>= 2;
08455                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
08456 2470           8A46         FB            mov	al,-5[bp]
08457 2473           30E4                       xor	ah,ah
08458 2475           24                     03  and	al,*3
08459                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
08460 2477           8886       FDF3            mov	-$20D[bp],al
08461                                           !BCC_EOS
08462                                           !BCC_EOS
08463 247B           EB           17            jmp .1C8
08464                       0000247D            .1C9:
08465                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
08466 247D           8A86       FDDD            mov	al,-$223[bp]
08467 2481           30E4                       xor	ah,ah
08468 2483           D1E8                       shr	ax,*1
08469 2485           D1E8                       shr	ax,*1
08470 2487           8886       FDDD            mov	-$223[bp],al
08471                                           !BCC_EOS
08472                                           ! 1653       translation &= 0x03;
08473                       0000248B            .1C7:
08474                                           ! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
08475 248B           8A86       FDF3            mov	al,-$20D[bp]
08476 248F           48                         dec	ax
08477 2490           8886       FDF3            mov	-$20D[bp],al
08478                       00002494            .1C8:
08479                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
08480 2494           8A86       FDF3            mov	al,-$20D[bp]
08481 2498           84C0                       test	al,al
08482 249A           75           E1            jne	.1C9
08483                       0000249C            .1CA:
08484                       0000249C            .1C6:
08485                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
08486 249C           8A86       FDDD            mov	al,-$223[bp]
08487 24A0           24                     03  and	al,*3
08488 24A2           8886       FDDD            mov	-$223[bp],al
08489                                           !BCC_EOS
08490                                           ! 1654       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
08491                                           ! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
08492 24A6           8A86       FDDD            mov	al,-$223[bp]
08493 24AA           30E4                       xor	ah,ah
08494 24AC           50                         push	ax
08495                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08496 24AD           8A46         FB            mov	al,-5[bp]
08497 24B0           30E4                       xor	ah,ah
08498 24B2           B9                   001E  mov	cx,*$1E
08499 24B5           F7E9                       imul	cx
08500 24B7           89C3                       mov	bx,ax
08501                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
08502                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
08503 24B9           81C3                 014A  add	bx,#$14A
08504 24BD           53                         push	bx
08505                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08506 24BE           FF76         FE            push	-2[bp]
08507                                           ! Debug: func () void = write_byte+0 (used reg = )
08508 24C1           E8         E156            call	_write_byte
08509 24C4           83C4                   06  add	sp,*6
08510                                           !BCC_EOS
08511                                           ! 1655       switch (translation) {
08512 24C7           8A86       FDDD            mov	al,-$223[bp]
08513 24CB           EB           0A            jmp .1CD
08514                                           ! 1656         case 0:
08515                                           ! 1657           ;
08516                       000024CD            .1CE:
08517                                           !BCC_EOS
08518                                           ! 1658           break;
08519 24CD           EB           18            jmp .1CB
08520                                           !BCC_EOS
08521                                           ! 1659         case 1:
08522                                           ! 1660           ;
08523                       000024CF            .1CF:
08524                                           !BCC_EOS
08525                                           ! 1661           break;
08526 24CF           EB           16            jmp .1CB
08527                                           !BCC_EOS
08528                                           ! 1662         case 2:
08529                                           ! 1663           ;
08530                       000024D1            .1D0:
08531                                           !BCC_EOS
08532                                           ! 1664           break;
08533 24D1           EB           14            jmp .1CB
08534                                           !BCC_EOS
08535                                           ! 1665         case 3:
08536                                           ! 1666           ;
08537                       000024D3            .1D1:
08538                                           !BCC_EOS
08539                                           ! 1667           break;
08540 24D3           EB           12            jmp .1CB
08541                                           !BCC_EOS
08542                                           ! 1668         }
08543                                           ! 1669       switch (translation) {
08544 24D5           EB           10            jmp .1CB
08545                       000024D7            .1CD:
08546 24D7           2C                     00  sub	al,*0
08547 24D9           74           F2            je 	.1CE
08548 24DB           2C                     01  sub	al,*1
08549 24DD           74           F0            je 	.1CF
08550 24DF           2C                     01  sub	al,*1
08551 24E1           74           EE            je 	.1D0
08552 24E3           2C                     01  sub	al,*1
08553 24E5           74           EC            je 	.1D1
08554                       000024E7            .1CB:
08555                       FFFFFDD8            ..FFFE	=	-$228
08556 24E7           8A86       FDDD            mov	al,-$223[bp]
08557 24EB           E9         0161            br 	.1D4
08558                                           ! 1670         case 0:
08559                                           ! 1671           break;
08560                       000024EE            .1D5:
08561 24EE           E9         0174            br 	.1D2
08562                                           !BCC_EOS
08563                                           ! 1672         case 1:
08564                                           ! 1673           spt = 63;
08565                       000024F1            .1D6:
08566                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
08567 24F1           B8                   003F  mov	ax,*$3F
08568 24F4           8986       FDE0            mov	-$220[bp],ax
08569                                           !BCC_EOS
08570                                           ! 1674           sectors_low /= 63;
08571                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
08572 24F8           B8                   003F  mov	ax,*$3F
08573 24FB           31DB                       xor	bx,bx
08574 24FD           53                         push	bx
08575 24FE           50                         push	ax
08576 24FF           8B86       FDEA            mov	ax,-$216[bp]
08577 2503           8B9E       FDEC            mov	bx,-$214[bp]
08578 2507           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08579 250B           E8         DC60            call	ldivul
08580 250E           8986       FDEA            mov	-$216[bp],ax
08581 2512           899E       FDEC            mov	-$214[bp],bx
08582 2516           83C4                   04  add	sp,*4
08583                                           !BCC_EOS
08584                                           ! 1675           heads = sectors_low / 1024;
08585                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08586 2519           B8                   0400  mov	ax,#$400
08587 251C           31DB                       xor	bx,bx
08588 251E           53                         push	bx
08589 251F           50                         push	ax
08590 2520           8B86       FDEA            mov	ax,-$216[bp]
08591 2524           8B9E       FDEC            mov	bx,-$214[bp]
08592 2528           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08593 252C           E8         DC3F            call	ldivul
08594 252F           83C4                   04  add	sp,*4
08595                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
08596 2532           8986       FDE2            mov	-$21E[bp],ax
08597                                           !BCC_EOS
08598                                           ! 1676           if (heads>128) heads = 255;
08599                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08600 2536           8B86       FDE2            mov	ax,-$21E[bp]
08601 253A           3D                   0080  cmp	ax,#$80
08602 253D           76           09            jbe 	.1D7
08603                       0000253F            .1D8:
08604                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
08605 253F           B8                   00FF  mov	ax,#$FF
08606 2542           8986       FDE2            mov	-$21E[bp],ax
08607                                           !BCC_EOS
08608                                           ! 1677           else if (heads>64) heads = 128;
08609 2546           EB           3D            jmp .1D9
08610                       00002548            .1D7:
08611                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08612 2548           8B86       FDE2            mov	ax,-$21E[bp]
08613 254C           3D                   0040  cmp	ax,*$40
08614 254F           76           09            jbe 	.1DA
08615                       00002551            .1DB:
08616                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08617 2551           B8                   0080  mov	ax,#$80
08618 2554           8986       FDE2            mov	-$21E[bp],ax
08619                                           !BCC_EOS
08620                                           ! 1678           else if (heads>32) heads = 64;
08621 2558           EB           2B            jmp .1DC
08622                       0000255A            .1DA:
08623                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08624 255A           8B86       FDE2            mov	ax,-$21E[bp]
08625 255E           3D                   0020  cmp	ax,*$20
08626 2561           76           09            jbe 	.1DD
08627                       00002563            .1DE:
08628                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08629 2563           B8                   0040  mov	ax,*$40
08630 2566           8986       FDE2            mov	-$21E[bp],ax
08631                                           !BCC_EOS
08632                                           ! 1679           else if (heads>16) heads = 32;
08633 256A           EB           19            jmp .1DF
08634                       0000256C            .1DD:
08635                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08636 256C           8B86       FDE2            mov	ax,-$21E[bp]
08637 2570           3D                   0010  cmp	ax,*$10
08638 2573           76           09            jbe 	.1E0
08639                       00002575            .1E1:
08640                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08641 2575           B8                   0020  mov	ax,*$20
08642 2578           8986       FDE2            mov	-$21E[bp],ax
08643                                           !BCC_EOS
08644                                           ! 1680           else heads=16;
08645 257C           EB           07            jmp .1E2
08646                       0000257E            .1E0:
08647                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08648 257E           B8                   0010  mov	ax,*$10
08649 2581           8986       FDE2            mov	-$21E[bp],ax
08650                                           !BCC_EOS
08651                                           ! 1681           cylinders = sectors_low / heads;
08652                       00002585            .1E2:
08653                       00002585            .1DF:
08654                       00002585            .1DC:
08655                       00002585            .1D9:
08656                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
08657 2585           8B86       FDE2            mov	ax,-$21E[bp]
08658 2589           31DB                       xor	bx,bx
08659                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08660 258B           53                         push	bx
08661 258C           50                         push	ax
08662 258D           8B86       FDEA            mov	ax,-$216[bp]
08663 2591           8B9E       FDEC            mov	bx,-$214[bp]
08664 2595           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08665 2599           E8         DBD2            call	ldivul
08666 259C           83C4                   04  add	sp,*4
08667                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08668 259F           8986       FDE4            mov	-$21C[bp],ax
08669                                           !BCC_EOS
08670                                           ! 1682           break;
08671 25A3           E9         00BF            br 	.1D2
08672                                           !BCC_EOS
08673                                           ! 1683         case 3:
08674                                           ! 1684           if (heads==16) {
08675                       000025A6            .1E3:
08676                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08677 25A6           8B86       FDE2            mov	ax,-$21E[bp]
08678 25AA           3D                   0010  cmp	ax,*$10
08679 25AD           75           72            jne 	.1E4
08680                       000025AF            .1E5:
08681                                           ! 1685             if(cylinders>61439) cylinders=61439;
08682                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08683 25AF           8B86       FDE4            mov	ax,-$21C[bp]
08684 25B3           31DB                       xor	bx,bx
08685                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08686 25B5           53                         push	bx
08687 25B6           50                         push	ax
08688 25B7           B8                   EFFF  mov	ax,#$EFFF
08689 25BA           31DB                       xor	bx,bx
08690 25BC           53                         push	bx
08691 25BD           50                         push	ax
08692 25BE           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08693 25C2           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08694 25C6           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08695 25CA           E8         DAFE            call	lcmpul
08696 25CD           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08697 25D1           76           07            jbe 	.1E6
08698                       000025D3            .1E7:
08699                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
08700 25D3           B8                   EFFF  mov	ax,#$EFFF
08701 25D6           8986       FDE4            mov	-$21C[bp],ax
08702                                           !BCC_EOS
08703                                           ! 1686             heads=15;
08704                       000025DA            .1E6:
08705                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
08706 25DA           B8                   000F  mov	ax,*$F
08707 25DD           8986       FDE2            mov	-$21E[bp],ax
08708                                           !BCC_EOS
08709                                           ! 1687             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08710                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08711 25E1           8B86       FDE4            mov	ax,-$21C[bp]
08712 25E5           31DB                       xor	bx,bx
08713                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08714 25E7           53                         push	bx
08715 25E8           50                         push	ax
08716 25E9           B8                   0010  mov	ax,*$10
08717 25EC           31DB                       xor	bx,bx
08718 25EE           53                         push	bx
08719 25EF           50                         push	ax
08720 25F0           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08721 25F4           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08722 25F8           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08723 25FC           E8         DAEA            call	lmulul
08724 25FF           83C4                   08  add	sp,*8
08725                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08726 2602           53                         push	bx
08727 2603           50                         push	ax
08728 2604           B8                   000F  mov	ax,*$F
08729 2607           31DB                       xor	bx,bx
08730 2609           53                         push	bx
08731 260A           50                         push	ax
08732 260B           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08733 260F           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08734 2613           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08735 2617           E8         DB54            call	ldivul
08736 261A           83C4                   08  add	sp,*8
08737                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08738                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08739 261D           8986       FDE4            mov	-$21C[bp],ax
08740                                           !BCC_EOS
08741                                           ! 1688             }
08742                                           ! 1689         case 2:
08743                       00002621            .1E4:
08744                                           ! 1690           while(cylinders > 1024) {
08745                       00002621            .1E8:
08746 2621           EB           1F            jmp .1EA
08747                       00002623            .1EB:
08748                                           ! 1691             cylinders >>= 1;
08749                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08750 2623           8B86       FDE4            mov	ax,-$21C[bp]
08751 2627           D1E8                       shr	ax,*1
08752 2629           8986       FDE4            mov	-$21C[bp],ax
08753                                           !BCC_EOS
08754                                           ! 1692             heads <<= 1;
08755                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
08756 262D           8B86       FDE2            mov	ax,-$21E[bp]
08757 2631           D1E0                       shl	ax,*1
08758 2633           8986       FDE2            mov	-$21E[bp],ax
08759                                           !BCC_EOS
08760                                           ! 1693             if (heads > 127) break;
08761                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
08762 2637           8B86       FDE2            mov	ax,-$21E[bp]
08763 263B           3D                   007F  cmp	ax,*$7F
08764 263E           76           02            jbe 	.1EC
08765                       00002640            .1ED:
08766 2640           EB           09            jmp .1E9
08767                                           !BCC_EOS
08768                                           ! 1694           }
08769                       00002642            .1EC:
08770                                           ! 1695           break;
08771                       00002642            .1EA:
08772                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08773 2642           8B86       FDE4            mov	ax,-$21C[bp]
08774 2646           3D                   0400  cmp	ax,#$400
08775 2649           77           D8            ja 	.1EB
08776                       0000264B            .1EE:
08777                       0000264B            .1E9:
08778 264B           EB           18            jmp .1D2
08779                                           !BCC_EOS
08780                                           ! 1696         }
08781                                           ! 1697       if (cylinders > 1024) cylinders=1024;
08782 264D           EB           16            jmp .1D2
08783                       0000264F            .1D4:
08784 264F           2C                     00  sub	al,*0
08785 2651         0F84         FE99            beq 	.1D5
08786 2655           2C                     01  sub	al,*1
08787 2657         0F84         FE96            beq 	.1D6
08788 265B           2C                     01  sub	al,*1
08789 265D           74           C2            je 	.1E8
08790 265F           2C                     01  sub	al,*1
08791 2661         0F84         FF41            beq 	.1E3
08792                       00002665            .1D2:
08793                       FFFFFDD8            ..FFFD	=	-$228
08794                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08795 2665           8B86       FDE4            mov	ax,-$21C[bp]
08796 2669           3D                   0400  cmp	ax,#$400
08797 266C           76           07            jbe 	.1EF
08798                       0000266E            .1F0:
08799                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08800 266E           B8                   0400  mov	ax,#$400
08801 2671           8986       FDE4            mov	-$21C[bp],ax
08802                                           !BCC_EOS
08803                                           ! 1698       ;
08804                       00002675            .1EF:
08805                                           !BCC_EOS
08806                                           ! 1699       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
08807                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08808 2675           FFB6       FDE2            push	-$21E[bp]
08809                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08810 2679           8A46         FB            mov	al,-5[bp]
08811 267C           30E4                       xor	ah,ah
08812 267E           B9                   001E  mov	cx,*$1E
08813 2681           F7E9                       imul	cx
08814 2683           89C3                       mov	bx,ax
08815                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08816                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
08817 2685           81C3                 014C  add	bx,#$14C
08818 2689           53                         push	bx
08819                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08820 268A           FF76         FE            push	-2[bp]
08821                                           ! Debug: func () void = write_word+0 (used reg = )
08822 268D           E8         DFA2            call	_write_word
08823 2690           83C4                   06  add	sp,*6
08824                                           !BCC_EOS
08825                                           ! 1700       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
08826                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08827 2693           FFB6       FDE4            push	-$21C[bp]
08828                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08829 2697           8A46         FB            mov	al,-5[bp]
08830 269A           30E4                       xor	ah,ah
08831 269C           B9                   001E  mov	cx,*$1E
08832 269F           F7E9                       imul	cx
08833 26A1           89C3                       mov	bx,ax
08834                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08835                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
08836 26A3           81C3                 014E  add	bx,#$14E
08837 26A7           53                         push	bx
08838                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08839 26A8           FF76         FE            push	-2[bp]
08840                                           ! Debug: func () void = write_word+0 (used reg = )
08841 26AB           E8         DF84            call	_write_word
08842 26AE           83C4                   06  add	sp,*6
08843                                           !BCC_EOS
08844                                           ! 1701       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
08845                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08846 26B1           FFB6       FDE0            push	-$220[bp]
08847                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08848 26B5           8A46         FB            mov	al,-5[bp]
08849 26B8           30E4                       xor	ah,ah
08850 26BA           B9                   001E  mov	cx,*$1E
08851 26BD           F7E9                       imul	cx
08852 26BF           89C3                       mov	bx,ax
08853                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08854                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
08855 26C1           81C3                 0150  add	bx,#$150
08856 26C5           53                         push	bx
08857                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08858 26C6           FF76         FE            push	-2[bp]
08859                                           ! Debug: func () void = write_word+0 (used reg = )
08860 26C9           E8         DF66            call	_write_word
08861 26CC           83C4                   06  add	sp,*6
08862                                           !BCC_EOS
08863                                           ! 1702       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
08864                                           ! Debug: list unsigned char device = [S+$228-7] (used reg = )
08865 26CF           8A46         FB            mov	al,-5[bp]
08866 26D2           30E4                       xor	ah,ah
08867 26D4           50                         push	ax
08868                                           ! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
08869 26D5           8A46         FD            mov	al,-3[bp]
08870 26D8           30E4                       xor	ah,ah
08871 26DA           89C3                       mov	bx,ax
08872                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08873                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
08874 26DC           81C3                 0233  add	bx,#$233
08875 26E0           53                         push	bx
08876                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08877 26E1           FF76         FE            push	-2[bp]
08878                                           ! Debug: func () void = write_byte+0 (used reg = )
08879 26E4           E8         DF33            call	_write_byte
08880 26E7           83C4                   06  add	sp,*6
08881                                           !BCC_EOS
08882                                           ! 1703       hdcount++;
08883                                           ! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
08884 26EA           8A46         FD            mov	al,-3[bp]
08885 26ED           40                         inc	ax
08886 26EE           8846         FD            mov	-3[bp],al
08887                                           !BCC_EOS
08888                                           ! 1704       }
08889 26F1           83C4                   14  add	sp,*$14
08890                                           ! 1705     if(type == 0x03) {
08891                       000026F4            .1B8:
08892                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
08893 26F4           8A46         FA            mov	al,-6[bp]
08894 26F7           3C                     03  cmp	al,*3
08895 26F9         0F85         0186            bne 	.1F1
08896                       000026FD            .1F2:
08897                                           ! 1706       Bit8u type, removable, mode;
08898                                           !BCC_EOS
08899                                           ! 1707       Bit16u blksize;
08900                                           !BCC_EOS
08901                                           ! 1708       mode = 0x00;
08902 26FD           83C4                   FA  add	sp,*-6
08903                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
08904 2700           30C0                       xor	al,al
08905 2702           8886       FDEB            mov	-$215[bp],al
08906                                           !BCC_EOS
08907                                           ! 1709       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
08908                                           ! Debug: list int = const 5 (used reg = )
08909 2706           B8                   0005  mov	ax,*5
08910 2709           50                         push	ax
08911                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08912 270A           8A46         FB            mov	al,-5[bp]
08913 270D           30E4                       xor	ah,ah
08914 270F           B9                   001E  mov	cx,*$1E
08915 2712           F7E9                       imul	cx
08916 2714           89C3                       mov	bx,ax
08917                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08918                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08919 2716           81C3                 0143  add	bx,#$143
08920 271A           53                         push	bx
08921                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08922 271B           FF76         FE            push	-2[bp]
08923                                           ! Debug: func () void = write_byte+0 (used reg = )
08924 271E           E8         DEF9            call	_write_byte
08925 2721           83C4                   06  add	sp,*6
08926                                           !BCC_EOS
08927                                           ! 1710       write_byte(ebda_seg,&((ebda_data_t *)
08928                                           ! 1710  0)->ata.devices[device].mode, 0x00);
08929                                           ! Debug: list int = const 0 (used reg = )
08930 2724           31C0                       xor	ax,ax
08931 2726           50                         push	ax
08932                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08933 2727           8A46         FB            mov	al,-5[bp]
08934 272A           30E4                       xor	ah,ah
08935 272C           B9                   001E  mov	cx,*$1E
08936 272F           F7E9                       imul	cx
08937 2731           89C3                       mov	bx,ax
08938                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08939                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08940 2733           81C3                 0146  add	bx,#$146
08941 2737           53                         push	bx
08942                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08943 2738           FF76         FE            push	-2[bp]
08944                                           ! Debug: func () void = write_byte+0 (used reg = )
08945 273B           E8         DEDC            call	_write_byte
08946 273E           83C4                   06  add	sp,*6
08947                                           !BCC_EOS
08948                                           ! 1711       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08949                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08950 2741           8D9E       FDFA            lea	bx,-$206[bp]
08951 2745           53                         push	bx
08952                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08953 2746           E8         DF04            call	_get_SS
08954                                           ! Debug: list unsigned short = ax+0 (used reg = )
08955 2749           50                         push	ax
08956                                           ! Debug: list long = const 0 (used reg = )
08957 274A           31C0                       xor	ax,ax
08958 274C           31DB                       xor	bx,bx
08959 274E           53                         push	bx
08960 274F           50                         push	ax
08961                                           ! Debug: list long = const 0 (used reg = )
08962 2750           31C0                       xor	ax,ax
08963 2752           31DB                       xor	bx,bx
08964 2754           53                         push	bx
08965 2755           50                         push	ax
08966                                           ! Debug: list int = const 0 (used reg = )
08967 2756           31C0                       xor	ax,ax
08968 2758           50                         push	ax
08969                                           ! Debug: list int = const 0 (used reg = )
08970 2759           31C0                       xor	ax,ax
08971 275B           50                         push	ax
08972                                           ! Debug: list int = const 0 (used reg = )
08973 275C           31C0                       xor	ax,ax
08974 275E           50                         push	ax
08975                                           ! Debug: list int = const 1 (used reg = )
08976 275F           B8                   0001  mov	ax,*1
08977 2762           50                         push	ax
08978                                           ! Debug: list int = const $A1 (used reg = )
08979 2763           B8                   00A1  mov	ax,#$A1
08980 2766           50                         push	ax
08981                                           ! Debug: list unsigned char device = [S+$230-7] (used reg = )
08982 2767           8A46         FB            mov	al,-5[bp]
08983 276A           30E4                       xor	ah,ah
08984 276C           50                         push	ax
08985                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08986 276D           E8         05C7            call	_ata_cmd_data_in
08987 2770           83C4                   18  add	sp,*$18
08988                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08989 2773           85C0                       test	ax,ax
08990 2775           74           0E            je  	.1F3
08991                       00002777            .1F4:
08992                                           ! 1712         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08993                                           ! Debug: list * char = .1F5+0 (used reg = )
08994 2777           BB                   D403  mov	bx,#.1F5
08995 277A           53                         push	bx
08996                                           ! Debug: list int = const 7 (used reg = )
08997 277B           B8                   0007  mov	ax,*7
08998 277E           50                         push	ax
08999                                           ! Debug: func () void = bios_printf+0 (used reg = )
09000 277F           E8         E299            call	_bios_printf
09001 2782           83C4                   04  add	sp,*4
09002                                           !BCC_EOS
09003                                           ! 1713       type = read_byte(get_SS(),buffer+1) & 0x1f;
09004                       00002785            .1F3:
09005                                           ! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
09006 2785           8D9E       FDFB            lea	bx,-$205[bp]
09007 2789           53                         push	bx
09008                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09009 278A           E8         DEC0            call	_get_SS
09010                                           ! Debug: list unsigned short = ax+0 (used reg = )
09011 278D           50                         push	ax
09012                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09013 278E           E8         DE63            call	_read_byte
09014 2791           83C4                   04  add	sp,*4
09015                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
09016 2794           24                     1F  and	al,*$1F
09017                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
09018 2796           8886       FDED            mov	-$213[bp],al
09019                                           !BCC_EOS
09020                                           ! 1714       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
09021                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
09022 279A           8D9E       FDFA            lea	bx,-$206[bp]
09023 279E           53                         push	bx
09024                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09025 279F           E8         DEAB            call	_get_SS
09026                                           ! Debug: list unsigned short = ax+0 (used reg = )
09027 27A2           50                         push	ax
09028                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09029 27A3           E8         DE4E            call	_read_byte
09030 27A6           83C4                   04  add	sp,*4
09031                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
09032 27A9           24                     80  and	al,#$80
09033 27AB           84C0                       test	al,al
09034 27AD           74           04            je  	.1F6
09035                       000027AF            .1F7:
09036 27AF           B0                     01  mov	al,*1
09037 27B1           EB           02            jmp .1F8
09038                       000027B3            .1F6:
09039 27B3           30C0                       xor	al,al
09040                       000027B5            .1F8:
09041                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
09042 27B5           8886       FDEC            mov	-$214[bp],al
09043                                           !BCC_EOS
09044                                           ! 1715       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
09045                                           ! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
09046 27B9           8D9E       FE5A            lea	bx,-$1A6[bp]
09047 27BD           53                         push	bx
09048                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09049 27BE           E8         DE8C            call	_get_SS
09050                                           ! Debug: list unsigned short = ax+0 (used reg = )
09051 27C1           50                         push	ax
09052                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09053 27C2           E8         DE2F            call	_read_byte
09054 27C5           83C4                   04  add	sp,*4
09055 27C8           84C0                       test	al,al
09056 27CA           74           04            je  	.1F9
09057                       000027CC            .1FA:
09058 27CC           B0                     01  mov	al,*1
09059 27CE           EB           02            jmp .1FB
09060                       000027D0            .1F9:
09061 27D0           30C0                       xor	al,al
09062                       000027D2            .1FB:
09063                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
09064 27D2           8886       FDEB            mov	-$215[bp],al
09065                                           !BCC_EOS
09066                                           ! 1716       blksize = 2048;
09067                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
09068 27D6           B8                   0800  mov	ax,#$800
09069 27D9           8986       FDE8            mov	-$218[bp],ax
09070                                           !BCC_EOS
09071                                           ! 1717       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
09072                                           ! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
09073 27DD           8A86       FDED            mov	al,-$213[bp]
09074 27E1           30E4                       xor	ah,ah
09075 27E3           50                         push	ax
09076                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09077 27E4           8A46         FB            mov	al,-5[bp]
09078 27E7           30E4                       xor	ah,ah
09079 27E9           B9                   001E  mov	cx,*$1E
09080 27EC           F7E9                       imul	cx
09081 27EE           89C3                       mov	bx,ax
09082                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09083                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09084 27F0           81C3                 0143  add	bx,#$143
09085 27F4           53                         push	bx
09086                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09087 27F5           FF76         FE            push	-2[bp]
09088                                           ! Debug: func () void = write_byte+0 (used reg = )
09089 27F8           E8         DE1F            call	_write_byte
09090 27FB           83C4                   06  add	sp,*6
09091                                           !BCC_EOS
09092                                           ! 1718       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
09093                                           ! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
09094 27FE           8A86       FDEC            mov	al,-$214[bp]
09095 2802           30E4                       xor	ah,ah
09096 2804           50                         push	ax
09097                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09098 2805           8A46         FB            mov	al,-5[bp]
09099 2808           30E4                       xor	ah,ah
09100 280A           B9                   001E  mov	cx,*$1E
09101 280D           F7E9                       imul	cx
09102 280F           89C3                       mov	bx,ax
09103                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
09104                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
09105 2811           81C3                 0144  add	bx,#$144
09106 2815           53                         push	bx
09107                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09108 2816           FF76         FE            push	-2[bp]
09109                                           ! Debug: func () void = write_byte+0 (used reg = )
09110 2819           E8         DDFE            call	_write_byte
09111 281C           83C4                   06  add	sp,*6
09112                                           !BCC_EOS
09113                                           ! 1719       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
09114                                           ! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
09115 281F           8A86       FDEB            mov	al,-$215[bp]
09116 2823           30E4                       xor	ah,ah
09117 2825           50                         push	ax
09118                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09119 2826           8A46         FB            mov	al,-5[bp]
09120 2829           30E4                       xor	ah,ah
09121 282B           B9                   001E  mov	cx,*$1E
09122 282E           F7E9                       imul	cx
09123 2830           89C3                       mov	bx,ax
09124                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09125                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09126 2832           81C3                 0146  add	bx,#$146
09127 2836           53                         push	bx
09128                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09129 2837           FF76         FE            push	-2[bp]
09130                                           ! Debug: func () void = write_byte+0 (used reg = )
09131 283A           E8         DDDD            call	_write_byte
09132 283D           83C4                   06  add	sp,*6
09133                                           !BCC_EOS
09134                                           ! 1720       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
09135                                           ! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
09136 2840           FFB6       FDE8            push	-$218[bp]
09137                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09138 2844           8A46         FB            mov	al,-5[bp]
09139 2847           30E4                       xor	ah,ah
09140 2849           B9                   001E  mov	cx,*$1E
09141 284C           F7E9                       imul	cx
09142 284E           89C3                       mov	bx,ax
09143                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09144                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
09145 2850           81C3                 0148  add	bx,#$148
09146 2854           53                         push	bx
09147                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09148 2855           FF76         FE            push	-2[bp]
09149                                           ! Debug: func () void = write_word+0 (used reg = )
09150 2858           E8         DDD7            call	_write_word
09151 285B           83C4                   06  add	sp,*6
09152                                           !BCC_EOS
09153                                           ! 1721       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
09154                                           ! Debug: list unsigned char device = [S+$21A-7] (used reg = )
09155 285E           8A46         FB            mov	al,-5[bp]
09156 2861           30E4                       xor	ah,ah
09157 2863           50                         push	ax
09158                                           ! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
09159 2864           8A46         FC            mov	al,-4[bp]
09160 2867           30E4                       xor	ah,ah
09161 2869           89C3                       mov	bx,ax
09162                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
09163                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
09164 286B           81C3                 023C  add	bx,#$23C
09165 286F           53                         push	bx
09166                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09167 2870           FF76         FE            push	-2[bp]
09168                                           ! Debug: func () void = write_byte+0 (used reg = )
09169 2873           E8         DDA4            call	_write_byte
09170 2876           83C4                   06  add	sp,*6
09171                                           !BCC_EOS
09172                                           ! 1722       cdcount++;
09173                                           ! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
09174 2879           8A46         FC            mov	al,-4[bp]
09175 287C           40                         inc	ax
09176 287D           8846         FC            mov	-4[bp],al
09177                                           !BCC_EOS
09178                                           ! 1723       }
09179 2880           83C4                   06  add	sp,*6
09180                                           ! 1724       {
09181                       00002883            .1F1:
09182                                           ! 1725       Bit32u sizeinmb;
09183                                           !BCC_EOS
09184                                           ! 1726       Bit16u ataversion;
09185                                           !BCC_EOS
09186                                           ! 1727       Bit8u c, i, version, model[41];
09187                                           !BCC_EOS
09188                                           ! 1728       switch (type) {
09189 2883           83C4                   CE  add	sp,*-$32
09190 2886           8A46         FA            mov	al,-6[bp]
09191 2889           E9         020C            br 	.1FE
09192                                           ! 1729         case 0x02:
09193                                           ! 1730           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
09194                       0000288C            .1FF:
09195                                           ! 1731             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
09196                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09197 288C           8A46         FB            mov	al,-5[bp]
09198 288F           30E4                       xor	ah,ah
09199 2891           B9                   001E  mov	cx,*$1E
09200 2894           F7E9                       imul	cx
09201 2896           89C3                       mov	bx,ax
09202                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
09203                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
09204 2898           81C3                 0158  add	bx,#$158
09205 289C           53                         push	bx
09206                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09207 289D           FF76         FE            push	-2[bp]
09208                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09209 28A0           E8         D7E0            call	_read_dword
09210 28A3           89D3                       mov	bx,dx
09211 28A5           83C4                   04  add	sp,*4
09212                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
09213 28A8           88E0                       mov	al,ah
09214 28AA           88DC                       mov	ah,bl
09215 28AC           88FB                       mov	bl,bh
09216 28AE           28FF                       sub	bh,bh
09217 28B0           BF                   0003  mov	di,*3
09218 28B3           E8         D873            call	lsrul
09219 28B6           53                         push	bx
09220 28B7           50                         push	ax
09221                                           ! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
09222 28B8           8A46         FB            mov	al,-5[bp]
09223 28BB           30E4                       xor	ah,ah
09224 28BD           B9                   001E  mov	cx,*$1E
09225 28C0           F7E9                       imul	cx
09226 28C2           89C3                       mov	bx,ax
09227                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
09228                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
09229 28C4           81C3                 015C  add	bx,#$15C
09230 28C8           53                         push	bx
09231                                           ! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
09232 28C9           FF76         FE            push	-2[bp]
09233                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09234 28CC           E8         D7B4            call	_read_dword
09235 28CF           89D3                       mov	bx,dx
09236 28D1           83C4                   04  add	sp,*4
09237                                           ! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
09238 28D4           B1                     05  mov	cl,*5
09239 28D6           D3E0                       shl	ax,cl
09240 28D8           93                         xchg	bx,ax
09241 28D9           31C0                       xor	ax,ax
09242                                           ! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
09243 28DB           8DBE       FDB8            lea	di,-2+..FFFC[bp]
09244 28DF           E8         D825            call	lorul
09245 28E2           83C4                   04  add	sp,*4
09246                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09247 28E5           8986       FDEA            mov	-$216[bp],ax
09248 28E9           899E       FDEC            mov	-$214[bp],bx
09249                                           !BCC_EOS
09250                                           ! 1732         case 0x03:
09251                                           ! 1733           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
09252                       000028ED            .200:
09253                                           ! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
09254 28ED           8D9E       FE9A            lea	bx,-$166[bp]
09255 28F1           53                         push	bx
09256                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09257 28F2           E8         DD58            call	_get_SS
09258                                           ! Debug: list unsigned short = ax+0 (used reg = )
09259 28F5           50                         push	ax
09260                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09261 28F6           E8         DCFB            call	_read_byte
09262 28F9           83C4                   04  add	sp,*4
09263 28FC           50                         push	ax
09264                                           ! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
09265 28FD           8D9E       FE9B            lea	bx,-$165[bp]
09266 2901           53                         push	bx
09267                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09268 2902           E8         DD48            call	_get_SS
09269                                           ! Debug: list unsigned short = ax+0 (used reg = )
09270 2905           50                         push	ax
09271                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09272 2906           E8         DCEB            call	_read_byte
09273 2909           83C4                   04  add	sp,*4
09274                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
09275 290C           30E4                       xor	ah,ah
09276                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
09277 290E           88C4                       mov	ah,al
09278 2910           30C0                       xor	al,al
09279                                           ! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
09280 2912           0A86       FDBA            or	al,0+..FFFC[bp]
09281 2916           44                         inc	sp
09282 2917           44                         inc	sp
09283                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09284 2918           8986       FDE8            mov	-$218[bp],ax
09285                                           !BCC_EOS
09286                                           ! 1734           for(version=15;version>0;version--) {
09287                                           ! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
09288 291C           B0                     0F  mov	al,*$F
09289 291E           8886       FDE5            mov	-$21B[bp],al
09290                                           !BCC_EOS
09291                                           !BCC_EOS
09292 2922           EB           22            jmp .203
09293                       00002924            .204:
09294                                           ! 1735             if((ataversion&(1<<version))!=0)
09295                                           ! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
09296 2924           8A86       FDE5            mov	al,-$21B[bp]
09297 2928           30E4                       xor	ah,ah
09298 292A           89C3                       mov	bx,ax
09299 292C           B8                   0001  mov	ax,*1
09300 292F           89D9                       mov	cx,bx
09301 2931           D3E0                       shl	ax,cl
09302                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09303                                           ! Debug: expression subtree swapping
09304 2933           2386       FDE8            and	ax,-$218[bp]
09305                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
09306 2937           85C0                       test	ax,ax
09307 2939           74           02            je  	.205
09308                       0000293B            .206:
09309                                           ! 1736             break;
09310 293B           EB           11            jmp .201
09311                                           !BCC_EOS
09312                                           ! 1737             }
09313                       0000293D            .205:
09314                                           ! 1738           for(i=0;i<20;i++){
09315                       0000293D            .202:
09316                                           ! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
09317 293D           8A86       FDE5            mov	al,-$21B[bp]
09318 2941           48                         dec	ax
09319 2942           8886       FDE5            mov	-$21B[bp],al
09320                       00002946            .203:
09321                                           ! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
09322 2946           8A86       FDE5            mov	al,-$21B[bp]
09323 294A           84C0                       test	al,al
09324 294C           75           D6            jne	.204
09325                       0000294E            .207:
09326                       0000294E            .201:
09327                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09328 294E           30C0                       xor	al,al
09329 2950           8886       FDE6            mov	-$21A[bp],al
09330                                           !BCC_EOS
09331                                           !BCC_EOS
09332 2954           E9         007B            br 	.20A
09333                       00002957            .20B:
09334                                           ! 1739             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
09335                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09336 2957           8A86       FDE6            mov	al,-$21A[bp]
09337 295B           30E4                       xor	ah,ah
09338 295D           D1E0                       shl	ax,*1
09339                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09340 295F           89EB                       mov	bx,bp
09341 2961           01C3                       add	bx,ax
09342                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09343                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
09344                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
09345                                           ! Debug: list * unsigned char = bx-$1CF (used reg = )
09346 2963           81C3                 FE31  add	bx,#-$1CF
09347 2967           53                         push	bx
09348                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09349 2968           E8         DCE2            call	_get_SS
09350                                           ! Debug: list unsigned short = ax+0 (used reg = )
09351 296B           50                         push	ax
09352                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09353 296C           E8         DC85            call	_read_byte
09354 296F           83C4                   04  add	sp,*4
09355                                           ! Debug: list unsigned char = al+0 (used reg = )
09356 2972           30E4                       xor	ah,ah
09357 2974           50                         push	ax
09358                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09359 2975           8A86       FDE6            mov	al,-$21A[bp]
09360 2979           30E4                       xor	ah,ah
09361 297B           D1E0                       shl	ax,*1
09362                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09363 297D           89EB                       mov	bx,bp
09364 297F           01C3                       add	bx,ax
09365                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09366                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09367 2981           81C3                 FDBC  add	bx,#-$244
09368 2985           53                         push	bx
09369                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09370 2986           E8         DCC4            call	_get_SS
09371                                           ! Debug: list unsigned short = ax+0 (used reg = )
09372 2989           50                         push	ax
09373                                           ! Debug: func () void = write_byte+0 (used reg = )
09374 298A           E8         DC8D            call	_write_byte
09375 298D           83C4                   06  add	sp,*6
09376                                           !BCC_EOS
09377                                           ! 1740             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
09378                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09379 2990           8A86       FDE6            mov	al,-$21A[bp]
09380 2994           30E4                       xor	ah,ah
09381 2996           D1E0                       shl	ax,*1
09382                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09383 2998           89EB                       mov	bx,bp
09384 299A           01C3                       add	bx,ax
09385                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09386                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
09387                                           ! Debug: list * unsigned char = bx-$1D0 (used reg = )
09388 299C           81C3                 FE30  add	bx,#-$1D0
09389 29A0           53                         push	bx
09390                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09391 29A1           E8         DCA9            call	_get_SS
09392                                           ! Debug: list unsigned short = ax+0 (used reg = )
09393 29A4           50                         push	ax
09394                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09395 29A5           E8         DC4C            call	_read_byte
09396 29A8           83C4                   04  add	sp,*4
09397                                           ! Debug: list unsigned char = al+0 (used reg = )
09398 29AB           30E4                       xor	ah,ah
09399 29AD           50                         push	ax
09400                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09401 29AE           8A86       FDE6            mov	al,-$21A[bp]
09402 29B2           30E4                       xor	ah,ah
09403 29B4           D1E0                       shl	ax,*1
09404                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09405 29B6           89EB                       mov	bx,bp
09406 29B8           01C3                       add	bx,ax
09407                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
09408                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
09409                                           ! Debug: list * unsigned char = bx-$243 (used reg = )
09410 29BA           81C3                 FDBD  add	bx,#-$243
09411 29BE           53                         push	bx
09412                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09413 29BF           E8         DC8B            call	_get_SS
09414                                           ! Debug: list unsigned short = ax+0 (used reg = )
09415 29C2           50                         push	ax
09416                                           ! Debug: func () void = write_byte+0 (used reg = )
09417 29C3           E8         DC54            call	_write_byte
09418 29C6           83C4                   06  add	sp,*6
09419                                           !BCC_EOS
09420                                           ! 1741           }
09421                                           ! 1742           write_byte(get_SS(),model+40,0x00);
09422                       000029C9            .209:
09423                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09424 29C9           8A86       FDE6            mov	al,-$21A[bp]
09425 29CD           40                         inc	ax
09426 29CE           8886       FDE6            mov	-$21A[bp],al
09427                       000029D2            .20A:
09428                                           ! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
09429 29D2           8A86       FDE6            mov	al,-$21A[bp]
09430 29D6           3C                     14  cmp	al,*$14
09431 29D8         0F82         FF7B            blo 	.20B
09432                       000029DC            .20C:
09433                       000029DC            .208:
09434                                           ! Debug: list int = const 0 (used reg = )
09435 29DC           31C0                       xor	ax,ax
09436 29DE           50                         push	ax
09437                                           ! Debug: list * unsigned char model = S+$248-$21E (used reg = )
09438 29DF           8D9E       FDE4            lea	bx,-$21C[bp]
09439 29E3           53                         push	bx
09440                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09441 29E4           E8         DC66            call	_get_SS
09442                                           ! Debug: list unsigned short = ax+0 (used reg = )
09443 29E7           50                         push	ax
09444                                           ! Debug: func () void = write_byte+0 (used reg = )
09445 29E8           E8         DC2F            call	_write_byte
09446 29EB           83C4                   06  add	sp,*6
09447                                           !BCC_EOS
09448                                           ! 1743           for(i=39;i>0;i--){
09449                                           ! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
09450 29EE           B0                     27  mov	al,*$27
09451 29F0           8886       FDE6            mov	-$21A[bp],al
09452                                           !BCC_EOS
09453                                           !BCC_EOS
09454 29F4           EB           46            jmp .20F
09455                       000029F6            .210:
09456                                           ! 1744             if(read_byte(get_SS(),model+i)==0x20)
09457                                           ! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
09458 29F6           8A86       FDE6            mov	al,-$21A[bp]
09459 29FA           30E4                       xor	ah,ah
09460 29FC           89EB                       mov	bx,bp
09461 29FE           01C3                       add	bx,ax
09462                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09463                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09464 2A00           81C3                 FDBC  add	bx,#-$244
09465 2A04           53                         push	bx
09466                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09467 2A05           E8         DC45            call	_get_SS
09468                                           ! Debug: list unsigned short = ax+0 (used reg = )
09469 2A08           50                         push	ax
09470                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09471 2A09           E8         DBE8            call	_read_byte
09472 2A0C           83C4                   04  add	sp,*4
09473                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
09474 2A0F           3C                     20  cmp	al,*$20
09475 2A11           75           1E            jne 	.211
09476                       00002A13            .212:
09477                                           ! 1745               write_byte(get_SS(),model+i,0x00);
09478                                           ! Debug: list int = const 0 (used reg = )
09479 2A13           31C0                       xor	ax,ax
09480 2A15           50                         push	ax
09481                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09482 2A16           8A86       FDE6            mov	al,-$21A[bp]
09483 2A1A           30E4                       xor	ah,ah
09484 2A1C           89EB                       mov	bx,bp
09485 2A1E           01C3                       add	bx,ax
09486                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09487                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09488 2A20           81C3                 FDBC  add	bx,#-$244
09489 2A24           53                         push	bx
09490                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09491 2A25           E8         DC25            call	_get_SS
09492                                           ! Debug: list unsigned short = ax+0 (used reg = )
09493 2A28           50                         push	ax
09494                                           ! Debug: func () void = write_byte+0 (used reg = )
09495 2A29           E8         DBEE            call	_write_byte
09496 2A2C           83C4                   06  add	sp,*6
09497                                           !BCC_EOS
09498                                           ! 1746             else break;
09499 2A2F           EB           02            jmp .213
09500                       00002A31            .211:
09501 2A31           EB           11            jmp .20D
09502                                           !BCC_EOS
09503                                           ! 1747           }
09504                       00002A33            .213:
09505                                           ! 1748           if (i>36) {
09506                       00002A33            .20E:
09507                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09508 2A33           8A86       FDE6            mov	al,-$21A[bp]
09509 2A37           48                         dec	ax
09510 2A38           8886       FDE6            mov	-$21A[bp],al
09511                       00002A3C            .20F:
09512                                           ! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09513 2A3C           8A86       FDE6            mov	al,-$21A[bp]
09514 2A40           84C0                       test	al,al
09515 2A42           75           B2            jne	.210
09516                       00002A44            .214:
09517                       00002A44            .20D:
09518                                           ! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
09519 2A44           8A86       FDE6            mov	al,-$21A[bp]
09520 2A48           3C                     24  cmp	al,*$24
09521 2A4A           76           48            jbe 	.215
09522                       00002A4C            .216:
09523                                           ! 1749             write_byte(get_SS(),model+36,0x00);
09524                                           ! Debug: list int = const 0 (used reg = )
09525 2A4C           31C0                       xor	ax,ax
09526 2A4E           50                         push	ax
09527                                           ! Debug: list * unsigned char model = S+$248-$222 (used reg = )
09528 2A4F           8D9E       FDE0            lea	bx,-$220[bp]
09529 2A53           53                         push	bx
09530                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09531 2A54           E8         DBF6            call	_get_SS
09532                                           ! Debug: list unsigned short = ax+0 (used reg = )
09533 2A57           50                         push	ax
09534                                           ! Debug: func () void = write_byte+0 (used reg = )
09535 2A58           E8         DBBF            call	_write_byte
09536 2A5B           83C4                   06  add	sp,*6
09537                                           !BCC_EOS
09538                                           ! 1750             for(i=35;i>32;i--){
09539                                           ! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
09540 2A5E           B0                     23  mov	al,*$23
09541 2A60           8886       FDE6            mov	-$21A[bp],al
09542                                           !BCC_EOS
09543                                           !BCC_EOS
09544 2A64           EB           26            jmp .219
09545                       00002A66            .21A:
09546                                           ! 1751               write_byte(get_SS(),model+i,0x2E);
09547                                           ! Debug: list int = const $2E (used reg = )
09548 2A66           B8                   002E  mov	ax,*$2E
09549 2A69           50                         push	ax
09550                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09551 2A6A           8A86       FDE6            mov	al,-$21A[bp]
09552 2A6E           30E4                       xor	ah,ah
09553 2A70           89EB                       mov	bx,bp
09554 2A72           01C3                       add	bx,ax
09555                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09556                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09557 2A74           81C3                 FDBC  add	bx,#-$244
09558 2A78           53                         push	bx
09559                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09560 2A79           E8         DBD1            call	_get_SS
09561                                           ! Debug: list unsigned short = ax+0 (used reg = )
09562 2A7C           50                         push	ax
09563                                           ! Debug: func () void = write_byte+0 (used reg = )
09564 2A7D           E8         DB9A            call	_write_byte
09565 2A80           83C4                   06  add	sp,*6
09566                                           !BCC_EOS
09567                                           ! 1752             }
09568                                           ! 1753           }
09569                       00002A83            .218:
09570                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09571 2A83           8A86       FDE6            mov	al,-$21A[bp]
09572 2A87           48                         dec	ax
09573 2A88           8886       FDE6            mov	-$21A[bp],al
09574                       00002A8C            .219:
09575                                           ! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
09576 2A8C           8A86       FDE6            mov	al,-$21A[bp]
09577 2A90           3C                     20  cmp	al,*$20
09578 2A92           77           D2            ja 	.21A
09579                       00002A94            .21B:
09580                       00002A94            .217:
09581                                           ! 1754           break;
09582                       00002A94            .215:
09583 2A94           EB           0E            jmp .1FC
09584                                           !BCC_EOS
09585                                           ! 1755         }
09586                                           ! 1756  
09587                                           ! 1756      switch (type) {
09588 2A96           EB           0C            jmp .1FC
09589                       00002A98            .1FE:
09590 2A98           2C                     02  sub	al,*2
09591 2A9A         0F84         FDEE            beq 	.1FF
09592 2A9E           2C                     01  sub	al,*1
09593 2AA0         0F84         FE49            beq 	.200
09594                       00002AA4            .1FC:
09595                       FFFFFDBA            ..FFFC	=	-$246
09596 2AA4           8A46         FA            mov	al,-6[bp]
09597 2AA7           E9         00C9            br 	.21E
09598                                           ! 1757         case 0x02:
09599                                           ! 1758           bios_printf(2, "XS Virtual IDE Controller      Hard Drive");
09600                       00002AAA            .21F:
09601                                           ! Debug: list * char = .220+0 (used reg = )
09602 2AAA           BB                   D3D9  mov	bx,#.220
09603 2AAD           53                         push	bx
09604                                           ! Debug: list int = const 2 (used reg = )
09605 2AAE           B8                   0002  mov	ax,*2
09606 2AB1           50                         push	ax
09607                                           ! Debug: func () void = bios_printf+0 (used reg = )
09608 2AB2           E8         DF66            call	_bios_printf
09609 2AB5           83C4                   04  add	sp,*4
09610                                           !BCC_EOS
09611                                           ! 1759    if (sizeinmb < (1UL<<16))
09612                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09613 2AB8           31C0                       xor	ax,ax
09614 2ABA           BB                   0001  mov	bx,*1
09615 2ABD           8DBE       FDEA            lea	di,-$216[bp]
09616 2AC1           E8         D607            call	lcmpul
09617 2AC4           76           18            jbe 	.221
09618                       00002AC6            .222:
09619                                           ! 1760             bios_printf(2, " (%uMB)\n", sizeinmb);
09620                                           ! Debug: list unsigned long sizeinmb = [S+$246-$218] (used reg = )
09621 2AC6           FFB6       FDEC            push	-$214[bp]
09622 2ACA           FFB6       FDEA            push	-$216[bp]
09623                                           ! Debug: list * char = .223+0 (used reg = )
09624 2ACE           BB                   D3D0  mov	bx,#.223
09625 2AD1           53                         push	bx
09626                                           ! Debug: list int = const 2 (used reg = )
09627 2AD2           B8                   0002  mov	ax,*2
09628 2AD5           50                         push	ax
09629                                           ! Debug: func () void = bios_printf+0 (used reg = )
09630 2AD6           E8         DF42            call	_bios_printf
09631 2AD9           83C4                   08  add	sp,*8
09632                                           !BCC_EOS
09633                                           ! 1761    else
09634                                           ! 1762             bios_printf(2, " (%uGB)\n", sizeinmb>>10);
09635 2ADC           EB           26            jmp .224
09636                       00002ADE            .221:
09637                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09638 2ADE           8B86       FDEA            mov	ax,-$216[bp]
09639 2AE2           8B9E       FDEC            mov	bx,-$214[bp]
09640 2AE6           88E0                       mov	al,ah
09641 2AE8           88DC                       mov	ah,bl
09642 2AEA           88FB                       mov	bl,bh
09643 2AEC           28FF                       sub	bh,bh
09644 2AEE           BF                   0002  mov	di,*2
09645 2AF1           E8         D635            call	lsrul
09646                                           ! Debug: list unsigned long = bx+0 (used reg = )
09647 2AF4           53                         push	bx
09648 2AF5           50                         push	ax
09649                                           ! Debug: list * char = .225+0 (used reg = )
09650 2AF6           BB                   D3C7  mov	bx,#.225
09651 2AF9           53                         push	bx
09652                                           ! Debug: list int = const 2 (used reg = )
09653 2AFA           B8                   0002  mov	ax,*2
09654 2AFD           50                         push	ax
09655                                           ! Debug: func () void = bios_printf+0 (used reg = )
09656 2AFE           E8         DF1A            call	_bios_printf
09657 2B01           83C4                   08  add	sp,*8
09658                                           !BCC_EOS
09659                                           ! 1763           break;
09660                       00002B04            .224:
09661 2B04           E9         007A            br 	.21C
09662                                           !BCC_EOS
09663                                           ! 1764         case 0x03:
09664                                           ! 1765           bios_printf(2, "XS Virtual ATAPI-");
09665                       00002B07            .226:
09666                                           ! Debug: list * char = .227+0 (used reg = )
09667 2B07           BB                   D3B5  mov	bx,#.227
09668 2B0A           53                         push	bx
09669                                           ! Debug: list int = const 2 (used reg = )
09670 2B0B           B8                   0002  mov	ax,*2
09671 2B0E           50                         push	ax
09672                                           ! Debug: func () void = bios_printf+0 (used reg = )
09673 2B0F           E8         DF09            call	_bios_printf
09674 2B12           83C4                   04  add	sp,*4
09675                                           !BCC_EOS
09676                                           ! 1766           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
09677                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09678 2B15           8A46         FB            mov	al,-5[bp]
09679 2B18           30E4                       xor	ah,ah
09680 2B1A           B9                   001E  mov	cx,*$1E
09681 2B1D           F7E9                       imul	cx
09682 2B1F           89C3                       mov	bx,ax
09683                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09684                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09685 2B21           81C3                 0143  add	bx,#$143
09686 2B25           53                         push	bx
09687                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09688 2B26           FF76         FE            push	-2[bp]
09689                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09690 2B29           E8         DAC8            call	_read_byte
09691 2B2C           83C4                   04  add	sp,*4
09692                                           ! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
09693 2B2F           3C                     05  cmp	al,*5
09694 2B31           75           17            jne 	.228
09695                       00002B33            .229:
09696                                           ! 1767             bios_printf(2, "%d             CD-Rom/DVD-Rom\n",version);
09697                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09698 2B33           8A86       FDE5            mov	al,-$21B[bp]
09699 2B37           30E4                       xor	ah,ah
09700 2B39           50                         push	ax
09701                                           ! Debug: list * char = .22A+0 (used reg = )
09702 2B3A           BB                   D396  mov	bx,#.22A
09703 2B3D           53                         push	bx
09704                                           ! Debug: list int = const 2 (used reg = )
09705 2B3E           B8                   0002  mov	ax,*2
09706 2B41           50                         push	ax
09707                                           ! Debug: func () void = bios_printf+0 (used reg = )
09708 2B42           E8         DED6            call	_bios_printf
09709 2B45           83C4                   06  add	sp,*6
09710                                           !BCC_EOS
09711                                           ! 1768           else
09712                                           ! 1769             bios_printf(2, "%d             Device\n",version);
09713 2B48           EB           15            jmp .22B
09714                       00002B4A            .228:
09715                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09716 2B4A           8A86       FDE5            mov	al,-$21B[bp]
09717 2B4E           30E4                       xor	ah,ah
09718 2B50           50                         push	ax
09719                                           ! Debug: list * char = .22C+0 (used reg = )
09720 2B51           BB                   D37F  mov	bx,#.22C
09721 2B54           53                         push	bx
09722                                           ! Debug: list int = const 2 (used reg = )
09723 2B55           B8                   0002  mov	ax,*2
09724 2B58           50                         push	ax
09725                                           ! Debug: func () void = bios_printf+0 (used reg = )
09726 2B59           E8         DEBF            call	_bios_printf
09727 2B5C           83C4                   06  add	sp,*6
09728                                           !BCC_EOS
09729                                           ! 1770           break;
09730                       00002B5F            .22B:
09731 2B5F           EB           20            jmp .21C
09732                                           !BCC_EOS
09733                                           ! 1771         case 0x01:
09734                                           ! 1772           bios_printf(2, "Unknown device\n");
09735                       00002B61            .22D:
09736                                           ! Debug: list * char = .22E+0 (used reg = )
09737 2B61           BB                   D36F  mov	bx,#.22E
09738 2B64           53                         push	bx
09739                                           ! Debug: list int = const 2 (used reg = )
09740 2B65           B8                   0002  mov	ax,*2
09741 2B68           50                         push	ax
09742                                           ! Debug: func () void = bios_printf+0 (used reg = )
09743 2B69           E8         DEAF            call	_bios_printf
09744 2B6C           83C4                   04  add	sp,*4
09745                                           !BCC_EOS
09746                                           ! 1773           break;
09747 2B6F           EB           10            jmp .21C
09748                                           !BCC_EOS
09749                                           ! 1774         }
09750                                           ! 1775       }
09751 2B71           EB           0E            jmp .21C
09752                       00002B73            .21E:
09753 2B73           2C                     01  sub	al,*1
09754 2B75           74           EA            je 	.22D
09755 2B77           2C                     01  sub	al,*1
09756 2B79         0F84         FF2D            beq 	.21F
09757 2B7D           2C                     01  sub	al,*1
09758 2B7F           74           86            je 	.226
09759                       00002B81            .21C:
09760                       FFFFFDBA            ..FFFB	=	-$246
09761 2B81           83C4                   32  add	sp,*$32
09762                                           ! 1776     }
09763 2B84           83C4                   0C  add	sp,*$C
09764                                           ! 1777   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
09765                       00002B87            .19D:
09766                                           ! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
09767 2B87           8A46         FB            mov	al,-5[bp]
09768 2B8A           40                         inc	ax
09769 2B8B           8846         FB            mov	-5[bp],al
09770                       00002B8E            .19E:
09771                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
09772 2B8E           8A46         FB            mov	al,-5[bp]
09773 2B91           3C                     08  cmp	al,*8
09774 2B93         0F82         F39A            blo 	.19F
09775                       00002B97            .22F:
09776                       00002B97            .19C:
09777                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09778 2B97           8A46         FD            mov	al,-3[bp]
09779 2B9A           30E4                       xor	ah,ah
09780 2B9C           50                         push	ax
09781                                           ! Debug: list * unsigned char = const $232 (used reg = )
09782 2B9D           B8                   0232  mov	ax,#$232
09783 2BA0           50                         push	ax
09784                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09785 2BA1           FF76         FE            push	-2[bp]
09786                                           ! Debug: func () void = write_byte+0 (used reg = )
09787 2BA4           E8         DA73            call	_write_byte
09788 2BA7           83C4                   06  add	sp,*6
09789                                           !BCC_EOS
09790                                           ! 1778   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
09791                                           ! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
09792 2BAA           8A46         FC            mov	al,-4[bp]
09793 2BAD           30E4                       xor	ah,ah
09794 2BAF           50                         push	ax
09795                                           ! Debug: list * unsigned char = const $23B (used reg = )
09796 2BB0           B8                   023B  mov	ax,#$23B
09797 2BB3           50                         push	ax
09798                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09799 2BB4           FF76         FE            push	-2[bp]
09800                                           ! Debug: func () void = write_byte+0 (used reg = )
09801 2BB7           E8         DA60            call	_write_byte
09802 2BBA           83C4                   06  add	sp,*6
09803                                           !BCC_EOS
09804                                           ! 1779   write_byte(0x40,0x75, hdcount);
09805                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09806 2BBD           8A46         FD            mov	al,-3[bp]
09807 2BC0           30E4                       xor	ah,ah
09808 2BC2           50                         push	ax
09809                                           ! Debug: list int = const $75 (used reg = )
09810 2BC3           B8                   0075  mov	ax,*$75
09811 2BC6           50                         push	ax
09812                                           ! Debug: list int = const $40 (used reg = )
09813 2BC7           B8                   0040  mov	ax,*$40
09814 2BCA           50                         push	ax
09815                                           ! Debug: func () void = write_byte+0 (used reg = )
09816 2BCB           E8         DA4C            call	_write_byte
09817 2BCE           83C4                   06  add	sp,*6
09818                                           !BCC_EOS
09819                                           ! 1780   bios_printf(2, "\n");
09820                                           ! Debug: list * char = .230+0 (used reg = )
09821 2BD1           BB                   D36D  mov	bx,#.230
09822 2BD4           53                         push	bx
09823                                           ! Debug: list int = const 2 (used reg = )
09824 2BD5           B8                   0002  mov	ax,*2
09825 2BD8           50                         push	ax
09826                                           ! Debug: func () void = bios_printf+0 (used reg = )
09827 2BD9           E8         DE3F            call	_bios_printf
09828 2BDC           83C4                   04  add	sp,*4
09829                                           !BCC_EOS
09830                                           ! 1781 }
09831 2BDF           89EC                       mov	sp,bp
09832 2BE1           5D                         pop	bp
09833 2BE2           C3                         ret
09834                                           ! 1782 void ata_reset(device)
09835                                           ! Register BX used in function ata_detect
09836                                           ! 1783 Bit16u device;
09837                                           export	_ata_reset
09838                       00002BE3            _ata_reset:
09839                                           !BCC_EOS
09840                                           ! 1784 {
09841                                           ! 1785   Bit16u ebda_seg=read_word(0x0040,0x000E);
09842 2BE3           55                         push	bp
09843 2BE4           89E5                       mov	bp,sp
09844 2BE6           4C                         dec	sp
09845 2BE7           4C                         dec	sp
09846                                           ! Debug: list int = const $E (used reg = )
09847 2BE8           B8                   000E  mov	ax,*$E
09848 2BEB           50                         push	ax
09849                                           ! Debug: list int = const $40 (used reg = )
09850 2BEC           B8                   0040  mov	ax,*$40
09851 2BEF           50                         push	ax
09852                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09853 2BF0           E8         DA14            call	_read_word
09854 2BF3           83C4                   04  add	sp,*4
09855                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
09856 2BF6           8946         FE            mov	-2[bp],ax
09857                                           !BCC_EOS
09858                                           ! 1786   Bit16u iobase1, iobase2;
09859                                           !BCC_EOS
09860                                           ! 1787   Bit8u channel, slave, sn, sc;
09861                                           !BCC_EOS
09862                                           ! 1788   Bit8u type;
09863                                           !BCC_EOS
09864                                           ! 1789   Bit16u max;
09865                                           !BCC_EOS
09866                                           ! 1790   channel = device / 2;
09867 2BF9           83C4                   F4  add	sp,*-$C
09868                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09869 2BFC           8B46         04            mov	ax,4[bp]
09870 2BFF           D1E8                       shr	ax,*1
09871                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
09872 2C01           8846         F9            mov	-7[bp],al
09873                                           !BCC_EOS
09874                                           ! 1791   slave = device % 2;
09875                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09876 2C04           8B46         04            mov	ax,4[bp]
09877 2C07           24                     01  and	al,*1
09878                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
09879 2C09           8846         F8            mov	-8[bp],al
09880                                           !BCC_EOS
09881                                           ! 1792   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
09882                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
09883 2C0C           8A46         F9            mov	al,-7[bp]
09884 2C0F           30E4                       xor	ah,ah
09885 2C11           B1                     03  mov	cl,*3
09886 2C13           D3E0                       shl	ax,cl
09887 2C15           89C3                       mov	bx,ax
09888                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09889                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
09890 2C17           81C3                 0124  add	bx,#$124
09891 2C1B           53                         push	bx
09892                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09893 2C1C           FF76         FE            push	-2[bp]
09894                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09895 2C1F           E8         D9E5            call	_read_word
09896 2C22           83C4                   04  add	sp,*4
09897                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
09898 2C25           8946         FC            mov	-4[bp],ax
09899                                           !BCC_EOS
09900                                           ! 1793   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
09901                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
09902 2C28           8A46         F9            mov	al,-7[bp]
09903 2C2B           30E4                       xor	ah,ah
09904 2C2D           B1                     03  mov	cl,*3
09905 2C2F           D3E0                       shl	ax,cl
09906 2C31           89C3                       mov	bx,ax
09907                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09908                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
09909 2C33           81C3                 0126  add	bx,#$126
09910 2C37           53                         push	bx
09911                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09912 2C38           FF76         FE            push	-2[bp]
09913                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09914 2C3B           E8         D9C9            call	_read_word
09915 2C3E           83C4                   04  add	sp,*4
09916                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
09917 2C41           8946         FA            mov	-6[bp],ax
09918                                           !BCC_EOS
09919                                           ! 1794   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09920                                           ! Debug: list int = const $E (used reg = )
09921 2C44           B8                   000E  mov	ax,*$E
09922 2C47           50                         push	ax
09923                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
09924 2C48           8B46         FA            mov	ax,-6[bp]
09925                                           ! Debug: list unsigned int = ax+6 (used reg = )
09926 2C4B           05                   0006  add	ax,*6
09927 2C4E           50                         push	ax
09928                                           ! Debug: func () void = outb+0 (used reg = )
09929 2C4F           E8         D902            call	_outb
09930 2C52           83C4                   04  add	sp,*4
09931                                           !BCC_EOS
09932                                           ! 1795   outb(0x80, 0x00);
09933                                           ! Debug: list int = const 0 (used reg = )
09934 2C55           31C0                       xor	ax,ax
09935 2C57           50                         push	ax
09936                                           ! Debug: list int = const $80 (used reg = )
09937 2C58           B8                   0080  mov	ax,#$80
09938 2C5B           50                         push	ax
09939                                           ! Debug: func () void = outb+0 (used reg = )
09940 2C5C           E8         D8F5            call	_outb
09941 2C5F           83C4                   04  add	sp,*4
09942                                           !BCC_EOS
09943                                           ! 1796   outb(iobase2+6, 0x08 | 0x02);
09944                                           ! Debug: list int = const $A (used reg = )
09945 2C62           B8                   000A  mov	ax,*$A
09946 2C65           50                         push	ax
09947                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
09948 2C66           8B46         FA            mov	ax,-6[bp]
09949                                           ! Debug: list unsigned int = ax+6 (used reg = )
09950 2C69           05                   0006  add	ax,*6
09951 2C6C           50                         push	ax
09952                                           ! Debug: func () void = outb+0 (used reg = )
09953 2C6D           E8         D8E4            call	_outb
09954 2C70           83C4                   04  add	sp,*4
09955                                           !BCC_EOS
09956                                           ! 1797   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
09957                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
09958 2C73           8B46         04            mov	ax,4[bp]
09959 2C76           B9                   001E  mov	cx,*$1E
09960 2C79           F7E9                       imul	cx
09961 2C7B           89C3                       mov	bx,ax
09962                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
09963                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
09964 2C7D           81C3                 0142  add	bx,#$142
09965 2C81           53                         push	bx
09966                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09967 2C82           FF76         FE            push	-2[bp]
09968                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09969 2C85           E8         D96C            call	_read_byte
09970 2C88           83C4                   04  add	sp,*4
09971                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
09972 2C8B           8846         F5            mov	-$B[bp],al
09973                                           !BCC_EOS
09974                                           ! 1798   if (type != 0x00) {
09975                                           ! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
09976 2C8E           8A46         F5            mov	al,-$B[bp]
09977 2C91           84C0                       test	al,al
09978 2C93         0F84         0084            beq 	.231
09979                       00002C97            .232:
09980                                           ! 1799     outb(iobase1+6, slave?0xb0:0xa0);
09981 2C97           8A46         F8            mov	al,-8[bp]
09982 2C9A           84C0                       test	al,al
09983 2C9C           74           04            je  	.233
09984                       00002C9E            .234:
09985 2C9E           B0                     B0  mov	al,#$B0
09986 2CA0           EB           02            jmp .235
09987                       00002CA2            .233:
09988 2CA2           B0                     A0  mov	al,#$A0
09989                       00002CA4            .235:
09990                                           ! Debug: list char = al+0 (used reg = )
09991 2CA4           30E4                       xor	ah,ah
09992 2CA6           50                         push	ax
09993                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
09994 2CA7           8B46         FC            mov	ax,-4[bp]
09995                                           ! Debug: list unsigned int = ax+6 (used reg = )
09996 2CAA           05                   0006  add	ax,*6
09997 2CAD           50                         push	ax
09998                                           ! Debug: func () void = outb+0 (used reg = )
09999 2CAE           E8         D8A3            call	_outb
10000 2CB1           83C4                   04  add	sp,*4
10001                                           !BCC_EOS
10002                                           ! 1800     sc = inb(iobase1+2);
10003                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
10004 2CB4           8B46         FC            mov	ax,-4[bp]
10005                                           ! Debug: list unsigned int = ax+2 (used reg = )
10006 2CB7           40                         inc	ax
10007 2CB8           40                         inc	ax
10008 2CB9           50                         push	ax
10009                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10010 2CBA           E8         D881            call	_inb
10011 2CBD           44                         inc	sp
10012 2CBE           44                         inc	sp
10013                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
10014 2CBF           8846         F6            mov	-$A[bp],al
10015                                           !BCC_EOS
10016                                           ! 1801     sn = inb(iobase1+3);
10017                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
10018 2CC2           8B46         FC            mov	ax,-4[bp]
10019                                           ! Debug: list unsigned int = ax+3 (used reg = )
10020 2CC5           05                   0003  add	ax,*3
10021 2CC8           50                         push	ax
10022                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10023 2CC9           E8         D872            call	_inb
10024 2CCC           44                         inc	sp
10025 2CCD           44                         inc	sp
10026                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
10027 2CCE           8846         F7            mov	-9[bp],al
10028                                           !BCC_EOS
10029                                           ! 1802     if ( (sc==0x01) && (sn==0x01) ) {
10030                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
10031 2CD1           8A46         F6            mov	al,-$A[bp]
10032 2CD4           3C                     01  cmp	al,*1
10033 2CD6           75           32            jne 	.236
10034                       00002CD8            .238:
10035                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
10036 2CD8           8A46         F7            mov	al,-9[bp]
10037 2CDB           3C                     01  cmp	al,*1
10038 2CDD           75           2B            jne 	.236
10039                       00002CDF            .237:
10040                                           ! 1803       if (type == 0x02)
10041                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
10042 2CDF           8A46         F5            mov	al,-$B[bp]
10043 2CE2           3C                     02  cmp	al,*2
10044 2CE4           75           13            jne 	.239
10045                       00002CE6            .23A:
10046                                           ! 1804         await_ide(5, iobase1, 32000u);
10047                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10048 2CE6           B8                   7D00  mov	ax,#$7D00
10049 2CE9           50                         push	ax
10050                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10051 2CEA           FF76         FC            push	-4[bp]
10052                                           ! Debug: list int = const 5 (used reg = )
10053 2CED           B8                   0005  mov	ax,*5
10054 2CF0           50                         push	ax
10055                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10056 2CF1           E8         EFB0            call	_await_ide
10057 2CF4           83C4                   06  add	sp,*6
10058                                           !BCC_EOS
10059                                           ! 1805       else
10060                                           ! 1806         await_ide(2, iobase1, 32000u);
10061 2CF7           EB           11            jmp .23B
10062                       00002CF9            .239:
10063                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10064 2CF9           B8                   7D00  mov	ax,#$7D00
10065 2CFC           50                         push	ax
10066                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10067 2CFD           FF76         FC            push	-4[bp]
10068                                           ! Debug: list int = const 2 (used reg = )
10069 2D00           B8                   0002  mov	ax,*2
10070 2D03           50                         push	ax
10071                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10072 2D04           E8         EF9D            call	_await_ide
10073 2D07           83C4                   06  add	sp,*6
10074                                           !BCC_EOS
10075                                           ! 1807     }
10076                       00002D0A            .23B:
10077                                           ! 1808     await_ide(2, iobase1, 32000u);
10078                       00002D0A            .236:
10079                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10080 2D0A           B8                   7D00  mov	ax,#$7D00
10081 2D0D           50                         push	ax
10082                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10083 2D0E           FF76         FC            push	-4[bp]
10084                                           ! Debug: list int = const 2 (used reg = )
10085 2D11           B8                   0002  mov	ax,*2
10086 2D14           50                         push	ax
10087                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10088 2D15           E8         EF8C            call	_await_ide
10089 2D18           83C4                   06  add	sp,*6
10090                                           !BCC_EOS
10091                                           ! 1809   }
10092                                           ! 1810   outb(iobase2+6, 0x08);
10093                       00002D1B            .231:
10094                                           ! Debug: list int = const 8 (used reg = )
10095 2D1B           B8                   0008  mov	ax,*8
10096 2D1E           50                         push	ax
10097                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10098 2D1F           8B46         FA            mov	ax,-6[bp]
10099                                           ! Debug: list unsigned int = ax+6 (used reg = )
10100 2D22           05                   0006  add	ax,*6
10101 2D25           50                         push	ax
10102                                           ! Debug: func () void = outb+0 (used reg = )
10103 2D26           E8         D82B            call	_outb
10104 2D29           83C4                   04  add	sp,*4
10105                                           !BCC_EOS
10106                                           ! 1811 }
10107 2D2C           89EC                       mov	sp,bp
10108 2D2E           5D                         pop	bp
10109 2D2F           C3                         ret
10110                                           ! 1812 Bit16u ata_cmd_non_data()
10111                                           ! Register BX used in function ata_reset
10112                                           ! 1813 {return 0;}
10113                                           export	_ata_cmd_non_data
10114                       00002D30            _ata_cmd_non_data:
10115 2D30           55                         push	bp
10116 2D31           89E5                       mov	bp,sp
10117 2D33           31C0                       xor	ax,ax
10118 2D35           5D                         pop	bp
10119 2D36           C3                         ret
10120                                           !BCC_EOS
10121                                           ! 1814 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
10122                                           ! 1815 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10123                                           export	_ata_cmd_data_in
10124                       00002D37            _ata_cmd_data_in:
10125                                           !BCC_EOS
10126                                           ! 1816 Bit32u lba_low, lba_high;
10127                                           !BCC_EOS
10128                                           ! 1817 {
10129                                           ! 1818   Bit16u ebda_seg=read_
10130                                           ! 1818 word(0x0040,0x000E);
10131 2D37           55                         push	bp
10132 2D38           89E5                       mov	bp,sp
10133 2D3A           4C                         dec	sp
10134 2D3B           4C                         dec	sp
10135                                           ! Debug: list int = const $E (used reg = )
10136 2D3C           B8                   000E  mov	ax,*$E
10137 2D3F           50                         push	ax
10138                                           ! Debug: list int = const $40 (used reg = )
10139 2D40           B8                   0040  mov	ax,*$40
10140 2D43           50                         push	ax
10141                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10142 2D44           E8         D8C0            call	_read_word
10143 2D47           83C4                   04  add	sp,*4
10144                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10145 2D4A           8946         FE            mov	-2[bp],ax
10146                                           !BCC_EOS
10147                                           ! 1819   Bit16u iobase1, iobase2, blksize;
10148                                           !BCC_EOS
10149                                           ! 1820   Bit8u channel, slave;
10150                                           !BCC_EOS
10151                                           ! 1821   Bit8u status, current, mode;
10152                                           !BCC_EOS
10153                                           ! 1822   channel = device / 2;
10154 2D4D           83C4                   F4  add	sp,*-$C
10155                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10156 2D50           8B46         04            mov	ax,4[bp]
10157 2D53           D1E8                       shr	ax,*1
10158                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10159 2D55           8846         F7            mov	-9[bp],al
10160                                           !BCC_EOS
10161                                           ! 1823   slave = device % 2;
10162                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10163 2D58           8B46         04            mov	ax,4[bp]
10164 2D5B           24                     01  and	al,*1
10165                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
10166 2D5D           8846         F6            mov	-$A[bp],al
10167                                           !BCC_EOS
10168                                           ! 1824   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10169                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10170 2D60           8A46         F7            mov	al,-9[bp]
10171 2D63           30E4                       xor	ah,ah
10172 2D65           B1                     03  mov	cl,*3
10173 2D67           D3E0                       shl	ax,cl
10174 2D69           89C3                       mov	bx,ax
10175                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10176                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10177 2D6B           81C3                 0124  add	bx,#$124
10178 2D6F           53                         push	bx
10179                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10180 2D70           FF76         FE            push	-2[bp]
10181                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10182 2D73           E8         D891            call	_read_word
10183 2D76           83C4                   04  add	sp,*4
10184                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10185 2D79           8946         FC            mov	-4[bp],ax
10186                                           !BCC_EOS
10187                                           ! 1825   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10188                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10189 2D7C           8A46         F7            mov	al,-9[bp]
10190 2D7F           30E4                       xor	ah,ah
10191 2D81           B1                     03  mov	cl,*3
10192 2D83           D3E0                       shl	ax,cl
10193 2D85           89C3                       mov	bx,ax
10194                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10195                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10196 2D87           81C3                 0126  add	bx,#$126
10197 2D8B           53                         push	bx
10198                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10199 2D8C           FF76         FE            push	-2[bp]
10200                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10201 2D8F           E8         D875            call	_read_word
10202 2D92           83C4                   04  add	sp,*4
10203                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10204 2D95           8946         FA            mov	-6[bp],ax
10205                                           !BCC_EOS
10206                                           ! 1826   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
10207                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10208 2D98           8B46         04            mov	ax,4[bp]
10209 2D9B           B9                   001E  mov	cx,*$1E
10210 2D9E           F7E9                       imul	cx
10211 2DA0           89C3                       mov	bx,ax
10212                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10213                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
10214 2DA2           81C3                 0146  add	bx,#$146
10215 2DA6           53                         push	bx
10216                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10217 2DA7           FF76         FE            push	-2[bp]
10218                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10219 2DAA           E8         D847            call	_read_byte
10220 2DAD           83C4                   04  add	sp,*4
10221                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
10222 2DB0           8846         F3            mov	-$D[bp],al
10223                                           !BCC_EOS
10224                                           ! 1827   blksize = 0x200;
10225                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
10226 2DB3           B8                   0200  mov	ax,#$200
10227 2DB6           8946         F8            mov	-8[bp],ax
10228                                           !BCC_EOS
10229                                           ! 1828   if (mode == 0x01) blksize>>=2;
10230                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
10231 2DB9           8A46         F3            mov	al,-$D[bp]
10232 2DBC           3C                     01  cmp	al,*1
10233 2DBE           75           0C            jne 	.23C
10234                       00002DC0            .23D:
10235                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
10236 2DC0           8B46         F8            mov	ax,-8[bp]
10237 2DC3           D1E8                       shr	ax,*1
10238 2DC5           D1E8                       shr	ax,*1
10239 2DC7           8946         F8            mov	-8[bp],ax
10240                                           !BCC_EOS
10241                                           ! 1829   else blksize>>=1;
10242 2DCA           EB           08            jmp .23E
10243                       00002DCC            .23C:
10244                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
10245 2DCC           8B46         F8            mov	ax,-8[bp]
10246 2DCF           D1E8                       shr	ax,*1
10247 2DD1           8946         F8            mov	-8[bp],ax
10248                                           !BCC_EOS
10249                                           ! 1830   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
10250                       00002DD4            .23E:
10251                                           ! Debug: list int = const 0 (used reg = )
10252 2DD4           31C0                       xor	ax,ax
10253 2DD6           50                         push	ax
10254                                           ! Debug: list * unsigned short = const $254 (used reg = )
10255 2DD7           B8                   0254  mov	ax,#$254
10256 2DDA           50                         push	ax
10257                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10258 2DDB           FF76         FE            push	-2[bp]
10259                                           ! Debug: func () void = write_word+0 (used reg = )
10260 2DDE           E8         D851            call	_write_word
10261 2DE1           83C4                   06  add	sp,*6
10262                                           !BCC_EOS
10263                                           ! 1831   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
10264                                           ! Debug: list long = const 0 (used reg = )
10265 2DE4           31C0                       xor	ax,ax
10266 2DE6           31DB                       xor	bx,bx
10267 2DE8           53                         push	bx
10268 2DE9           50                         push	ax
10269                                           ! Debug: list * unsigned long = const $256 (used reg = )
10270 2DEA           B8                   0256  mov	ax,#$256
10271 2DED           50                         push	ax
10272                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
10273 2DEE           FF76         FE            push	-2[bp]
10274                                           ! Debug: func () void = write_dword+0 (used reg = )
10275 2DF1           E8         D2A7            call	_write_dword
10276 2DF4           83C4                   08  add	sp,*8
10277                                           !BCC_EOS
10278                                           ! 1832   current = 0;
10279                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
10280 2DF7           30C0                       xor	al,al
10281 2DF9           8846         F4            mov	-$C[bp],al
10282                                           !BCC_EOS
10283                                           ! 1833   status = inb(iobase1 + 7);
10284                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10285 2DFC           8B46         FC            mov	ax,-4[bp]
10286                                           ! Debug: list unsigned int = ax+7 (used reg = )
10287 2DFF           05                   0007  add	ax,*7
10288 2E02           50                         push	ax
10289                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10290 2E03           E8         D738            call	_inb
10291 2E06           44                         inc	sp
10292 2E07           44                         inc	sp
10293                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10294 2E08           8846         F5            mov	-$B[bp],al
10295                                           !BCC_EOS
10296                                           ! 1834   if (status & 0x80) return 1;
10297                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10298 2E0B           8A46         F5            mov	al,-$B[bp]
10299 2E0E           24                     80  and	al,#$80
10300 2E10           84C0                       test	al,al
10301 2E12           74           07            je  	.23F
10302                       00002E14            .240:
10303 2E14           B8                   0001  mov	ax,*1
10304 2E17           89EC                       mov	sp,bp
10305 2E19           5D                         pop	bp
10306 2E1A           C3                         ret
10307                                           !BCC_EOS
10308                                           ! 1835   outb(iobase2 + 6, 0x08 | 0x02);
10309                       00002E1B            .23F:
10310                                           ! Debug: list int = const $A (used reg = )
10311 2E1B           B8                   000A  mov	ax,*$A
10312 2E1E           50                         push	ax
10313                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10314 2E1F           8B46         FA            mov	ax,-6[bp]
10315                                           ! Debug: list unsigned int = ax+6 (used reg = )
10316 2E22           05                   0006  add	ax,*6
10317 2E25           50                         push	ax
10318                                           ! Debug: func () void = outb+0 (used reg = )
10319 2E26           E8         D72B            call	_outb
10320 2E29           83C4                   04  add	sp,*4
10321                                           !BCC_EOS
10322                                           ! 1836   if (sector == 0) {
10323                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
10324 2E2C           8B46         0E            mov	ax,$E[bp]
10325 2E2F           85C0                       test	ax,ax
10326 2E31         0F85         0167            bne 	.241
10327                       00002E35            .242:
10328                                           ! 1837     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
10329                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
10330 2E35           8B46         08            mov	ax,8[bp]
10331 2E38           3D                   0100  cmp	ax,#$100
10332 2E3B           72           04            jb 	.247
10333 2E3D           B0                     01  mov	al,*1
10334 2E3F           EB           02            jmp	.248
10335                       00002E41            .247:
10336 2E41           30C0                       xor	al,al
10337                       00002E43            .248:
10338                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
10339 2E43           30E4                       xor	ah,ah
10340 2E45           99                         cwd
10341 2E46           89D3                       mov	bx,dx
10342 2E48           E8         D2C9            call	ltstl
10343 2E4B           75           32            jne 	.244
10344                       00002E4D            .246:
10345 2E4D           8B46         14            mov	ax,$14[bp]
10346 2E50           8B5E         16            mov	bx,$16[bp]
10347 2E53           E8         D2BE            call	ltstl
10348 2E56           75           27            jne 	.244
10349                       00002E58            .245:
10350                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
10351 2E58           8B46         08            mov	ax,8[bp]
10352 2E5B           31DB                       xor	bx,bx
10353                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
10354                                           ! Debug: expression subtree swapping
10355 2E5D           8D7E         10            lea	di,$10[bp]
10356 2E60           E8         D260            call	laddul
10357                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
10358 2E63           53                         push	bx
10359 2E64           50                         push	ax
10360 2E65           31C0                       xor	ax,ax
10361 2E67           BB                   1000  mov	bx,#$1000
10362 2E6A           53                         push	bx
10363 2E6B           50                         push	ax
10364 2E6C           8B46         EE            mov	ax,-$12[bp]
10365 2E6F           8B5E         F0            mov	bx,-$10[bp]
10366 2E72           8D7E         EA            lea	di,-$16[bp]
10367 2E75           E8         D253            call	lcmpul
10368 2E78           8D66         F2            lea	sp,-$E[bp]
10369 2E7B         0F82         00BC            blo 	.243
10370                       00002E7F            .244:
10371                                           ! 1838       outb(iobase1 + 1, 0x00);
10372                                           ! Debug: list int = const 0 (used reg = )
10373 2E7F           31C0                       xor	ax,ax
10374 2E81           50                         push	ax
10375                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10376 2E82           8B46         FC            mov	ax,-4[bp]
10377                                           ! Debug: list unsigned int = ax+1 (used reg = )
10378 2E85           40                         inc	ax
10379 2E86           50                         push	ax
10380                                           ! Debug: func () void = outb+0 (used reg = )
10381 2E87           E8         D6CA            call	_outb
10382 2E8A           83C4                   04  add	sp,*4
10383                                           !BCC_EOS
10384                                           ! 1839       outb(iobase1 + 2, (count >> 8) & 0xff);
10385                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
10386 2E8D           8B46         08            mov	ax,8[bp]
10387 2E90           88E0                       mov	al,ah
10388 2E92           30E4                       xor	ah,ah
10389                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
10390                                           ! Debug: list unsigned char = al+0 (used reg = )
10391 2E94           30E4                       xor	ah,ah
10392 2E96           50                         push	ax
10393                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10394 2E97           8B46         FC            mov	ax,-4[bp]
10395                                           ! Debug: list unsigned int = ax+2 (used reg = )
10396 2E9A           40                         inc	ax
10397 2E9B           40                         inc	ax
10398 2E9C           50                         push	ax
10399                                           ! Debug: func () void = outb+0 (used reg = )
10400 2E9D           E8         D6B4            call	_outb
10401 2EA0           83C4                   04  add	sp,*4
10402                                           !BCC_EOS
10403                                           ! 1840       outb(iobase1 + 3, lba_low >> 24);
10404                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10405 2EA3           8B46         10            mov	ax,$10[bp]
10406 2EA6           8B5E         12            mov	bx,$12[bp]
10407 2EA9           93                         xchg	bx,ax
10408 2EAA           88E0                       mov	al,ah
10409 2EAC           30E4                       xor	ah,ah
10410 2EAE           31DB                       xor	bx,bx
10411                                           ! Debug: list unsigned long = bx+0 (used reg = )
10412 2EB0           53                         push	bx
10413 2EB1           50                         push	ax
10414                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
10415 2EB2           8B46         FC            mov	ax,-4[bp]
10416                                           ! Debug: list unsigned int = ax+3 (used reg = )
10417 2EB5           05                   0003  add	ax,*3
10418 2EB8           50                         push	ax
10419                                           ! Debug: func () void = outb+0 (used reg = )
10420 2EB9           E8         D698            call	_outb
10421 2EBC           83C4                   06  add	sp,*6
10422                                           !BCC_EOS
10423                                           ! 1841       outb(iobase1 + 4, lba_high & 0xff);
10424                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
10425                                           ! Debug: expression subtree swapping
10426 2EBF           B8                   00FF  mov	ax,#$FF
10427 2EC2           31DB                       xor	bx,bx
10428 2EC4           8D7E         14            lea	di,$14[bp]
10429 2EC7           E8         D1F1            call	landul
10430                                           ! Debug: list unsigned long = bx+0 (used reg = )
10431 2ECA           53                         push	bx
10432 2ECB           50                         push	ax
10433                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
10434 2ECC           8B46         FC            mov	ax,-4[bp]
10435                                           ! Debug: list unsigned int = ax+4 (used reg = )
10436 2ECF           05                   0004  add	ax,*4
10437 2ED2           50                         push	ax
10438                                           ! Debug: func () void = outb+0 (used reg = )
10439 2ED3           E8         D67E            call	_outb
10440 2ED6           83C4                   06  add	sp,*6
10441                                           !BCC_EOS
10442                                           ! 1842       outb(iobase1 + 5, lba_high >> 8);
10443                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
10444 2ED9           8B46         14            mov	ax,$14[bp]
10445 2EDC           8B5E         16            mov	bx,$16[bp]
10446 2EDF           88E0                       mov	al,ah
10447 2EE1           88DC                       mov	ah,bl
10448 2EE3           88FB                       mov	bl,bh
10449 2EE5           28FF                       sub	bh,bh
10450                                           ! Debug: list unsigned long = bx+0 (used reg = )
10451 2EE7           53                         push	bx
10452 2EE8           50                         push	ax
10453                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
10454 2EE9           8B46         FC            mov	ax,-4[bp]
10455                                           ! Debug: list unsigned int = ax+5 (used reg = )
10456 2EEC           05                   0005  add	ax,*5
10457 2EEF           50                         push	ax
10458                                           ! Debug: func () void = outb+0 (used reg = )
10459 2EF0           E8         D661            call	_outb
10460 2EF3           83C4                   06  add	sp,*6
10461                                           !BCC_EOS
10462                                           ! 1843       command |= 0x04;
10463                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
10464 2EF6           8B46         06            mov	ax,6[bp]
10465 2EF9           0C                     04  or	al,*4
10466 2EFB           8946         06            mov	6[bp],ax
10467                                           !BCC_EOS
10468                                           ! 1844       count &= (1UL << 8) - 1;
10469                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
10470 2EFE           8B46         08            mov	ax,8[bp]
10471 2F01           31DB                       xor	bx,bx
10472 2F03           53                         push	bx
10473 2F04           50                         push	ax
10474 2F05           B8                   00FF  mov	ax,#$FF
10475 2F08           31DB                       xor	bx,bx
10476 2F0A           53                         push	bx
10477 2F0B           50                         push	ax
10478 2F0C           8B46         EE            mov	ax,-$12[bp]
10479 2F0F           8B5E         F0            mov	bx,-$10[bp]
10480 2F12           8D7E         EA            lea	di,-$16[bp]
10481 2F15           E8         D1A3            call	landul
10482 2F18           8946         08            mov	8[bp],ax
10483 2F1B           83C4                   08  add	sp,*8
10484                                           !BCC_EOS
10485                                           ! 1845       lba_low &= (1UL << 24) - 1;
10486                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
10487 2F1E           B8                   FFFF  mov	ax,#$FFFF
10488 2F21           BB                   00FF  mov	bx,#$FF
10489 2F24           53                         push	bx
10490 2F25           50                         push	ax
10491 2F26           8B46         10            mov	ax,$10[bp]
10492 2F29           8B5E         12            mov	bx,$12[bp]
10493 2F2C           8D7E         EE            lea	di,-$12[bp]
10494 2F2F           E8         D189            call	landul
10495 2F32           8946         10            mov	$10[bp],ax
10496 2F35           895E         12            mov	$12[bp],bx
10497 2F38           83C4                   04  add	sp,*4
10498                                           !BCC_EOS
10499                                           ! 1846       }
10500                                           ! 1847     sector = (Bit16u) (lba_low & 0x000000ffL);
10501                       00002F3B            .243:
10502                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
10503                                           ! Debug: expression subtree swapping
10504 2F3B           B8                   00FF  mov	ax,#$FF
10505 2F3E           31DB                       xor	bx,bx
10506 2F40           8D7E         10            lea	di,$10[bp]
10507 2F43           E8         D175            call	landul
10508                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10509                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
10510 2F46           8946         0E            mov	$E[bp],ax
10511                                           !BCC_EOS
10512                                           ! 1848     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
10513                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
10514 2F49           8B46         10            mov	ax,$10[bp]
10515 2F4C           8B5E         12            mov	bx,$12[bp]
10516 2F4F           88E0                       mov	al,ah
10517 2F51           88DC                       mov	ah,bl
10518 2F53           88FB                       mov	bl,bh
10519 2F55           28FF                       sub	bh,bh
10520                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
10521 2F57           53                         push	bx
10522 2F58           50                         push	ax
10523 2F59           B8                   FFFF  mov	ax,#$FFFF
10524 2F5C           31DB                       xor	bx,bx
10525 2F5E           53                         push	bx
10526 2F5F           50                         push	ax
10527 2F60           8B46         EE            mov	ax,-$12[bp]
10528 2F63           8B5E         F0            mov	bx,-$10[bp]
10529 2F66           8D7E         EA            lea	di,-$16[bp]
10530 2F69           E8         D14F            call	landul
10531 2F6C           83C4                   08  add	sp,*8
10532                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10533                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
10534 2F6F           8946         0A            mov	$A[bp],ax
10535                                           !BCC_EOS
10536                                           ! 1849     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
10537                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10538 2F72           8B46         10            mov	ax,$10[bp]
10539 2F75           8B5E         12            mov	bx,$12[bp]
10540 2F78           93                         xchg	bx,ax
10541 2F79           88E0                       mov	al,ah
10542 2F7B           30E4                       xor	ah,ah
10543 2F7D           31DB                       xor	bx,bx
10544                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
10545 2F7F           53                         push	bx
10546 2F80           50                         push	ax
10547 2F81           B8                   000F  mov	ax,*$F
10548 2F84           31DB                       xor	bx,bx
10549 2F86           53                         push	bx
10550 2F87           50                         push	ax
10551 2F88           8B46         EE            mov	ax,-$12[bp]
10552 2F8B           8B5E         F0            mov	bx,-$10[bp]
10553 2F8E           8D7E         EA            lea	di,-$16[bp]
10554 2F91           E8         D127            call	landul
10555 2F94           83C4                   08  add	sp,*8
10556                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10557                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
10558 2F97           0C                     40  or	al,*$40
10559                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
10560 2F99           8946         0C            mov	$C[bp],ax
10561                                           !BCC_EOS
10562                                           ! 1850   }
10563                                           ! 1851   outb(iobase1 + 1, 0x00);
10564                       00002F9C            .241:
10565                                           ! Debug: list int = const 0 (used reg = )
10566 2F9C           31C0                       xor	ax,ax
10567 2F9E           50                         push	ax
10568                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10569 2F9F           8B46         FC            mov	ax,-4[bp]
10570                                           ! Debug: list unsigned int = ax+1 (used reg = )
10571 2FA2           40                         inc	ax
10572 2FA3           50                         push	ax
10573                                           ! Debug: func () void = outb+0 (used reg = )
10574 2FA4           E8         D5AD            call	_outb
10575 2FA7           83C4                   04  add	sp,*4
10576                                           !BCC_EOS
10577                                           ! 1852   outb(iobase1 + 2, count);
10578                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
10579 2FAA           FF76         08            push	8[bp]
10580                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10581 2FAD           8B46         FC            mov	ax,-4[bp]
10582                                           ! Debug: list unsigned int = ax+2 (used reg = )
10583 2FB0           40                         inc	ax
10584 2FB1           40                         inc	ax
10585 2FB2           50                         push	ax
10586                                           ! Debug: func () void = outb+0 (used reg = )
10587 2FB3           E8         D59E            call	_outb
10588 2FB6           83C4                   04  add	sp,*4
10589                                           !BCC_EOS
10590                                           ! 1853   outb(iobase1 + 3, sector);
10591                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
10592 2FB9           FF76         0E            push	$E[bp]
10593                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
10594 2FBC           8B46         FC            mov	ax,-4[bp]
10595                                           ! Debug: list unsigned int = ax+3 (used reg = )
10596 2FBF           05                   0003  add	ax,*3
10597 2FC2           50                         push	ax
10598                                           ! Debug: func () void = outb+0 (used reg = )
10599 2FC3           E8         D58E            call	_outb
10600 2FC6           83C4                   04  add	sp,*4
10601                                           !BCC_EOS
10602                                           ! 1854   outb(iobase1 + 4, cylinder & 0x00ff);
10603                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
10604 2FC9           8A46         0A            mov	al,$A[bp]
10605                                           ! Debug: list unsigned char = al+0 (used reg = )
10606 2FCC           30E4                       xor	ah,ah
10607 2FCE           50                         push	ax
10608                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10609 2FCF           8B46         FC            mov	ax,-4[bp]
10610                                           ! Debug: list unsigned int = ax+4 (used reg = )
10611 2FD2           05                   0004  add	ax,*4
10612 2FD5           50                         push	ax
10613                                           ! Debug: func () void = outb+0 (used reg = )
10614 2FD6           E8         D57B            call	_outb
10615 2FD9           83C4                   04  add	sp,*4
10616                                           !BCC_EOS
10617                                           ! 1855   outb(iobase1 + 5, cylinder >> 8);
10618                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
10619 2FDC           8B46         0A            mov	ax,$A[bp]
10620 2FDF           88E0                       mov	al,ah
10621 2FE1           30E4                       xor	ah,ah
10622                                           ! Debug: list unsigned int = ax+0 (used reg = )
10623 2FE3           50                         push	ax
10624                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10625 2FE4           8B46         FC            mov	ax,-4[bp]
10626                                           ! Debug: list unsigned int = ax+5 (used reg = )
10627 2FE7           05                   0005  add	ax,*5
10628 2FEA           50                         push	ax
10629                                           ! Debug: func () void = outb+0 (used reg = )
10630 2FEB           E8         D566            call	_outb
10631 2FEE           83C4                   04  add	sp,*4
10632                                           !BCC_EOS
10633                                           ! 1856   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10634 2FF1           8A46         F6            mov	al,-$A[bp]
10635 2FF4           84C0                       test	al,al
10636 2FF6           74           04            je  	.24A
10637                       00002FF8            .24B:
10638 2FF8           B0                     B0  mov	al,#$B0
10639 2FFA           EB           02            jmp .24C
10640                       00002FFC            .24A:
10641 2FFC           B0                     A0  mov	al,#$A0
10642                       00002FFE            .24C:
10643                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
10644 2FFE           0A46         0C            or	al,$C[bp]
10645                                           ! Debug: list unsigned char = al+0 (used reg = )
10646 3001           30E4                       xor	ah,ah
10647 3003           50                         push	ax
10648                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10649 3004           8B46         FC            mov	ax,-4[bp]
10650                                           ! Debug: list unsigned int = ax+6 (used reg = )
10651 3007           05                   0006  add	ax,*6
10652 300A           50                         push	ax
10653                                           ! Debug: func () void = outb+0 (used reg = )
10654 300B           E8         D546            call	_outb
10655 300E           83C4                   04  add	sp,*4
10656                                           !BCC_EOS
10657                                           ! 1857   outb(iobase1 + 7, command);
10658                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
10659 3011           FF76         06            push	6[bp]
10660                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
10661 3014           8B46         FC            mov	ax,-4[bp]
10662                                           ! Debug: list unsigned int = ax+7 (used reg = )
10663 3017           05                   0007  add	ax,*7
10664 301A           50                         push	ax
10665                                           ! Debug: func () void = outb+0 (used reg = )
10666 301B           E8         D536            call	_outb
10667 301E           83C4                   04  add	sp,*4
10668                                           !BCC_EOS
10669                                           ! 1858   status = await_ide(3, iobase1, 32000u);
10670                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10671 3021           B8                   7D00  mov	ax,#$7D00
10672 3024           50                         push	ax
10673                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10674 3025           FF76         FC            push	-4[bp]
10675                                           ! Debug: list int = const 3 (used reg = )
10676 3028           B8                   0003  mov	ax,*3
10677 302B           50                         push	ax
10678                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10679 302C           E8         EC75            call	_await_ide
10680 302F           83C4                   06  add	sp,*6
10681                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10682 3032           8846         F5            mov	-$B[bp],al
10683                                           !BCC_EOS
10684                                           ! 1859   if (status & 0x01) {
10685                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
10686 3035           8A46         F5            mov	al,-$B[bp]
10687 3038           24                     01  and	al,*1
10688 303A           84C0                       test	al,al
10689 303C           74           09            je  	.24D
10690                       0000303E            .24E:
10691                                           ! 1860     ;
10692                                           !BCC_EOS
10693                                           ! 1861     return 2;
10694 303E           B8                   0002  mov	ax,*2
10695 3041           89EC                       mov	sp,bp
10696 3043           5D                         pop	bp
10697 3044           C3                         ret
10698                                           !BCC_EOS
10699                                           ! 1862     } else if ( !(status & 0x08) ) {
10700 3045           EB           10            jmp .24F
10701                       00003047            .24D:
10702                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
10703 3047           8A46         F5            mov	al,-$B[bp]
10704 304A           24                     08  and	al,*8
10705 304C           84C0                       test	al,al
10706 304E           75           07            jne 	.250
10707                       00003050            .251:
10708                                           ! 1863     ;
10709                                           !BCC_EOS
10710                                           ! 1864     return 3;
10711 3050           B8                   0003  mov	ax,*3
10712 3053           89EC                       mov	sp,bp
10713 3055           5D                         pop	bp
10714 3056           C3                         ret
10715                                           !BCC_EOS
10716                                           ! 1865   }
10717                                           ! 1866 #asm
10718                       00003057            .250:
10719                       00003057            .24F:
10720                                           !BCC_EOS
10721                                           !BCC_ASM
10722                       00000016            _ata_cmd_data_in.count	set	$16
10723                       00000008            .ata_cmd_data_in.count	set	8
10724                       00000026            _ata_cmd_data_in.segment	set	$26
10725                       00000018            .ata_cmd_data_in.segment	set	$18
10726                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10727                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10728                       00000005            _ata_cmd_data_in.channel	set	5
10729                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10730                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10731                       00000010            .ata_cmd_data_in.lba_low	set	$10
10732                       00000022            _ata_cmd_data_in.lba_high	set	$22
10733                       00000014            .ata_cmd_data_in.lba_high	set	$14
10734                       0000001C            _ata_cmd_data_in.sector	set	$1C
10735                       0000000E            .ata_cmd_data_in.sector	set	$E
10736                       00000006            _ata_cmd_data_in.blksize	set	6
10737                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10738                       0000001A            _ata_cmd_data_in.head	set	$1A
10739                       0000000C            .ata_cmd_data_in.head	set	$C
10740                       00000018            _ata_cmd_data_in.cylinder	set	$18
10741                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10742                       00000012            _ata_cmd_data_in.device	set	$12
10743                       00000004            .ata_cmd_data_in.device	set	4
10744                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10745                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10746                       00000003            _ata_cmd_data_in.status	set	3
10747                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10748                       00000002            _ata_cmd_data_in.current	set	2
10749                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10750                       00000014            _ata_cmd_data_in.command	set	$14
10751                       00000006            .ata_cmd_data_in.command	set	6
10752                       00000001            _ata_cmd_data_in.mode	set	1
10753                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10754                       00000008            _ata_cmd_data_in.iobase2	set	8
10755                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10756                       00000028            _ata_cmd_data_in.offset	set	$28
10757                       0000001A            .ata_cmd_data_in.offset	set	$1A
10758                       00000004            _ata_cmd_data_in.slave	set	4
10759                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10760 3057           FB                                 sti ;; enable higher priority interrupts
10761                                           ! 1868 endasm
10762                                           !BCC_ENDASM
10763                                           !BCC_EOS
10764                                           ! 1869   while (1) {
10765                       00003058            .254:
10766                                           ! 1870 #asm
10767                                           !BCC_EOS
10768                                           !BCC_ASM
10769                       00000016            _ata_cmd_data_in.count	set	$16
10770                       00000008            .ata_cmd_data_in.count	set	8
10771                       00000026            _ata_cmd_data_in.segment	set	$26
10772                       00000018            .ata_cmd_data_in.segment	set	$18
10773                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10774                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10775                       00000005            _ata_cmd_data_in.channel	set	5
10776                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10777                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10778                       00000010            .ata_cmd_data_in.lba_low	set	$10
10779                       00000022            _ata_cmd_data_in.lba_high	set	$22
10780                       00000014            .ata_cmd_data_in.lba_high	set	$14
10781                       0000001C            _ata_cmd_data_in.sector	set	$1C
10782                       0000000E            .ata_cmd_data_in.sector	set	$E
10783                       00000006            _ata_cmd_data_in.blksize	set	6
10784                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10785                       0000001A            _ata_cmd_data_in.head	set	$1A
10786                       0000000C            .ata_cmd_data_in.head	set	$C
10787                       00000018            _ata_cmd_data_in.cylinder	set	$18
10788                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10789                       00000012            _ata_cmd_data_in.device	set	$12
10790                       00000004            .ata_cmd_data_in.device	set	4
10791                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10792                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10793                       00000003            _ata_cmd_data_in.status	set	3
10794                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10795                       00000002            _ata_cmd_data_in.current	set	2
10796                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10797                       00000014            _ata_cmd_data_in.command	set	$14
10798                       00000006            .ata_cmd_data_in.command	set	6
10799                       00000001            _ata_cmd_data_in.mode	set	1
10800                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10801                       00000008            _ata_cmd_data_in.iobase2	set	8
10802                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10803                       00000028            _ata_cmd_data_in.offset	set	$28
10804                       0000001A            .ata_cmd_data_in.offset	set	$1A
10805                       00000004            _ata_cmd_data_in.slave	set	4
10806                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10807 3058           55                                 push bp
10808 3059           89E5                               mov bp, sp
10809 305B           8B7E         2A                    mov di, _ata_cmd_data_in.offset + 2[bp]
10810 305E           8B46         28                    mov ax, _ata_cmd_data_in.segment + 2[bp]
10811 3061           8B4E         08                    mov cx, _ata_cmd_data_in.blksize + 2[bp]
10812                                                   ;; adjust if there will be an overrun. 2K max sector size
10813 3064           81FF                 F800          cmp di, #0xf800 ;;
10814 3068           76           07                    jbe ata_in_no_adjust
10815                       0000306A            ata_in_adjust:
10816 306A           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10817 306E           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10818                       00003071            ata_in_no_adjust:
10819 3071           8EC0                               mov es, ax ;; segment in es
10820 3073           8B56         0C                    mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
10821 3076           8A66         03                    mov ah, _ata_cmd_data_in.mode + 2[bp]
10822 3079           80FC                   01          cmp ah, #0x01
10823 307C           74           04                    je ata_in_32
10824                       0000307E            ata_in_16:
10825 307E           F3                                 rep
10826 307F           6D                                   insw ;; CX words transfered from port(DX) to ES:[DI]
10827 3080           EB           03                    jmp ata_in_done
10828                       00003082            ata_in_32:
10829 3082           F3                                 rep
10830 3083     66    6D                                   insd ;; CX dwords transfered from port(DX) to ES:[DI]
10831                       00003085            ata_in_done:
10832 3085           897E         2A                    mov _ata_cmd_data_in.offset + 2[bp], di
10833 3088           8C46         28                    mov _ata_cmd_data_in.segment + 2[bp], es
10834 308B           5D                                 pop bp
10835                                           ! 1899 endasm
10836                                           !BCC_ENDASM
10837                                           !BCC_EOS
10838                                           ! 1900     current++;
10839                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
10840 308C           8A46         F4            mov	al,-$C[bp]
10841 308F           40                         inc	ax
10842 3090           8846         F4            mov	-$C[bp],al
10843                                           !BCC_EOS
10844                                           ! 1901     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
10845                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
10846 3093           8A46         F4            mov	al,-$C[bp]
10847 3096           30E4                       xor	ah,ah
10848 3098           50                         push	ax
10849                                           ! Debug: list * unsigned short = const $254 (used reg = )
10850 3099           B8                   0254  mov	ax,#$254
10851 309C           50                         push	ax
10852                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10853 309D           FF76         FE            push	-2[bp]
10854                                           ! Debug: func () void = write_word+0 (used reg = )
10855 30A0           E8         D58F            call	_write_word
10856 30A3           83C4                   06  add	sp,*6
10857                                           !BCC_EOS
10858                                           ! 1902     count--;
10859                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
10860 30A6           8B46         08            mov	ax,8[bp]
10861 30A9           48                         dec	ax
10862 30AA           8946         08            mov	8[bp],ax
10863                                           !BCC_EOS
10864                                           ! 1903     status = await_ide(2, iobase1, 32000u);
10865                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10866 30AD           B8                   7D00  mov	ax,#$7D00
10867 30B0           50                         push	ax
10868                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10869 30B1           FF76         FC            push	-4[bp]
10870                                           ! Debug: list int = const 2 (used reg = )
10871 30B4           B8                   0002  mov	ax,*2
10872 30B7           50                         push	ax
10873                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10874 30B8           E8         EBE9            call	_await_ide
10875 30BB           83C4                   06  add	sp,*6
10876                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10877 30BE           8846         F5            mov	-$B[bp],al
10878                                           !BCC_EOS
10879                                           ! 1904     if (count == 0) {
10880                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
10881 30C1           8B46         08            mov	ax,8[bp]
10882 30C4           85C0                       test	ax,ax
10883 30C6           75           14            jne 	.255
10884                       000030C8            .256:
10885                                           ! 1905       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10886                                           ! 1906           != 0x40 ) {
10887                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10888 30C8           8A46         F5            mov	al,-$B[bp]
10889 30CB           24                     C9  and	al,#$C9
10890                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10891 30CD           3C                     40  cmp	al,*$40
10892 30CF           74           07            je  	.257
10893                       000030D1            .258:
10894                                           ! 1907         ;
10895                                           !BCC_EOS
10896                                           ! 1908         return 4;
10897 30D1           B8                   0004  mov	ax,*4
10898 30D4           89EC                       mov	sp,bp
10899 30D6           5D                         pop	bp
10900 30D7           C3                         ret
10901                                           !BCC_EOS
10902                                           ! 1909         }
10903                                           ! 1910       break;
10904                       000030D8            .257:
10905 30D8           EB           17            jmp .252
10906                                           !BCC_EOS
10907                                           ! 1911       }
10908                                           ! 1912     else {
10909 30DA           EB           12            jmp .259
10910                       000030DC            .255:
10911                                           ! 1913       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10912                                           ! 1914           != (0x40 | 0x08) ) {
10913                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10914 30DC           8A46         F5            mov	al,-$B[bp]
10915 30DF           24                     C9  and	al,#$C9
10916                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10917 30E1           3C                     48  cmp	al,*$48
10918 30E3           74           07            je  	.25A
10919                       000030E5            .25B:
10920                                           ! 1915         ;
10921                                           !BCC_EOS
10922                                           ! 1916         return 5;
10923 30E5           B8                   0005  mov	ax,*5
10924 30E8           89EC                       mov	sp,bp
10925 30EA           5D                         pop	bp
10926 30EB           C3                         ret
10927                                           !BCC_EOS
10928                                           ! 1917       }
10929                                           ! 1918       continue;
10930                       000030EC            .25A:
10931 30EC           EB           00            jmp .253
10932                                           !BCC_EOS
10933                                           ! 1919     }
10934                                           ! 1920   }
10935                       000030EE            .259:
10936                                           ! 1921   outb(iobase2+6, 0x08);
10937                       000030EE            .253:
10938 30EE           E9         FF67            jmp	.254
10939                       000030F1            .25C:
10940                       000030F1            .252:
10941                                           ! Debug: list int = const 8 (used reg = )
10942 30F1           B8                   0008  mov	ax,*8
10943 30F4           50                         push	ax
10944                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10945 30F5           8B46         FA            mov	ax,-6[bp]
10946                                           ! Debug: list unsigned int = ax+6 (used reg = )
10947 30F8           05                   0006  add	ax,*6
10948 30FB           50                         push	ax
10949                                           ! Debug: func () void = outb+0 (used reg = )
10950 30FC           E8         D455            call	_outb
10951 30FF           83C4                   04  add	sp,*4
10952                                           !BCC_EOS
10953                                           ! 1922   return 0;
10954 3102           31C0                       xor	ax,ax
10955 3104           89EC                       mov	sp,bp
10956 3106           5D                         pop	bp
10957 3107           C3                         ret
10958                                           !BCC_EOS
10959                                           ! 1923 }
10960                                           ! 1924 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
10961                                           ! Register BX used in function ata_cmd_data_in
10962                                           ! 1925 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10963                                           export	_ata_cmd_data_out
10964                       00003108            _ata_cmd_data_out:
10965                                           !BCC_EOS
10966                                           ! 1926 Bit32u lba_low, lba_high;
10967                                           !BCC_EOS
10968                                           ! 1927 {
10969                                           ! 1928   Bit16u ebda_seg=read_word(0x0040,0x000E);
10970 3108           55                         push	bp
10971 3109           89E5                       mov	bp,sp
10972 310B           4C                         dec	sp
10973 310C           4C                         dec	sp
10974                                           ! Debug: list int = const $E (used reg = )
10975 310D           B8                   000E  mov	ax,*$E
10976 3110           50                         push	ax
10977                                           ! Debug: list int = const $40 (used reg = )
10978 3111           B8                   0040  mov	ax,*$40
10979 3114           50                         push	ax
10980                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10981 3115           E8         D4EF            call	_read_word
10982 3118           83C4                   04  add	sp,*4
10983                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10984 311B           8946         FE            mov	-2[bp],ax
10985                                           !BCC_EOS
10986                                           ! 1929   Bit16u iobase1, iobase2, blksize;
10987                                           !BCC_EOS
10988                                           ! 1930   Bit8u channel, slave;
10989                                           !BCC_EOS
10990                                           ! 1931   Bit8u status, current, mode;
10991                                           !BCC_EOS
10992                                           ! 1932   channel = device / 2;
10993 311E           83C4                   F4  add	sp,*-$C
10994                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10995 3121           8B46         04            mov	ax,4[bp]
10996 3124           D1E8                       shr	ax,*1
10997                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10998 3126           8846         F7            mov	-9[bp],al
10999                                           !BCC_EOS
11000                                           ! 1933   slave = device % 2;
11001                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11002 3129           8B46         04            mov	ax,4[bp]
11003 312C           24                     01  and	al,*1
11004                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
11005 312E           8846         F6            mov	-$A[bp],al
11006                                           !BCC_EOS
11007                                           ! 1934   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11008                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11009 3131           8A46         F7            mov	al,-9[bp]
11010 3134           30E4                       xor	ah,ah
11011 3136           B1                     03  mov	cl,*3
11012 3138           D3E0                       shl	ax,cl
11013 313A           89C3                       mov	bx,ax
11014                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11015                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11016 313C           81C3                 0124  add	bx,#$124
11017 3140           53                         push	bx
11018                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11019 3141           FF76         FE            push	-2[bp]
11020                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11021 3144           E8         D4C0            call	_read_word
11022 3147           83C4                   04  add	sp,*4
11023                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
11024 314A           8946         FC            mov	-4[bp],ax
11025                                           !BCC_EOS
11026                                           ! 1935   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11027                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11028 314D           8A46         F7            mov	al,-9[bp]
11029 3150           30E4                       xor	ah,ah
11030 3152           B1                     03  mov	cl,*3
11031 3154           D3E0                       shl	ax,cl
11032 3156           89C3                       mov	bx,ax
11033                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11034                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11035 3158           81C3                 0126  add	bx,#$126
11036 315C           53                         push	bx
11037                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11038 315D           FF76         FE            push	-2[bp]
11039                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11040 3160           E8         D4A4            call	_read_word
11041 3163           83C4                   04  add	sp,*4
11042                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
11043 3166           8946         FA            mov	-6[bp],ax
11044                                           !BCC_EOS
11045                                           ! 1936   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11046                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
11047 3169           8B46         04            mov	ax,4[bp]
11048 316C           B9                   001E  mov	cx,*$1E
11049 316F           F7E9                       imul	cx
11050 3171           89C3                       mov	bx,ax
11051                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11052                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11053 3173           81C3                 0146  add	bx,#$146
11054 3177           53                         push	bx
11055                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11056 3178           FF76         FE            push	-2[bp]
11057                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11058 317B           E8         D476            call	_read_byte
11059 317E           83C4                   04  add	sp,*4
11060                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
11061 3181           8846         F3            mov	-$D[bp],al
11062                                           !BCC_EOS
11063                                           ! 1937   blksize = 0x200;
11064                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
11065 3184           B8                   0200  mov	ax,#$200
11066 3187           8946         F8            mov	-8[bp],ax
11067                                           !BCC_EOS
11068                                           ! 1938   if (mode == 0x01) blksize>>=2;
11069                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
11070 318A           8A46         F3            mov	al,-$D[bp]
11071 318D           3C                     01  cmp	al,*1
11072 318F           75           0C            jne 	.25D
11073                       00003191            .25E:
11074                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
11075 3191           8B46         F8            mov	ax,-8[bp]
11076 3194           D1E8                       shr	ax,*1
11077 3196           D1E8                       shr	ax,*1
11078 3198           8946         F8            mov	-8[bp],ax
11079                                           !BCC_EOS
11080                                           ! 1939   else blksize>>=1;
11081 319B           EB           08            jmp .25F
11082                       0000319D            .25D:
11083                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
11084 319D           8B46         F8            mov	ax,-8[bp]
11085 31A0           D1E8                       shr	ax,*1
11086 31A2           8946         F8            mov	-8[bp],ax
11087                                           !BCC_EOS
11088                                           ! 1940   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11089                       000031A5            .25F:
11090                                           ! Debug: list int = const 0 (used reg = )
11091 31A5           31C0                       xor	ax,ax
11092 31A7           50                         push	ax
11093                                           ! Debug: list * unsigned short = const $254 (used reg = )
11094 31A8           B8                   0254  mov	ax,#$254
11095 31AB           50                         push	ax
11096                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11097 31AC           FF76         FE            push	-2[bp]
11098                                           ! Debug: func () void = write_word+0 (used reg = )
11099 31AF           E8         D480            call	_write_word
11100 31B2           83C4                   06  add	sp,*6
11101                                           !BCC_EOS
11102                                           ! 1941   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11103                                           ! Debug: list long = const 0 (used reg = )
11104 31B5           31C0                       xor	ax,ax
11105 31B7           31DB                       xor	bx,bx
11106 31B9           53                         push	bx
11107 31BA           50                         push	ax
11108                                           ! Debug: list * unsigned long = const $256 (used reg = )
11109 31BB           B8                   0256  mov	ax,#$256
11110 31BE           50                         push	ax
11111                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
11112 31BF           FF76         FE            push	-2[bp]
11113                                           ! Debug: func () void = write_dword+0 (used reg = )
11114 31C2           E8         CED6            call	_write_dword
11115 31C5           83C4                   08  add	sp,*8
11116                                           !BCC_EOS
11117                                           ! 1942   current = 0;
11118                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
11119 31C8           30C0                       xor	al,al
11120 31CA           8846         F4            mov	-$C[bp],al
11121                                           !BCC_EOS
11122                                           ! 1943   status = inb(iobase1 + 7);
11123                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11124 31CD           8B46         FC            mov	ax,-4[bp]
11125                                           ! Debug: list unsigned int = ax+7 (used reg = )
11126 31D0           05                   0007  add	ax,*7
11127 31D3           50                         push	ax
11128                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11129 31D4           E8         D367            call	_inb
11130 31D7           44                         inc	sp
11131 31D8           44                         inc	sp
11132                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11133 31D9           8846         F5            mov	-$B[bp],al
11134                                           !BCC_EOS
11135                                           ! 1944  
11136                                           ! 1944  if (status & 0x80) return 1;
11137                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
11138 31DC           8A46         F5            mov	al,-$B[bp]
11139 31DF           24                     80  and	al,#$80
11140 31E1           84C0                       test	al,al
11141 31E3           74           07            je  	.260
11142                       000031E5            .261:
11143 31E5           B8                   0001  mov	ax,*1
11144 31E8           89EC                       mov	sp,bp
11145 31EA           5D                         pop	bp
11146 31EB           C3                         ret
11147                                           !BCC_EOS
11148                                           ! 1945   outb(iobase2 + 6, 0x08 | 0x02);
11149                       000031EC            .260:
11150                                           ! Debug: list int = const $A (used reg = )
11151 31EC           B8                   000A  mov	ax,*$A
11152 31EF           50                         push	ax
11153                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11154 31F0           8B46         FA            mov	ax,-6[bp]
11155                                           ! Debug: list unsigned int = ax+6 (used reg = )
11156 31F3           05                   0006  add	ax,*6
11157 31F6           50                         push	ax
11158                                           ! Debug: func () void = outb+0 (used reg = )
11159 31F7           E8         D35A            call	_outb
11160 31FA           83C4                   04  add	sp,*4
11161                                           !BCC_EOS
11162                                           ! 1946   if (sector == 0) {
11163                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
11164 31FD           8B46         0E            mov	ax,$E[bp]
11165 3200           85C0                       test	ax,ax
11166 3202         0F85         0167            bne 	.262
11167                       00003206            .263:
11168                                           ! 1947     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
11169                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
11170 3206           8B46         08            mov	ax,8[bp]
11171 3209           3D                   0100  cmp	ax,#$100
11172 320C           72           04            jb 	.268
11173 320E           B0                     01  mov	al,*1
11174 3210           EB           02            jmp	.269
11175                       00003212            .268:
11176 3212           30C0                       xor	al,al
11177                       00003214            .269:
11178                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
11179 3214           30E4                       xor	ah,ah
11180 3216           99                         cwd
11181 3217           89D3                       mov	bx,dx
11182 3219           E8         CEF8            call	ltstl
11183 321C           75           32            jne 	.265
11184                       0000321E            .267:
11185 321E           8B46         14            mov	ax,$14[bp]
11186 3221           8B5E         16            mov	bx,$16[bp]
11187 3224           E8         CEED            call	ltstl
11188 3227           75           27            jne 	.265
11189                       00003229            .266:
11190                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
11191 3229           8B46         08            mov	ax,8[bp]
11192 322C           31DB                       xor	bx,bx
11193                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
11194                                           ! Debug: expression subtree swapping
11195 322E           8D7E         10            lea	di,$10[bp]
11196 3231           E8         CE8F            call	laddul
11197                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
11198 3234           53                         push	bx
11199 3235           50                         push	ax
11200 3236           31C0                       xor	ax,ax
11201 3238           BB                   1000  mov	bx,#$1000
11202 323B           53                         push	bx
11203 323C           50                         push	ax
11204 323D           8B46         EE            mov	ax,-$12[bp]
11205 3240           8B5E         F0            mov	bx,-$10[bp]
11206 3243           8D7E         EA            lea	di,-$16[bp]
11207 3246           E8         CE82            call	lcmpul
11208 3249           8D66         F2            lea	sp,-$E[bp]
11209 324C         0F82         00BC            blo 	.264
11210                       00003250            .265:
11211                                           ! 1948       outb(iobase1 + 1, 0x00);
11212                                           ! Debug: list int = const 0 (used reg = )
11213 3250           31C0                       xor	ax,ax
11214 3252           50                         push	ax
11215                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11216 3253           8B46         FC            mov	ax,-4[bp]
11217                                           ! Debug: list unsigned int = ax+1 (used reg = )
11218 3256           40                         inc	ax
11219 3257           50                         push	ax
11220                                           ! Debug: func () void = outb+0 (used reg = )
11221 3258           E8         D2F9            call	_outb
11222 325B           83C4                   04  add	sp,*4
11223                                           !BCC_EOS
11224                                           ! 1949       outb(iobase1 + 2, (count >> 8) & 0xff);
11225                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
11226 325E           8B46         08            mov	ax,8[bp]
11227 3261           88E0                       mov	al,ah
11228 3263           30E4                       xor	ah,ah
11229                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
11230                                           ! Debug: list unsigned char = al+0 (used reg = )
11231 3265           30E4                       xor	ah,ah
11232 3267           50                         push	ax
11233                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11234 3268           8B46         FC            mov	ax,-4[bp]
11235                                           ! Debug: list unsigned int = ax+2 (used reg = )
11236 326B           40                         inc	ax
11237 326C           40                         inc	ax
11238 326D           50                         push	ax
11239                                           ! Debug: func () void = outb+0 (used reg = )
11240 326E           E8         D2E3            call	_outb
11241 3271           83C4                   04  add	sp,*4
11242                                           !BCC_EOS
11243                                           ! 1950       outb(iobase1 + 3, lba_low >> 24);
11244                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11245 3274           8B46         10            mov	ax,$10[bp]
11246 3277           8B5E         12            mov	bx,$12[bp]
11247 327A           93                         xchg	bx,ax
11248 327B           88E0                       mov	al,ah
11249 327D           30E4                       xor	ah,ah
11250 327F           31DB                       xor	bx,bx
11251                                           ! Debug: list unsigned long = bx+0 (used reg = )
11252 3281           53                         push	bx
11253 3282           50                         push	ax
11254                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
11255 3283           8B46         FC            mov	ax,-4[bp]
11256                                           ! Debug: list unsigned int = ax+3 (used reg = )
11257 3286           05                   0003  add	ax,*3
11258 3289           50                         push	ax
11259                                           ! Debug: func () void = outb+0 (used reg = )
11260 328A           E8         D2C7            call	_outb
11261 328D           83C4                   06  add	sp,*6
11262                                           !BCC_EOS
11263                                           ! 1951       outb(iobase1 + 4, lba_high & 0xff);
11264                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
11265                                           ! Debug: expression subtree swapping
11266 3290           B8                   00FF  mov	ax,#$FF
11267 3293           31DB                       xor	bx,bx
11268 3295           8D7E         14            lea	di,$14[bp]
11269 3298           E8         CE20            call	landul
11270                                           ! Debug: list unsigned long = bx+0 (used reg = )
11271 329B           53                         push	bx
11272 329C           50                         push	ax
11273                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
11274 329D           8B46         FC            mov	ax,-4[bp]
11275                                           ! Debug: list unsigned int = ax+4 (used reg = )
11276 32A0           05                   0004  add	ax,*4
11277 32A3           50                         push	ax
11278                                           ! Debug: func () void = outb+0 (used reg = )
11279 32A4           E8         D2AD            call	_outb
11280 32A7           83C4                   06  add	sp,*6
11281                                           !BCC_EOS
11282                                           ! 1952       outb(iobase1 + 5, lba_high >> 8);
11283                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
11284 32AA           8B46         14            mov	ax,$14[bp]
11285 32AD           8B5E         16            mov	bx,$16[bp]
11286 32B0           88E0                       mov	al,ah
11287 32B2           88DC                       mov	ah,bl
11288 32B4           88FB                       mov	bl,bh
11289 32B6           28FF                       sub	bh,bh
11290                                           ! Debug: list unsigned long = bx+0 (used reg = )
11291 32B8           53                         push	bx
11292 32B9           50                         push	ax
11293                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
11294 32BA           8B46         FC            mov	ax,-4[bp]
11295                                           ! Debug: list unsigned int = ax+5 (used reg = )
11296 32BD           05                   0005  add	ax,*5
11297 32C0           50                         push	ax
11298                                           ! Debug: func () void = outb+0 (used reg = )
11299 32C1           E8         D290            call	_outb
11300 32C4           83C4                   06  add	sp,*6
11301                                           !BCC_EOS
11302                                           ! 1953       command |= 0x04;
11303                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
11304 32C7           8B46         06            mov	ax,6[bp]
11305 32CA           0C                     04  or	al,*4
11306 32CC           8946         06            mov	6[bp],ax
11307                                           !BCC_EOS
11308                                           ! 1954       count &= (1UL << 8) - 1;
11309                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
11310 32CF           8B46         08            mov	ax,8[bp]
11311 32D2           31DB                       xor	bx,bx
11312 32D4           53                         push	bx
11313 32D5           50                         push	ax
11314 32D6           B8                   00FF  mov	ax,#$FF
11315 32D9           31DB                       xor	bx,bx
11316 32DB           53                         push	bx
11317 32DC           50                         push	ax
11318 32DD           8B46         EE            mov	ax,-$12[bp]
11319 32E0           8B5E         F0            mov	bx,-$10[bp]
11320 32E3           8D7E         EA            lea	di,-$16[bp]
11321 32E6           E8         CDD2            call	landul
11322 32E9           8946         08            mov	8[bp],ax
11323 32EC           83C4                   08  add	sp,*8
11324                                           !BCC_EOS
11325                                           ! 1955       lba_low &= (1UL << 24) - 1;
11326                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
11327 32EF           B8                   FFFF  mov	ax,#$FFFF
11328 32F2           BB                   00FF  mov	bx,#$FF
11329 32F5           53                         push	bx
11330 32F6           50                         push	ax
11331 32F7           8B46         10            mov	ax,$10[bp]
11332 32FA           8B5E         12            mov	bx,$12[bp]
11333 32FD           8D7E         EE            lea	di,-$12[bp]
11334 3300           E8         CDB8            call	landul
11335 3303           8946         10            mov	$10[bp],ax
11336 3306           895E         12            mov	$12[bp],bx
11337 3309           83C4                   04  add	sp,*4
11338                                           !BCC_EOS
11339                                           ! 1956       }
11340                                           ! 1957     sector = (Bit16u) (lba_low & 0x000000ffL);
11341                       0000330C            .264:
11342                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
11343                                           ! Debug: expression subtree swapping
11344 330C           B8                   00FF  mov	ax,#$FF
11345 330F           31DB                       xor	bx,bx
11346 3311           8D7E         10            lea	di,$10[bp]
11347 3314           E8         CDA4            call	landul
11348                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11349                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
11350 3317           8946         0E            mov	$E[bp],ax
11351                                           !BCC_EOS
11352                                           ! 1958     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
11353                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
11354 331A           8B46         10            mov	ax,$10[bp]
11355 331D           8B5E         12            mov	bx,$12[bp]
11356 3320           88E0                       mov	al,ah
11357 3322           88DC                       mov	ah,bl
11358 3324           88FB                       mov	bl,bh
11359 3326           28FF                       sub	bh,bh
11360                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
11361 3328           53                         push	bx
11362 3329           50                         push	ax
11363 332A           B8                   FFFF  mov	ax,#$FFFF
11364 332D           31DB                       xor	bx,bx
11365 332F           53                         push	bx
11366 3330           50                         push	ax
11367 3331           8B46         EE            mov	ax,-$12[bp]
11368 3334           8B5E         F0            mov	bx,-$10[bp]
11369 3337           8D7E         EA            lea	di,-$16[bp]
11370 333A           E8         CD7E            call	landul
11371 333D           83C4                   08  add	sp,*8
11372                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11373                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
11374 3340           8946         0A            mov	$A[bp],ax
11375                                           !BCC_EOS
11376                                           ! 1959     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
11377                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11378 3343           8B46         10            mov	ax,$10[bp]
11379 3346           8B5E         12            mov	bx,$12[bp]
11380 3349           93                         xchg	bx,ax
11381 334A           88E0                       mov	al,ah
11382 334C           30E4                       xor	ah,ah
11383 334E           31DB                       xor	bx,bx
11384                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
11385 3350           53                         push	bx
11386 3351           50                         push	ax
11387 3352           B8                   000F  mov	ax,*$F
11388 3355           31DB                       xor	bx,bx
11389 3357           53                         push	bx
11390 3358           50                         push	ax
11391 3359           8B46         EE            mov	ax,-$12[bp]
11392 335C           8B5E         F0            mov	bx,-$10[bp]
11393 335F           8D7E         EA            lea	di,-$16[bp]
11394 3362           E8         CD56            call	landul
11395 3365           83C4                   08  add	sp,*8
11396                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11397                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
11398 3368           0C                     40  or	al,*$40
11399                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
11400 336A           8946         0C            mov	$C[bp],ax
11401                                           !BCC_EOS
11402                                           ! 1960   }
11403                                           ! 1961   outb(iobase1 + 1, 0x00);
11404                       0000336D            .262:
11405                                           ! Debug: list int = const 0 (used reg = )
11406 336D           31C0                       xor	ax,ax
11407 336F           50                         push	ax
11408                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11409 3370           8B46         FC            mov	ax,-4[bp]
11410                                           ! Debug: list unsigned int = ax+1 (used reg = )
11411 3373           40                         inc	ax
11412 3374           50                         push	ax
11413                                           ! Debug: func () void = outb+0 (used reg = )
11414 3375           E8         D1DC            call	_outb
11415 3378           83C4                   04  add	sp,*4
11416                                           !BCC_EOS
11417                                           ! 1962   outb(iobase1 + 2, count);
11418                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
11419 337B           FF76         08            push	8[bp]
11420                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11421 337E           8B46         FC            mov	ax,-4[bp]
11422                                           ! Debug: list unsigned int = ax+2 (used reg = )
11423 3381           40                         inc	ax
11424 3382           40                         inc	ax
11425 3383           50                         push	ax
11426                                           ! Debug: func () void = outb+0 (used reg = )
11427 3384           E8         D1CD            call	_outb
11428 3387           83C4                   04  add	sp,*4
11429                                           !BCC_EOS
11430                                           ! 1963   outb(iobase1 + 3, sector);
11431                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
11432 338A           FF76         0E            push	$E[bp]
11433                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
11434 338D           8B46         FC            mov	ax,-4[bp]
11435                                           ! Debug: list unsigned int = ax+3 (used reg = )
11436 3390           05                   0003  add	ax,*3
11437 3393           50                         push	ax
11438                                           ! Debug: func () void = outb+0 (used reg = )
11439 3394           E8         D1BD            call	_outb
11440 3397           83C4                   04  add	sp,*4
11441                                           !BCC_EOS
11442                                           ! 1964   outb(iobase1 + 4, cylinder & 0x00ff);
11443                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
11444 339A           8A46         0A            mov	al,$A[bp]
11445                                           ! Debug: list unsigned char = al+0 (used reg = )
11446 339D           30E4                       xor	ah,ah
11447 339F           50                         push	ax
11448                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
11449 33A0           8B46         FC            mov	ax,-4[bp]
11450                                           ! Debug: list unsigned int = ax+4 (used reg = )
11451 33A3           05                   0004  add	ax,*4
11452 33A6           50                         push	ax
11453                                           ! Debug: func () void = outb+0 (used reg = )
11454 33A7           E8         D1AA            call	_outb
11455 33AA           83C4                   04  add	sp,*4
11456                                           !BCC_EOS
11457                                           ! 1965   outb(iobase1 + 5, cylinder >> 8);
11458                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
11459 33AD           8B46         0A            mov	ax,$A[bp]
11460 33B0           88E0                       mov	al,ah
11461 33B2           30E4                       xor	ah,ah
11462                                           ! Debug: list unsigned int = ax+0 (used reg = )
11463 33B4           50                         push	ax
11464                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
11465 33B5           8B46         FC            mov	ax,-4[bp]
11466                                           ! Debug: list unsigned int = ax+5 (used reg = )
11467 33B8           05                   0005  add	ax,*5
11468 33BB           50                         push	ax
11469                                           ! Debug: func () void = outb+0 (used reg = )
11470 33BC           E8         D195            call	_outb
11471 33BF           83C4                   04  add	sp,*4
11472                                           !BCC_EOS
11473                                           ! 1966   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
11474 33C2           8A46         F6            mov	al,-$A[bp]
11475 33C5           84C0                       test	al,al
11476 33C7           74           04            je  	.26B
11477                       000033C9            .26C:
11478 33C9           B0                     B0  mov	al,#$B0
11479 33CB           EB           02            jmp .26D
11480                       000033CD            .26B:
11481 33CD           B0                     A0  mov	al,#$A0
11482                       000033CF            .26D:
11483                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
11484 33CF           0A46         0C            or	al,$C[bp]
11485                                           ! Debug: list unsigned char = al+0 (used reg = )
11486 33D2           30E4                       xor	ah,ah
11487 33D4           50                         push	ax
11488                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
11489 33D5           8B46         FC            mov	ax,-4[bp]
11490                                           ! Debug: list unsigned int = ax+6 (used reg = )
11491 33D8           05                   0006  add	ax,*6
11492 33DB           50                         push	ax
11493                                           ! Debug: func () void = outb+0 (used reg = )
11494 33DC           E8         D175            call	_outb
11495 33DF           83C4                   04  add	sp,*4
11496                                           !BCC_EOS
11497                                           ! 1967   outb(iobase1 + 7, command);
11498                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
11499 33E2           FF76         06            push	6[bp]
11500                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
11501 33E5           8B46         FC            mov	ax,-4[bp]
11502                                           ! Debug: list unsigned int = ax+7 (used reg = )
11503 33E8           05                   0007  add	ax,*7
11504 33EB           50                         push	ax
11505                                           ! Debug: func () void = outb+0 (used reg = )
11506 33EC           E8         D165            call	_outb
11507 33EF           83C4                   04  add	sp,*4
11508                                           !BCC_EOS
11509                                           ! 1968   status = await_ide(3, iobase1, 32000u);
11510                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11511 33F2           B8                   7D00  mov	ax,#$7D00
11512 33F5           50                         push	ax
11513                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11514 33F6           FF76         FC            push	-4[bp]
11515                                           ! Debug: list int = const 3 (used reg = )
11516 33F9           B8                   0003  mov	ax,*3
11517 33FC           50                         push	ax
11518                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
11519 33FD           E8         E8A4            call	_await_ide
11520 3400           83C4                   06  add	sp,*6
11521                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11522 3403           8846         F5            mov	-$B[bp],al
11523                                           !BCC_EOS
11524                                           ! 1969   if (status & 0x01) {
11525                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
11526 3406           8A46         F5            mov	al,-$B[bp]
11527 3409           24                     01  and	al,*1
11528 340B           84C0                       test	al,al
11529 340D           74           09            je  	.26E
11530                       0000340F            .26F:
11531                                           ! 1970     ;
11532                                           !BCC_EOS
11533                                           ! 1971     return 2;
11534 340F           B8                   0002  mov	ax,*2
11535 3412           89EC                       mov	sp,bp
11536 3414           5D                         pop	bp
11537 3415           C3                         ret
11538                                           !BCC_EOS
11539                                           ! 1972     } else if ( !(status & 0x08) ) {
11540 3416           EB           10            jmp .270
11541                       00003418            .26E:
11542                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
11543 3418           8A46         F5            mov	al,-$B[bp]
11544 341B           24                     08  and	al,*8
11545 341D           84C0                       test	al,al
11546 341F           75           07            jne 	.271
11547                       00003421            .272:
11548                                           ! 1973     ;
11549                                           !BCC_EOS
11550                                           ! 1974     return 3;
11551 3421           B8                   0003  mov	ax,*3
11552 3424           89EC                       mov	sp,bp
11553 3426           5D                         pop	bp
11554 3427           C3                         ret
11555                                           !BCC_EOS
11556                                           ! 1975     }
11557                                           ! 1976 #asm
11558                       00003428            .271:
11559                       00003428            .270:
11560                                           !BCC_EOS
11561                                           !BCC_ASM
11562                       00000016            _ata_cmd_data_out.count	set	$16
11563                       00000008            .ata_cmd_data_out.count	set	8
11564                       00000026            _ata_cmd_data_out.segment	set	$26
11565                       00000018            .ata_cmd_data_out.segment	set	$18
11566                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11567                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11568                       00000005            _ata_cmd_data_out.channel	set	5
11569                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11570                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11571                       00000010            .ata_cmd_data_out.lba_low	set	$10
11572                       00000022            _ata_cmd_data_out.lba_high	set	$22
11573                       00000014            .ata_cmd_data_out.lba_high	set	$14
11574                       0000001C            _ata_cmd_data_out.sector	set	$1C
11575                       0000000E            .ata_cmd_data_out.sector	set	$E
11576                       00000006            _ata_cmd_data_out.blksize	set	6
11577                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11578                       0000001A            _ata_cmd_data_out.head	set	$1A
11579                       0000000C            .ata_cmd_data_out.head	set	$C
11580                       00000018            _ata_cmd_data_out.cylinder	set	$18
11581                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11582                       00000012            _ata_cmd_data_out.device	set	$12
11583                       00000004            .ata_cmd_data_out.device	set	4
11584                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11585                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11586                       00000003            _ata_cmd_data_out.status	set	3
11587                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11588                       00000002            _ata_cmd_data_out.current	set	2
11589                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11590                       00000014            _ata_cmd_data_out.command	set	$14
11591                       00000006            .ata_cmd_data_out.command	set	6
11592                       00000001            _ata_cmd_data_out.mode	set	1
11593                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11594                       00000008            _ata_cmd_data_out.iobase2	set	8
11595                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11596                       00000028            _ata_cmd_data_out.offset	set	$28
11597                       0000001A            .ata_cmd_data_out.offset	set	$1A
11598                       00000004            _ata_cmd_data_out.slave	set	4
11599                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11600 3428           FB                                 sti ;; enable higher priority interrupts
11601                                           ! 1978 endasm
11602                                           !BCC_ENDASM
11603                                           !BCC_EOS
11604                                           ! 1979   while (1) {
11605                       00003429            .275:
11606                                           ! 1980 #asm
11607                                           !BCC_EOS
11608                                           !BCC_ASM
11609                       00000016            _ata_cmd_data_out.count	set	$16
11610                       00000008            .ata_cmd_data_out.count	set	8
11611                       00000026            _ata_cmd_data_out.segment	set	$26
11612                       00000018            .ata_cmd_data_out.segment	set	$18
11613                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11614                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11615                       00000005            _ata_cmd_data_out.channel	set	5
11616                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11617                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11618                       00000010            .ata_cmd_data_out.lba_low	set	$10
11619                       00000022            _ata_cmd_data_out.lba_high	set	$22
11620                       00000014            .ata_cmd_data_out.lba_high	set	$14
11621                       0000001C            _ata_cmd_data_out.sector	set	$1C
11622                       0000000E            .ata_cmd_data_out.sector	set	$E
11623                       00000006            _ata_cmd_data_out.blksize	set	6
11624                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11625                       0000001A            _ata_cmd_data_out.head	set	$1A
11626                       0000000C            .ata_cmd_data_out.head	set	$C
11627                       00000018            _ata_cmd_data_out.cylinder	set	$18
11628                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11629                       00000012            _ata_cmd_data_out.device	set	$12
11630                       00000004            .ata_cmd_data_out.device	set	4
11631                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11632                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11633                       00000003            _ata_cmd_data_out.status	set	3
11634                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11635                       00000002            _ata_cmd_data_out.current	set	2
11636                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11637                       00000014            _ata_cmd_data_out.command	set	$14
11638                       00000006            .ata_cmd_data_out.command	set	6
11639                       00000001            _ata_cmd_data_out.mode	set	1
11640                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11641                       00000008            _ata_cmd_data_out.iobase2	set	8
11642                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11643                       00000028            _ata_cmd_data_out.offset	set	$28
11644                       0000001A            .ata_cmd_data_out.offset	set	$1A
11645                       00000004            _ata_cmd_data_out.slave	set	4
11646                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11647 3429           55                                 push bp
11648 342A           89E5                               mov bp, sp
11649 342C           8B76         2A                    mov si, _ata_cmd_data_out.offset + 2[bp]
11650 342F           8B46         28                    mov ax, _ata_cmd_data_out.segment + 2[bp]
11651 3432           8B4E         08                    mov cx, _ata_cmd_data_out.blksize + 2[bp]
11652                                                   ;; adjust if there will be an overrun. 2K max sector size
11653 3435           81FE                 F800          cmp si, #0xf800 ;;
11654 3439           76           07                    jbe ata_out_no_adjust
11655                       0000343B            ata_out_adjust:
11656 343B           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
11657 343F           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
11658                       00003442            ata_out_no_adjust:
11659 3442           8EC0                               mov es, ax ;; segment in es
11660 3444           8B56         0C                    mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
11661 3447           8A66         03                    mov ah, _ata_cmd_data_out.mode + 2[bp]
11662 344A           80FC                   01          cmp ah, #0x01
11663 344D           74           05                    je ata_out_32
11664                       0000344F            ata_out_16:
11665 344F           26                                 seg ES
11666 3450           F3                                 rep
11667 3451           6F                                   outsw ;; CX words transfered from port(DX) to ES:[SI]
11668 3452           EB           04                    jmp ata_out_done
11669                       00003454            ata_out_32:
11670 3454           26                                 seg ES
11671 3455           F3                                 rep
11672 3456     66    6F                                   outsd ;; CX dwords transfered from port(DX) to ES:[SI]
11673                       00003458            ata_out_done:
11674 3458           8976         2A                    mov _ata_cmd_data_out.offset + 2[bp], si
11675 345B           8C46         28                    mov _ata_cmd_data_out.segment + 2[bp], es
11676 345E           5D                                 pop bp
11677                                           ! 2011 endasm
11678                                           !BCC_ENDASM
11679                                           !BCC_EOS
11680                                           ! 2012     current++;
11681                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11682 345F           8A46         F4            mov	al,-$C[bp]
11683 3462           40                         inc	ax
11684 3463           8846         F4            mov	-$C[bp],al
11685                                           !BCC_EOS
11686                                           ! 2013     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
11687                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11688 3466           8A46         F4            mov	al,-$C[bp]
11689 3469           30E4                       xor	ah,ah
11690 346B           50                         push	ax
11691                                           ! Debug: list * unsigned short = const $254 (used reg = )
11692 346C           B8                   0254  mov	ax,#$254
11693 346F           50                         push	ax
11694                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11695 3470           FF76         FE            push	-2[bp]
11696                                           ! Debug: func () void = write_word+0 (used reg = )
11697 3473           E8         D1BC            call	_write_word
11698 3476           83C4                   06  add	sp,*6
11699                                           !BCC_EOS
11700                                           ! 2014     count--;
11701                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11702 3479           8B46         08            mov	ax,8[bp]
11703 347C           48                         dec	ax
11704 347D           8946         08            mov	8[bp],ax
11705                                           !BCC_EOS
11706                                           ! 2015     status = await_ide(2, iobase1, 32000u);
11707                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11708 3480           B8                   7D00  mov	ax,#$7D00
11709 3483           50                         push	ax
11710                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11711 3484           FF76         FC            push	-4[bp]
11712                                           ! Debug: list int = const 2 (used reg = )
11713 3487           B8                   0002  mov	ax,*2
11714 348A           50                         push	ax
11715                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
11716 348B           E8         E816            call	_await_ide
11717 348E           83C4                   06  add	sp,*6
11718                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11719 3491           8846         F5            mov	-$B[bp],al
11720                                           !BCC_EOS
11721                                           ! 2016     if (count == 0) {
11722                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11723 3494           8B46         08            mov	ax,8[bp]
11724 3497           85C0                       test	ax,ax
11725 3499           75           14            jne 	.276
11726                       0000349B            .277:
11727                                           ! 2017       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11728                                           ! 2018           != 0x40 ) {
11729                                           ! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
11730 349B           8A46         F5            mov	al,-$B[bp]
11731 349E           24                     E9  and	al,#$E9
11732                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11733 34A0           3C                     40  cmp	al,*$40
11734 34A2           74           07            je  	.278
11735                       000034A4            .279:
11736                                           ! 2019         ;
11737                                           !BCC_EOS
11738                                           ! 2020         return 6;
11739 34A4           B8                   0006  mov	ax,*6
11740 34A7           89EC                       mov	sp,bp
11741 34A9           5D                         pop	bp
11742 34AA           C3                         ret
11743                                           !BCC_EOS
11744                                           ! 2021         }
11745                                           ! 2022       break;
11746                       000034AB            .278:
11747 34AB           EB           17            jmp .273
11748                                           !BCC_EOS
11749                                           ! 2023       }
11750                                           ! 2024     else {
11751 34AD           EB           12            jmp .27A
11752                       000034AF            .276:
11753                                           ! 2025       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11754                                           ! 2026           != (0x40 | 0x08) ) {
11755                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11756 34AF           8A46         F5            mov	al,-$B[bp]
11757 34B2           24                     C9  and	al,#$C9
11758                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11759 34B4           3C                     48  cmp	al,*$48
11760 34B6           74           07            je  	.27B
11761                       000034B8            .27C:
11762                                           ! 2027         ;
11763                                           !BCC_EOS
11764                                           ! 2028         return 7;
11765 34B8           B8                   0007  mov	ax,*7
11766 34BB           89EC                       mov	sp,bp
11767 34BD           5D                         pop	bp
11768 34BE           C3                         ret
11769                                           !BCC_EOS
11770                                           ! 2029       }
11771                                           ! 2030       continue;
11772                       000034BF            .27B:
11773 34BF           EB           00            jmp .274
11774                                           !BCC_EOS
11775                                           ! 2031     }
11776                                           ! 2032   }
11777                       000034C1            .27A:
11778                                           ! 2033   outb(iobase2+6, 0x08);
11779                       000034C1            .274:
11780 34C1           E9         FF65            jmp	.275
11781                       000034C4            .27D:
11782                       000034C4            .273:
11783                                           ! Debug: list int = const 8 (used reg = )
11784 34C4           B8                   0008  mov	ax,*8
11785 34C7           50                         push	ax
11786                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11787 34C8           8B46         FA            mov	ax,-6[bp]
11788                                           ! Debug: list unsigned int = ax+6 (used reg = )
11789 34CB           05                   0006  add	ax,*6
11790 34CE           50                         push	ax
11791                                           ! Debug: func () void = outb+0 (used reg = )
11792 34CF           E8         D082            call	_outb
11793 34D2           83C4                   04  add	sp,*4
11794                                           !BCC_EOS
11795                                           ! 2034   return 0;
11796 34D5           31C0                       xor	ax,ax
11797 34D7           89EC                       mov	sp,bp
11798 34D9           5D                         pop	bp
11799 34DA           C3                         ret
11800                                           !BCC_EOS
11801                                           ! 2035 }
11802                                           ! 2036 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
11803                                           ! Register BX used in function ata_cmd_data_out
11804                                           ! 2037 Bit8u cmdlen,inout;
11805                                           export	_ata_cmd_packet
11806                       000034DB            _ata_cmd_packet:
11807                                           !BCC_EOS
11808                                           ! 2038 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
11809                                           !BCC_EOS
11810                                           ! 2039 Bit16u header;
11811                                           !BCC_EOS
11812                                           ! 2040 Bit32u length;
11813                                           !BCC_EOS
11814                                           ! 2041 {
11815                                           ! 2042   Bit16u ebda_seg=read_word(0x0040,0x000E);
11816 34DB           55                         push	bp
11817 34DC           89E5                       mov	bp,sp
11818 34DE           4C                         dec	sp
11819 34DF           4C                         dec	sp
11820                                           ! Debug: list int = const $E (used reg = )
11821 34E0           B8                   000E  mov	ax,*$E
11822 34E3           50                         push	ax
11823                                           ! Debug: list int = const $40 (used reg = )
11824 34E4           B8                   0040  mov	ax,*$40
11825 34E7           50                         push	ax
11826                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11827 34E8           E8         D11C            call	_read_word
11828 34EB           83C4                   04  add	sp,*4
11829                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11830 34EE           8946         FE            mov	-2[bp],ax
11831                                           !BCC_EOS
11832                                           ! 2043   Bit16u iobase1, iobase2;
11833                                           !BCC_EOS
11834                                           ! 2044   Bit16u lcount, lbefore, lafter, count;
11835                                           !BCC_EOS
11836                                           ! 2045   Bit8u channel, slave;
11837                                           !BCC_EOS
11838                                           ! 2046   Bit8u status, mode, lmode;
11839                                           !BCC_EOS
11840                                           ! 2047   Bit32u total, transfer;
11841                                           !BCC_EOS
11842                                           ! 2048   channel = device / 2;
11843 34F1           83C4                   E6  add	sp,*-$1A
11844                                           ! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11845 34F4           8B46         04            mov	ax,4[bp]
11846 34F7           D1E8                       shr	ax,*1
11847                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
11848 34F9           8846         F1            mov	-$F[bp],al
11849                                           !BCC_EOS
11850                                           ! 2049   slave = device % 2;
11851                                           ! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11852 34FC           8B46         04            mov	ax,4[bp]
11853 34FF           24                     01  and	al,*1
11854                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
11855 3501           8846         F0            mov	-$10[bp],al
11856                                           !BCC_EOS
11857                                           ! 2050   if (inout == 0x02) {
11858                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
11859 3504           8A46         12            mov	al,$12[bp]
11860 3507           3C                     02  cmp	al,*2
11861 3509           75           07            jne 	.27E
11862                       0000350B            .27F:
11863                                           ! 2051     ;
11864                                           !BCC_EOS
11865                                           ! 2052     return 1;
11866 350B           B8                   0001  mov	ax,*1
11867 350E           89EC                       mov	sp,bp
11868 3510           5D                         pop	bp
11869 3511           C3                         ret
11870                                           !BCC_EOS
11871                                           ! 2053     }
11872                                           ! 2054   if (header & 1) {
11873                       00003512            .27E:
11874                                           ! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
11875 3512           8A46         0C            mov	al,$C[bp]
11876 3515           24                     01  and	al,*1
11877 3517           84C0                       test	al,al
11878 3519           74           07            je  	.280
11879                       0000351B            .281:
11880                                           ! 2055     ;
11881                                           !BCC_EOS
11882                                           ! 2056     return 1;
11883 351B           B8                   0001  mov	ax,*1
11884 351E           89EC                       mov	sp,bp
11885 3520           5D                         pop	bp
11886 3521           C3                         ret
11887                                           !BCC_EOS
11888                                           ! 2057     }
11889                                           ! 2058   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11890                       00003522            .280:
11891                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
11892 3522           8A46         F1            mov	al,-$F[bp]
11893 3525           30E4                       xor	ah,ah
11894 3527           B1                     03  mov	cl,*3
11895 3529           D3E0                       shl	ax,cl
11896 352B           89C3                       mov	bx,ax
11897                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11898                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11899 352D           81C3                 0124  add	bx,#$124
11900 3531           53                         push	bx
11901                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
11902 3532           FF76         FE            push	-2[bp]
11903                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11904 3535           E8         D0CF            call	_read_word
11905 3538           83C4                   04  add	sp,*4
11906                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
11907 353B           8946         FC            mov	-4[bp],ax
11908                                           !BCC_EOS
11909                                           ! 2059   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11910                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
11911 353E           8A46         F1            mov	al,-$F[bp]
11912 3541           30E4                       xor	ah,ah
11913 3543           B1                     03  mov	cl,*3
11914 3545           D3E0                       shl	ax,cl
11915 3547           89C3                       mov	bx,ax
11916                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11917                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11918 3549           81C3                 0126  add	bx,#$126
11919 354D           53                         push	bx
11920                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
11921 354E           FF76         FE            push	-2[bp]
11922                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11923 3551           E8         D0B3            call	_read_word
11924 3554           83C4                   04  add	sp,*4
11925                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
11926 3557           8946         FA            mov	-6[bp],ax
11927                                           !BCC_EOS
11928                                           ! 2060   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11929                                           ! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
11930 355A           8B46         04            mov	ax,4[bp]
11931 355D           B9                   001E  mov	cx,*$1E
11932 3560           F7E9                       imul	cx
11933 3562           89C3                       mov	bx,ax
11934                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11935                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11936 3564           81C3                 0146  add	bx,#$146
11937 3568           53                         push	bx
11938                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
11939 3569           FF76         FE            push	-2[bp]
11940                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11941 356C           E8         D085            call	_read_byte
11942 356F           83C4                   04  add	sp,*4
11943                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
11944 3572           8846         EE            mov	-$12[bp],al
11945                                           !BCC_EOS
11946                                           ! 2061   transfer= 0L;
11947                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
11948 3575           31C0                       xor	ax,ax
11949 3577           31DB                       xor	bx,bx
11950 3579           8946         E4            mov	-$1C[bp],ax
11951 357C           895E         E6            mov	-$1A[bp],bx
11952                                           !BCC_EOS
11953                                           ! 2062   if (cmdlen < 12) cmdlen=12;
11954                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
11955 357F           8A46         06            mov	al,6[bp]
11956 3582           3C                     0C  cmp	al,*$C
11957 3584           73           05            jae 	.282
11958                       00003586            .283:
11959                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
11960 3586           B0                     0C  mov	al,*$C
11961 3588           8846         06            mov	6[bp],al
11962                                           !BCC_EOS
11963                                           ! 2063   if (cmdlen > 12) cmdlen=16;
11964                       0000358B            .282:
11965                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
11966 358B           8A46         06            mov	al,6[bp]
11967 358E           3C                     0C  cmp	al,*$C
11968 3590           76           05            jbe 	.284
11969                       00003592            .285:
11970                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
11971 3592           B0                     10  mov	al,*$10
11972 3594           8846         06            mov	6[bp],al
11973                                           !BCC_EOS
11974                                           ! 2064   cmdlen>>=1;
11975                       00003597            .284:
11976                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
11977 3597           8A46         06            mov	al,6[bp]
11978 359A           30E4                       xor	ah,ah
11979 359C           D1E8                       shr	ax,*1
11980 359E           8846         06            mov	6[bp],al
11981                                           !BCC_EOS
11982                                           ! 2065   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11983                                           ! Debug: list int = const 0 (used reg = )
11984 35A1           31C0                       xor	ax,ax
11985 35A3           50                         push	ax
11986                                           ! Debug: list * unsigned short = const $254 (used reg = )
11987 35A4           B8                   0254  mov	ax,#$254
11988 35A7           50                         push	ax
11989                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
11990 35A8           FF76         FE            push	-2[bp]
11991                                           ! Debug: func () void = write_word+0 (used reg = )
11992 35AB           E8         D084            call	_write_word
11993 35AE           83C4                   06  add	sp,*6
11994                                           !BCC_EOS
11995                                           ! 2066   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11996                                           ! Debug: list long = const 0 (used reg = )
11997 35B1           31C0                       xor	ax,ax
11998 35B3           31DB                       xor	bx,bx
11999 35B5           53                         push	bx
12000 35B6           50                         push	ax
12001                                           ! Debug: list * unsigned long = const $256 (used reg = )
12002 35B7           B8                   0256  mov	ax,#$256
12003 35BA           50                         push	ax
12004                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
12005 35BB           FF76         FE            push	-2[bp]
12006                                           ! Debug: func () void = write_dword+0 (used reg = )
12007 35BE           E8         CADA            call	_write_dword
12008 35C1           83C4                   08  add	sp,*8
12009                                           !BCC_EOS
12010                                           ! 2067   status = inb(iobase1 + 7);
12011                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12012 35C4           8B46         FC            mov	ax,-4[bp]
12013                                           ! Debug: list unsigned int = ax+7 (used reg = )
12014 35C7           05                   0007  add	ax,*7
12015 35CA           50                         push	ax
12016                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12017 35CB           E8         CF70            call	_inb
12018 35CE           44                         inc	sp
12019 35CF           44                         inc	sp
12020                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12021 35D0           8846         EF            mov	-$11[bp],al
12022                                           !BCC_EOS
12023                                           ! 2068   if (status & 0x80) return 2;
12024                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
12025 35D3           8A46         EF            mov	al,-$11[bp]
12026 35D6           24                     80  and	al,#$80
12027 35D8           84C0                       test	al,al
12028 35DA           74           07            je  	.286
12029                       000035DC            .287:
12030 35DC           B8                   0002  mov	ax,*2
12031 35DF           89EC                       mov	sp,bp
12032 35E1           5D                         pop	bp
12033 35E2           C3                         ret
12034                                           !BCC_EOS
12035                                           ! 2069   outb(iobase2 + 6, 0x08 | 0x02);
12036                       000035E3            .286:
12037                                           ! Debug: list int = const $A (used reg = )
12038 35E3           B8                   000A  mov	ax,*$A
12039 35E6           50                         push	ax
12040                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
12041 35E7           8B46         FA            mov	ax,-6[bp]
12042                                           ! Debug: list unsigned int = ax+6 (used reg = )
12043 35EA           05                   0006  add	ax,*6
12044 35ED           50                         push	ax
12045                                           ! Debug: func () void = outb+0 (used reg = )
12046 35EE           E8         CF63            call	_outb
12047 35F1           83C4                   04  add	sp,*4
12048                                           !BCC_EOS
12049                                           ! 2070   outb(iobase1 + 1, 0x00);
12050                                           ! Debug: list int = const 0 (used reg = )
12051 35F4           31C0                       xor	ax,ax
12052 35F6           50                         push	ax
12053                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
12054 35F7           8B46         FC            mov	ax,-4[bp]
12055                                           ! Debug: list unsigned int = ax+1 (used reg = )
12056 35FA           40                         inc	ax
12057 35FB           50                         push	ax
12058                                           ! Debug: func () void = outb+0 (used reg = )
12059 35FC           E8         CF55            call	_outb
12060 35FF           83C4                   04  add	sp,*4
12061                                           !BCC_EOS
12062                                           ! 2071   outb(iobase1 + 2, 0x00);
12063                                           ! Debug: list int = const 0 (used reg = )
12064 3602           31C0                       xor	ax,ax
12065 3604           50                         push	ax
12066                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
12067 3605           8B46         FC            mov	ax,-4[bp]
12068                                           ! Debug: list unsigned int = ax+2 (used reg = )
12069 3608           40                         inc	ax
12070 3609           40                         inc	ax
12071 360A           50                         push	ax
12072                                           ! Debug: func () void = outb+0 (used reg = )
12073 360B           E8         CF46            call	_outb
12074 360E           83C4                   04  add	sp,*4
12075                                           !BCC_EOS
12076                                           ! 2072   outb(iobase1 + 3, 0x00);
12077                                           ! Debug: list int = const 0 (used reg = )
12078 3611           31C0                       xor	ax,ax
12079 3613           50                         push	ax
12080                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
12081 3614           8B46         FC            mov	ax,-4[bp]
12082                                           ! Debug: list unsigned int = ax+3 (used reg = )
12083 3617           05                   0003  add	ax,*3
12084 361A           50                         push	ax
12085                                           ! Debug: func () void = outb+0 (used reg = )
12086 361B           E8         CF36            call	_outb
12087 361E           83C4                   04  add	sp,*4
12088                                           !BCC_EOS
12089                                           ! 2073   outb(iobase1 + 4, 0xfff0 & 0x00ff);
12090                                           ! Debug: list unsigned int = const $F0 (used reg = )
12091 3621           B8                   00F0  mov	ax,#$F0
12092 3624           50                         push	ax
12093                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
12094 3625           8B46         FC            mov	ax,-4[bp]
12095                                           ! Debug: list unsigned int = ax+4 (used reg = )
12096 3628           05                   0004  add	ax,*4
12097 362B           50                         push	ax
12098                                           ! Debug: func () void = outb+0 (used reg = )
12099 362C           E8         CF25            call	_outb
12100 362F           83C4                   04  add	sp,*4
12101                                           !BCC_EOS
12102                                           ! 2074   outb(iobase1 + 5, 0xfff0 >> 8);
12103                                           ! Debug: list unsigned int = const $FF (used reg = )
12104 3632           B8                   00FF  mov	ax,#$FF
12105 3635           50                         push	ax
12106                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
12107 3636           8B46         FC            mov	ax,-4[bp]
12108                                           ! Debug: list unsigned int = ax+5 (used reg = )
12109 3639           05                   0005  add	ax,*5
12110 363C           50                         push	ax
12111                                           ! Debug: func () void = outb+0 (used reg = )
12112 363D           E8         CF14            call	_outb
12113 3640           83C4                   04  add	sp,*4
12114                                           !BCC_EOS
12115                                           ! 2075   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
12116 3643           8A46         F0            mov	al,-$10[bp]
12117 3646           84C0                       test	al,al
12118 3648           74           04            je  	.288
12119                       0000364A            .289:
12120 364A           B0                     B0  mov	al,#$B0
12121 364C           EB           02            jmp .28A
12122                       0000364E            .288:
12123 364E           B0                     A0  mov	al,#$A0
12124                       00003650            .28A:
12125                                           ! Debug: list char = al+0 (used reg = )
12126 3650           30E4                       xor	ah,ah
12127 3652           50                         push	ax
12128                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
12129 3653           8B46         FC            mov	ax,-4[bp]
12130                                           ! Debug: list unsigned int = ax+6 (used reg = )
12131 3656           05                   0006  add	ax,*6
12132 3659           50                         push	ax
12133                                           ! Debug: func () void = outb+0 (used reg = )
12134 365A           E8         CEF7            call	_outb
12135 365D           83C4                   04  add	sp,*4
12136                                           !BCC_EOS
12137                                           ! 2076   outb(iobase1 + 7, 0xA0);
12138                                           ! Debug: list int = const $A0 (used reg = )
12139 3660           B8                   00A0  mov	ax,#$A0
12140 3663           50                         push	ax
12141                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
12142 3664           8B46         FC            mov	ax,-4[bp]
12143                                           ! Debug: list unsigned int = ax+7 (used reg = )
12144 3667           05                   0007  add	ax,*7
12145 366A           50                         push	ax
12146                                           ! Debug: func () void = outb+0 (used reg = )
12147 366B           E8         CEE6            call	_outb
12148 366E           83C4                   04  add	sp,*4
12149                                           !BCC_EOS
12150                                           ! 2077   status = await_ide(3, iobase1, 32000u);
12151                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12152 3671           B8                   7D00  mov	ax,#$7D00
12153 3674           50                         push	ax
12154                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12155 3675           FF76         FC            push	-4[bp]
12156                                           ! Debug: list int = const 3 (used reg = )
12157 3678           B8                   0003  mov	ax,*3
12158 367B           50                         push	ax
12159                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12160 367C           E8         E625            call	_await_ide
12161 367F           83C4                   06  add	sp,*6
12162                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12163 3682           8846         EF            mov	-$11[bp],al
12164                                           !BCC_EOS
12165                                           ! 2078   if (status & 0x01) {
12166                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
12167 3685           8A46         EF            mov	al,-$11[bp]
12168 3688           24                     01  and	al,*1
12169 368A           84C0                       test	al,al
12170 368C           74           09            je  	.28B
12171                       0000368E            .28C:
12172                                           ! 2079     ;
12173                                           !BCC_EOS
12174                                           ! 2080     return 3;
12175 368E           B8                   0003  mov	ax,*3
12176 3691           89EC                       mov	sp,bp
12177 3693           5D                         pop	bp
12178 3694           C3                         ret
12179                                           !BCC_EOS
12180                                           ! 2081     } else if ( !(status & 0x08) ) {
12181 3695           EB           10            jmp .28D
12182                       00003697            .28B:
12183                                           ! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
12184 3697           8A46         EF            mov	al,-$11[bp]
12185 369A           24                     08  and	al,*8
12186 369C           84C0                       test	al,al
12187 369E           75           07            jne 	.28E
12188                       000036A0            .28F:
12189                                           ! 2082     ;
12190                                           !BCC_EOS
12191                                           ! 2083     return 4;
12192 36A0           B8                   0004  mov	ax,*4
12193 36A3           89EC                       mov	sp,bp
12194 36A5           5D                         pop	bp
12195 36A6           C3                         ret
12196                                           !BCC_EOS
12197                                           ! 2084     }
12198                                           ! 2085   cmdseg += (cmdoff / 16);
12199                       000036A7            .28E:
12200                       000036A7            .28D:
12201                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12202 36A7           8B46         0A            mov	ax,$A[bp]
12203 36AA           B1                     04  mov	cl,*4
12204 36AC           D3E8                       shr	ax,cl
12205                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
12206 36AE           0346         08            add	ax,8[bp]
12207 36B1           8946         08            mov	8[bp],ax
12208                                           !BCC_EOS
12209                                           ! 2086 
12210                                           ! 2086   cmdoff %= 16;
12211                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12212 36B4           8B46         0A            mov	ax,$A[bp]
12213 36B7           24                     0F  and	al,*$F
12214 36B9           30E4                       xor	ah,ah
12215 36BB           8946         0A            mov	$A[bp],ax
12216                                           !BCC_EOS
12217                                           ! 2087 #asm
12218                                           !BCC_EOS
12219                                           !BCC_ASM
12220                       00000026            _ata_cmd_packet.cmdoff	set	$26
12221                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12222                       00000028            _ata_cmd_packet.header	set	$28
12223                       0000000C            .ata_cmd_packet.header	set	$C
12224                       0000000E            _ata_cmd_packet.count	set	$E
12225                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12226                       00000010            _ata_cmd_packet.lafter	set	$10
12227                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12228                       00000018            _ata_cmd_packet.iobase1	set	$18
12229                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12230                       0000000D            _ata_cmd_packet.channel	set	$D
12231                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12232                       00000024            _ata_cmd_packet.cmdseg	set	$24
12233                       00000008            .ata_cmd_packet.cmdseg	set	8
12234                       00000022            _ata_cmd_packet.cmdlen	set	$22
12235                       00000006            .ata_cmd_packet.cmdlen	set	6
12236                       00000009            _ata_cmd_packet.lmode	set	9
12237                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12238                       00000020            _ata_cmd_packet.device	set	$20
12239                       00000004            .ata_cmd_packet.device	set	4
12240                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
12241                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12242                       00000014            _ata_cmd_packet.lcount	set	$14
12243                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12244                       00000004            _ata_cmd_packet.total	set	4
12245                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12246                       0000000B            _ata_cmd_packet.status	set	$B
12247                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12248                       0000000A            _ata_cmd_packet.mode	set	$A
12249                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12250                       00000032            _ata_cmd_packet.bufoff	set	$32
12251                       00000016            .ata_cmd_packet.bufoff	set	$16
12252                       00000000            _ata_cmd_packet.transfer	set	0
12253                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12254                       00000016            _ata_cmd_packet.iobase2	set	$16
12255                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12256                       00000012            _ata_cmd_packet.lbefore	set	$12
12257                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12258                       00000030            _ata_cmd_packet.bufseg	set	$30
12259                       00000014            .ata_cmd_packet.bufseg	set	$14
12260                       0000000C            _ata_cmd_packet.slave	set	$C
12261                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12262                       0000002E            _ata_cmd_packet.inout	set	$2E
12263                       00000012            .ata_cmd_packet.inout	set	$12
12264                       0000002A            _ata_cmd_packet.length	set	$2A
12265                       0000000E            .ata_cmd_packet.length	set	$E
12266 36BE           FB                               sti ;; enable higher priority interrupts
12267 36BF           55                               push bp
12268 36C0           89E5                             mov bp, sp
12269 36C2           8B76         28                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
12270 36C5           8B46         26                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
12271 36C8           8B4E         24                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
12272 36CB           8EC0                             mov es, ax ;; segment in es
12273 36CD           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
12274 36D0           26                               seg ES
12275 36D1           F3                               rep
12276 36D2           6F                                 outsw ;; CX words transfered from port(DX) to ES:[SI]
12277 36D3           5D                               pop bp
12278                                           ! 2100 endasm
12279                                           !BCC_ENDASM
12280                                           !BCC_EOS
12281                                           ! 2101   if (inout == 0x00) {
12282                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
12283 36D4           8A46         12            mov	al,$12[bp]
12284 36D7           84C0                       test	al,al
12285 36D9           75           17            jne 	.290
12286                       000036DB            .291:
12287                                           ! 2102     status = await_ide(2, iobase1, 32000u);
12288                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12289 36DB           B8                   7D00  mov	ax,#$7D00
12290 36DE           50                         push	ax
12291                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12292 36DF           FF76         FC            push	-4[bp]
12293                                           ! Debug: list int = const 2 (used reg = )
12294 36E2           B8                   0002  mov	ax,*2
12295 36E5           50                         push	ax
12296                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12297 36E6           E8         E5BB            call	_await_ide
12298 36E9           83C4                   06  add	sp,*6
12299                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12300 36EC           8846         EF            mov	-$11[bp],al
12301                                           !BCC_EOS
12302                                           ! 2103     }
12303                                           ! 2104   else {
12304 36EF           E9         0272            br 	.292
12305                       000036F2            .290:
12306                                           ! 2105         Bit16u loops = 0;
12307 36F2           4C                         dec	sp
12308 36F3           4C                         dec	sp
12309                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
12310 36F4           31C0                       xor	ax,ax
12311 36F6           8946         E2            mov	-$1E[bp],ax
12312                                           !BCC_EOS
12313                                           ! 2106         Bit8u sc;
12314                                           !BCC_EOS
12315                                           ! 2107   while (1) {
12316 36F9           4C                         dec	sp
12317 36FA           4C                         dec	sp
12318                       000036FB            .295:
12319                                           ! 2108       if (loops == 0) {
12320                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
12321 36FB           8B46         E2            mov	ax,-$1E[bp]
12322 36FE           85C0                       test	ax,ax
12323 3700           75           25            jne 	.296
12324                       00003702            .297:
12325                                           ! 2109         status = inb(iobase2 + 6);
12326                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
12327 3702           8B46         FA            mov	ax,-6[bp]
12328                                           ! Debug: list unsigned int = ax+6 (used reg = )
12329 3705           05                   0006  add	ax,*6
12330 3708           50                         push	ax
12331                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12332 3709           E8         CE32            call	_inb
12333 370C           44                         inc	sp
12334 370D           44                         inc	sp
12335                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12336 370E           8846         EF            mov	-$11[bp],al
12337                                           !BCC_EOS
12338                                           ! 2110         status = await_ide(3, iobase1, 32000u);
12339                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12340 3711           B8                   7D00  mov	ax,#$7D00
12341 3714           50                         push	ax
12342                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12343 3715           FF76         FC            push	-4[bp]
12344                                           ! Debug: list int = const 3 (used reg = )
12345 3718           B8                   0003  mov	ax,*3
12346 371B           50                         push	ax
12347                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12348 371C           E8         E585            call	_await_ide
12349 371F           83C4                   06  add	sp,*6
12350                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12351 3722           8846         EF            mov	-$11[bp],al
12352                                           !BCC_EOS
12353                                           ! 2111       }
12354                                           ! 2112       else
12355                                           ! 2113         status = await_ide(2, iobase1, 32000u);
12356 3725           EB           14            jmp .298
12357                       00003727            .296:
12358                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12359 3727           B8                   7D00  mov	ax,#$7D00
12360 372A           50                         push	ax
12361                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12362 372B           FF76         FC            push	-4[bp]
12363                                           ! Debug: list int = const 2 (used reg = )
12364 372E           B8                   0002  mov	ax,*2
12365 3731           50                         push	ax
12366                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12367 3732           E8         E56F            call	_await_ide
12368 3735           83C4                   06  add	sp,*6
12369                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12370 3738           8846         EF            mov	-$11[bp],al
12371                                           !BCC_EOS
12372                                           ! 2114       loops++;
12373                       0000373B            .298:
12374                                           ! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
12375 373B           8B46         E2            mov	ax,-$1E[bp]
12376 373E           40                         inc	ax
12377 373F           8946         E2            mov	-$1E[bp],ax
12378                                           !BCC_EOS
12379                                           ! 2115       sc = inb(iobase1 + 2);
12380                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12381 3742           8B46         FC            mov	ax,-4[bp]
12382                                           ! Debug: list unsigned int = ax+2 (used reg = )
12383 3745           40                         inc	ax
12384 3746           40                         inc	ax
12385 3747           50                         push	ax
12386                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12387 3748           E8         CDF3            call	_inb
12388 374B           44                         inc	sp
12389 374C           44                         inc	sp
12390                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
12391 374D           8846         E1            mov	-$1F[bp],al
12392                                           !BCC_EOS
12393                                           ! 2116       if(((inb(iobase1 + 2)&0x7)==0x3) &&
12394                                           ! 2117          ((status & (0x40 | 0x01)) == 0x40)) break;
12395                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12396 3750           8B46         FC            mov	ax,-4[bp]
12397                                           ! Debug: list unsigned int = ax+2 (used reg = )
12398 3753           40                         inc	ax
12399 3754           40                         inc	ax
12400 3755           50                         push	ax
12401                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12402 3756           E8         CDE5            call	_inb
12403 3759           44                         inc	sp
12404 375A           44                         inc	sp
12405                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
12406 375B           24                     07  and	al,*7
12407                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
12408 375D           3C                     03  cmp	al,*3
12409 375F           75           0C            jne 	.299
12410                       00003761            .29B:
12411                                           ! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
12412 3761           8A46         EF            mov	al,-$11[bp]
12413 3764           24                     41  and	al,*$41
12414                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
12415 3766           3C                     40  cmp	al,*$40
12416 3768           75           03            jne 	.299
12417                       0000376A            .29A:
12418 376A           E9         01F4            br 	.293
12419                                           !BCC_EOS
12420                                           ! 2118       if (status & 0x01) {
12421                       0000376D            .299:
12422                                           ! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
12423 376D           8A46         EF            mov	al,-$11[bp]
12424 3770           24                     01  and	al,*1
12425 3772           84C0                       test	al,al
12426 3774           74           07            je  	.29C
12427                       00003776            .29D:
12428                                           ! 2119         ;
12429                                           !BCC_EOS
12430                                           ! 2120         return 3;
12431 3776           B8                   0003  mov	ax,*3
12432 3779           89EC                       mov	sp,bp
12433 377B           5D                         pop	bp
12434 377C           C3                         ret
12435                                           !BCC_EOS
12436                                           ! 2121       }
12437                                           ! 2122       bufseg += (bufoff / 16);
12438                       0000377D            .29C:
12439                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12440 377D           8B46         16            mov	ax,$16[bp]
12441 3780           B1                     04  mov	cl,*4
12442 3782           D3E8                       shr	ax,cl
12443                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
12444 3784           0346         14            add	ax,$14[bp]
12445 3787           8946         14            mov	$14[bp],ax
12446                                           !BCC_EOS
12447                                           ! 2123       bufoff %= 16;
12448                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12449 378A           8B46         16            mov	ax,$16[bp]
12450 378D           24                     0F  and	al,*$F
12451 378F           30E4                       xor	ah,ah
12452 3791           8946         16            mov	$16[bp],ax
12453                                           !BCC_EOS
12454                                           ! 2124       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
12455                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
12456 3794           8B46         FC            mov	ax,-4[bp]
12457                                           ! Debug: list unsigned int = ax+4 (used reg = )
12458 3797           05                   0004  add	ax,*4
12459 379A           50                         push	ax
12460                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12461 379B           E8         CDA0            call	_inb
12462 379E           44                         inc	sp
12463 379F           44                         inc	sp
12464 37A0           50                         push	ax
12465                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
12466 37A1           8B46         FC            mov	ax,-4[bp]
12467                                           ! Debug: list unsigned int = ax+5 (used reg = )
12468 37A4           05                   0005  add	ax,*5
12469 37A7           50                         push	ax
12470                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12471 37A8           E8         CD93            call	_inb
12472 37AB           44                         inc	sp
12473 37AC           44                         inc	sp
12474                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
12475 37AD           30E4                       xor	ah,ah
12476                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
12477 37AF           88C4                       mov	ah,al
12478 37B1           30C0                       xor	al,al
12479                                           ! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
12480 37B3           0246         DE            add	al,-$22[bp]
12481 37B6           80D4                   00  adc	ah,*0
12482 37B9           44                         inc	sp
12483 37BA           44                         inc	sp
12484                                           ! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
12485 37BB           8946         F8            mov	-8[bp],ax
12486                                           !BCC_EOS
12487                                           ! 2125       if(header>lcount) {
12488                                           ! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12489 37BE           8B46         0C            mov	ax,$C[bp]
12490 37C1           3B46         F8            cmp	ax,-8[bp]
12491 37C4           76           16            jbe 	.29E
12492                       000037C6            .29F:
12493                                           ! 2126          lbefore=lcount;
12494                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12495 37C6           8B46         F8            mov	ax,-8[bp]
12496 37C9           8946         F6            mov	-$A[bp],ax
12497                                           !BCC_EOS
12498                                           ! 2127          header-=lcount;
12499                                           ! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12500 37CC           8B46         0C            mov	ax,$C[bp]
12501 37CF           2B46         F8            sub	ax,-8[bp]
12502 37D2           8946         0C            mov	$C[bp],ax
12503                                           !BCC_EOS
12504                                           ! 2128          lcount=0;
12505                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12506 37D5           31C0                       xor	ax,ax
12507 37D7           8946         F8            mov	-8[bp],ax
12508                                           !BCC_EOS
12509                                           ! 2129          }
12510                                           ! 2130       else {
12511 37DA           EB           14            jmp .2A0
12512                       000037DC            .29E:
12513                                           ! 2131         lbefore=header;
12514                                           ! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12515 37DC           8B46         0C            mov	ax,$C[bp]
12516 37DF           8946         F6            mov	-$A[bp],ax
12517                                           !BCC_EOS
12518                                           ! 2132         header=0;
12519                                           ! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
12520 37E2           31C0                       xor	ax,ax
12521 37E4           8946         0C            mov	$C[bp],ax
12522                                           !BCC_EOS
12523                                           ! 2133         lcount-=lbefore;
12524                                           ! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12525 37E7           8B46         F8            mov	ax,-8[bp]
12526 37EA           2B46         F6            sub	ax,-$A[bp]
12527 37ED           8946         F8            mov	-8[bp],ax
12528                                           !BCC_EOS
12529                                           ! 2134         }
12530                                           ! 2135       if(lcount>length) {
12531                       000037F0            .2A0:
12532                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12533 37F0           8B46         F8            mov	ax,-8[bp]
12534 37F3           31DB                       xor	bx,bx
12535                                           ! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12536 37F5           8D7E         0E            lea	di,$E[bp]
12537 37F8           E8         C8D0            call	lcmpul
12538 37FB           76           20            jbe 	.2A1
12539                       000037FD            .2A2:
12540                                           ! 2136         lafter=lcount-length;
12541                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12542 37FD           8B46         F8            mov	ax,-8[bp]
12543 3800           31DB                       xor	bx,bx
12544                                           ! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12545 3802           8D7E         0E            lea	di,$E[bp]
12546 3805           E8         C8D9            call	lsubul
12547                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
12548 3808           8946         F4            mov	-$C[bp],ax
12549                                           !BCC_EOS
12550                                           ! 2137         lcount=length;
12551                                           ! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12552 380B           8B46         0E            mov	ax,$E[bp]
12553 380E           8946         F8            mov	-8[bp],ax
12554                                           !BCC_EOS
12555                                           ! 2138         length=0;
12556                                           ! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
12557 3811           31C0                       xor	ax,ax
12558 3813           31DB                       xor	bx,bx
12559 3815           8946         0E            mov	$E[bp],ax
12560 3818           895E         10            mov	$10[bp],bx
12561                                           !BCC_EOS
12562                                           ! 2139         }
12563                                           ! 2140       else {
12564 381B           EB           21            jmp .2A3
12565                       0000381D            .2A1:
12566                                           ! 2141         lafter=0;
12567                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12568 381D           31C0                       xor	ax,ax
12569 381F           8946         F4            mov	-$C[bp],ax
12570                                           !BCC_EOS
12571                                           ! 2142         length-=lcount;
12572                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12573 3822           8B46         F8            mov	ax,-8[bp]
12574 3825           31DB                       xor	bx,bx
12575                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
12576 3827           53                         push	bx
12577 3828           50                         push	ax
12578 3829           8B46         0E            mov	ax,$E[bp]
12579 382C           8B5E         10            mov	bx,$10[bp]
12580 382F           8D7E         DC            lea	di,-$24[bp]
12581 3832           E8         C8AC            call	lsubul
12582 3835           8946         0E            mov	$E[bp],ax
12583 3838           895E         10            mov	$10[bp],bx
12584 383B           83C4                   04  add	sp,*4
12585                                           !BCC_EOS
12586                                           ! 2143         }
12587                                           ! 2144       count = lcount;
12588                       0000383E            .2A3:
12589                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
12590 383E           8B46         F8            mov	ax,-8[bp]
12591 3841           8946         F2            mov	-$E[bp],ax
12592                                           !BCC_EOS
12593                                           ! 2145       ;
12594                                           !BCC_EOS
12595                                           ! 2146       ;
12596                                           !BCC_EOS
12597                                           ! 2147       lmode = mode;
12598                                           ! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
12599 3844           8A46         EE            mov	al,-$12[bp]
12600 3847           8846         ED            mov	-$13[bp],al
12601                                           !BCC_EOS
12602                                           ! 2148       if (lbefore & 0x03) lmode=0x00;
12603                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
12604 384A           8A46         F6            mov	al,-$A[bp]
12605 384D           24                     03  and	al,*3
12606 384F           84C0                       test	al,al
12607 3851           74           05            je  	.2A4
12608                       00003853            .2A5:
12609                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12610 3853           30C0                       xor	al,al
12611 3855           8846         ED            mov	-$13[bp],al
12612                                           !BCC_EOS
12613                                           ! 2149       if (lcount & 0x03) lmode=0x00;
12614                       00003858            .2A4:
12615                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
12616 3858           8A46         F8            mov	al,-8[bp]
12617 385B           24                     03  and	al,*3
12618 385D           84C0                       test	al,al
12619 385F           74           05            je  	.2A6
12620                       00003861            .2A7:
12621                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12622 3861           30C0                       xor	al,al
12623 3863           8846         ED            mov	-$13[bp],al
12624                                           !BCC_EOS
12625                                           ! 2150       if (lafter & 0x03) lmode=0x00;
12626                       00003866            .2A6:
12627                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
12628 3866           8A46         F4            mov	al,-$C[bp]
12629 3869           24                     03  and	al,*3
12630 386B           84C0                       test	al,al
12631 386D           74           05            je  	.2A8
12632                       0000386F            .2A9:
12633                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12634 386F           30C0                       xor	al,al
12635 3871           8846         ED            mov	-$13[bp],al
12636                                           !BCC_EOS
12637                                           ! 2151       if (lcount & 0x01) {
12638                       00003874            .2A8:
12639                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12640 3874           8A46         F8            mov	al,-8[bp]
12641 3877           24                     01  and	al,*1
12642 3879           84C0                       test	al,al
12643 387B           74           1E            je  	.2AA
12644                       0000387D            .2AB:
12645                                           ! 2152         lcount+=1;
12646                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12647 387D           8B46         F8            mov	ax,-8[bp]
12648 3880           40                         inc	ax
12649 3881           8946         F8            mov	-8[bp],ax
12650                                           !BCC_EOS
12651                                           ! 2153         if ((lafter > 0) && (lafter & 0x01)) {
12652                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12653 3884           8B46         F4            mov	ax,-$C[bp]
12654 3887           85C0                       test	ax,ax
12655 3889           74           10            je  	.2AC
12656                       0000388B            .2AE:
12657                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12658 388B           8A46         F4            mov	al,-$C[bp]
12659 388E           24                     01  and	al,*1
12660 3890           84C0                       test	al,al
12661 3892           74           07            je  	.2AC
12662                       00003894            .2AD:
12663                                           ! 2154           lafter-=1;
12664                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12665 3894           8B46         F4            mov	ax,-$C[bp]
12666 3897           48                         dec	ax
12667 3898           8946         F4            mov	-$C[bp],ax
12668                                           !BCC_EOS
12669                                           ! 2155           }
12670                                           ! 2156         }
12671                       0000389B            .2AC:
12672                                           ! 2157       if (lmode == 0x01) {
12673                       0000389B            .2AA:
12674                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
12675 389B           8A46         ED            mov	al,-$13[bp]
12676 389E           3C                     01  cmp	al,*1
12677 38A0           75           20            jne 	.2AF
12678                       000038A2            .2B0:
12679                                           ! 2158         lcount>>=2; lbefore>>=2; lafter>>=2;
12680                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
12681 38A2           8B46         F8            mov	ax,-8[bp]
12682 38A5           D1E8                       shr	ax,*1
12683 38A7           D1E8                       shr	ax,*1
12684 38A9           8946         F8            mov	-8[bp],ax
12685                                           !BCC_EOS
12686                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
12687 38AC           8B46         F6            mov	ax,-$A[bp]
12688 38AF           D1E8                       shr	ax,*1
12689 38B1           D1E8                       shr	ax,*1
12690 38B3           8946         F6            mov	-$A[bp],ax
12691                                           !BCC_EOS
12692                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
12693 38B6           8B46         F4            mov	ax,-$C[bp]
12694 38B9           D1E8                       shr	ax,*1
12695 38BB           D1E8                       shr	ax,*1
12696 38BD           8946         F4            mov	-$C[bp],ax
12697                                           !BCC_EOS
12698                                           ! 2159         }
12699                                           ! 2160       else {
12700 38C0           EB           18            jmp .2B1
12701                       000038C2            .2AF:
12702                                           ! 2161         lcount>>=1; lbefore>>=1; lafter>>=1;
12703                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12704 38C2           8B46         F8            mov	ax,-8[bp]
12705 38C5           D1E8                       shr	ax,*1
12706 38C7           8946         F8            mov	-8[bp],ax
12707                                           !BCC_EOS
12708                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
12709 38CA           8B46         F6            mov	ax,-$A[bp]
12710 38CD           D1E8                       shr	ax,*1
12711 38CF           8946         F6            mov	-$A[bp],ax
12712                                           !BCC_EOS
12713                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12714 38D2           8B46         F4            mov	ax,-$C[bp]
12715 38D5           D1E8                       shr	ax,*1
12716 38D7           8946         F4            mov	-$C[bp],ax
12717                                           !BCC_EOS
12718                                           ! 2162         }
12719                                           ! 2163        ;
12720                       000038DA            .2B1:
12721                                           !BCC_EOS
12722                                           ! 2164 #asm
12723                                           !BCC_EOS
12724                                           !BCC_ASM
12725                       0000002A            _ata_cmd_packet.cmdoff	set	$2A
12726                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12727                       0000002C            _ata_cmd_packet.header	set	$2C
12728                       0000000C            .ata_cmd_packet.header	set	$C
12729                       00000012            _ata_cmd_packet.count	set	$12
12730                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12731                       00000014            _ata_cmd_packet.lafter	set	$14
12732                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12733                       0000001C            _ata_cmd_packet.iobase1	set	$1C
12734                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12735                       00000011            _ata_cmd_packet.channel	set	$11
12736                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12737                       00000028            _ata_cmd_packet.cmdseg	set	$28
12738                       00000008            .ata_cmd_packet.cmdseg	set	8
12739                       00000026            _ata_cmd_packet.cmdlen	set	$26
12740                       00000006            .ata_cmd_packet.cmdlen	set	6
12741                       0000000D            _ata_cmd_packet.lmode	set	$D
12742                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12743                       00000024            _ata_cmd_packet.device	set	$24
12744                       00000004            .ata_cmd_packet.device	set	4
12745                       00000002            _ata_cmd_packet.loops	set	2
12746                       FFFFFFE2            .ata_cmd_packet.loops	set	-$1E
12747                       0000001E            _ata_cmd_packet.ebda_seg	set	$1E
12748                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12749                       00000018            _ata_cmd_packet.lcount	set	$18
12750                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12751                       00000008            _ata_cmd_packet.total	set	8
12752                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12753                       0000000F            _ata_cmd_packet.status	set	$F
12754                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12755                       0000000E            _ata_cmd_packet.mode	set	$E
12756                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12757                       00000036            _ata_cmd_packet.bufoff	set	$36
12758                       00000016            .ata_cmd_packet.bufoff	set	$16
12759                       00000004            _ata_cmd_packet.transfer	set	4
12760                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12761                       00000001            _ata_cmd_packet.sc	set	1
12762                       FFFFFFE1            .ata_cmd_packet.sc	set	-$1F
12763                       0000001A            _ata_cmd_packet.iobase2	set	$1A
12764                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12765                       00000016            _ata_cmd_packet.lbefore	set	$16
12766                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12767                       00000034            _ata_cmd_packet.bufseg	set	$34
12768                       00000014            .ata_cmd_packet.bufseg	set	$14
12769                       00000010            _ata_cmd_packet.slave	set	$10
12770                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12771                       00000032            _ata_cmd_packet.inout	set	$32
12772                       00000012            .ata_cmd_packet.inout	set	$12
12773                       0000002E            _ata_cmd_packet.length	set	$2E
12774                       0000000E            .ata_cmd_packet.length	set	$E
12775 38DA           55                                 push bp
12776 38DB           89E5                               mov bp, sp
12777 38DD           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
12778 38E0           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
12779 38E3           E3           15                    jcxz ata_packet_no_before
12780 38E5           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12781 38E8           80FC                   01          cmp ah, #0x01
12782 38EB           74           05                    je ata_packet_in_before_32
12783                       000038ED            ata_packet_in_before_16:
12784 38ED           ED                                 in ax, dx
12785 38EE           E2           FD                    loop ata_packet_in_before_16
12786 38F0           EB           08                    jmp ata_packet_no_before
12787                       000038F2            ata_packet_in_before_32:
12788 38F2     66    50                                 push eax
12789                       000038F4            ata_packet_in_before_32_loop:
12790 38F4     66    ED                                 in eax, dx
12791 38F6           E2           FC                    loop ata_packet_in_before_32_loop
12792 38F8     66    58                                 pop eax
12793                       000038FA            ata_packet_no_before:
12794 38FA           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
12795 38FD           E3           17                    jcxz ata_packet_after
12796 38FF           8B7E         38                    mov di, _ata_cmd_packet.bufoff + 2[bp]
12797 3902           8B46         36                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
12798 3905           8EC0                               mov es, ax
12799 3907           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12800 390A           80FC                   01          cmp ah, #0x01
12801 390D           74           04                    je ata_packet_in_32
12802                       0000390F            ata_packet_in_16:
12803 390F           F3                                 rep
12804 3910           6D                                   insw ;; CX words transfered tp port(DX) to ES:[DI]
12805 3911           EB           03                    jmp ata_packet_after
12806                       00003913            ata_packet_in_32:
12807 3913           F3                                 rep
12808 3914     66    6D                                   insd ;; CX dwords transfered to port(DX) to ES:[DI]
12809                       00003916            ata_packet_after:
12810 3916           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
12811 3919           E3           15                    jcxz ata_packet_done
12812 391B           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12813 391E           80FC                   01          cmp ah, #0x01
12814 3921           74           05                    je ata_packet_in_after_32
12815                       00003923            ata_packet_in_after_16:
12816 3923           ED                                 in ax, dx
12817 3924           E2           FD                    loop ata_packet_in_after_16
12818 3926           EB           08                    jmp ata_packet_done
12819                       00003928            ata_packet_in_after_32:
12820 3928     66    50                                 push eax
12821                       0000392A            ata_packet_in_after_32_loop:
12822 392A     66    ED                                 in eax, dx
12823 392C           E2           FC                    loop ata_packet_in_after_32_loop
12824 392E     66    58                                 pop eax
12825                       00003930            ata_packet_done:
12826 3930           5D                                 pop bp
12827                                           ! 2217 endasm
12828                                           !BCC_ENDASM
12829                                           !BCC_EOS
12830                                           ! 2218       bufoff += count;
12831                                           ! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
12832 3931           8B46         16            mov	ax,$16[bp]
12833 3934           0346         F2            add	ax,-$E[bp]
12834 3937           8946         16            mov	$16[bp],ax
12835                                           !BCC_EOS
12836                                           ! 2219       transfer += count;
12837                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
12838 393A           8B46         F2            mov	ax,-$E[bp]
12839 393D           31DB                       xor	bx,bx
12840                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
12841 393F           8D7E         E4            lea	di,-$1C[bp]
12842 3942           E8         C77E            call	laddul
12843 3945           8946         E4            mov	-$1C[bp],ax
12844 3948           895E         E6            mov	-$1A[bp],bx
12845                                           !BCC_EOS
12846                                           ! 2220       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
12847                                           ! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
12848 394B           FF76         E6            push	-$1A[bp]
12849 394E           FF76         E4            push	-$1C[bp]
12850                                           ! Debug: list * unsigned long = const $256 (used reg = )
12851 3951           B8                   0256  mov	ax,#$256
12852 3954           50                         push	ax
12853                                           ! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
12854 3955           FF76         FE            push	-2[bp]
12855                                           ! Debug: func () void = write_dword+0 (used reg = )
12856 3958           E8         C740            call	_write_dword
12857 395B           83C4                   08  add	sp,*8
12858                                           !BCC_EOS
12859                                           ! 2221       }
12860                                           ! 2222     }
12861                       0000395E            .294:
12862 395E           E9         FD9A            br 	.295
12863                       00003961            .2B2:
12864                       00003961            .293:
12865 3961           83C4                   04  add	sp,*4
12866                                           ! 2223   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
12867                       00003964            .292:
12868                                           ! 2224          != 0x40 ) {
12869                                           ! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
12870 3964           8A46         EF            mov	al,-$11[bp]
12871 3967           24                     E9  and	al,#$E9
12872                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
12873 3969           3C                     40  cmp	al,*$40
12874 396B           74           07            je  	.2B3
12875                       0000396D            .2B4:
12876                                           ! 2225     ;
12877                                           !BCC_EOS
12878                                           ! 2226     return 4;
12879 396D           B8                   0004  mov	ax,*4
12880 3970           89EC                       mov	sp,bp
12881 3972           5D                         pop	bp
12882 3973           C3                         ret
12883                                           !BCC_EOS
12884                                           ! 2227     }
12885                                           ! 2228   outb(iobase2+6, 0x08);
12886                       00003974            .2B3:
12887                                           ! Debug: list int = const 8 (used reg = )
12888 3974           B8                   0008  mov	ax,*8
12889 3977           50                         push	ax
12890                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
12891 3978           8B46         FA            mov	ax,-6[bp]
12892                                           ! Debug: list unsigned int = ax+6 (used reg = )
12893 397B           05                   0006  add	ax,*6
12894 397E           50                         push	ax
12895                                           ! Debug: func () void = outb+0 (used reg = )
12896 397F           E8         CBD2            call	_outb
12897 3982           83C4                   04  add	sp,*4
12898                                           !BCC_EOS
12899                                           ! 2229   return 0;
12900 3985           31C0                       xor	ax,ax
12901 3987           89EC                       mov	sp,bp
12902 3989           5D                         pop	bp
12903 398A           C3                         ret
12904                                           !BCC_EOS
12905                                           ! 2230 }
12906                                           ! 2231   Bit16u
12907                                           ! Register BX used in function ata_cmd_packet
12908                                           ! 2232 atapi_get_sense(device, seg, asc, ascq)
12909                                           ! 2233   Bit16u device;
12910                                           export	_atapi_get_sense
12911                       0000398B            _atapi_get_sense:
12912                                           !BCC_EOS
12913                                           ! 2234 {
12914                                           ! 2235   Bit8u atacmd[12];
12915                                           !BCC_EOS
12916                                           ! 2236   Bit8u buffer[18];
12917                                           !BCC_EOS
12918                                           ! 2237   Bit8u i;
12919                                           !BCC_EOS
12920                                           ! 2238   memsetb(get_SS(),atacmd,0,12);
12921 398B           55                         push	bp
12922 398C           89E5                       mov	bp,sp
12923 398E           83C4                   E0  add	sp,*-$20
12924                                           ! Debug: list int = const $C (used reg = )
12925 3991           B8                   000C  mov	ax,*$C
12926 3994           50                         push	ax
12927                                           ! Debug: list int = const 0 (used reg = )
12928 3995           31C0                       xor	ax,ax
12929 3997           50                         push	ax
12930                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
12931 3998           8D5E         F4            lea	bx,-$C[bp]
12932 399B           53                         push	bx
12933                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12934 399C           E8         CCAE            call	_get_SS
12935                                           ! Debug: list unsigned short = ax+0 (used reg = )
12936 399F           50                         push	ax
12937                                           ! Debug: func () void = memsetb+0 (used reg = )
12938 39A0           E8         C65D            call	_memsetb
12939 39A3           83C4                   08  add	sp,*8
12940                                           !BCC_EOS
12941                                           ! 2239   atacmd[0]=0x03;
12942                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
12943 39A6           B0                     03  mov	al,*3
12944 39A8           8846         F4            mov	-$C[bp],al
12945                                           !BCC_EOS
12946                                           ! 2240   atacmd[4]=sizeof(buffer);
12947                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
12948 39AB           B0                     12  mov	al,*$12
12949 39AD           8846         F8            mov	-8[bp],al
12950                                           !BCC_EOS
12951                                           ! 2241   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
12952                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
12953 39B0           8D5E         E2            lea	bx,-$1E[bp]
12954 39B3           53                         push	bx
12955                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12956 39B4           E8         CC96            call	_get_SS
12957                                           ! Debug: list unsigned short = ax+0 (used reg = )
12958 39B7           50                         push	ax
12959                                           ! Debug: list int = const 1 (used reg = )
12960 39B8           B8                   0001  mov	ax,*1
12961 39BB           50                         push	ax
12962                                           ! Debug: list long = const $12 (used reg = )
12963 39BC           B8                   0012  mov	ax,*$12
12964 39BF           31DB                       xor	bx,bx
12965 39C1           53                         push	bx
12966 39C2           50                         push	ax
12967                                           ! Debug: list int = const 0 (used reg = )
12968 39C3           31C0                       xor	ax,ax
12969 39C5           50                         push	ax
12970                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
12971 39C6           8D5E         F4            lea	bx,-$C[bp]
12972 39C9           53                         push	bx
12973                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12974 39CA           E8         CC80            call	_get_SS
12975                                           ! Debug: list unsigned short = ax+0 (used reg = )
12976 39CD           50                         push	ax
12977                                           ! Debug: list int = const $C (used reg = )
12978 39CE           B8                   000C  mov	ax,*$C
12979 39D1           50                         push	ax
12980                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
12981 39D2           FF76         04            push	4[bp]
12982                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12983 39D5           E8         FB03            call	_ata_cmd_packet
12984 39D8           83C4                   14  add	sp,*$14
12985                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12986 39DB           85C0                       test	ax,ax
12987 39DD           74           07            je  	.2B5
12988                       000039DF            .2B6:
12989                                           ! 2242     return 0x0002;
12990 39DF           B8                   0002  mov	ax,*2
12991 39E2           89EC                       mov	sp,bp
12992 39E4           5D                         pop	bp
12993 39E5           C3                         ret
12994                                           !BCC_EOS
12995                                           ! 2243   write_byte(seg,asc,buffer[12]);
12996                       000039E6            .2B5:
12997                                           ! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
12998 39E6           8A46         EE            mov	al,-$12[bp]
12999 39E9           30E4                       xor	ah,ah
13000 39EB           50                         push	ax
13001                                           ! Debug: list int asc = [S+$24+6] (used reg = )
13002 39EC           FF76         08            push	8[bp]
13003                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13004 39EF           FF76         06            push	6[bp]
13005                                           ! Debug: func () void = write_byte+0 (used reg = )
13006 39F2           E8         CC25            call	_write_byte
13007 39F5           83C4                   06  add	sp,*6
13008                                           !BCC_EOS
13009                                           ! 2244   write
13010                                           ! 2244 _byte(seg,ascq,buffer[13]);
13011                                           ! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
13012 39F8           8A46         EF            mov	al,-$11[bp]
13013 39FB           30E4                       xor	ah,ah
13014 39FD           50                         push	ax
13015                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
13016 39FE           FF76         0A            push	$A[bp]
13017                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13018 3A01           FF76         06            push	6[bp]
13019                                           ! Debug: func () void = write_byte+0 (used reg = )
13020 3A04           E8         CC13            call	_write_byte
13021 3A07           83C4                   06  add	sp,*6
13022                                           !BCC_EOS
13023                                           ! 2245   return 0;
13024 3A0A           31C0                       xor	ax,ax
13025 3A0C           89EC                       mov	sp,bp
13026 3A0E           5D                         pop	bp
13027 3A0F           C3                         ret
13028                                           !BCC_EOS
13029                                           ! 2246 }
13030                                           ! 2247   Bit16u
13031                                           ! Register BX used in function atapi_get_sense
13032                                           ! 2248 atapi_is_ready(device)
13033                                           ! 2249   Bit16u device;
13034                                           export	_atapi_is_ready
13035                       00003A10            _atapi_is_ready:
13036                                           !BCC_EOS
13037                                           ! 2250 {
13038                                           ! 2251   Bit8u packet[12];
13039                                           !BCC_EOS
13040                                           ! 2252   Bit8u buf[8];
13041                                           !BCC_EOS
13042                                           ! 2253   Bit32u block_len;
13043                                           !BCC_EOS
13044                                           ! 2254   Bit32u sectors;
13045                                           !BCC_EOS
13046                                           ! 2255   Bit32u timeout;
13047                                           !BCC_EOS
13048                                           ! 2256   Bit32u time;
13049                                           !BCC_EOS
13050                                           ! 2257   Bit8u asc, ascq;
13051                                           !BCC_EOS
13052                                           ! 2258   Bit8u in_progress;
13053                                           !BCC_EOS
13054                                           ! 2259   Bit16u ebda_seg = read_word(0x0040,0x000E);
13055 3A10           55                         push	bp
13056 3A11           89E5                       mov	bp,sp
13057 3A13           83C4                   D6  add	sp,*-$2A
13058                                           ! Debug: list int = const $E (used reg = )
13059 3A16           B8                   000E  mov	ax,*$E
13060 3A19           50                         push	ax
13061                                           ! Debug: list int = const $40 (used reg = )
13062 3A1A           B8                   0040  mov	ax,*$40
13063 3A1D           50                         push	ax
13064                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13065 3A1E           E8         CBE6            call	_read_word
13066 3A21           83C4                   04  add	sp,*4
13067                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
13068 3A24           8946         D6            mov	-$2A[bp],ax
13069                                           !BCC_EOS
13070                                           ! 2260   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
13071                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13072 3A27           8B46         04            mov	ax,4[bp]
13073 3A2A           B9                   001E  mov	cx,*$1E
13074 3A2D           F7E9                       imul	cx
13075 3A2F           89C3                       mov	bx,ax
13076                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13077                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13078 3A31           81C3                 0142  add	bx,#$142
13079 3A35           53                         push	bx
13080                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13081 3A36           FF76         D6            push	-$2A[bp]
13082                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13083 3A39           E8         CBB8            call	_read_byte
13084 3A3C           83C4                   04  add	sp,*4
13085                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13086 3A3F           3C                     03  cmp	al,*3
13087 3A41           74           15            je  	.2B7
13088                       00003A43            .2B8:
13089                                           ! 2261     bios_printf(2, "not implemented for non-ATAPI device\n");
13090                                           ! Debug: list * char = .2B9+0 (used reg = )
13091 3A43           BB                   D347  mov	bx,#.2B9
13092 3A46           53                         push	bx
13093                                           ! Debug: list int = const 2 (used reg = )
13094 3A47           B8                   0002  mov	ax,*2
13095 3A4A           50                         push	ax
13096                                           ! Debug: func () void = bios_printf+0 (used reg = )
13097 3A4B           E8         CFCD            call	_bios_printf
13098 3A4E           83C4                   04  add	sp,*4
13099                                           !BCC_EOS
13100                                           ! 2262     return -1;
13101 3A51           B8                   FFFF  mov	ax,#$FFFF
13102 3A54           89EC                       mov	sp,bp
13103 3A56           5D                         pop	bp
13104 3A57           C3                         ret
13105                                           !BCC_EOS
13106                                           ! 2263   }
13107                                           ! 2264   ;
13108                       00003A58            .2B7:
13109                                           !BCC_EOS
13110                                           ! 2265   memsetb(get_SS(),packet, 0, sizeof packet);
13111                                           ! Debug: list int = const $C (used reg = )
13112 3A58           B8                   000C  mov	ax,*$C
13113 3A5B           50                         push	ax
13114                                           ! Debug: list int = const 0 (used reg = )
13115 3A5C           31C0                       xor	ax,ax
13116 3A5E           50                         push	ax
13117                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
13118 3A5F           8D5E         F4            lea	bx,-$C[bp]
13119 3A62           53                         push	bx
13120                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13121 3A63           E8         CBE7            call	_get_SS
13122                                           ! Debug: list unsigned short = ax+0 (used reg = )
13123 3A66           50                         push	ax
13124                                           ! Debug: func () void = memsetb+0 (used reg = )
13125 3A67           E8         C596            call	_memsetb
13126 3A6A           83C4                   08  add	sp,*8
13127                                           !BCC_EOS
13128                                           ! 2266   packet[0] = 0x25;
13129                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
13130 3A6D           B0                     25  mov	al,*$25
13131 3A6F           8846         F4            mov	-$C[bp],al
13132                                           !BCC_EOS
13133                                           ! 2267   timeout = 5000;
13134                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
13135 3A72           B8                   1388  mov	ax,#$1388
13136 3A75           31DB                       xor	bx,bx
13137 3A77           8946         E0            mov	-$20[bp],ax
13138 3A7A           895E         E2            mov	-$1E[bp],bx
13139                                           !BCC_EOS
13140                                           ! 2268   time = 0;
13141                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
13142 3A7D           31C0                       xor	ax,ax
13143 3A7F           31DB                       xor	bx,bx
13144 3A81           8946         DC            mov	-$24[bp],ax
13145 3A84           895E         DE            mov	-$22[bp],bx
13146                                           !BCC_EOS
13147                                           ! 2269   in_progress = 0;
13148                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13149 3A87           30C0                       xor	al,al
13150 3A89           8846         D9            mov	-$27[bp],al
13151                                           !BCC_EOS
13152                                           ! 2270   while (time < timeout) {
13153 3A8C           E9         00AB            br 	.2BB
13154                       00003A8F            .2BC:
13155                                           ! 2271     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
13156                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
13157 3A8F           8D5E         EC            lea	bx,-$14[bp]
13158 3A92           53                         push	bx
13159                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13160 3A93           E8         CBB7            call	_get_SS
13161                                           ! Debug: list unsigned short = ax+0 (used reg = )
13162 3A96           50                         push	ax
13163                                           ! Debug: list int = const 1 (used reg = )
13164 3A97           B8                   0001  mov	ax,*1
13165 3A9A           50                         push	ax
13166                                           ! Debug: list long = const 8 (used reg = )
13167 3A9B           B8                   0008  mov	ax,*8
13168 3A9E           31DB                       xor	bx,bx
13169 3AA0           53                         push	bx
13170 3AA1           50                         push	ax
13171                                           ! Debug: list int = const 0 (used reg = )
13172 3AA2           31C0                       xor	ax,ax
13173 3AA4           50                         push	ax
13174                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
13175 3AA5           8D5E         F4            lea	bx,-$C[bp]
13176 3AA8           53                         push	bx
13177                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13178 3AA9           E8         CBA1            call	_get_SS
13179                                           ! Debug: list unsigned short = ax+0 (used reg = )
13180 3AAC           50                         push	ax
13181                                           ! Debug: list int = const $C (used reg = )
13182 3AAD           B8                   000C  mov	ax,*$C
13183 3AB0           50                         push	ax
13184                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
13185 3AB1           FF76         04            push	4[bp]
13186                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13187 3AB4           E8         FA24            call	_ata_cmd_packet
13188 3AB7           83C4                   14  add	sp,*$14
13189                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13190 3ABA           85C0                       test	ax,ax
13191 3ABC           75           06            jne 	.2BD
13192                       00003ABE            .2BE:
13193                                           ! 2272       goto ok;
13194 3ABE           83C4                   00  add	sp,#..FFFA+$2C
13195 3AC1           E9         008D            br 	.FFFA
13196                                           !BCC_EOS
13197                                           ! 2273     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
13198                       00003AC4            .2BD:
13199                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
13200 3AC4           8D5E         DA            lea	bx,-$26[bp]
13201 3AC7           53                         push	bx
13202                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
13203 3AC8           8D5E         DB            lea	bx,-$25[bp]
13204 3ACB           53                         push	bx
13205                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13206 3ACC           E8         CB7E            call	_get_SS
13207                                           ! Debug: list unsigned short = ax+0 (used reg = )
13208 3ACF           50                         push	ax
13209                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
13210 3AD0           FF76         04            push	4[bp]
13211                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
13212 3AD3           E8         FEB5            call	_atapi_get_sense
13213 3AD6           83C4                   08  add	sp,*8
13214                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13215 3AD9           85C0                       test	ax,ax
13216 3ADB           75           41            jne 	.2BF
13217                       00003ADD            .2C0:
13218                                           ! 2274       if (asc == 0x3a) {
13219                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
13220 3ADD           8A46         DB            mov	al,-$25[bp]
13221 3AE0           3C                     3A  cmp	al,*$3A
13222 3AE2           75           07            jne 	.2C1
13223                       00003AE4            .2C2:
13224                                           ! 2275         ;
13225                                           !BCC_EOS
13226                                           ! 2276         return -1;
13227 3AE4           B8                   FFFF  mov	ax,#$FFFF
13228 3AE7           89EC                       mov	sp,bp
13229 3AE9           5D                         pop	bp
13230 3AEA           C3                         ret
13231                                           !BCC_EOS
13232                                           ! 2277       }
13233                                           ! 2278       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
13234                       00003AEB            .2C1:
13235                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
13236 3AEB           8A46         DB            mov	al,-$25[bp]
13237 3AEE           3C                     04  cmp	al,*4
13238 3AF0           75           2C            jne 	.2C3
13239                       00003AF2            .2C6:
13240                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
13241 3AF2           8A46         DA            mov	al,-$26[bp]
13242 3AF5           3C                     01  cmp	al,*1
13243 3AF7           75           25            jne 	.2C3
13244                       00003AF9            .2C5:
13245 3AF9           8A46         D9            mov	al,-$27[bp]
13246 3AFC           84C0                       test	al,al
13247 3AFE           75           1E            jne 	.2C3
13248                       00003B00            .2C4:
13249                                           ! 2279         bios_printf(2, "Waiting for device to detect medium... ");
13250                                           ! Debug: list * char = .2C7+0 (used reg = )
13251 3B00           BB                   D31F  mov	bx,#.2C7
13252 3B03           53                         push	bx
13253                                           ! Debug: list int = const 2 (used reg = )
13254 3B04           B8                   0002  mov	ax,*2
13255 3B07           50                         push	ax
13256                                           ! Debug: func () void = bios_printf+0 (used reg = )
13257 3B08           E8         CF10            call	_bios_printf
13258 3B0B           83C4                   04  add	sp,*4
13259                                           !BCC_EOS
13260                                           ! 2280         timeout = 30000;
13261                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
13262 3B0E           B8                   7530  mov	ax,#$7530
13263 3B11           31DB                       xor	bx,bx
13264 3B13           8946         E0            mov	-$20[bp],ax
13265 3B16           895E         E2            mov	-$1E[bp],bx
13266                                           !BCC_EOS
13267                                           ! 2281         in_progress = 1;
13268                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13269 3B19           B0                     01  mov	al,*1
13270 3B1B           8846         D9            mov	-$27[bp],al
13271                                           !BCC_EOS
13272                                           ! 2282       }
13273                                           ! 2283     }
13274                       00003B1E            .2C3:
13275                                           ! 2284     time += 100;
13276                       00003B1E            .2BF:
13277                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
13278 3B1E           B8                   0064  mov	ax,*$64
13279 3B21           31DB                       xor	bx,bx
13280 3B23           53                         push	bx
13281 3B24           50                         push	ax
13282 3B25           8B46         DC            mov	ax,-$24[bp]
13283 3B28           8B5E         DE            mov	bx,-$22[bp]
13284 3B2B           8D7E         D2            lea	di,-$2E[bp]
13285 3B2E           E8         C592            call	laddul
13286 3B31           8946         DC            mov	-$24[bp],ax
13287 3B34           895E         DE            mov	-$22[bp],bx
13288 3B37           83C4                   04  add	sp,*4
13289                                           !BCC_EOS
13290                                           ! 2285   }
13291                                           ! 2286   ;
13292                       00003B3A            .2BB:
13293                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
13294 3B3A           8B46         E0            mov	ax,-$20[bp]
13295 3B3D           8B5E         E2            mov	bx,-$1E[bp]
13296 3B40           8D7E         DC            lea	di,-$24[bp]
13297 3B43           E8         C585            call	lcmpul
13298 3B46         0F87         FF45            bhi 	.2BC
13299                       00003B4A            .2C8:
13300                       00003B4A            .2BA:
13301                                           !BCC_EOS
13302                                           ! 2287   return -1;
13303 3B4A           B8                   FFFF  mov	ax,#$FFFF
13304 3B4D           89EC                       mov	sp,bp
13305 3B4F           5D                         pop	bp
13306 3B50           C3                         ret
13307                                           !BCC_EOS
13308                                           ! 2288 ok:
13309                       00003B51            .FFFA:
13310                       FFFFFFD4            ..FFFA	=	-$2C
13311                                           ! 2289   block_len = (Bit32u) buf[4] << 24
13312                                           ! 2290     | (Bit32u) buf[5] << 16
13313                                           ! 2291     | (Bit32u) buf[6] << 8
13314                                           ! 2292     | (Bit32u) buf[7] << 0;
13315                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
13316 3B51           8A46         F3            mov	al,-$D[bp]
13317 3B54           30E4                       xor	ah,ah
13318 3B56           31DB                       xor	bx,bx
13319                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13320 3B58           53                         push	bx
13321 3B59           50                         push	ax
13322                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
13323 3B5A           8A46         F2            mov	al,-$E[bp]
13324 3B5D           30E4                       xor	ah,ah
13325 3B5F           31DB                       xor	bx,bx
13326                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13327 3B61           88DF                       mov	bh,bl
13328 3B63           88E3                       mov	bl,ah
13329 3B65           88C4                       mov	ah,al
13330 3B67           30C0                       xor	al,al
13331 3B69           53                         push	bx
13332 3B6A           50                         push	ax
13333                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
13334 3B6B           8A46         F1            mov	al,-$F[bp]
13335 3B6E           30E4                       xor	ah,ah
13336 3B70           31DB                       xor	bx,bx
13337                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13338 3B72           93                         xchg	bx,ax
13339 3B73           31C0                       xor	ax,ax
13340 3B75           53                         push	bx
13341 3B76           50                         push	ax
13342                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
13343 3B77           8A46         F0            mov	al,-$10[bp]
13344 3B7A           30E4                       xor	ah,ah
13345 3B7C           31DB                       xor	bx,bx
13346                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13347 3B7E           88C4                       mov	ah,al
13348 3B80           30C0                       xor	al,al
13349 3B82           93                         xchg	bx,ax
13350 3B83           31C0                       xor	ax,ax
13351                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13352 3B85           8D7E         CA            lea	di,-$36[bp]
13353 3B88           E8         C57C            call	lorul
13354 3B8B           83C4                   04  add	sp,*4
13355                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13356 3B8E           8D7E         CE            lea	di,-$32[bp]
13357 3B91           E8         C573            call	lorul
13358 3B94           83C4                   04  add	sp,*4
13359                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13360 3B97           8D7E         D2            lea	di,-$2E[bp]
13361 3B9A           E8         C56A            call	lorul
13362 3B9D           83C4                   04  add	sp,*4
13363                                           ! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13364 3BA0           8946         E8            mov	-$18[bp],ax
13365 3BA3           895E         EA            mov	-$16[bp],bx
13366                                           !BCC_EOS
13367                                           ! 2293   ;
13368                                           !BCC_EOS
13369                                           ! 2294   if (block_len!= 2048 && block_len!= 512)
13370                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13371                                           ! Debug: expression subtree swapping
13372 3BA6           B8                   0800  mov	ax,#$800
13373 3BA9           31DB                       xor	bx,bx
13374 3BAB           53                         push	bx
13375 3BAC           50                         push	ax
13376 3BAD           8B46         E8            mov	ax,-$18[bp]
13377 3BB0           8B5E         EA            mov	bx,-$16[bp]
13378 3BB3           8D7E         D2            lea	di,-$2E[bp]
13379 3BB6           E8         C512            call	lcmpul
13380 3BB9           8D66         D6            lea	sp,-$2A[bp]
13381 3BBC           74           33            je  	.2C9
13382                       00003BBE            .2CB:
13383                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13384                                           ! Debug: expression subtree swapping
13385 3BBE           B8                   0200  mov	ax,#$200
13386 3BC1           31DB                       xor	bx,bx
13387 3BC3           53                         push	bx
13388 3BC4           50                         push	ax
13389 3BC5           8B46         E8            mov	ax,-$18[bp]
13390 3BC8           8B5E         EA            mov	bx,-$16[bp]
13391 3BCB           8D7E         D2            lea	di,-$2E[bp]
13392 3BCE           E8         C4FA            call	lcmpul
13393 3BD1           8D66         D6            lea	sp,-$2A[bp]
13394 3BD4           74           1B            je  	.2C9
13395                       00003BD6            .2CA:
13396                                           ! 2295   {
13397                                           ! 2296     bios_printf(2, "Unsupported sector size %u\n", block_len);
13398                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13399 3BD6           FF76         EA            push	-$16[bp]
13400 3BD9           FF76         E8            push	-$18[bp]
13401                                           ! Debug: list * char = .2CC+0 (used reg = )
13402 3BDC           BB                   D303  mov	bx,#.2CC
13403 3BDF           53                         push	bx
13404                                           ! Debug: list int = const 2 (used reg = )
13405 3BE0           B8                   0002  mov	ax,*2
13406 3BE3           50                         push	ax
13407                                           ! Debug: func () void = bios_printf+0 (used reg = )
13408 3BE4           E8         CE34            call	_bios_printf
13409 3BE7           83C4                   08  add	sp,*8
13410                                           !BCC_EOS
13411                                           ! 2297     return -1;
13412 3BEA           B8                   FFFF  mov	ax,#$FFFF
13413 3BED           89EC                       mov	sp,bp
13414 3BEF           5D                         pop	bp
13415 3BF0           C3                         ret
13416                                           !BCC_EOS
13417                                           ! 2298   }
13418                                           ! 2299   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
13419                       00003BF1            .2C9:
13420                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13421 3BF1           FF76         EA            push	-$16[bp]
13422 3BF4           FF76         E8            push	-$18[bp]
13423                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13424 3BF7           8B46         04            mov	ax,4[bp]
13425 3BFA           B9                   001E  mov	cx,*$1E
13426 3BFD           F7E9                       imul	cx
13427 3BFF           89C3                       mov	bx,ax
13428                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
13429                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
13430 3C01           81C3                 0148  add	bx,#$148
13431 3C05           53                         push	bx
13432                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13433 3C06           FF76         D6            push	-$2A[bp]
13434                                           ! Debug: func () void = write_dword+0 (used reg = )
13435 3C09           E8         C48F            call	_write_dword
13436 3C0C           83C4                   08  add	sp,*8
13437                                           !BCC_EOS
13438                                           ! 2300   sectors = (Bit32u) buf[0] << 24
13439                                           ! 2301     | (Bit32u) buf[1] << 16
13440                                           ! 2302     | (Bit32u) buf[2] << 8
13441                                           ! 2303     | (Bit32u) buf[3] << 0;
13442                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
13443 3C0F           8A46         EF            mov	al,-$11[bp]
13444 3C12           30E4                       xor	ah,ah
13445 3C14           31DB                       xor	bx,bx
13446                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13447 3C16           53                         push	bx
13448 3C17           50                         push	ax
13449                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
13450 3C18           8A46         EE            mov	al,-$12[bp]
13451 3C1B           30E4                       xor	ah,ah
13452 3C1D           31DB                       xor	bx,bx
13453                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13454 3C1F           88DF                       mov	bh,bl
13455 3C21           88E3                       mov	bl,ah
13456 3C23           88C4                       mov	ah,al
13457 3C25           30C0                       xor	al,al
13458 3C27           53                         push	bx
13459 3C28           50                         push	ax
13460                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
13461 3C29           8A46         ED            mov	al,-$13[bp]
13462 3C2C           30E4                       xor	ah,ah
13463 3C2E           31DB                       xor	bx,bx
13464                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13465 3C30           93                         xchg	bx,ax
13466 3C31           31C0                       xor	ax,ax
13467 3C33           53                         push	bx
13468 3C34           50                         push	ax
13469                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
13470 3C35           8A46         EC            mov	al,-$14[bp]
13471 3C38           30E4                       xor	ah,ah
13472 3C3A           31DB                       xor	bx,bx
13473                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13474 3C3C           88C4                       mov	ah,al
13475 3C3E           30C0                       xor	al,al
13476 3C40           93                         xchg	bx,ax
13477 3C41           31C0                       xor	ax,ax
13478                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13479 3C43           8D7E         CA            lea	di,-$36[bp]
13480 3C46           E8         C4BE            call	lorul
13481 3C49           83C4                   04  add	sp,*4
13482                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13483 3C4C           8D7E         CE            lea	di,-$32[bp]
13484 3C4F           E8         C4B5            call	lorul
13485 3C52           83C4                   04  add	sp,*4
13486                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13487 3C55           8D7E         D2            lea	di,-$2E[bp]
13488 3C58           E8         C4AC            call	lorul
13489 3C5B           83C4                   04  add	sp,*4
13490                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13491 3C5E           8946         E4            mov	-$1C[bp],ax
13492 3C61           895E         E6            mov	-$1A[bp],bx
13493                                           !BCC_EOS
13494                                           ! 2304   ;
13495                                           !BCC_EOS
13496                                           ! 2305   if (block_len == 2048)
13497                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13498                                           ! Debug: expression subtree swapping
13499 3C64           B8                   0800  mov	ax,#$800
13500 3C67           31DB                       xor	bx,bx
13501 3C69           53                         push	bx
13502 3C6A           50                         push	ax
13503 3C6B           8B46         E8            mov	ax,-$18[bp]
13504 3C6E           8B5E         EA            mov	bx,-$16[bp]
13505 3C71           8D7E         D2            lea	di,-$2E[bp]
13506 3C74           E8         C454            call	lcmpul
13507 3C77           8D66         D6            lea	sp,-$2A[bp]
13508 3C7A           75           12            jne 	.2CD
13509                       00003C7C            .2CE:
13510                                           ! 2306     sectors <<= 2;
13511                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13512 3C7C           8B46         E4            mov	ax,-$1C[bp]
13513 3C7F           8B5E         E6            mov	bx,-$1A[bp]
13514 3C82           BF                   0002  mov	di,*2
13515 3C85           E8         C4BF            call	lslul
13516 3C88           8946         E4            mov	-$1C[bp],ax
13517 3C8B           895E         E6            mov	-$1A[bp],bx
13518                                           !BCC_EOS
13519                                           ! 2307   if (sectors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
13520                       00003C8E            .2CD:
13521                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13522 3C8E           8B46         04            mov	ax,4[bp]
13523 3C91           B9                   001E  mov	cx,*$1E
13524 3C94           F7E9                       imul	cx
13525 3C96           89C3                       mov	bx,ax
13526                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13527                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13528 3C98           81C3                 0158  add	bx,#$158
13529 3C9C           53                         push	bx
13530                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13531 3C9D           FF76         D6            push	-$2A[bp]
13532                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
13533 3CA0           E8         C3E0            call	_read_dword
13534 3CA3           89D3                       mov	bx,dx
13535 3CA5           83C4                   04  add	sp,*4
13536                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13537                                           ! Debug: expression subtree swapping
13538 3CA8           8D7E         E4            lea	di,-$1C[bp]
13539 3CAB           E8         C41D            call	lcmpul
13540 3CAE           74           24            je  	.2CF
13541                       00003CB0            .2D0:
13542                                           ! 2308     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
13543                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
13544 3CB0           8B46         E4            mov	ax,-$1C[bp]
13545 3CB3           8B5E         E6            mov	bx,-$1A[bp]
13546 3CB6           88E0                       mov	al,ah
13547 3CB8           88DC                       mov	ah,bl
13548 3CBA           88FB                       mov	bl,bh
13549 3CBC           28FF                       sub	bh,bh
13550 3CBE           BF                   0003  mov	di,*3
13551 3CC1           E8         C465            call	lsrul
13552                                           ! Debug: list unsigned long = bx+0 (used reg = )
13553 3CC4           53                         push	bx
13554 3CC5           50                         push	ax
13555                                           ! Debug: list * char = .2D1+0 (used reg = )
13556 3CC6           BB                   D2ED  mov	bx,#.2D1
13557 3CC9           53                         push	bx
13558                                           ! Debug: list int = const 2 (used reg = )
13559 3CCA           B8                   0002  mov	ax,*2
13560 3CCD           50                         push	ax
13561                                           ! Debug: func () void = bios_printf+0 (used reg = )
13562 3CCE           E8         CD4A            call	_bios_printf
13563 3CD1           83C4                   08  add	sp,*8
13564                                           !BCC_EOS
13565                                           ! 2309   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
13566                       00003CD4            .2CF:
13567                                           ! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
13568 3CD4           FF76         E6            push	-$1A[bp]
13569 3CD7           FF76         E4            push	-$1C[bp]
13570                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13571 3CDA           8B46         04            mov	ax,4[bp]
13572 3CDD           B9                   001E  mov	cx,*$1E
13573 3CE0           F7E9                       imul	cx
13574 3CE2           89C3                       mov	bx,ax
13575                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13576                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13577 3CE4           81C3                 0158  add	bx,#$158
13578 3CE8           53                         push	bx
13579                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13580 3CE9           FF76         D6            push	-$2A[bp]
13581                                           ! Debug: func () void = write_dword+0 (used reg = )
13582 3CEC           E8         C3AC            call	_write_dword
13583 3CEF           83C4                   08  add	sp,*8
13584                                           !BCC_EOS
13585                                           ! 2310   return 0;
13586 3CF2           31C0                       xor	ax,ax
13587 3CF4           89EC                       mov	sp,bp
13588 3CF6           5D                         pop	bp
13589 3CF7           C3                         ret
13590                                           !BCC_EOS
13591                                           ! 2311 }
13592                                           ! 2312   Bit16u
13593                                           ! Register BX used in function atapi_is_ready
13594                                           ! 2313 atapi_is_cdrom(device)
13595                                           ! 2314   Bit8u device;
13596                                           export	_atapi_is_cdrom
13597                       00003CF8            _atapi_is_cdrom:
13598                                           !BCC_EOS
13599                                           ! 2315 {
13600                                           ! 2316   Bit16u ebda_seg=read_word(0x0040,0x000E);
13601 3CF8           55                         push	bp
13602 3CF9           89E5                       mov	bp,sp
13603 3CFB           4C                         dec	sp
13604 3CFC           4C                         dec	sp
13605                                           ! Debug: list int = const $E (used reg = )
13606 3CFD           B8                   000E  mov	ax,*$E
13607 3D00           50                         push	ax
13608                                           ! Debug: list int = const $40 (used reg = )
13609 3D01           B8                   0040  mov	ax,*$40
13610 3D04           50                         push	ax
13611                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13612 3D05           E8         C8FF            call	_read_word
13613 3D08           83C4                   04  add	sp,*4
13614                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13615 3D0B           8946         FE            mov	-2[bp],ax
13616                                           !BCC_EOS
13617                                           ! 2317   if (device >= (4*2))
13618                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
13619 3D0E           8A46         04            mov	al,4[bp]
13620 3D11           3C                     08  cmp	al,*8
13621 3D13           72           06            jb  	.2D2
13622                       00003D15            .2D3:
13623                                           ! 2318     return 0;
13624 3D15           31C0                       xor	ax,ax
13625 3D17           89EC                       mov	sp,bp
13626 3D19           5D                         pop	bp
13627 3D1A           C3                         ret
13628                                           !BCC_EOS
13629                                           ! 2319   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
13630                       00003D1B            .2D2:
13631                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13632 3D1B           8A46         04            mov	al,4[bp]
13633 3D1E           30E4                       xor	ah,ah
13634 3D20           B9                   001E  mov	cx,*$1E
13635 3D23           F7E9                       imul	cx
13636 3D25           89C3                       mov	bx,ax
13637                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13638                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13639 3D27           81C3                 0142  add	bx,#$142
13640 3D2B           53                         push	bx
13641                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13642 3D2C           FF76         FE            push	-2[bp]
13643                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13644 3D2F           E8         C8C2            call	_read_byte
13645 3D32           83C4                   04  add	sp,*4
13646                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13647 3D35           3C                     03  cmp	al,*3
13648 3D37           74           06            je  	.2D4
13649                       00003D39            .2D5:
13650                                           ! 2320     retu
13651                                           ! 2320 rn 0;
13652 3D39           31C0                       xor	ax,ax
13653 3D3B           89EC                       mov	sp,bp
13654 3D3D           5D                         pop	bp
13655 3D3E           C3                         ret
13656                                           !BCC_EOS
13657                                           ! 2321   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
13658                       00003D3F            .2D4:
13659                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13660 3D3F           8A46         04            mov	al,4[bp]
13661 3D42           30E4                       xor	ah,ah
13662 3D44           B9                   001E  mov	cx,*$1E
13663 3D47           F7E9                       imul	cx
13664 3D49           89C3                       mov	bx,ax
13665                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
13666                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
13667 3D4B           81C3                 0143  add	bx,#$143
13668 3D4F           53                         push	bx
13669                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13670 3D50           FF76         FE            push	-2[bp]
13671                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13672 3D53           E8         C89E            call	_read_byte
13673 3D56           83C4                   04  add	sp,*4
13674                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
13675 3D59           3C                     05  cmp	al,*5
13676 3D5B           74           06            je  	.2D6
13677                       00003D5D            .2D7:
13678                                           ! 2322     return 0;
13679 3D5D           31C0                       xor	ax,ax
13680 3D5F           89EC                       mov	sp,bp
13681 3D61           5D                         pop	bp
13682 3D62           C3                         ret
13683                                           !BCC_EOS
13684                                           ! 2323   return 1;
13685                       00003D63            .2D6:
13686 3D63           B8                   0001  mov	ax,*1
13687 3D66           89EC                       mov	sp,bp
13688 3D68           5D                         pop	bp
13689 3D69           C3                         ret
13690                                           !BCC_EOS
13691                                           ! 2324 }
13692                                           ! 2325   void
13693                                           ! Register BX used in function atapi_is_cdrom
13694                                           ! 2326 cdemu_init()
13695                                           ! 2327 {
13696                                           export	_cdemu_init
13697                       00003D6A            _cdemu_init:
13698                                           ! 2328   Bit16u ebda_seg=read_word(0x0040,0x000E);
13699 3D6A           55                         push	bp
13700 3D6B           89E5                       mov	bp,sp
13701 3D6D           4C                         dec	sp
13702 3D6E           4C                         dec	sp
13703                                           ! Debug: list int = const $E (used reg = )
13704 3D6F           B8                   000E  mov	ax,*$E
13705 3D72           50                         push	ax
13706                                           ! Debug: list int = const $40 (used reg = )
13707 3D73           B8                   0040  mov	ax,*$40
13708 3D76           50                         push	ax
13709                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13710 3D77           E8         C88D            call	_read_word
13711 3D7A           83C4                   04  add	sp,*4
13712                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13713 3D7D           8946         FE            mov	-2[bp],ax
13714                                           !BCC_EOS
13715                                           ! 2329   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
13716                                           ! Debug: list int = const 0 (used reg = )
13717 3D80           31C0                       xor	ax,ax
13718 3D82           50                         push	ax
13719                                           ! Debug: list * unsigned char = const $25A (used reg = )
13720 3D83           B8                   025A  mov	ax,#$25A
13721 3D86           50                         push	ax
13722                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
13723 3D87           FF76         FE            push	-2[bp]
13724                                           ! Debug: func () void = write_byte+0 (used reg = )
13725 3D8A           E8         C88D            call	_write_byte
13726 3D8D           83C4                   06  add	sp,*6
13727                                           !BCC_EOS
13728                                           ! 2330 }
13729 3D90           89EC                       mov	sp,bp
13730 3D92           5D                         pop	bp
13731 3D93           C3                         ret
13732                                           ! 2331   Bit8u
13733                                           ! 2332 cdemu_isactive()
13734                                           ! 2333 {
13735                                           export	_cdemu_isactive
13736                       00003D94            _cdemu_isactive:
13737                                           ! 2334   Bit16u ebda_seg=read_word(0x0040,0x000E);
13738 3D94           55                         push	bp
13739 3D95           89E5                       mov	bp,sp
13740 3D97           4C                         dec	sp
13741 3D98           4C                         dec	sp
13742                                           ! Debug: list int = const $E (used reg = )
13743 3D99           B8                   000E  mov	ax,*$E
13744 3D9C           50                         push	ax
13745                                           ! Debug: list int = const $40 (used reg = )
13746 3D9D           B8                   0040  mov	ax,*$40
13747 3DA0           50                         push	ax
13748                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13749 3DA1           E8         C863            call	_read_word
13750 3DA4           83C4                   04  add	sp,*4
13751                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13752 3DA7           8946         FE            mov	-2[bp],ax
13753                                           !BCC_EOS
13754                                           ! 2335   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
13755                                           ! Debug: list * unsigned char = const $25A (used reg = )
13756 3DAA           B8                   025A  mov	ax,#$25A
13757 3DAD           50                         push	ax
13758                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13759 3DAE           FF76         FE            push	-2[bp]
13760                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13761 3DB1           E8         C840            call	_read_byte
13762 3DB4           83C4                   04  add	sp,*4
13763                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13764 3DB7           89EC                       mov	sp,bp
13765 3DB9           5D                         pop	bp
13766 3DBA           C3                         ret
13767                                           !BCC_EOS
13768                                           ! 2336 }
13769                                           ! 2337   Bit8u
13770                                           ! 2338 cdemu_emulated_drive()
13771                                           ! 2339 {
13772                                           export	_cdemu_emulated_drive
13773                       00003DBB            _cdemu_emulated_drive:
13774                                           ! 2340   Bit16u ebda_seg=read_word(0x0040,0x000E);
13775 3DBB           55                         push	bp
13776 3DBC           89E5                       mov	bp,sp
13777 3DBE           4C                         dec	sp
13778 3DBF           4C                         dec	sp
13779                                           ! Debug: list int = const $E (used reg = )
13780 3DC0           B8                   000E  mov	ax,*$E
13781 3DC3           50                         push	ax
13782                                           ! Debug: list int = const $40 (used reg = )
13783 3DC4           B8                   0040  mov	ax,*$40
13784 3DC7           50                         push	ax
13785                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13786 3DC8           E8         C83C            call	_read_word
13787 3DCB           83C4                   04  add	sp,*4
13788                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13789 3DCE           8946         FE            mov	-2[bp],ax
13790                                           !BCC_EOS
13791                                           ! 2341   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
13792                                           ! Debug: list * unsigned char = const $25C (used reg = )
13793 3DD1           B8                   025C  mov	ax,#$25C
13794 3DD4           50                         push	ax
13795                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13796 3DD5           FF76         FE            push	-2[bp]
13797                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13798 3DD8           E8         C819            call	_read_byte
13799 3DDB           83C4                   04  add	sp,*4
13800                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13801 3DDE           89EC                       mov	sp,bp
13802 3DE0           5D                         pop	bp
13803 3DE1           C3                         ret
13804                                           !BCC_EOS
13805                                           ! 2342 }
13806                                           ! 2343 static char isotag[6]="CD001";
13807                                           
13808                       00003DE2            _isotag:
13809                       00003DE2            .2D8:
13810 3DE2                        43            .ascii	"CD001"
13811 3DE7                        00            .byte	0
13812                                           !BCC_EOS
13813                                           ! 2344 static char eltorito[24]="EL TORITO SPECIFICATION";
13814                       00003DE8            _eltorito:
13815                       00003DE8            .2D9:
13816 3DE8                        45            .ascii	"EL TORITO SPECIFICATION"
13817 3DFF                        00            .byte	0
13818                                           !BCC_EOS
13819                                           ! 2345   Bit16u
13820                                           ! 2346 cdrom_boot()
13821                                           ! 2347 {
13822                                           
13823                                           export	_cdrom_boot
13824                       00003E00            _cdrom_boot:
13825                                           ! 2348   Bit16u ebda_seg=read_word(0x0040,0x000E);
13826 3E00           55                         push	bp
13827 3E01           89E5                       mov	bp,sp
13828 3E03           4C                         dec	sp
13829 3E04           4C                         dec	sp
13830                                           ! Debug: list int = const $E (used reg = )
13831 3E05           B8                   000E  mov	ax,*$E
13832 3E08           50                         push	ax
13833                                           ! Debug: list int = const $40 (used reg = )
13834 3E09           B8                   0040  mov	ax,*$40
13835 3E0C           50                         push	ax
13836                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13837 3E0D           E8         C7F7            call	_read_word
13838 3E10           83C4                   04  add	sp,*4
13839                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13840 3E13           8946         FE            mov	-2[bp],ax
13841                                           !BCC_EOS
13842                                           ! 2349   Bit8u atacmd[12], buffer[2048];
13843                                           !BCC_EOS
13844                                           ! 2350   Bit32u lba;
13845                                           !BCC_EOS
13846                                           ! 2351   Bit16u boot_segment, nbsectors, i, error;
13847                                           !BCC_EOS
13848                                           ! 2352   Bit8u device;
13849                                           !BCC_EOS
13850                                           ! 2353   for (device=0; device<(4*2);device++) {
13851 3E16           81C4                 F7E6  add	sp,#-$81A
13852                                           ! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
13853 3E1A           30C0                       xor	al,al
13854 3E1C           8886       F7E5            mov	-$81B[bp],al
13855                                           !BCC_EOS
13856                                           !BCC_EOS
13857 3E20           EB           1B            jmp .2DC
13858                       00003E22            .2DD:
13859                                           ! 2354     if (atapi_is_cdrom(device)) break;
13860                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
13861 3E22           8A86       F7E5            mov	al,-$81B[bp]
13862 3E26           30E4                       xor	ah,ah
13863 3E28           50                         push	ax
13864                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
13865 3E29           E8         FECC            call	_atapi_is_cdrom
13866 3E2C           44                         inc	sp
13867 3E2D           44                         inc	sp
13868 3E2E           85C0                       test	ax,ax
13869 3E30           74           02            je  	.2DE
13870                       00003E32            .2DF:
13871 3E32           EB           11            jmp .2DA
13872                                           !BCC_EOS
13873                                           ! 2355     }
13874                       00003E34            .2DE:
13875                                           ! 2356   if(device >= (4*2)) return 2;
13876                       00003E34            .2DB:
13877                                           ! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
13878 3E34           8A86       F7E5            mov	al,-$81B[bp]
13879 3E38           40                         inc	ax
13880 3E39           8886       F7E5            mov	-$81B[bp],al
13881                       00003E3D            .2DC:
13882                                           ! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
13883 3E3D           8A86       F7E5            mov	al,-$81B[bp]
13884 3E41           3C                     08  cmp	al,*8
13885 3E43           72           DD            jb 	.2DD
13886                       00003E45            .2E0:
13887                       00003E45            .2DA:
13888                                           ! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
13889 3E45           8A86       F7E5            mov	al,-$81B[bp]
13890 3E49           3C                     08  cmp	al,*8
13891 3E4B           72           07            jb  	.2E1
13892                       00003E4D            .2E2:
13893 3E4D           B8                   0002  mov	ax,*2
13894 3E50           89EC                       mov	sp,bp
13895 3E52           5D                         pop	bp
13896 3E53           C3                         ret
13897                                           !BCC_EOS
13898                                           ! 2357   if(error = atapi_is_ready(device) != 0)
13899                       00003E54            .2E1:
13900                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
13901 3E54           8A86       F7E5            mov	al,-$81B[bp]
13902 3E58           30E4                       xor	ah,ah
13903 3E5A           50                         push	ax
13904                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
13905 3E5B           E8         FBB2            call	_atapi_is_ready
13906 3E5E           44                         inc	sp
13907 3E5F           44                         inc	sp
13908                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13909 3E60           85C0                       test	ax,ax
13910 3E62           74           04            je 	.2E5
13911 3E64           B0                     01  mov	al,*1
13912 3E66           EB           02            jmp	.2E6
13913                       00003E68            .2E5:
13914 3E68           30C0                       xor	al,al
13915                       00003E6A            .2E6:
13916                                           ! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
13917 3E6A           30E4                       xor	ah,ah
13918 3E6C           8986       F7E6            mov	-$81A[bp],ax
13919 3E70           85C0                       test	ax,ax
13920 3E72           74           00            je  	.2E3
13921                       00003E74            .2E4:
13922                                           ! 2358     ;
13923                                           !BCC_EOS
13924                                           ! 2359   memsetb(get_SS(),atacmd,0,12);
13925                       00003E74            .2E3:
13926                                           ! Debug: list int = const $C (used reg = )
13927 3E74           B8                   000C  mov	ax,*$C
13928 3E77           50                         push	ax
13929                                           ! Debug: list int = const 0 (used reg = )
13930 3E78           31C0                       xor	ax,ax
13931 3E7A           50                         push	ax
13932                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
13933 3E7B           8D5E         F2            lea	bx,-$E[bp]
13934 3E7E           53                         push	bx
13935                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13936 3E7F           E8         C7CB            call	_get_SS
13937                                           ! Debug: list unsigned short = ax+0 (used reg = )
13938 3E82           50                         push	ax
13939                                           ! Debug: func () void = memsetb+0 (used reg = )
13940 3E83           E8         C17A            call	_memsetb
13941 3E86           83C4                   08  add	sp,*8
13942                                           !BCC_EOS
13943                                           ! 2360   atacmd[0]=0x28;
13944                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
13945 3E89           B0                     28  mov	al,*$28
13946 3E8B           8846         F2            mov	-$E[bp],al
13947                                           !BCC_EOS
13948                                           ! 2361   atacmd[7]=(0x01 & 0xff00) >> 8;
13949                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
13950 3E8E           30C0                       xor	al,al
13951 3E90           8846         F9            mov	-7[bp],al
13952                                           !BCC_EOS
13953                                           ! 2362   atacmd[8]=(0x01 & 0x00ff);
13954                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
13955 3E93           B0                     01  mov	al,*1
13956 3E95           8846         FA            mov	-6[bp],al
13957                                           !BCC_EOS
13958                                           ! 2363   atacmd[2]=(0x11 & 0xff000000) >> 24;
13959                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
13960 3E98           30C0                       xor	al,al
13961 3E9A           8846         F4            mov	-$C[bp],al
13962                                           !BCC_EOS
13963                                           ! 2364   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
13964                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
13965 3E9D           30C0                       xor	al,al
13966 3E9F           8846         F5            mov	-$B[bp],al
13967                                           !BCC_EOS
13968                                           ! 2365   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
13969                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
13970 3EA2           30C0                       xor	al,al
13971 3EA4           8846         F6            mov	-$A[bp],al
13972                                           !BCC_EOS
13973                                           ! 2366   atacmd[5]=(0x11 & 0x000000ff);
13974                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
13975 3EA7           B0                     11  mov	al,*$11
13976 3EA9           8846         F7            mov	-9[bp],al
13977                                           !BCC_EOS
13978                                           ! 2367   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
13979                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
13980 3EAC           8D9E       F7F2            lea	bx,-$80E[bp]
13981 3EB0           53                         push	bx
13982                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13983 3EB1           E8         C799            call	_get_SS
13984                                           ! Debug: list unsigned short = ax+0 (used reg = )
13985 3EB4           50                         push	ax
13986                                           ! Debug: list int = const 1 (used reg = )
13987 3EB5           B8                   0001  mov	ax,*1
13988 3EB8           50                         push	ax
13989                                           ! Debug: list long = const $800 (used reg = )
13990 3EB9           B8                   0800  mov	ax,#$800
13991 3EBC           31DB                       xor	bx,bx
13992 3EBE           53                         push	bx
13993 3EBF           50                         push	ax
13994                                           ! Debug: list int = const 0 (used reg = )
13995 3EC0           31C0                       xor	ax,ax
13996 3EC2           50                         push	ax
13997                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
13998 3EC3           8D5E         F2            lea	bx,-$E[bp]
13999 3EC6           53                         push	bx
14000                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14001 3EC7           E8         C783            call	_get_SS
14002                                           ! Debug: list unsigned short = ax+0 (used reg = )
14003 3ECA           50                         push	ax
14004                                           ! Debug: list int = const $C (used reg = )
14005 3ECB           B8                   000C  mov	ax,*$C
14006 3ECE           50                         push	ax
14007                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14008 3ECF           8A86       F7E5            mov	al,-$81B[bp]
14009 3ED3           30E4                       xor	ah,ah
14010 3ED5           50                         push	ax
14011                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14012 3ED6           E8         F602            call	_ata_cmd_packet
14013 3ED9           83C4                   14  add	sp,*$14
14014                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14015 3EDC           8986       F7E6            mov	-$81A[bp],ax
14016                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14017 3EE0           85C0                       test	ax,ax
14018 3EE2           74           07            je  	.2E7
14019                       00003EE4            .2E8:
14020                                           ! 2368     return 3;
14021 3EE4           B8                   0003  mov	ax,*3
14022 3EE7           89EC                       mov	sp,bp
14023 3EE9           5D                         pop	bp
14024 3EEA           C3                         ret
14025                                           !BCC_EOS
14026                                           ! 2369   if(buffer[0]!=0)return 4;
14027                       00003EEB            .2E7:
14028                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
14029 3EEB           8A86       F7F2            mov	al,-$80E[bp]
14030 3EEF           84C0                       test	al,al
14031 3EF1           74           07            je  	.2E9
14032                       00003EF3            .2EA:
14033 3EF3           B8                   0004  mov	ax,*4
14034 3EF6           89EC                       mov	sp,bp
14035 3EF8           5D                         pop	bp
14036 3EF9           C3                         ret
14037                                           !BCC_EOS
14038                                           ! 2370   for(i=0;i<5;i++){
14039                       00003EFA            .2E9:
14040                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14041 3EFA           31C0                       xor	ax,ax
14042 3EFC           8986       F7E8            mov	-$818[bp],ax
14043                                           !BCC_EOS
14044                                           !BCC_EOS
14045 3F00           EB           46            jmp .2ED
14046                       00003F02            .2EE:
14047                                           ! 2371     if(read_byte(get_SS(),&buffer[1+i])!=read_byte(0xf000,&isotag[i]))return 5;
14048                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
14049 3F02           8B9E       F7E8            mov	bx,-$818[bp]
14050                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
14051                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
14052 3F06           81C3                 3DE2  add	bx,#_isotag
14053 3F0A           53                         push	bx
14054                                           ! Debug: list unsigned int = const $F000 (used reg = )
14055 3F0B           B8                   F000  mov	ax,#$F000
14056 3F0E           50                         push	ax
14057                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14058 3F0F           E8         C6E2            call	_read_byte
14059 3F12           83C4                   04  add	sp,*4
14060 3F15           50                         push	ax
14061                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
14062                                           ! Debug: expression subtree swapping
14063 3F16           8B86       F7E8            mov	ax,-$818[bp]
14064                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14065 3F1A           40                         inc	ax
14066 3F1B           89EB                       mov	bx,bp
14067 3F1D           01C3                       add	bx,ax
14068                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14069                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14070 3F1F           81C3                 F7F2  add	bx,#-$80E
14071 3F23           53                         push	bx
14072                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14073 3F24           E8         C726            call	_get_SS
14074                                           ! Debug: list unsigned short = ax+0 (used reg = )
14075 3F27           50                         push	ax
14076                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14077 3F28           E8         C6C9            call	_read_byte
14078 3F2B           83C4                   04  add	sp,*4
14079                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14080 3F2E           3A86       F7E2            cmp	al,-$81E[bp]
14081 3F32           8DA6       F7E4            lea	sp,-$81C[bp]
14082 3F36           74           07            je  	.2EF
14083                       00003F38            .2F0:
14084 3F38           B8                   0005  mov	ax,*5
14085 3F3B           89EC                       mov	sp,bp
14086 3F3D           5D                         pop	bp
14087 3F3E           C3                         ret
14088                                           !BCC_EOS
14089                                           ! 2372    }
14090                       00003F3F            .2EF:
14091                                           ! 2373   for(i=0;i<23;i++)
14092                       00003F3F            .2EC:
14093                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14094 3F3F           8B86       F7E8            mov	ax,-$818[bp]
14095 3F43           40                         inc	ax
14096 3F44           8986       F7E8            mov	-$818[bp],ax
14097                       00003F48            .2ED:
14098                                           ! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
14099 3F48           8B86       F7E8            mov	ax,-$818[bp]
14100 3F4C           3D                   0005  cmp	ax,*5
14101 3F4F           72           B1            jb 	.2EE
14102                       00003F51            .2F1:
14103                       00003F51            .2EB:
14104                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14105 3F51           31C0                       xor	ax,ax
14106 3F53           8986       F7E8            mov	-$818[bp],ax
14107                                           !BCC_EOS
14108                                           !BCC_EOS
14109                                           ! 2374     if(read_byte(get_SS(),&buffer[7+i])!=read_byte(0xf000,&eltorito[i]))return 6;
14110 3F57           EB           48            jmp .2F4
14111                       00003F59            .2F5:
14112                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
14113 3F59           8B9E       F7E8            mov	bx,-$818[bp]
14114                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
14115                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
14116 3F5D           81C3                 3DE8  add	bx,#_eltorito
14117 3F61           53                         push	bx
14118                                           ! Debug: list unsigned int = const $F000 (used reg = )
14119 3F62           B8                   F000  mov	ax,#$F000
14120 3F65           50                         push	ax
14121                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14122 3F66           E8         C68B            call	_read_byte
14123 3F69           83C4                   04  add	sp,*4
14124 3F6C           50                         push	ax
14125                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
14126                                           ! Debug: expression subtree swapping
14127 3F6D           8B86       F7E8            mov	ax,-$818[bp]
14128                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14129 3F71           05                   0007  add	ax,*7
14130 3F74           89EB                       mov	bx,bp
14131 3F76           01C3                       add	bx,ax
14132                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14133                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14134 3F78           81C3                 F7F2  add	bx,#-$80E
14135 3F7C           53                         push	bx
14136                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14137 3F7D           E8         C6CD            call	_get_SS
14138                                           ! Debug: list unsigned short = ax+0 (used reg = )
14139 3F80           50                         push	ax
14140                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14141 3F81           E8         C670            call	_read_byte
14142 3F84           83C4                   04  add	sp,*4
14143                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14144 3F87           3A86       F7E2            cmp	al,-$81E[bp]
14145 3F8B           8DA6       F7E4            lea	sp,-$81C[bp]
14146 3F8F           74           07            je  	.2F6
14147                       00003F91            .2F7:
14148 3F91           B8                   0006  mov	ax,*6
14149 3F94           89EC                       mov	sp,bp
14150 3F96           5D                         pop	bp
14151 3F97           C3                         ret
14152                                           !BCC_EOS
14153                                           ! 2375   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
14154                       00003F98            .2F6:
14155                       00003F98            .2F3:
14156                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14157 3F98           8B86       F7E8            mov	ax,-$818[bp]
14158 3F9C           40                         inc	ax
14159 3F9D           8986       F7E8            mov	-$818[bp],ax
14160                       00003FA1            .2F4:
14161                                           ! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
14162 3FA1           8B86       F7E8            mov	ax,-$818[bp]
14163 3FA5           3D                   0017  cmp	ax,*$17
14164 3FA8           72           AF            jb 	.2F5
14165                       00003FAA            .2F8:
14166                       00003FAA            .2F2:
14167                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
14168 3FAA           8A86       F839            mov	al,-$7C7[bp]
14169 3FAE           30E4                       xor	ah,ah
14170 3FB0           31DB                       xor	bx,bx
14171 3FB2           53                         push	bx
14172 3FB3           50                         push	ax
14173                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
14174 3FB4           8A86       F83A            mov	al,-$7C6[bp]
14175 3FB8           30E4                       xor	ah,ah
14176 3FBA           B9                   0100  mov	cx,#$100
14177 3FBD           F7E9                       imul	cx
14178                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14179 3FBF           31DB                       xor	bx,bx
14180 3FC1           53                         push	bx
14181 3FC2           50                         push	ax
14182                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
14183 3FC3           8A86       F83B            mov	al,-$7C5[bp]
14184 3FC7           30E4                       xor	ah,ah
14185 3FC9           31DB                       xor	bx,bx
14186                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14187 3FCB           53                         push	bx
14188 3FCC           50                         push	ax
14189 3FCD           31C0                       xor	ax,ax
14190 3FCF           BB                   0001  mov	bx,*1
14191 3FD2           53                         push	bx
14192 3FD3           50                         push	ax
14193 3FD4           8B86       F7D8            mov	ax,-$828[bp]
14194 3FD8           8B9E       F7DA            mov	bx,-$826[bp]
14195 3FDC           8DBE       F7D4            lea	di,-$82C[bp]
14196 3FE0           E8         C106            call	lmulul
14197 3FE3           83C4                   08  add	sp,*8
14198 3FE6           53                         push	bx
14199 3FE7           50                         push	ax
14200                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
14201 3FE8           8A86       F83C            mov	al,-$7C4[bp]
14202 3FEC           30E4                       xor	ah,ah
14203 3FEE           31DB                       xor	bx,bx
14204                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14205 3FF0           53                         push	bx
14206 3FF1           50                         push	ax
14207 3FF2           31C0                       xor	ax,ax
14208 3FF4           BB                   0100  mov	bx,#$100
14209 3FF7           53                         push	bx
14210 3FF8           50                         push	ax
14211 3FF9           8B86       F7D4            mov	ax,-$82C[bp]
14212 3FFD           8B9E       F7D6            mov	bx,-$82A[bp]
14213 4001           8DBE       F7D0            lea	di,-$830[bp]
14214 4005           E8         C0E1            call	lmulul
14215 4008           83C4                   08  add	sp,*8
14216                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14217 400B           8DBE       F7D8            lea	di,-$828[bp]
14218 400F           E8         C0B1            call	laddul
14219 4012           83C4                   04  add	sp,*4
14220                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14221 4015           8DBE       F7DC            lea	di,-$824[bp]
14222 4019           E8         C0A7            call	laddul
14223 401C           83C4                   04  add	sp,*4
14224                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14225 401F           8DBE       F7E0            lea	di,-$820[bp]
14226 4023           E8         C09D            call	laddul
14227 4026           83C4                   04  add	sp,*4
14228                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14229 4029           8986       F7EE            mov	-$812[bp],ax
14230 402D           899E       F7F0            mov	-$810[bp],bx
14231                                           !BCC_EOS
14232                                           ! 2376   memsetb(get_SS(),atacmd,0,12);
14233                                           ! Debug: list int = const $C (used reg = )
14234 4031           B8                   000C  mov	ax,*$C
14235 4034           50                         push	ax
14236                                           ! Debug: list int = const 0 (used reg = )
14237 4035           31C0                       xor	ax,ax
14238 4037           50                         push	ax
14239                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14240 4038           8D5E         F2            lea	bx,-$E[bp]
14241 403B           53                         push	bx
14242                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14243 403C           E8         C60E            call	_get_SS
14244                                           ! Debug: list unsigned short = ax+0 (used reg = )
14245 403F           50                         push	ax
14246                                           ! Debug: func () void = memsetb+0 (used reg = )
14247 4040           E8         BFBD            call	_memsetb
14248 4043           83C4                   08  add	sp,*8
14249                                           !BCC_EOS
14250                                           ! 2377   atacmd[0]=0x28;
14251                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14252 4046           B0                     28  mov	al,*$28
14253 4048           8846         F2            mov	-$E[bp],al
14254                                           !BCC_EOS
14255                                           ! 2378   atacmd[7]=(0x01 & 0xff00) >> 8;
14256                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14257 404B           30C0                       xor	al,al
14258 404D           8846         F9            mov	-7[bp],al
14259                                           !BCC_EOS
14260                                           ! 2379   atacmd[8]=(0x01 & 0x00ff);
14261                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14262 4050           B0                     01  mov	al,*1
14263 4052           8846         FA            mov	-6[bp],al
14264                                           !BCC_EOS
14265                                           ! 2380   atacmd[2]=(lba & 0xff000000) >> 24;
14266                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14267                                           ! Debug: expression subtree swapping
14268 4055           31C0                       xor	ax,ax
14269 4057           BB                   FF00  mov	bx,#$FF00
14270 405A           8DBE       F7EE            lea	di,-$812[bp]
14271 405E           E8         C05A            call	landul
14272                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14273 4061           93                         xchg	bx,ax
14274 4062           88E0                       mov	al,ah
14275 4064           30E4                       xor	ah,ah
14276 4066           31DB                       xor	bx,bx
14277                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14278 4068           8846         F4            mov	-$C[bp],al
14279                                           !BCC_EOS
14280                                           ! 2381   atacmd[3]=(lba & 0x00ff0000) >> 16;
14281                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14282                                           ! Debug: expression subtree swapping
14283 406B           31C0                       xor	ax,ax
14284 406D           BB                   00FF  mov	bx,#$FF
14285 4070           8DBE       F7EE            lea	di,-$812[bp]
14286 4074           E8         C044            call	landul
14287                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14288 4077           93                         xchg	bx,ax
14289 4078           31DB                       xor	bx,bx
14290                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14291 407A           8846         F5            mov	-$B[bp],al
14292                                           !BCC_EOS
14293                                           ! 2382   atacmd[4]=(lba & 0x0000ff00) >> 8;
14294                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14295                                           ! Debug: expression subtree swapping
14296 407D           B8                   FF00  mov	ax,#$FF00
14297 4080           31DB                       xor	bx,bx
14298 4082           8DBE       F7EE            lea	di,-$812[bp]
14299 4086           E8         C032            call	landul
14300                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14301 4089           88E0                       mov	al,ah
14302 408B           88DC                       mov	ah,bl
14303 408D           88FB                       mov	bl,bh
14304 408F           28FF                       sub	bh,bh
14305                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14306 4091           8846         F6            mov	-$A[bp],al
14307                                           !BCC_EOS
14308                                           ! 2383   atacmd[5]=(lba & 0x000000ff);
14309                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14310                                           ! Debug: expression subtree swapping
14311 4094           B8                   00FF  mov	ax,#$FF
14312 4097           31DB                       xor	bx,bx
14313 4099           8DBE       F7EE            lea	di,-$812[bp]
14314 409D           E8         C01B            call	landul
14315                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14316 40A0           8846         F7            mov	-9[bp],al
14317                                           !BCC_EOS
14318                                           ! 2384   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14319                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14320 40A3           8D9E       F7F2            lea	bx,-$80E[bp]
14321 40A7           53                         push	bx
14322                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14323 40A8           E8         C5A2            call	_get_SS
14324                                           ! Debug: list unsigned short = ax+0 (used reg = )
14325 40AB           50                         push	ax
14326                                           ! Debug: list int = const 1 (used reg = )
14327 40AC           B8                   0001  mov	ax,*1
14328 40AF           50                         push	ax
14329                                           ! Debug: list long = const $800 (used reg = )
14330 40B0           B8                   0800  mov	ax,#$800
14331 40B3           31DB                       xor	bx,bx
14332 40B5           53                         push	bx
14333 40B6           50                         push	ax
14334                                           ! Debug: list int = const 0 (used reg = )
14335 40B7           31C0                       xor	ax,ax
14336 40B9           50                         push	ax
14337                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14338 40BA           8D5E         F2            lea	bx,-$E[bp]
14339 40BD           53                         push	bx
14340                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14341 40BE           E8         C58C            call	_get_SS
14342                                           ! Debug: list unsigned short = ax+0 (used reg = )
14343 40C1           50                         push	ax
14344                                           ! Debug: list int = const $C (used reg = )
14345 40C2           B8                   000C  mov	ax,*$C
14346 40C5           50                         push	ax
14347                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14348 40C6           8A86       F7E5            mov	al,-$81B[bp]
14349 40CA           30E4                       xor	ah,ah
14350 40CC           50                         push	ax
14351                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14352 40CD           E8         F40B            call	_ata_cmd_packet
14353 40D0           83C4                   14  add	sp,*$14
14354                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14355 40D3           8986       F7E6            mov	-$81A[bp],ax
14356                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14357 40D7           85C0                       test	ax,ax
14358 40D9           74           07            je  	.2F9
14359                       000040DB            .2FA:
14360                                           ! 2385     return 7;
14361 40DB           B8                   0007  mov	ax,*7
14362 40DE           89EC                       mov	sp,bp
14363 40E0           5D                         pop	bp
14364 40E1           C3                         ret
14365                                           !BCC_EOS
14366                                           ! 2386   if(buffer[
14367                       000040E2            .2F9:
14368                                           ! 2386 0x00]!=0x01)return 8;
14369                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
14370 40E2           8A86       F7F2            mov	al,-$80E[bp]
14371 40E6           3C                     01  cmp	al,*1
14372 40E8           74           07            je  	.2FB
14373                       000040EA            .2FC:
14374 40EA           B8                   0008  mov	ax,*8
14375 40ED           89EC                       mov	sp,bp
14376 40EF           5D                         pop	bp
14377 40F0           C3                         ret
14378                                           !BCC_EOS
14379                                           ! 2387   if(buffer[0x01]!=0x00)return 9;
14380                       000040F1            .2FB:
14381                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
14382 40F1           8A86       F7F3            mov	al,-$80D[bp]
14383 40F5           84C0                       test	al,al
14384 40F7           74           07            je  	.2FD
14385                       000040F9            .2FE:
14386 40F9           B8                   0009  mov	ax,*9
14387 40FC           89EC                       mov	sp,bp
14388 40FE           5D                         pop	bp
14389 40FF           C3                         ret
14390                                           !BCC_EOS
14391                                           ! 2388   if(buffer[0x1E]!=0x55)return 10;
14392                       00004100            .2FD:
14393                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
14394 4100           8A86       F810            mov	al,-$7F0[bp]
14395 4104           3C                     55  cmp	al,*$55
14396 4106           74           07            je  	.2FF
14397                       00004108            .300:
14398 4108           B8                   000A  mov	ax,*$A
14399 410B           89EC                       mov	sp,bp
14400 410D           5D                         pop	bp
14401 410E           C3                         ret
14402                                           !BCC_EOS
14403                                           ! 2389   if(buffer[0x1F]!=0xAA)return 10;
14404                       0000410F            .2FF:
14405                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
14406 410F           8A86       F811            mov	al,-$7EF[bp]
14407 4113           3C                     AA  cmp	al,#$AA
14408 4115           74           07            je  	.301
14409                       00004117            .302:
14410 4117           B8                   000A  mov	ax,*$A
14411 411A           89EC                       mov	sp,bp
14412 411C           5D                         pop	bp
14413 411D           C3                         ret
14414                                           !BCC_EOS
14415                                           ! 2390   if(buffer[0x20]!=0x88)return 11;
14416                       0000411E            .301:
14417                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
14418 411E           8A86       F812            mov	al,-$7EE[bp]
14419 4122           3C                     88  cmp	al,#$88
14420 4124           74           07            je  	.303
14421                       00004126            .304:
14422 4126           B8                   000B  mov	ax,*$B
14423 4129           89EC                       mov	sp,bp
14424 412B           5D                         pop	bp
14425 412C           C3                         ret
14426                                           !BCC_EOS
14427                                           ! 2391   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
14428                       0000412D            .303:
14429                                           ! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
14430 412D           8A86       F813            mov	al,-$7ED[bp]
14431 4131           30E4                       xor	ah,ah
14432 4133           50                         push	ax
14433                                           ! Debug: list * unsigned char = const $25B (used reg = )
14434 4134           B8                   025B  mov	ax,#$25B
14435 4137           50                         push	ax
14436                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14437 4138           FF76         FE            push	-2[bp]
14438                                           ! Debug: func () void = write_byte+0 (used reg = )
14439 413B           E8         C4DC            call	_write_byte
14440 413E           83C4                   06  add	sp,*6
14441                                           !BCC_EOS
14442                                           ! 2392   if(buffer[0x21]==0){
14443                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14444 4141           8A86       F813            mov	al,-$7ED[bp]
14445 4145           84C0                       test	al,al
14446 4147           75           13            jne 	.305
14447                       00004149            .306:
14448                                           ! 2393     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
14449                                           ! Debug: list int = const $E0 (used reg = )
14450 4149           B8                   00E0  mov	ax,#$E0
14451 414C           50                         push	ax
14452                                           ! Debug: list * unsigned char = const $25C (used reg = )
14453 414D           B8                   025C  mov	ax,#$25C
14454 4150           50                         push	ax
14455                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14456 4151           FF76         FE            push	-2[bp]
14457                                           ! Debug: func () void = write_byte+0 (used reg = )
14458 4154           E8         C4C3            call	_write_byte
14459 4157           83C4                   06  add	sp,*6
14460                                           !BCC_EOS
14461                                           ! 2394     }
14462                                           ! 2395   else if(buffer[0x21]<4)
14463 415A           EB           2B            jmp .307
14464                       0000415C            .305:
14465                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14466 415C           8A86       F813            mov	al,-$7ED[bp]
14467 4160           3C                     04  cmp	al,*4
14468 4162           73           12            jae 	.308
14469                       00004164            .309:
14470                                           ! 2396     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
14471                                           ! Debug: list int = const 0 (used reg = )
14472 4164           31C0                       xor	ax,ax
14473 4166           50                         push	ax
14474                                           ! Debug: list * unsigned char = const $25C (used reg = )
14475 4167           B8                   025C  mov	ax,#$25C
14476 416A           50                         push	ax
14477                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14478 416B           FF76         FE            push	-2[bp]
14479                                           ! Debug: func () void = write_byte+0 (used reg = )
14480 416E           E8         C4A9            call	_write_byte
14481 4171           83C4                   06  add	sp,*6
14482                                           !BCC_EOS
14483                                           ! 2397   else
14484                                           ! 2398     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
14485 4174           EB           11            jmp .30A
14486                       00004176            .308:
14487                                           ! Debug: list int = const $80 (used reg = )
14488 4176           B8                   0080  mov	ax,#$80
14489 4179           50                         push	ax
14490                                           ! Debug: list * unsigned char = const $25C (used reg = )
14491 417A           B8                   025C  mov	ax,#$25C
14492 417D           50                         push	ax
14493                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14494 417E           FF76         FE            push	-2[bp]
14495                                           ! Debug: func () void = write_byte+0 (used reg = )
14496 4181           E8         C496            call	_write_byte
14497 4184           83C4                   06  add	sp,*6
14498                                           !BCC_EOS
14499                                           ! 2399   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
14500                       00004187            .30A:
14501                       00004187            .307:
14502                                           ! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14503 4187           8A86       F7E5            mov	al,-$81B[bp]
14504 418B           30E4                       xor	ah,ah
14505 418D           D1E8                       shr	ax,*1
14506                                           ! Debug: list unsigned int = ax+0 (used reg = )
14507 418F           50                         push	ax
14508                                           ! Debug: list * unsigned char = const $25D (used reg = )
14509 4190           B8                   025D  mov	ax,#$25D
14510 4193           50                         push	ax
14511                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14512 4194           FF76         FE            push	-2[bp]
14513                                           ! Debug: func () void = write_byte+0 (used reg = )
14514 4197           E8         C480            call	_write_byte
14515 419A           83C4                   06  add	sp,*6
14516                                           !BCC_EOS
14517                                           ! 2400   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
14518                                           ! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14519 419D           8A86       F7E5            mov	al,-$81B[bp]
14520 41A1           30E4                       xor	ah,ah
14521 41A3           24                     01  and	al,*1
14522                                           ! Debug: list unsigned char = al+0 (used reg = )
14523 41A5           30E4                       xor	ah,ah
14524 41A7           50                         push	ax
14525                                           ! Debug: list * unsigned short = const $25E (used reg = )
14526 41A8           B8                   025E  mov	ax,#$25E
14527 41AB           50                         push	ax
14528                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14529 41AC           FF76         FE            push	-2[bp]
14530                                           ! Debug: func () void = write_byte+0 (used reg = )
14531 41AF           E8         C468            call	_write_byte
14532 41B2           83C4                   06  add	sp,*6
14533                                           !BCC_EOS
14534                                           ! 2401   boot_segment=buffer[0x23]*0x100+buffer[0x22];
14535                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
14536 41B5           8A86       F815            mov	al,-$7EB[bp]
14537 41B9           30E4                       xor	ah,ah
14538 41BB           B9                   0100  mov	cx,#$100
14539 41BE           F7E9                       imul	cx
14540                                           ! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
14541 41C0           0286       F814            add	al,-$7EC[bp]
14542 41C4           80D4                   00  adc	ah,*0
14543                                           ! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14544 41C7           8986       F7EC            mov	-$814[bp],ax
14545                                           !BCC_EOS
14546                                           ! 2402   if(boot_segment==0x0000)boot_segment=0x07C0;
14547                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14548 41CB           8B86       F7EC            mov	ax,-$814[bp]
14549 41CF           85C0                       test	ax,ax
14550 41D1           75           07            jne 	.30B
14551                       000041D3            .30C:
14552                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14553 41D3           B8                   07C0  mov	ax,#$7C0
14554 41D6           8986       F7EC            mov	-$814[bp],ax
14555                                           !BCC_EOS
14556                                           ! 2403   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
14557                       000041DA            .30B:
14558                                           ! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
14559 41DA           FFB6       F7EC            push	-$814[bp]
14560                                           ! Debug: list * unsigned short = const $266 (used reg = )
14561 41DE           B8                   0266  mov	ax,#$266
14562 41E1           50                         push	ax
14563                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14564 41E2           FF76         FE            push	-2[bp]
14565                                           ! Debug: func () void = write_word+0 (used reg = )
14566 41E5           E8         C44A            call	_write_word
14567 41E8           83C4                   06  add	sp,*6
14568                                           !BCC_EOS
14569                                           ! 2404   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
14570                                           ! Debug: list int = const 0 (used reg = )
14571 41EB           31C0                       xor	ax,ax
14572 41ED           50                         push	ax
14573                                           ! Debug: list * unsigned short = const $264 (used reg = )
14574 41EE           B8                   0264  mov	ax,#$264
14575 41F1           50                         push	ax
14576                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14577 41F2           FF76         FE            push	-2[bp]
14578                                           ! Debug: func () void = write_word+0 (used reg = )
14579 41F5           E8         C43A            call	_write_word
14580 41F8           83C4                   06  add	sp,*6
14581                                           !BCC_EOS
14582                                           ! 2405   nbsectors=buffer[0x27]*0x100+buffer[0x26];
14583                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
14584 41FB           8A86       F819            mov	al,-$7E7[bp]
14585 41FF           30E4                       xor	ah,ah
14586 4201           B9                   0100  mov	cx,#$100
14587 4204           F7E9                       imul	cx
14588                                           ! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
14589 4206           0286       F818            add	al,-$7E8[bp]
14590 420A           80D4                   00  adc	ah,*0
14591                                           ! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14592 420D           8986       F7EA            mov	-$816[bp],ax
14593                                           !BCC_EOS
14594                                           ! 2406   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
14595                                           ! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
14596 4211           FFB6       F7EA            push	-$816[bp]
14597                                           ! Debug: list * unsigned short = const $268 (used reg = )
14598 4215           B8                   0268  mov	ax,#$268
14599 4218           50                         push	ax
14600                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14601 4219           FF76         FE            push	-2[bp]
14602                                           ! Debug: func () void = write_word+0 (used reg = )
14603 421C           E8         C413            call	_write_word
14604 421F           83C4                   06  add	sp,*6
14605                                           !BCC_EOS
14606                                           ! 2407   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
14607                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
14608 4222           8A86       F81A            mov	al,-$7E6[bp]
14609 4226           30E4                       xor	ah,ah
14610 4228           31DB                       xor	bx,bx
14611 422A           53                         push	bx
14612 422B           50                         push	ax
14613                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
14614 422C           8A86       F81B            mov	al,-$7E5[bp]
14615 4230           30E4                       xor	ah,ah
14616 4232           B9                   0100  mov	cx,#$100
14617 4235           F7E9                       imul	cx
14618                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14619 4237           31DB                       xor	bx,bx
14620 4239           53                         push	bx
14621 423A           50                         push	ax
14622                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
14623 423B           8A86       F81C            mov	al,-$7E4[bp]
14624 423F           30E4                       xor	ah,ah
14625 4241           31DB                       xor	bx,bx
14626                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14627 4243           53                         push	bx
14628 4244           50                         push	ax
14629 4245           31C0                       xor	ax,ax
14630 4247           BB                   0001  mov	bx,*1
14631 424A           53                         push	bx
14632 424B           50                         push	ax
14633 424C           8B86       F7D8            mov	ax,-$828[bp]
14634 4250           8B9E       F7DA            mov	bx,-$826[bp]
14635 4254           8DBE       F7D4            lea	di,-$82C[bp]
14636 4258           E8         BE8E            call	lmulul
14637 425B           83C4                   08  add	sp,*8
14638 425E           53                         push	bx
14639 425F           50                         push	ax
14640                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
14641 4260           8A86       F81D            mov	al,-$7E3[bp]
14642 4264           30E4                       xor	ah,ah
14643 4266           31DB                       xor	bx,bx
14644                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14645 4268           53                         push	bx
14646 4269           50                         push	ax
14647 426A           31C0                       xor	ax,ax
14648 426C           BB                   0100  mov	bx,#$100
14649 426F           53                         push	bx
14650 4270           50                         push	ax
14651 4271           8B86       F7D4            mov	ax,-$82C[bp]
14652 4275           8B9E       F7D6            mov	bx,-$82A[bp]
14653 4279           8DBE       F7D0            lea	di,-$830[bp]
14654 427D           E8         BE69            call	lmulul
14655 4280           83C4                   08  add	sp,*8
14656                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14657 4283           8DBE       F7D8            lea	di,-$828[bp]
14658 4287           E8         BE39            call	laddul
14659 428A           83C4                   04  add	sp,*4
14660                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14661 428D           8DBE       F7DC            lea	di,-$824[bp]
14662 4291           E8         BE2F            call	laddul
14663 4294           83C4                   04  add	sp,*4
14664                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14665 4297           8DBE       F7E0            lea	di,-$820[bp]
14666 429B           E8         BE25            call	laddul
14667 429E           83C4                   04  add	sp,*4
14668                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14669 42A1           8986       F7EE            mov	-$812[bp],ax
14670 42A5           899E       F7F0            mov	-$810[bp],bx
14671                                           !BCC_EOS
14672                                           ! 2408   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
14673                                           ! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
14674 42A9           FFB6       F7F0            push	-$810[bp]
14675 42AD           FFB6       F7EE            push	-$812[bp]
14676                                           ! Debug: list * unsigned long = const $260 (used reg = )
14677 42B1           B8                   0260  mov	ax,#$260
14678 42B4           50                         push	ax
14679                                           ! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
14680 42B5           FF76         FE            push	-2[bp]
14681                                           ! Debug: func () void = write_dword+0 (used reg = )
14682 42B8           E8         BDE0            call	_write_dword
14683 42BB           83C4                   08  add	sp,*8
14684                                           !BCC_EOS
14685                                           ! 2409   memsetb(get_SS(),atacmd,0,12);
14686                                           ! Debug: list int = const $C (used reg = )
14687 42BE           B8                   000C  mov	ax,*$C
14688 42C1           50                         push	ax
14689                                           ! Debug: list int = const 0 (used reg = )
14690 42C2           31C0                       xor	ax,ax
14691 42C4           50                         push	ax
14692                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14693 42C5           8D5E         F2            lea	bx,-$E[bp]
14694 42C8           53                         push	bx
14695                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14696 42C9           E8         C381            call	_get_SS
14697                                           ! Debug: list unsigned short = ax+0 (used reg = )
14698 42CC           50                         push	ax
14699                                           ! Debug: func () void = memsetb+0 (used reg = )
14700 42CD           E8         BD30            call	_memsetb
14701 42D0           83C4                   08  add	sp,*8
14702                                           !BCC_EOS
14703                                           ! 2410   atacmd[0]=0x28;
14704                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14705 42D3           B0                     28  mov	al,*$28
14706 42D5           8846         F2            mov	-$E[bp],al
14707                                           !BCC_EOS
14708                                           ! 2411   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
14709                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14710 42D8           8B86       F7EA            mov	ax,-$816[bp]
14711                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14712 42DC           48                         dec	ax
14713 42DD           D1E8                       shr	ax,*1
14714 42DF           D1E8                       shr	ax,*1
14715                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14716                                           ! Debug: expression subtree swapping
14717                                           ! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
14718 42E1           40                         inc	ax
14719 42E2           30C0                       xor	al,al
14720                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
14721 42E4           88E0                       mov	al,ah
14722 42E6           30E4                       xor	ah,ah
14723                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14724 42E8           8846         F9            mov	-7[bp],al
14725                                           !BCC_EOS
14726                                           ! 2412   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
14727                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14728 42EB           8B86       F7EA            mov	ax,-$816[bp]
14729                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14730 42EF           48                         dec	ax
14731 42F0           D1E8                       shr	ax,*1
14732 42F2           D1E8                       shr	ax,*1
14733                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14734                                           ! Debug: expression subtree swapping
14735                                           ! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
14736 42F4           40                         inc	ax
14737                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
14738 42F5           8846         FA            mov	-6[bp],al
14739                                           !BCC_EOS
14740                                           ! 2413   atacmd[2]=(lba & 0xff000000) >> 24;
14741                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14742                                           ! Debug: expression subtree swapping
14743 42F8           31C0                       xor	ax,ax
14744 42FA           BB                   FF00  mov	bx,#$FF00
14745 42FD           8DBE       F7EE            lea	di,-$812[bp]
14746 4301           E8         BDB7            call	landul
14747                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14748 4304           93                         xchg	bx,ax
14749 4305           88E0                       mov	al,ah
14750 4307           30E4                       xor	ah,ah
14751 4309           31DB                       xor	bx,bx
14752                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14753 430B           8846         F4            mov	-$C[bp],al
14754                                           !BCC_EOS
14755                                           ! 2414   atacmd[3]=(lba & 0x00ff0000) >> 16;
14756                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14757                                           ! Debug: expression subtree swapping
14758 430E           31C0                       xor	ax,ax
14759 4310           BB                   00FF  mov	bx,#$FF
14760 4313           8DBE       F7EE            lea	di,-$812[bp]
14761 4317           E8         BDA1            call	landul
14762                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14763 431A           93                         xchg	bx,ax
14764 431B           31DB                       xor	bx,bx
14765                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14766 431D           8846         F5            mov	-$B[bp],al
14767                                           !BCC_EOS
14768                                           ! 2415   atacmd[4]=(lba & 0x0000ff00) >> 8;
14769                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14770                                           ! Debug: expression subtree swapping
14771 4320           B8                   FF00  mov	ax,#$FF00
14772 4323           31DB                       xor	bx,bx
14773 4325           8DBE       F7EE            lea	di,-$812[bp]
14774 4329           E8         BD8F            call	landul
14775                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14776 432C           88E0                       mov	al,ah
14777 432E           88DC                       mov	ah,bl
14778 4330           88FB                       mov	bl,bh
14779 4332           28FF                       sub	bh,bh
14780                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14781 4334           8846         F6            mov	-$A[bp],al
14782                                           !BCC_EOS
14783                                           ! 2416   atacmd[5]=(lba & 0x000000ff);
14784                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14785                                           ! Debug: expression subtree swapping
14786 4337           B8                   00FF  mov	ax,#$FF
14787 433A           31DB                       xor	bx,bx
14788 433C           8DBE       F7EE            lea	di,-$812[bp]
14789 4340           E8         BD78            call	landul
14790                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14791 4343           8846         F7            mov	-9[bp],al
14792                                           !BCC_EOS
14793                                           ! 2417   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
14794                                           ! Debug: list int = const 0 (used reg = )
14795 4346           31C0                       xor	ax,ax
14796 4348           50                         push	ax
14797                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
14798 4349           FFB6       F7EC            push	-$814[bp]
14799                                           ! Debug: list int = const 1 (used reg = )
14800 434D           B8                   0001  mov	ax,*1
14801 4350           50                         push	ax
14802                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
14803 4351           8B86       F7EA            mov	ax,-$816[bp]
14804 4355           31DB                       xor	bx,bx
14805                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
14806 4357           53                         push	bx
14807 4358           50                         push	ax
14808 4359           B8                   0200  mov	ax,#$200
14809 435C           31DB                       xor	bx,bx
14810 435E           53                         push	bx
14811 435F           50                         push	ax
14812 4360           8B86       F7DA            mov	ax,-$826[bp]
14813 4364           8B9E       F7DC            mov	bx,-$824[bp]
14814 4368           8DBE       F7D6            lea	di,-$82A[bp]
14815 436C           E8         BD7A            call	lmulul
14816 436F           83C4                   08  add	sp,*8
14817                                           ! Debug: list unsigned long = bx+0 (used reg = )
14818 4372           53                         push	bx
14819 4373           50                         push	ax
14820                                           ! Debug: list int = const 0 (used reg = )
14821 4374           31C0                       xor	ax,ax
14822 4376           50                         push	ax
14823                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14824 4377           8D5E         F2            lea	bx,-$E[bp]
14825 437A           53                         push	bx
14826                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14827 437B           E8         C2CF            call	_get_SS
14828                                           ! Debug: list unsigned short = ax+0 (used reg = )
14829 437E           50                         push	ax
14830                                           ! Debug: list int = const $C (used reg = )
14831 437F           B8                   000C  mov	ax,*$C
14832 4382           50                         push	ax
14833                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14834 4383           8A86       F7E5            mov	al,-$81B[bp]
14835 4387           30E4                       xor	ah,ah
14836 4389           50                         push	ax
14837                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14838 438A           E8         F14E            call	_ata_cmd_packet
14839 438D           83C4                   14  add	sp,*$14
14840                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14841 4390           8986       F7E6            mov	-$81A[bp],ax
14842                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14843 4394           85C0                       test	ax,ax
14844 4396           74           07            je  	.30D
14845                       00004398            .30E:
14846                                           ! 2418     return 12;
14847 4398           B8                   000C  mov	ax,*$C
14848 439B           89EC                       mov	sp,bp
14849 439D           5D                         pop	bp
14850 439E           C3                         ret
14851                                           !BCC_EOS
14852                                           ! 2419   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
14853                       0000439F            .30D:
14854                                           ! Debug: list * unsigned char = const $25B (used reg = )
14855 439F           B8                   025B  mov	ax,#$25B
14856 43A2           50                         push	ax
14857                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
14858 43A3           FF76         FE            push	-2[bp]
14859                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14860 43A6           E8         C24B            call	_read_byte
14861 43A9           83C4                   04  add	sp,*4
14862 43AC           E9         0120            br 	.311
14863                                           ! 2420     case 0x01:
14864                                           ! 2421       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
14865                       000043AF            .312:
14866                                           ! Debug: list int = const $F (used reg = )
14867 43AF           B8                   000F  mov	ax,*$F
14868 43B2           50                         push	ax
14869                                           ! Debug: list * unsigned short = const $26E (used reg = )
14870 43B3           B8                   026E  mov	ax,#$26E
14871 43B6           50                         push	ax
14872                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14873 43B7           FF76         FE            push	-2[bp]
14874                                           ! Debug: func () void = write_word+0 (used reg = )
14875 43BA           E8         C275            call	_write_word
14876 43BD           83C4                   06  add	sp,*6
14877                                           !BCC_EOS
14878                                           ! 2422       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
14879                                           ! Debug: list int = const $50 (used reg = )
14880 43C0           B8                   0050  mov	ax,*$50
14881 43C3           50                         push	ax
14882                                           ! Debug: list * unsigned short = const $26C (used reg = )
14883 43C4           B8                   026C  mov	ax,#$26C
14884 43C7           50                         push	ax
14885                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14886 43C8           FF76         FE            push	-2[bp]
14887                                           ! Debug: func () void = write_word+0 (used reg = )
14888 43CB           E8         C264            call	_write_word
14889 43CE           83C4                   06  add	sp,*6
14890                                           !BCC_EOS
14891                                           ! 2423       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
14892                                           ! Debug: list int = const 2 (used reg = )
14893 43D1           B8                   0002  mov	ax,*2
14894 43D4           50                         push	ax
14895                                           ! Debug: list * unsigned short = const $26A (used reg = )
14896 43D5           B8                   026A  mov	ax,#$26A
14897 43D8           50                         push	ax
14898                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14899 43D9           FF76         FE            push	-2[bp]
14900                                           ! Debug: func () void = write_word+0 (used reg = )
14901 43DC           E8         C253            call	_write_word
14902 43DF           83C4                   06  add	sp,*6
14903                                           !BCC_EOS
14904                                           ! 2424       break;
14905 43E2           E9         0102            br 	.30F
14906                                           !BCC_EOS
14907                                           ! 2425     case 0x02:
14908                                           ! 2426       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
14909                       000043E5            .313:
14910                                           ! Debug: list int = const $12 (used reg = )
14911 43E5           B8                   0012  mov	ax,*$12
14912 43E8           50                         push	ax
14913                                           ! Debug: list * unsigned short = const $26E (used reg = )
14914 43E9           B8                   026E  mov	ax,#$26E
14915 43EC           50                         push	ax
14916                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14917 43ED           FF76         FE            push	-2[bp]
14918                                           ! Debug: func () void = write_word+0 (used reg = )
14919 43F0           E8         C23F            call	_write_word
14920 43F3           83C4                   06  add	sp,*6
14921                                           !BCC_EOS
14922                                           ! 2427       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdev
14923                                           ! 2427 ice.cylinders,80);
14924                                           ! Debug: list int = const $50 (used reg = )
14925 43F6           B8                   0050  mov	ax,*$50
14926 43F9           50                         push	ax
14927                                           ! Debug: list * unsigned short = const $26C (used reg = )
14928 43FA           B8                   026C  mov	ax,#$26C
14929 43FD           50                         push	ax
14930                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14931 43FE           FF76         FE            push	-2[bp]
14932                                           ! Debug: func () void = write_word+0 (used reg = )
14933 4401           E8         C22E            call	_write_word
14934 4404           83C4                   06  add	sp,*6
14935                                           !BCC_EOS
14936                                           ! 2428       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
14937                                           ! Debug: list int = const 2 (used reg = )
14938 4407           B8                   0002  mov	ax,*2
14939 440A           50                         push	ax
14940                                           ! Debug: list * unsigned short = const $26A (used reg = )
14941 440B           B8                   026A  mov	ax,#$26A
14942 440E           50                         push	ax
14943                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14944 440F           FF76         FE            push	-2[bp]
14945                                           ! Debug: func () void = write_word+0 (used reg = )
14946 4412           E8         C21D            call	_write_word
14947 4415           83C4                   06  add	sp,*6
14948                                           !BCC_EOS
14949                                           ! 2429       break;
14950 4418           E9         00CC            br 	.30F
14951                                           !BCC_EOS
14952                                           ! 2430     case 0x03:
14953                                           ! 2431       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
14954                       0000441B            .314:
14955                                           ! Debug: list int = const $24 (used reg = )
14956 441B           B8                   0024  mov	ax,*$24
14957 441E           50                         push	ax
14958                                           ! Debug: list * unsigned short = const $26E (used reg = )
14959 441F           B8                   026E  mov	ax,#$26E
14960 4422           50                         push	ax
14961                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14962 4423           FF76         FE            push	-2[bp]
14963                                           ! Debug: func () void = write_word+0 (used reg = )
14964 4426           E8         C209            call	_write_word
14965 4429           83C4                   06  add	sp,*6
14966                                           !BCC_EOS
14967                                           ! 2432       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
14968                                           ! Debug: list int = const $50 (used reg = )
14969 442C           B8                   0050  mov	ax,*$50
14970 442F           50                         push	ax
14971                                           ! Debug: list * unsigned short = const $26C (used reg = )
14972 4430           B8                   026C  mov	ax,#$26C
14973 4433           50                         push	ax
14974                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14975 4434           FF76         FE            push	-2[bp]
14976                                           ! Debug: func () void = write_word+0 (used reg = )
14977 4437           E8         C1F8            call	_write_word
14978 443A           83C4                   06  add	sp,*6
14979                                           !BCC_EOS
14980                                           ! 2433       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
14981                                           ! Debug: list int = const 2 (used reg = )
14982 443D           B8                   0002  mov	ax,*2
14983 4440           50                         push	ax
14984                                           ! Debug: list * unsigned short = const $26A (used reg = )
14985 4441           B8                   026A  mov	ax,#$26A
14986 4444           50                         push	ax
14987                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14988 4445           FF76         FE            push	-2[bp]
14989                                           ! Debug: func () void = write_word+0 (used reg = )
14990 4448           E8         C1E7            call	_write_word
14991 444B           83C4                   06  add	sp,*6
14992                                           !BCC_EOS
14993                                           ! 2434       break;
14994 444E           E9         0096            br 	.30F
14995                                           !BCC_EOS
14996                                           ! 2435     case 0x04:
14997                                           ! 2436       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
14998                       00004451            .315:
14999                                           ! Debug: list int = const $1C4 (used reg = )
15000 4451           B8                   01C4  mov	ax,#$1C4
15001 4454           50                         push	ax
15002                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15003 4455           FFB6       F7EC            push	-$814[bp]
15004                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15005 4459           E8         C198            call	_read_byte
15006 445C           83C4                   04  add	sp,*4
15007                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
15008 445F           24                     3F  and	al,*$3F
15009                                           ! Debug: list unsigned char = al+0 (used reg = )
15010 4461           30E4                       xor	ah,ah
15011 4463           50                         push	ax
15012                                           ! Debug: list * unsigned short = const $26E (used reg = )
15013 4464           B8                   026E  mov	ax,#$26E
15014 4467           50                         push	ax
15015                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15016 4468           FF76         FE            push	-2[bp]
15017                                           ! Debug: func () void = write_word+0 (used reg = )
15018 446B           E8         C1C4            call	_write_word
15019 446E           83C4                   06  add	sp,*6
15020                                           !BCC_EOS
15021                                           ! 2437       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
15022                                           ! 2438               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
15023                                           ! Debug: list int = const $1C5 (used reg = )
15024 4471           B8                   01C5  mov	ax,#$1C5
15025 4474           50                         push	ax
15026                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15027 4475           FFB6       F7EC            push	-$814[bp]
15028                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15029 4479           E8         C178            call	_read_byte
15030 447C           83C4                   04  add	sp,*4
15031 447F           50                         push	ax
15032                                           ! Debug: list int = const $1C4 (used reg = )
15033 4480           B8                   01C4  mov	ax,#$1C4
15034 4483           50                         push	ax
15035                                           ! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
15036 4484           FFB6       F7EC            push	-$814[bp]
15037                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15038 4488           E8         C169            call	_read_byte
15039 448B           83C4                   04  add	sp,*4
15040                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
15041 448E           30E4                       xor	ah,ah
15042 4490           D1E0                       shl	ax,*1
15043 4492           D1E0                       shl	ax,*1
15044                                           ! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
15045 4494           0286       F7E2            add	al,0+..FFF9[bp]
15046 4498           80D4                   00  adc	ah,*0
15047 449B           44                         inc	sp
15048 449C           44                         inc	sp
15049                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
15050                                           ! Debug: list unsigned int = ax+1 (used reg = )
15051 449D           40                         inc	ax
15052 449E           50                         push	ax
15053                                           ! Debug: list * unsigned short = const $26C (used reg = )
15054 449F           B8                   026C  mov	ax,#$26C
15055 44A2           50                         push	ax
15056                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15057 44A3           FF76         FE            push	-2[bp]
15058                                           ! Debug: func () void = write_word+0 (used reg = )
15059 44A6           E8         C189            call	_write_word
15060 44A9           83C4                   06  add	sp,*6
15061                                           !BCC_EOS
15062                                           ! 2439       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
15063                                           ! Debug: list int = const $1C3 (used reg = )
15064 44AC           B8                   01C3  mov	ax,#$1C3
15065 44AF           50                         push	ax
15066                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15067 44B0           FFB6       F7EC            push	-$814[bp]
15068                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15069 44B4           E8         C13D            call	_read_byte
15070 44B7           83C4                   04  add	sp,*4
15071                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15072 44BA           30E4                       xor	ah,ah
15073                                           ! Debug: list unsigned int = ax+1 (used reg = )
15074 44BC           40                         inc	ax
15075 44BD           50                         push	ax
15076                                           ! Debug: list * unsigned short = const $26A (used reg = )
15077 44BE           B8                   026A  mov	ax,#$26A
15078 44C1           50                         push	ax
15079                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15080 44C2           FF76         FE            push	-2[bp]
15081                                           ! Debug: func () void = write_word+0 (used reg = )
15082 44C5           E8         C16A            call	_write_word
15083 44C8           83C4                   06  add	sp,*6
15084                                           !BCC_EOS
15085                                           ! 2440       break;
15086 44CB           EB           1A            jmp .30F
15087                                           !BCC_EOS
15088                                           ! 2441    }
15089                                           ! 2442   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
15090 44CD           EB           18            jmp .30F
15091                       000044CF            .311:
15092 44CF           2C                     01  sub	al,*1
15093 44D1         0F84         FEDA            beq 	.312
15094 44D5           2C                     01  sub	al,*1
15095 44D7         0F84         FF0A            beq 	.313
15096 44DB           2C                     01  sub	al,*1
15097 44DD         0F84         FF3A            beq 	.314
15098 44E1           2C                     01  sub	al,*1
15099 44E3         0F84         FF6A            beq 	.315
15100                       000044E7            .30F:
15101                       FFFFF7E2            ..FFF9	=	-$81E
15102                                           ! Debug: list * unsigned char = const $25B (used reg = )
15103 44E7           B8                   025B  mov	ax,#$25B
15104 44EA           50                         push	ax
15105                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15106 44EB           FF76         FE            push	-2[bp]
15107                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15108 44EE           E8         C103            call	_read_byte
15109 44F1           83C4                   04  add	sp,*4
15110                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15111 44F4           84C0                       test	al,al
15112 44F6           74           52            je  	.316
15113                       000044F8            .317:
15114                                           ! 2443     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
15115                                           ! Debug: list * unsigned char = const $25C (used reg = )
15116 44F8           B8                   025C  mov	ax,#$25C
15117 44FB           50                         push	ax
15118                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15119 44FC           FF76         FE            push	-2[bp]
15120                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15121 44FF           E8         C0F2            call	_read_byte
15122 4502           83C4                   04  add	sp,*4
15123                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15124 4505           84C0                       test	al,al
15125 4507           75           23            jne 	.318
15126                       00004509            .319:
15127                                           ! 2444       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
15128                                           ! Debug: list int = const $10 (used reg = )
15129 4509           B8                   0010  mov	ax,*$10
15130 450C           50                         push	ax
15131                                           ! Debug: list int = const $40 (used reg = )
15132 450D           B8                   0040  mov	ax,*$40
15133 4510           50                         push	ax
15134                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15135 4511           E8         C0E0            call	_read_byte
15136 4514           83C4                   04  add	sp,*4
15137                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
15138 4517           0C                     41  or	al,*$41
15139                                           ! Debug: list unsigned char = al+0 (used reg = )
15140 4519           30E4                       xor	ah,ah
15141 451B           50                         push	ax
15142                                           ! Debug: list int = const $10 (used reg = )
15143 451C           B8                   0010  mov	ax,*$10
15144 451F           50                         push	ax
15145                                           ! Debug: list int = const $40 (used reg = )
15146 4520           B8                   0040  mov	ax,*$40
15147 4523           50                         push	ax
15148                                           ! Debug: func () void = write_byte+0 (used reg = )
15149 4524           E8         C0F3            call	_write_byte
15150 4527           83C4                   06  add	sp,*6
15151                                           !BCC_EOS
15152                                           ! 2445     else
15153                                           ! 2446       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
15154 452A           EB           1E            jmp .31A
15155                       0000452C            .318:
15156                                           ! Debug: list * unsigned char = const $232 (used reg = )
15157 452C           B8                   0232  mov	ax,#$232
15158 452F           50                         push	ax
15159                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15160 4530           FF76         FE            push	-2[bp]
15161                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15162 4533           E8         C0BE            call	_read_byte
15163 4536           83C4                   04  add	sp,*4
15164                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15165 4539           30E4                       xor	ah,ah
15166                                           ! Debug: list unsigned int = ax+1 (used reg = )
15167 453B           40                         inc	ax
15168 453C           50                         push	ax
15169                                           ! Debug: list * unsigned char = const $232 (used reg = )
15170 453D           B8                   0232  mov	ax,#$232
15171 4540           50                         push	ax
15172                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15173 4541           FF76         FE            push	-2[bp]
15174                                           ! Debug: func () void = write_byte+0 (used reg = )
15175 4544           E8         C0D3            call	_write_byte
15176 4547           83C4                   06  add	sp,*6
15177                                           !BCC_EOS
15178                                           ! 2447    }
15179                       0000454A            .31A:
15180                                           ! 2448   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
15181                       0000454A            .316:
15182                                           ! Debug: list * unsigned char = const $25B (used reg = )
15183 454A           B8                   025B  mov	ax,#$25B
15184 454D           50                         push	ax
15185                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15186 454E           FF76         FE            push	-2[bp]
15187                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15188 4551           E8         C0A0            call	_read_byte
15189 4554           83C4                   04  add	sp,*4
15190                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15191 4557           84C0                       test	al,al
15192 4559           74           11            je  	.31B
15193                       0000455B            .31C:
15194                                           ! 2449     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
15195                                           ! Debug: list int = const 1 (used reg = )
15196 455B           B8                   0001  mov	ax,*1
15197 455E           50                         push	ax
15198                                           ! Debug: list * unsigned char = const $25A (used reg = )
15199 455F           B8                   025A  mov	ax,#$25A
15200 4562           50                         push	ax
15201                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15202 4563           FF76         FE            push	-2[bp]
15203                                           ! Debug: func () void = write_byte+0 (used reg = )
15204 4566           E8         C0B1            call	_write_byte
15205 4569           83C4                   06  add	sp,*6
15206                                           !BCC_EOS
15207                                           ! 2450   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
15208                       0000456C            .31B:
15209                                           ! Debug: list * unsigned char = const $25C (used reg = )
15210 456C           B8                   025C  mov	ax,#$25C
15211 456F           50                         push	ax
15212                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15213 4570           FF76         FE            push	-2[bp]
15214                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15215 4573           E8         C07E            call	_read_byte
15216 4576           83C4                   04  add	sp,*4
15217                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
15218 4579           30E4                       xor	ah,ah
15219 457B           B9                   0100  mov	cx,#$100
15220 457E           F7E9                       imul	cx
15221                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
15222                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
15223 4580           89EC                       mov	sp,bp
15224 4582           5D                         pop	bp
15225 4583           C3                         ret
15226                                           !BCC_EOS
15227                                           ! 2451 }
15228                                           ! 2452   void
15229                                           ! Register BX used in function cdrom_boot
15230                                           ! 2453 int14_function(regs, ds, iret_addr)
15231                                           ! 2454   pusha_regs_t regs;
15232                                           export	_int14_function
15233                       00004584            _int14_function:
15234                                           !BCC_EOS
15235                                           ! 2455   Bit16u ds;
15236                                           !BCC_EOS
15237                                           ! 2456   iret_addr_t iret_addr;
15238                                           !BCC_EOS
15239                                           ! 2457 {
15240                                           ! 2458   Bit16u addr,timer,val16;
15241                                           !BCC_EOS
15242                                           ! 2459   Bit8u timeout;
15243                                           !BCC_EOS
15244                                           ! 2460 #asm
15245 4584           55                         push	bp
15246 4585           89E5                       mov	bp,sp
15247 4587           83C4                   F8  add	sp,*-8
15248                                           !BCC_EOS
15249                                           !BCC_ASM
15250                       0000001C            _int14_function.ds	set	$1C
15251                       00000014            .int14_function.ds	set	$14
15252                       00000004            _int14_function.timer	set	4
15253                       FFFFFFFC            .int14_function.timer	set	-4
15254                       00000001            _int14_function.timeout	set	1
15255                       FFFFFFF9            .int14_function.timeout	set	-7
15256                       0000001E            _int14_function.iret_addr	set	$1E
15257                       00000016            .int14_function.iret_addr	set	$16
15258                       00000006            _int14_function.addr	set	6
15259                       FFFFFFFE            .int14_function.addr	set	-2
15260                       00000002            _int14_function.val16	set	2
15261                       FFFFFFFA            .int14_function.val16	set	-6
15262                       0000000C            _int14_function.regs	set	$C
15263                       00000004            .int14_function.regs	set	4
15264 458A           FB                           sti
15265                                           ! 2462 endasm
15266                                           !BCC_ENDASM
15267                                           !BCC_EOS
15268                                           ! 2463   addr = read_word(0x0040, (regs.u.r16.dx << 1));
15269                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
15270 458B           8B46         0E            mov	ax,$E[bp]
15271 458E           D1E0                       shl	ax,*1
15272                                           ! Debug: list unsigned int = ax+0 (used reg = )
15273 4590           50                         push	ax
15274                                           ! Debug: list int = const $40 (used reg = )
15275 4591           B8                   0040  mov	ax,*$40
15276 4594           50                         push	ax
15277                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15278 4595           E8         C06F            call	_read_word
15279 4598           83C4                   04  add	sp,*4
15280                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
15281 459B           8946         FE            mov	-2[bp],ax
15282                                           !BCC_EOS
15283                                           ! 2464   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
15284                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
15285                                           ! Debug: expression subtree swapping
15286 459E           8B46         0E            mov	ax,$E[bp]
15287                                           ! Debug: list unsigned int = ax+$7C (used reg = )
15288 45A1           05                   007C  add	ax,*$7C
15289 45A4           50                         push	ax
15290                                           ! Debug: list int = const $40 (used reg = )
15291 45A5           B8                   0040  mov	ax,*$40
15292 45A8           50                         push	ax
15293                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15294 45A9           E8         C048            call	_read_byte
15295 45AC           83C4                   04  add	sp,*4
15296                                           ! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
15297 45AF           8846         F9            mov	-7[bp],al
15298                                           !BCC_EOS
15299                                           ! 2465   if ((regs.u.r16.dx < 4) && (addr > 0)) {
15300                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
15301 45B2           8B46         0E            mov	ax,$E[bp]
15302 45B5           3D                   0004  cmp	ax,*4
15303 45B8         0F83         022C            bhis	.31D
15304                       000045BC            .31F:
15305                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
15306 45BC           8B46         FE            mov	ax,-2[bp]
15307 45BF           85C0                       test	ax,ax
15308 45C1         0F84         0223            beq 	.31D
15309                       000045C5            .31E:
15310                                           ! 2466     switch (regs.u.r8.ah) {
15311 45C5           8A46         13            mov	al,$13[bp]
15312 45C8           E9         0203            br 	.322
15313                                           ! 2467       case 0:
15314                                           ! 2468         outb(addr+3, inb(addr+3) | 0x80);
15315                       000045CB            .323:
15316                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
15317 45CB           8B46         FE            mov	ax,-2[bp]
15318                                           ! Debug: list unsigned int = ax+3 (used reg = )
15319 45CE           05                   0003  add	ax,*3
15320 45D1           50                         push	ax
15321                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15322 45D2           E8         BF69            call	_inb
15323 45D5           44                         inc	sp
15324 45D6           44                         inc	sp
15325                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
15326 45D7           0C                     80  or	al,#$80
15327                                           ! Debug: list unsigned char = al+0 (used reg = )
15328 45D9           30E4                       xor	ah,ah
15329 45DB           50                         push	ax
15330                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15331 45DC           8B46         FE            mov	ax,-2[bp]
15332                                           ! Debug: list unsigned int = ax+3 (used reg = )
15333 45DF           05                   0003  add	ax,*3
15334 45E2           50                         push	ax
15335                                           ! Debug: func () void = outb+0 (used reg = )
15336 45E3           E8         BF6E            call	_outb
15337 45E6           83C4                   04  add	sp,*4
15338                                           !BCC_EOS
15339                                           ! 2469         if (regs.u.r8.al & 0xE0 == 0) {
15340                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
15341 45E9           8A46         12            mov	al,$12[bp]
15342 45EC           30C0                       xor	al,al
15343 45EE           84C0                       test	al,al
15344 45F0           74           1E            je  	.324
15345                       000045F2            .325:
15346                                           ! 2470           outb(addr, 0x17);
15347                                           ! Debug: list int = const $17 (used reg = )
15348 45F2           B8                   0017  mov	ax,*$17
15349 45F5           50                         push	ax
15350                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15351 45F6           FF76         FE            push	-2[bp]
15352                                           ! Debug: func () void = outb+0 (used reg = )
15353 45F9           E8         BF58            call	_outb
15354 45FC           83C4                   04  add	sp,*4
15355                                           !BCC_EOS
15356                                           ! 2471           outb(addr+1, 0x04);
15357                                           ! Debug: list int = const 4 (used reg = )
15358 45FF           B8                   0004  mov	ax,*4
15359 4602           50                         push	ax
15360                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15361 4603           8B46         FE            mov	ax,-2[bp]
15362                                           ! Debug: list unsigned int = ax+1 (used reg = )
15363 4606           40                         inc	ax
15364 4607           50                         push	ax
15365                                           ! Debug: func () void = outb+0 (used reg = )
15366 4608           E8         BF49            call	_outb
15367 460B           83C4                   04  add	sp,*4
15368                                           !BCC_EOS
15369                                           ! 2472         } else {
15370 460E           EB           39            jmp .326
15371                       00004610            .324:
15372                                           ! 2473           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
15373                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
15374 4610           8A46         12            mov	al,$12[bp]
15375 4613           24                     E0  and	al,#$E0
15376                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
15377 4615           30E4                       xor	ah,ah
15378 4617           B1                     05  mov	cl,*5
15379 4619           D3E8                       shr	ax,cl
15380                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
15381 461B           89C3                       mov	bx,ax
15382 461D           B8                   0600  mov	ax,#$600
15383 4620           89D9                       mov	cx,bx
15384 4622           D3F8                       sar	ax,cl
15385                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15386 4624           8946         FA            mov	-6[bp],ax
15387                                           !BCC_EOS
15388                                           ! 2474           outb(addr, val16 & 0xFF);
15389                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
15390 4627           8A46         FA            mov	al,-6[bp]
15391                                           ! Debug: list unsigned char = al+0 (used reg = )
15392 462A           30E4                       xor	ah,ah
15393 462C           50                         push	ax
15394                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15395 462D           FF76         FE            push	-2[bp]
15396                                           ! Debug: func () void = outb+0 (used reg = )
15397 4630           E8         BF21            call	_outb
15398 4633           83C4                   04  add	sp,*4
15399                                           !BCC_EOS
15400                                           ! 2475           outb(addr+1, val16 >> 8);
15401                                           ! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
15402 4636           8B46         FA            mov	ax,-6[bp]
15403 4639           88E0                       mov	al,ah
15404 463B           30E4                       xor	ah,ah
15405                                           ! Debug: list unsigned int = ax+0 (used reg = )
15406 463D           50                         push	ax
15407                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15408 463E           8B46         FE            mov	ax,-2[bp]
15409                                           ! Debug: list unsigned int = ax+1 (used reg = )
15410 4641           40                         inc	ax
15411 4642           50                         push	ax
15412                                           ! Debug: func () void = outb+0 (used reg = )
15413 4643           E8         BF0E            call	_outb
15414 4646           83C4                   04  add	sp,*4
15415                                           !BCC_EOS
15416                                           ! 2476         }
15417                                           ! 2477         outb(addr+3, regs.u.r8.al & 0x1F);
15418                       00004649            .326:
15419                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
15420 4649           8A46         12            mov	al,$12[bp]
15421 464C           24                     1F  and	al,*$1F
15422                                           ! Debug: list unsigned char = al+0 (used reg = )
15423 464E           30E4                       xor	ah,ah
15424 4650           50                         push	ax
15425                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15426 4651           8B46         FE            mov	ax,-2[bp]
15427                                           ! Debug: list unsigned int = ax+3 (used reg = )
15428 4654           05                   0003  add	ax,*3
15429 4657           50                         push	ax
15430                                           ! Debug: func () void = outb+0 (used reg = )
15431 4658           E8         BEF9            call	_outb
15432 465B           83C4                   04  add	sp,*4
15433                                           !BCC_EOS
15434                                           ! 2478         regs.u.r8.ah = inb(addr+5);
15435                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15436 465E           8B46         FE            mov	ax,-2[bp]
15437                                           ! Debug: list unsigned int = ax+5 (used reg = )
15438 4661           05                   0005  add	ax,*5
15439 4664           50                         push	ax
15440                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15441 4665           E8         BED6            call	_inb
15442 4668           44                         inc	sp
15443 4669           44                         inc	sp
15444                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15445 466A           8846         13            mov	$13[bp],al
15446                                           !BCC_EOS
15447                                           ! 2479         regs.u.r
15448                                           ! 2479 8.al = inb(addr+6);
15449                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15450 466D           8B46         FE            mov	ax,-2[bp]
15451                                           ! Debug: list unsigned int = ax+6 (used reg = )
15452 4670           05                   0006  add	ax,*6
15453 4673           50                         push	ax
15454                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15455 4674           E8         BEC7            call	_inb
15456 4677           44                         inc	sp
15457 4678           44                         inc	sp
15458                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15459 4679           8846         12            mov	$12[bp],al
15460                                           !BCC_EOS
15461                                           ! 2480         iret_addr.flags.u.r8.flagsl &= 0xfe;
15462                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15463 467C           8A46         1A            mov	al,$1A[bp]
15464 467F           24                     FE  and	al,#$FE
15465 4681           8846         1A            mov	$1A[bp],al
15466                                           !BCC_EOS
15467                                           ! 2481         break;
15468 4684           E9         015F            br 	.320
15469                                           !BCC_EOS
15470                                           ! 2482       case 1:
15471                                           ! 2483         timer = read_word(0x0040, 0x006C);
15472                       00004687            .327:
15473                                           ! Debug: list int = const $6C (used reg = )
15474 4687           B8                   006C  mov	ax,*$6C
15475 468A           50                         push	ax
15476                                           ! Debug: list int = const $40 (used reg = )
15477 468B           B8                   0040  mov	ax,*$40
15478 468E           50                         push	ax
15479                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15480 468F           E8         BF75            call	_read_word
15481 4692           83C4                   04  add	sp,*4
15482                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15483 4695           8946         FC            mov	-4[bp],ax
15484                                           !BCC_EOS
15485                                           ! 2484         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
15486 4698           EB           26            jmp .329
15487                       0000469A            .32A:
15488                                           ! 2485           val16 = read_word(0x0040, 0x006C);
15489                                           ! Debug: list int = const $6C (used reg = )
15490 469A           B8                   006C  mov	ax,*$6C
15491 469D           50                         push	ax
15492                                           ! Debug: list int = const $40 (used reg = )
15493 469E           B8                   0040  mov	ax,*$40
15494 46A1           50                         push	ax
15495                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15496 46A2           E8         BF62            call	_read_word
15497 46A5           83C4                   04  add	sp,*4
15498                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15499 46A8           8946         FA            mov	-6[bp],ax
15500                                           !BCC_EOS
15501                                           ! 2486           if (val16 != timer) {
15502                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15503 46AB           8B46         FA            mov	ax,-6[bp]
15504 46AE           3B46         FC            cmp	ax,-4[bp]
15505 46B1           74           0D            je  	.32B
15506                       000046B3            .32C:
15507                                           ! 2487             timer = val16;
15508                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15509 46B3           8B46         FA            mov	ax,-6[bp]
15510 46B6           8946         FC            mov	-4[bp],ax
15511                                           !BCC_EOS
15512                                           ! 2488             timeout--;
15513                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
15514 46B9           8A46         F9            mov	al,-7[bp]
15515 46BC           48                         dec	ax
15516 46BD           8846         F9            mov	-7[bp],al
15517                                           !BCC_EOS
15518                                           ! 2489             }
15519                                           ! 2490           }
15520                       000046C0            .32B:
15521                                           ! 2491         if (timeout) outb(addr, regs.u.r8.al);
15522                       000046C0            .329:
15523                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15524 46C0           8B46         FE            mov	ax,-2[bp]
15525                                           ! Debug: list unsigned int = ax+5 (used reg = )
15526 46C3           05                   0005  add	ax,*5
15527 46C6           50                         push	ax
15528                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15529 46C7           E8         BE74            call	_inb
15530 46CA           44                         inc	sp
15531 46CB           44                         inc	sp
15532                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
15533 46CC           24                     60  and	al,*$60
15534                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
15535 46CE           3C                     60  cmp	al,*$60
15536 46D0           74           07            je  	.32D
15537                       000046D2            .32E:
15538 46D2           8A46         F9            mov	al,-7[bp]
15539 46D5           84C0                       test	al,al
15540 46D7           75           C1            jne	.32A
15541                       000046D9            .32D:
15542                       000046D9            .328:
15543 46D9           8A46         F9            mov	al,-7[bp]
15544 46DC           84C0                       test	al,al
15545 46DE           74           0F            je  	.32F
15546                       000046E0            .330:
15547                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
15548 46E0           8A46         12            mov	al,$12[bp]
15549 46E3           30E4                       xor	ah,ah
15550 46E5           50                         push	ax
15551                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15552 46E6           FF76         FE            push	-2[bp]
15553                                           ! Debug: func () void = outb+0 (used reg = )
15554 46E9           E8         BE68            call	_outb
15555 46EC           83C4                   04  add	sp,*4
15556                                           !BCC_EOS
15557                                           ! 2492         regs.u.r8.ah = inb(addr+5);
15558                       000046EF            .32F:
15559                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15560 46EF           8B46         FE            mov	ax,-2[bp]
15561                                           ! Debug: list unsigned int = ax+5 (used reg = )
15562 46F2           05                   0005  add	ax,*5
15563 46F5           50                         push	ax
15564                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15565 46F6           E8         BE45            call	_inb
15566 46F9           44                         inc	sp
15567 46FA           44                         inc	sp
15568                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15569 46FB           8846         13            mov	$13[bp],al
15570                                           !BCC_EOS
15571                                           ! 2493         if (!timeout) regs.u.r8.ah |= 0x80;
15572 46FE           8A46         F9            mov	al,-7[bp]
15573 4701           84C0                       test	al,al
15574 4703           75           08            jne 	.331
15575                       00004705            .332:
15576                                           ! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15577 4705           8A46         13            mov	al,$13[bp]
15578 4708           0C                     80  or	al,#$80
15579 470A           8846         13            mov	$13[bp],al
15580                                           !BCC_EOS
15581                                           ! 2494         iret_addr.flags.u.r8.flagsl &= 0xfe;
15582                       0000470D            .331:
15583                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15584 470D           8A46         1A            mov	al,$1A[bp]
15585 4710           24                     FE  and	al,#$FE
15586 4712           8846         1A            mov	$1A[bp],al
15587                                           !BCC_EOS
15588                                           ! 2495         break;
15589 4715           E9         00CE            br 	.320
15590                                           !BCC_EOS
15591                                           ! 2496       case 2:
15592                                           ! 2497         timer = read_word(0x0040, 0x006C);
15593                       00004718            .333:
15594                                           ! Debug: list int = const $6C (used reg = )
15595 4718           B8                   006C  mov	ax,*$6C
15596 471B           50                         push	ax
15597                                           ! Debug: list int = const $40 (used reg = )
15598 471C           B8                   0040  mov	ax,*$40
15599 471F           50                         push	ax
15600                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15601 4720           E8         BEE4            call	_read_word
15602 4723           83C4                   04  add	sp,*4
15603                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15604 4726           8946         FC            mov	-4[bp],ax
15605                                           !BCC_EOS
15606                                           ! 2498         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
15607 4729           EB           26            jmp .335
15608                       0000472B            .336:
15609                                           ! 2499           val16 = read_word(0x0040, 0x006C);
15610                                           ! Debug: list int = const $6C (used reg = )
15611 472B           B8                   006C  mov	ax,*$6C
15612 472E           50                         push	ax
15613                                           ! Debug: list int = const $40 (used reg = )
15614 472F           B8                   0040  mov	ax,*$40
15615 4732           50                         push	ax
15616                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15617 4733           E8         BED1            call	_read_word
15618 4736           83C4                   04  add	sp,*4
15619                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15620 4739           8946         FA            mov	-6[bp],ax
15621                                           !BCC_EOS
15622                                           ! 2500           if (val16 != timer) {
15623                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15624 473C           8B46         FA            mov	ax,-6[bp]
15625 473F           3B46         FC            cmp	ax,-4[bp]
15626 4742           74           0D            je  	.337
15627                       00004744            .338:
15628                                           ! 2501             timer = val16;
15629                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15630 4744           8B46         FA            mov	ax,-6[bp]
15631 4747           8946         FC            mov	-4[bp],ax
15632                                           !BCC_EOS
15633                                           ! 2502             timeout--;
15634                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
15635 474A           8A46         F9            mov	al,-7[bp]
15636 474D           48                         dec	ax
15637 474E           8846         F9            mov	-7[bp],al
15638                                           !BCC_EOS
15639                                           ! 2503             }
15640                                           ! 2504           }
15641                       00004751            .337:
15642                                           ! 2505         if (timeout) {
15643                       00004751            .335:
15644                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15645 4751           8B46         FE            mov	ax,-2[bp]
15646                                           ! Debug: list unsigned int = ax+5 (used reg = )
15647 4754           05                   0005  add	ax,*5
15648 4757           50                         push	ax
15649                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15650 4758           E8         BDE3            call	_inb
15651 475B           44                         inc	sp
15652 475C           44                         inc	sp
15653                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
15654 475D           24                     01  and	al,*1
15655                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15656 475F           84C0                       test	al,al
15657 4761           75           07            jne 	.339
15658                       00004763            .33A:
15659 4763           8A46         F9            mov	al,-7[bp]
15660 4766           84C0                       test	al,al
15661 4768           75           C1            jne	.336
15662                       0000476A            .339:
15663                       0000476A            .334:
15664 476A           8A46         F9            mov	al,-7[bp]
15665 476D           84C0                       test	al,al
15666 476F           74           12            je  	.33B
15667                       00004771            .33C:
15668                                           ! 2506           regs.u.r8.ah = 0;
15669                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
15670 4771           30C0                       xor	al,al
15671 4773           8846         13            mov	$13[bp],al
15672                                           !BCC_EOS
15673                                           ! 2507           regs.u.r8.al = inb(addr);
15674                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
15675 4776           FF76         FE            push	-2[bp]
15676                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15677 4779           E8         BDC2            call	_inb
15678 477C           44                         inc	sp
15679 477D           44                         inc	sp
15680                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15681 477E           8846         12            mov	$12[bp],al
15682                                           !BCC_EOS
15683                                           ! 2508         } else {
15684 4781           EB           0F            jmp .33D
15685                       00004783            .33B:
15686                                           ! 2509           regs.u.r8.ah = inb(addr+5);
15687                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15688 4783           8B46         FE            mov	ax,-2[bp]
15689                                           ! Debug: list unsigned int = ax+5 (used reg = )
15690 4786           05                   0005  add	ax,*5
15691 4789           50                         push	ax
15692                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15693 478A           E8         BDB1            call	_inb
15694 478D           44                         inc	sp
15695 478E           44                         inc	sp
15696                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15697 478F           8846         13            mov	$13[bp],al
15698                                           !BCC_EOS
15699                                           ! 2510           }
15700                                           ! 2511         iret_addr.flags.u.r8.flagsl &= 0xfe;
15701                       00004792            .33D:
15702                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15703 4792           8A46         1A            mov	al,$1A[bp]
15704 4795           24                     FE  and	al,#$FE
15705 4797           8846         1A            mov	$1A[bp],al
15706                                           !BCC_EOS
15707                                           ! 2512         break;
15708 479A           EB           4A            jmp .320
15709                                           !BCC_EOS
15710                                           ! 2513       case 3:
15711                                           ! 2514         regs.u.r8.ah = inb(addr+5);
15712                       0000479C            .33E:
15713                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15714 479C           8B46         FE            mov	ax,-2[bp]
15715                                           ! Debug: list unsigned int = ax+5 (used reg = )
15716 479F           05                   0005  add	ax,*5
15717 47A2           50                         push	ax
15718                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15719 47A3           E8         BD98            call	_inb
15720 47A6           44                         inc	sp
15721 47A7           44                         inc	sp
15722                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15723 47A8           8846         13            mov	$13[bp],al
15724                                           !BCC_EOS
15725                                           ! 2515         regs.u.r8.al = inb(addr+6);
15726                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15727 47AB           8B46         FE            mov	ax,-2[bp]
15728                                           ! Debug: list unsigned int = ax+6 (used reg = )
15729 47AE           05                   0006  add	ax,*6
15730 47B1           50                         push	ax
15731                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15732 47B2           E8         BD89            call	_inb
15733 47B5           44                         inc	sp
15734 47B6           44                         inc	sp
15735                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15736 47B7           8846         12            mov	$12[bp],al
15737                                           !BCC_EOS
15738                                           ! 2516         iret_addr.flags.u.r8.flagsl &= 0xfe;
15739                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15740 47BA           8A46         1A            mov	al,$1A[bp]
15741 47BD           24                     FE  and	al,#$FE
15742 47BF           8846         1A            mov	$1A[bp],al
15743                                           !BCC_EOS
15744                                           ! 2517         break;
15745 47C2           EB           22            jmp .320
15746                                           !BCC_EOS
15747                                           ! 2518       default:
15748                                           ! 2519         iret_addr.flags.u.r8.flagsl |= 0x01;
15749                       000047C4            .33F:
15750                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15751 47C4           8A46         1A            mov	al,$1A[bp]
15752 47C7           0C                     01  or	al,*1
15753 47C9           8846         1A            mov	$1A[bp],al
15754                                           !BCC_EOS
15755                                           ! 2520       }
15756                                           ! 2521   } else {
15757 47CC           EB           18            jmp .320
15758                       000047CE            .322:
15759 47CE           2C                     00  sub	al,*0
15760 47D0         0F84         FDF7            beq 	.323
15761 47D4           2C                     01  sub	al,*1
15762 47D6         0F84         FEAD            beq 	.327
15763 47DA           2C                     01  sub	al,*1
15764 47DC         0F84         FF38            beq 	.333
15765 47E0           2C                     01  sub	al,*1
15766 47E2           74           B8            je 	.33E
15767 47E4           EB           DE            jmp	.33F
15768                       000047E6            .320:
15769                       FFFFFFF6            ..FFF8	=	-$A
15770 47E6           EB           08            jmp .340
15771                       000047E8            .31D:
15772                                           ! 2522     iret_addr.flags.u.r8.flagsl |= 0x01;
15773                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15774 47E8           8A46         1A            mov	al,$1A[bp]
15775 47EB           0C                     01  or	al,*1
15776 47ED           8846         1A            mov	$1A[bp],al
15777                                           !BCC_EOS
15778                                           ! 2523     }
15779                                           ! 2524 }
15780                       000047F0            .340:
15781 47F0           89EC                       mov	sp,bp
15782 47F2           5D                         pop	bp
15783 47F3           C3                         ret
15784                                           ! 2525   void
15785                                           ! Register BX used in function int14_function
15786                                           ! 2526 int15_function(regs, ES, DS, FLAGS)
15787                                           ! 2527   pusha_regs_t regs;
15788                                           export	_int15_function
15789                       000047F4            _int15_function:
15790                                           !BCC_EOS
15791                                           ! 2528   Bit16u ES, DS, FLAGS;
15792                                           !BCC_EOS
15793                                           ! 2529 {
15794                                           ! 2530   Bit16u ebda_seg=read_word(0x0040,0x000E);
15795 47F4           55                         push	bp
15796 47F5           89E5                       mov	bp,sp
15797 47F7           4C                         dec	sp
15798 47F8           4C                         dec	sp
15799                                           ! Debug: list int = const $E (used reg = )
15800 47F9           B8                   000E  mov	ax,*$E
15801 47FC           50                         push	ax
15802                                           ! Debug: list int = const $40 (used reg = )
15803 47FD           B8                   0040  mov	ax,*$40
15804 4800           50                         push	ax
15805                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15806 4801           E8         BE03            call	_read_word
15807 4804           83C4                   04  add	sp,*4
15808                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15809 4807           8946         FE            mov	-2[bp],ax
15810                                           !BCC_EOS
15811                                           ! 2531   bx_bool prev_a20_enable;
15812                                           !BCC_EOS
15813                                           ! 2532   Bit16u base15_00;
15814                                           !BCC_EOS
15815                                           ! 2533   Bit8u base23_16;
15816                                           !BCC_EOS
15817                                           ! 2534   Bit16u ss;
15818                                           !BCC_EOS
15819                                           ! 2535   Bit16u CX,DX;
15820                                           !BCC_EOS
15821                                           ! 2536   Bit16u bRegister;
15822                                           !BCC_EOS
15823                                           ! 2537   Bit8u irqDisable;
15824                                           !BCC_EOS
15825                                           ! 2538 ;
15826 480A           83C4                   F0  add	sp,*-$10
15827                                           !BCC_EOS
15828                                           ! 2539   switch (regs.u.r8.ah) {
15829 480D           8A46         13            mov	al,$13[bp]
15830 4810           E9         0489            br 	.343
15831                                           ! 2540     case 0x24:
15832                                           ! 2541       switch (regs.u.r8.al) {
15833                       00004813            .344:
15834 4813           8A46         12            mov	al,$12[bp]
15835 4816           EB           74            jmp .347
15836                                           ! 2542         case 0x00:
15837                                           ! 2543           set_enable_a20(0);
15838                       00004818            .348:
15839                                           ! Debug: list int = const 0 (used reg = )
15840 4818           31C0                       xor	ax,ax
15841 481A           50                         push	ax
15842                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15843 481B           E8         D0AA            call	_set_enable_a20
15844 481E           44                         inc	sp
15845 481F           44                         inc	sp
15846                                           !BCC_EOS
15847                                           ! 2544           FLAGS &= 0xfffe;
15848                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15849 4820           8B46         18            mov	ax,$18[bp]
15850 4823           24                     FE  and	al,#$FE
15851 4825           8946         18            mov	$18[bp],ax
15852                                           !BCC_EOS
15853                                           ! 2545           regs.u.r8.ah = 0;
15854                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
15855 4828           30C0                       xor	al,al
15856 482A           8846         13            mov	$13[bp],al
15857                                           !BCC_EOS
15858                                           ! 2546           break;
15859 482D           EB           6F            jmp .345
15860                                           !BCC_EOS
15861                                           ! 2547         case 0x01:
15862                                           ! 2548           set_enable_a20(1);
15863                       0000482F            .349:
15864                                           ! Debug: list int = const 1 (used reg = )
15865 482F           B8                   0001  mov	ax,*1
15866 4832           50                         push	ax
15867                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15868 4833           E8         D092            call	_set_enable_a20
15869 4836           44                         inc	sp
15870 4837           44                         inc	sp
15871                                           !BCC_EOS
15872                                           ! 2549           FLAGS &= 0xfffe;
15873                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15874 4838           8B46         18            mov	ax,$18[bp]
15875 483B           24                     FE  and	al,#$FE
15876 483D           8946         18            mov	$18[bp],ax
15877                                           !BCC_EOS
15878                                           ! 2550           regs.u.r8.ah = 0;
15879                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
15880 4840           30C0                       xor	al,al
15881 4842           8846         13            mov	$13[bp],al
15882                                           !BCC_EOS
15883                                           ! 2551           break;
15884 4845           EB           57            jmp .345
15885                                           !BCC_EOS
15886                                           ! 2552         case 0x02:
15887                                           ! 2553           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
15888                       00004847            .34A:
15889                                           ! Debug: list int = const $92 (used reg = )
15890 4847           B8                   0092  mov	ax,#$92
15891 484A           50                         push	ax
15892                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15893 484B           E8         BCF0            call	_inb
15894 484E           44                         inc	sp
15895 484F           44                         inc	sp
15896                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
15897 4850           30E4                       xor	ah,ah
15898 4852           D1E8                       shr	ax,*1
15899                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
15900 4854           24                     01  and	al,*1
15901                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
15902 4856           8846         12            mov	$12[bp],al
15903                                           !BCC_EOS
15904                                           ! 2554           FLAGS &= 0xfffe;
15905                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15906 4859           8B46         18            mov	ax,$18[bp]
15907 485C           24                     FE  and	al,#$FE
15908 485E           8946         18            mov	$18[bp],ax
15909                                           !BCC_EOS
15910                                           ! 2555           regs.u.r8.ah = 0;
15911                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
15912 4861           30C0                       xor	al,al
15913 4863           8846         13            mov	$13[bp],al
15914                                           !BCC_EOS
15915                                           ! 2556           break;
15916 4866           EB           36            jmp .345
15917                                           !BCC_EOS
15918                                           ! 2557         case 0x03:
15919                                           ! 2558           
15920                                           ! 2558 FLAGS &= 0xfffe;
15921                       00004868            .34B:
15922                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15923 4868           8B46         18            mov	ax,$18[bp]
15924 486B           24                     FE  and	al,#$FE
15925 486D           8946         18            mov	$18[bp],ax
15926                                           !BCC_EOS
15927                                           ! 2559           regs.u.r8.ah = 0;
15928                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
15929 4870           30C0                       xor	al,al
15930 4872           8846         13            mov	$13[bp],al
15931                                           !BCC_EOS
15932                                           ! 2560           regs.u.r16.bx = 3;
15933                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
15934 4875           B8                   0003  mov	ax,*3
15935 4878           8946         0C            mov	$C[bp],ax
15936                                           !BCC_EOS
15937                                           ! 2561           break;
15938 487B           EB           21            jmp .345
15939                                           !BCC_EOS
15940                                           ! 2562         default:
15941                                           ! 2563           ;
15942                       0000487D            .34C:
15943                                           !BCC_EOS
15944                                           ! 2564           FLAGS |= 0x0001;
15945                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
15946 487D           8B46         18            mov	ax,$18[bp]
15947 4880           0C                     01  or	al,*1
15948 4882           8946         18            mov	$18[bp],ax
15949                                           !BCC_EOS
15950                                           ! 2565           regs.u.r8.ah = 0x86;
15951                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
15952 4885           B0                     86  mov	al,#$86
15953 4887           8846         13            mov	$13[bp],al
15954                                           !BCC_EOS
15955                                           ! 2566       }
15956                                           ! 2567       break;
15957 488A           EB           12            jmp .345
15958                       0000488C            .347:
15959 488C           2C                     00  sub	al,*0
15960 488E           74           88            je 	.348
15961 4890           2C                     01  sub	al,*1
15962 4892           74           9B            je 	.349
15963 4894           2C                     01  sub	al,*1
15964 4896           74           AF            je 	.34A
15965 4898           2C                     01  sub	al,*1
15966 489A           74           CC            je 	.34B
15967 489C           EB           DF            jmp	.34C
15968                       0000489E            .345:
15969 489E           E9         044B            br 	.341
15970                                           !BCC_EOS
15971                                           ! 2568     case 0x41:
15972                                           ! 2569       FLAGS |= 0x0001;
15973                       000048A1            .34D:
15974                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
15975 48A1           8B46         18            mov	ax,$18[bp]
15976 48A4           0C                     01  or	al,*1
15977 48A6           8946         18            mov	$18[bp],ax
15978                                           !BCC_EOS
15979                                           ! 2570       regs.u.r8.ah = 0x86;
15980                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
15981 48A9           B0                     86  mov	al,#$86
15982 48AB           8846         13            mov	$13[bp],al
15983                                           !BCC_EOS
15984                                           ! 2571       break;
15985 48AE           E9         043B            br 	.341
15986                                           !BCC_EOS
15987                                           ! 2572     case 0x4f:
15988                                           ! 2573       FLAGS |= 0x0001;
15989                       000048B1            .34E:
15990                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
15991 48B1           8B46         18            mov	ax,$18[bp]
15992 48B4           0C                     01  or	al,*1
15993 48B6           8946         18            mov	$18[bp],ax
15994                                           !BCC_EOS
15995                                           ! 2574       break;
15996 48B9           E9         0430            br 	.341
15997                                           !BCC_EOS
15998                                           ! 2575     case 0x52:
15999                                           ! 2576       FLAGS &= 0xfffe;
16000                       000048BC            .34F:
16001                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16002 48BC           8B46         18            mov	ax,$18[bp]
16003 48BF           24                     FE  and	al,#$FE
16004 48C1           8946         18            mov	$18[bp],ax
16005                                           !BCC_EOS
16006                                           ! 2577       regs.u.r8.ah = 0;
16007                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16008 48C4           30C0                       xor	al,al
16009 48C6           8846         13            mov	$13[bp],al
16010                                           !BCC_EOS
16011                                           ! 2578       break;
16012 48C9           E9         0420            br 	.341
16013                                           !BCC_EOS
16014                                           ! 2579     case 0x83: {
16015                       000048CC            .350:
16016                                           ! 2580       if( regs.u.r8.al == 0 ) {
16017                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
16018 48CC           8A46         12            mov	al,$12[bp]
16019 48CF           84C0                       test	al,al
16020 48D1         0F85         00C1            bne 	.351
16021                       000048D5            .352:
16022                                           ! 2581         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
16023                                           ! Debug: list int = const $A0 (used reg = )
16024 48D5           B8                   00A0  mov	ax,#$A0
16025 48D8           50                         push	ax
16026                                           ! Debug: list int = const $40 (used reg = )
16027 48D9           B8                   0040  mov	ax,*$40
16028 48DC           50                         push	ax
16029                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16030 48DD           E8         BD14            call	_read_byte
16031 48E0           83C4                   04  add	sp,*4
16032                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
16033 48E3           24                     01  and	al,*1
16034                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
16035 48E5           84C0                       test	al,al
16036 48E7         0F85         009C            bne 	.353
16037                       000048EB            .354:
16038                                           ! 2582           write_byte( 0x40, 0xA0, 1 );
16039                                           ! Debug: list int = const 1 (used reg = )
16040 48EB           B8                   0001  mov	ax,*1
16041 48EE           50                         push	ax
16042                                           ! Debug: list int = const $A0 (used reg = )
16043 48EF           B8                   00A0  mov	ax,#$A0
16044 48F2           50                         push	ax
16045                                           ! Debug: list int = const $40 (used reg = )
16046 48F3           B8                   0040  mov	ax,*$40
16047 48F6           50                         push	ax
16048                                           ! Debug: func () void = write_byte+0 (used reg = )
16049 48F7           E8         BD20            call	_write_byte
16050 48FA           83C4                   06  add	sp,*6
16051                                           !BCC_EOS
16052                                           ! 2583           write_word( 0x40, 0x98, ES );
16053                                           ! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
16054 48FD           FF76         14            push	$14[bp]
16055                                           ! Debug: list int = const $98 (used reg = )
16056 4900           B8                   0098  mov	ax,#$98
16057 4903           50                         push	ax
16058                                           ! Debug: list int = const $40 (used reg = )
16059 4904           B8                   0040  mov	ax,*$40
16060 4907           50                         push	ax
16061                                           ! Debug: func () void = write_word+0 (used reg = )
16062 4908           E8         BD27            call	_write_word
16063 490B           83C4                   06  add	sp,*6
16064                                           !BCC_EOS
16065                                           ! 2584           write_word( 0x40, 0x9A, regs.u.r16.bx );
16066                                           ! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
16067 490E           FF76         0C            push	$C[bp]
16068                                           ! Debug: list int = const $9A (used reg = )
16069 4911           B8                   009A  mov	ax,#$9A
16070 4914           50                         push	ax
16071                                           ! Debug: list int = const $40 (used reg = )
16072 4915           B8                   0040  mov	ax,*$40
16073 4918           50                         push	ax
16074                                           ! Debug: func () void = write_word+0 (used reg = )
16075 4919           E8         BD16            call	_write_word
16076 491C           83C4                   06  add	sp,*6
16077                                           !BCC_EOS
16078                                           ! 2585           write_word( 0x40, 0x9C, regs.u.r16.dx );
16079                                           ! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
16080 491F           FF76         0E            push	$E[bp]
16081                                           ! Debug: list int = const $9C (used reg = )
16082 4922           B8                   009C  mov	ax,#$9C
16083 4925           50                         push	ax
16084                                           ! Debug: list int = const $40 (used reg = )
16085 4926           B8                   0040  mov	ax,*$40
16086 4929           50                         push	ax
16087                                           ! Debug: func () void = write_word+0 (used reg = )
16088 492A           E8         BD05            call	_write_word
16089 492D           83C4                   06  add	sp,*6
16090                                           !BCC_EOS
16091                                           ! 2586           write_word( 0x40, 0x9E, regs.u.r16.cx );
16092                                           ! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
16093 4930           FF76         10            push	$10[bp]
16094                                           ! Debug: list int = const $9E (used reg = )
16095 4933           B8                   009E  mov	ax,#$9E
16096 4936           50                         push	ax
16097                                           ! Debug: list int = const $40 (used reg = )
16098 4937           B8                   0040  mov	ax,*$40
16099 493A           50                         push	ax
16100                                           ! Debug: func () void = write_word+0 (used reg = )
16101 493B           E8         BCF4            call	_write_word
16102 493E           83C4                   06  add	sp,*6
16103                                           !BCC_EOS
16104                                           ! 2587           FLAGS &= 0xfffe;
16105                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16106 4941           8B46         18            mov	ax,$18[bp]
16107 4944           24                     FE  and	al,#$FE
16108 4946           8946         18            mov	$18[bp],ax
16109                                           !BCC_EOS
16110                                           ! 2588           irqDisable = inb( 0xA1 );
16111                                           ! Debug: list int = const $A1 (used reg = )
16112 4949           B8                   00A1  mov	ax,#$A1
16113 494C           50                         push	ax
16114                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16115 494D           E8         BBEE            call	_inb
16116 4950           44                         inc	sp
16117 4951           44                         inc	sp
16118                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
16119 4952           8846         EF            mov	-$11[bp],al
16120                                           !BCC_EOS
16121                                           ! 2589           outb( 0xA1, irqDisable & 0xFE );
16122                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
16123 4955           8A46         EF            mov	al,-$11[bp]
16124 4958           24                     FE  and	al,#$FE
16125                                           ! Debug: list unsigned char = al+0 (used reg = )
16126 495A           30E4                       xor	ah,ah
16127 495C           50                         push	ax
16128                                           ! Debug: list int = const $A1 (used reg = )
16129 495D           B8                   00A1  mov	ax,#$A1
16130 4960           50                         push	ax
16131                                           ! Debug: func () void = outb+0 (used reg = )
16132 4961           E8         BBF0            call	_outb
16133 4964           83C4                   04  add	sp,*4
16134                                           !BCC_EOS
16135                                           ! 2590           bRegister = inb_cmos( 0xB );
16136                                           ! Debug: list int = const $B (used reg = )
16137 4967           B8                   000B  mov	ax,*$B
16138 496A           50                         push	ax
16139                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16140 496B           E8         BC15            call	_inb_cmos
16141 496E           44                         inc	sp
16142 496F           44                         inc	sp
16143                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16144 4970           30E4                       xor	ah,ah
16145 4972           8946         F0            mov	-$10[bp],ax
16146                                           !BCC_EOS
16147                                           ! 2591           outb_cmos( 0xB, bRegister | 0x40 );
16148                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
16149 4975           8B46         F0            mov	ax,-$10[bp]
16150 4978           0C                     40  or	al,*$40
16151                                           ! Debug: list unsigned int = ax+0 (used reg = )
16152 497A           50                         push	ax
16153                                           ! Debug: list int = const $B (used reg = )
16154 497B           B8                   000B  mov	ax,*$B
16155 497E           50                         push	ax
16156                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16157 497F           E8         BBF2            call	_outb_cmos
16158 4982           83C4                   04  add	sp,*4
16159                                           !BCC_EOS
16160                                           ! 2592         } else {
16161 4985           EB           0D            jmp .355
16162                       00004987            .353:
16163                                           ! 2593           ;
16164                                           !BCC_EOS
16165                                           ! 2594           FLAGS |= 0x0001;
16166                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16167 4987           8B46         18            mov	ax,$18[bp]
16168 498A           0C                     01  or	al,*1
16169 498C           8946         18            mov	$18[bp],ax
16170                                           !BCC_EOS
16171                                           ! 2595           regs.u.r8.ah = 0x86;
16172                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16173 498F           B0                     86  mov	al,#$86
16174 4991           8846         13            mov	$13[bp],al
16175                                           !BCC_EOS
16176                                           ! 2596         }
16177                                           ! 2597       } else if( regs.u.r8.al == 1 ) {
16178                       00004994            .355:
16179 4994           EB           54            jmp .356
16180                       00004996            .351:
16181                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
16182 4996           8A46         12            mov	al,$12[bp]
16183 4999           3C                     01  cmp	al,*1
16184 499B           75           39            jne 	.357
16185                       0000499D            .358:
16186                                           ! 2598         write_byte( 0x40, 0xA0, 0 );
16187                                           ! Debug: list int = const 0 (used reg = )
16188 499D           31C0                       xor	ax,ax
16189 499F           50                         push	ax
16190                                           ! Debug: list int = const $A0 (used reg = )
16191 49A0           B8                   00A0  mov	ax,#$A0
16192 49A3           50                         push	ax
16193                                           ! Debug: list int = const $40 (used reg = )
16194 49A4           B8                   0040  mov	ax,*$40
16195 49A7           50                         push	ax
16196                                           ! Debug: func () void = write_byte+0 (used reg = )
16197 49A8           E8         BC6F            call	_write_byte
16198 49AB           83C4                   06  add	sp,*6
16199                                           !BCC_EOS
16200                                           ! 2599         FLAGS &= 0xfffe;
16201                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16202 49AE           8B46         18            mov	ax,$18[bp]
16203 49B1           24                     FE  and	al,#$FE
16204 49B3           8946         18            mov	$18[bp],ax
16205                                           !BCC_EOS
16206                                           ! 2600         bRegister = inb_cmos( 0xB );
16207                                           ! Debug: list int = const $B (used reg = )
16208 49B6           B8                   000B  mov	ax,*$B
16209 49B9           50                         push	ax
16210                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16211 49BA           E8         BBC6            call	_inb_cmos
16212 49BD           44                         inc	sp
16213 49BE           44                         inc	sp
16214                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16215 49BF           30E4                       xor	ah,ah
16216 49C1           8946         F0            mov	-$10[bp],ax
16217                                           !BCC_EOS
16218                                           ! 2601         outb_cmos( 0xB, bRegister & ~0x40 );
16219                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
16220 49C4           8B46         F0            mov	ax,-$10[bp]
16221 49C7           24                     BF  and	al,#$BF
16222                                           ! Debug: list unsigned int = ax+0 (used reg = )
16223 49C9           50                         push	ax
16224                                           ! Debug: list int = const $B (used reg = )
16225 49CA           B8                   000B  mov	ax,*$B
16226 49CD           50                         push	ax
16227                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16228 49CE           E8         BBA3            call	_outb_cmos
16229 49D1           83C4                   04  add	sp,*4
16230                                           !BCC_EOS
16231                                           ! 2602       } else {
16232 49D4           EB           14            jmp .359
16233                       000049D6            .357:
16234                                           ! 2603         ;
16235                                           !BCC_EOS
16236                                           ! 2604         FLAGS |= 0x0001;
16237                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16238 49D6           8B46         18            mov	ax,$18[bp]
16239 49D9           0C                     01  or	al,*1
16240 49DB           8946         18            mov	$18[bp],ax
16241                                           !BCC_EOS
16242                                           ! 2605         regs.u.r8.ah = 0x86;
16243                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16244 49DE           B0                     86  mov	al,#$86
16245 49E0           8846         13            mov	$13[bp],al
16246                                           !BCC_EOS
16247                                           ! 2606         regs.u.r8.al--;
16248                                           ! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
16249 49E3           8A46         12            mov	al,$12[bp]
16250 49E6           48                         dec	ax
16251 49E7           8846         12            mov	$12[bp],al
16252                                           !BCC_EOS
16253                                           ! 2607       }
16254                                           ! 2608       break;
16255                       000049EA            .359:
16256                       000049EA            .356:
16257 49EA           E9         02FF            br 	.341
16258                                           !BCC_EOS
16259                                           ! 2609     }
16260                                           ! 2610     case 0x87:
16261                                           ! 2611 #asm
16262                       000049ED            .35A:
16263                                           !BCC_EOS
16264                                           !BCC_ASM
16265                       00000006            _int15_function.CX	set	6
16266                       FFFFFFF4            .int15_function.CX	set	-$C
16267                       0000002A            _int15_function.FLAGS	set	$2A
16268                       00000018            .int15_function.FLAGS	set	$18
16269                       00000001            _int15_function.irqDisable	set	1
16270                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16271                       00000028            _int15_function.DS	set	$28
16272                       00000016            .int15_function.DS	set	$16
16273                       00000004            _int15_function.DX	set	4
16274                       FFFFFFF2            .int15_function.DX	set	-$E
16275                       0000000B            _int15_function.base23_16	set	$B
16276                       FFFFFFF9            .int15_function.base23_16	set	-7
16277                       00000002            _int15_function.bRegister	set	2
16278                       FFFFFFF0            .int15_function.bRegister	set	-$10
16279                       00000026            _int15_function.ES	set	$26
16280                       00000014            .int15_function.ES	set	$14
16281                       00000010            _int15_function.ebda_seg	set	$10
16282                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16283                       0000000C            _int15_function.base15_00	set	$C
16284                       FFFFFFFA            .int15_function.base15_00	set	-6
16285                       00000008            _int15_function.ss	set	8
16286                       FFFFFFF6            .int15_function.ss	set	-$A
16287                       00000016            _int15_function.regs	set	$16
16288                       00000004            .int15_function.regs	set	4
16289                       0000000E            _int15_function.prev_a20_enable	set	$E
16290                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16291 49ED           FA                           cli
16292                                           ! 2613 endasm
16293                                           !BCC_ENDASM
16294                                           !BCC_EOS
16295                                           ! 2614       prev_a20_enable = set_enable_a20(1);
16296                                           ! Debug: list int = const 1 (used reg = )
16297 49EE           B8                   0001  mov	ax,*1
16298 49F1           50                         push	ax
16299                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16300 49F2           E8         CED3            call	_set_enable_a20
16301 49F5           44                         inc	sp
16302 49F6           44                         inc	sp
16303                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
16304 49F7           8946         FC            mov	-4[bp],ax
16305                                           !BCC_EOS
16306                                           ! 2615       base15_00 = (ES << 4) + regs.u.r16.si;
16307                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16308 49FA           8B46         14            mov	ax,$14[bp]
16309 49FD           B1                     04  mov	cl,*4
16310 49FF           D3E0                       shl	ax,cl
16311                                           ! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
16312 4A01           0346         06            add	ax,6[bp]
16313                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16314 4A04           8946         FA            mov	-6[bp],ax
16315                                           !BCC_EOS
16316                                           ! 2616       base23_16 = ES >> 12;
16317                                           ! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
16318 4A07           8B46         14            mov	ax,$14[bp]
16319 4A0A           88E0                       mov	al,ah
16320 4A0C           30E4                       xor	ah,ah
16321 4A0E           B1                     04  mov	cl,*4
16322 4A10           D3E8                       shr	ax,cl
16323                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16324 4A12           8846         F9            mov	-7[bp],al
16325                                           !BCC_EOS
16326                                           ! 2617       if (base15_00 < (ES<<4))
16327                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16328 4A15           8B46         14            mov	ax,$14[bp]
16329 4A18           B1                     04  mov	cl,*4
16330 4A1A           D3E0                       shl	ax,cl
16331                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16332 4A1C           3B46         FA            cmp	ax,-6[bp]
16333 4A1F           76           07            jbe 	.35B
16334                       00004A21            .35C:
16335                                           ! 2618         base23_16++;
16336                                           ! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
16337 4A21           8A46         F9            mov	al,-7[bp]
16338 4A24           40                         inc	ax
16339 4A25           8846         F9            mov	-7[bp],al
16340                                           !BCC_EOS
16341                                           ! 2619       write_word(ES, regs.u.r16.si+0x08+0, 47);
16342                       00004A28            .35B:
16343                                           ! Debug: list int = const $2F (used reg = )
16344 4A28           B8                   002F  mov	ax,*$2F
16345 4A2B           50                         push	ax
16346                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16347 4A2C           8B46         06            mov	ax,6[bp]
16348                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
16349                                           ! Debug: list unsigned int = ax+8 (used reg = )
16350 4A2F           05                   0008  add	ax,*8
16351 4A32           50                         push	ax
16352                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16353 4A33           FF76         14            push	$14[bp]
16354                                           ! Debug: func () void = write_word+0 (used reg = )
16355 4A36           E8         BBF9            call	_write_word
16356 4A39           83C4                   06  add	sp,*6
16357                                           !BCC_EOS
16358                                           ! 2620       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
16359                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16360 4A3C           FF76         FA            push	-6[bp]
16361                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16362 4A3F           8B46         06            mov	ax,6[bp]
16363                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
16364                                           ! Debug: list unsigned int = ax+$A (used reg = )
16365 4A42           05                   000A  add	ax,*$A
16366 4A45           50                         push	ax
16367                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16368 4A46           FF76         14            push	$14[bp]
16369                                           ! Debug: func () void = write_word+0 (used reg = )
16370 4A49           E8         BBE6            call	_write_word
16371 4A4C           83C4                   06  add	sp,*6
16372                                           !BCC_EOS
16373                                           ! 2621       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
16374                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16375 4A4F           8A46         F9            mov	al,-7[bp]
16376 4A52           30E4                       xor	ah,ah
16377 4A54           50                         push	ax
16378                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16379 4A55           8B46         06            mov	ax,6[bp]
16380                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
16381                                           ! Debug: list unsigned int = ax+$C (used reg = )
16382 4A58           05                   000C  add	ax,*$C
16383 4A5B           50                         push	ax
16384                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16385 4A5C           FF76         14            push	$14[bp]
16386                                           ! Debug: func () void = write_byte+0 (used reg = )
16387 4A5F           E8         BBB8            call	_write_byte
16388 4A62           83C4                   06  add	sp,*6
16389                                           !BCC_EOS
16390                                           ! 2622       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
16391                                           ! Debug: list int = const $93 (used reg = )
16392 4A65           B8                   0093  mov	ax,#$93
16393 4A68           50                         push	ax
16394                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16395 4A69           8B46         06            mov	ax,6[bp]
16396                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
16397                                           ! Debug: list unsigned int = ax+$D (used reg = )
16398 4A6C           05                   000D  add	ax,*$D
16399 4A6F           50                         push	ax
16400                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16401 4A70           FF76         14            push	$14[bp]
16402                                           ! Debug: func () void = write_byte+0 (used reg = )
16403 4A73           E8         BBA4            call	_write_byte
16404 4A76           83C4                   06  add	sp,*6
16405                                           !BCC_EOS
16406                                           ! 2623       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
16407                                           ! Debug: list int = const 0 (used reg = )
16408 4A79           31C0                       xor	ax,ax
16409 4A7B           50                         push	ax
16410                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16411 4A7C           8B46         06            mov	ax,6[bp]
16412                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
16413                                           ! Debug: list unsigned int = ax+$E (used reg = )
16414 4A7F           05                   000E  add	ax,*$E
16415 4A82           50                         push	ax
16416                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16417 4A83           FF76         14            push	$14[bp]
16418                                           ! Debug: func () void = write_word+0 (used reg = )
16419 4A86           E8         BBA9            call	_write_word
16420 4A89           83C4                   06  add	sp,*6
16421                                           !BCC_EOS
16422                                           ! 2624       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
16423                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16424 4A8C           B8                   FFFF  mov	ax,#$FFFF
16425 4A8F           50                         push	ax
16426                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16427 4A90           8B46         06            mov	ax,6[bp]
16428                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
16429                                           ! Debug: list unsigned int = ax+$20 (used reg = )
16430 4A93           05                   0020  add	ax,*$20
16431 4A96           50                         push	ax
16432                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16433 4A97           FF76         14            push	$14[bp]
16434                                           ! Debug: func () void = write_word+0 (used reg = )
16435 4A9A           E8         BB95            call	_write_word
16436 4A9D           83C4                   06  add	sp,*6
16437                                           !BCC_EOS
16438                                           ! 2625       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
16439                                           ! Debug: list int = const 0 (used reg = )
16440 4AA0           31C0                       xor	ax,ax
16441 4AA2           50                         push	ax
16442                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16443 4AA3           8B46         06            mov	ax,6[bp]
16444                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
16445                                           ! Debug: list unsigned int = ax+$22 (used reg = )
16446 4AA6           05                   0022  add	ax,*$22
16447 4AA9           50                         push	ax
16448                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16449 4AAA           FF76         14            push	$14[bp]
16450                                           ! Debug: func () void = write_word+0 (used reg = )
16451 4AAD           E8         BB82            call	_write_word
16452 4AB0           83C4                   06  add	sp,*6
16453                                           !BCC_EOS
16454                                           ! 2626       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
16455                                           ! Debug: list int = const $F (used reg = )
16456 4AB3           B8                   000F  mov	ax,*$F
16457 4AB6           50                         push	ax
16458                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16459 4AB7           8B46         06            mov	ax,6[bp]
16460                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
16461                                           ! Debug: list unsigned int = ax+$24 (used reg = )
16462 4ABA           05                   0024  add	ax,*$24
16463 4ABD           50                         push	ax
16464                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16465 4ABE           FF76         14            push	$14[bp]
16466                                           ! Debug: func () void = write_byte+0 (used reg = )
16467 4AC1           E8         BB56            call	_write_byte
16468 4AC4           83C4                   06  add	sp,*6
16469                                           !BCC_EOS
16470                                           ! 2627       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
16471                                           ! Debug: list int = const $9B (used reg = )
16472 4AC7           B8                   009B  mov	ax,#$9B
16473 4ACA           50                         push	ax
16474                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16475 4ACB           8B46         06            mov	ax,6[bp]
16476                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
16477                                           ! Debug: list unsigned int = ax+$25 (used reg = )
16478 4ACE           05                   0025  add	ax,*$25
16479 4AD1           50                         push	ax
16480                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16481 4AD2           FF76         14            push	$14[bp]
16482                                           ! Debug: func () void = write_byte+0 (used reg = )
16483 4AD5           E8         BB42            call	_write_byte
16484 4AD8           83C4                   06  add	sp,*6
16485                                           !BCC_EOS
16486                                           ! 2628       write_word(ES, regs.u.r16.si+0x20+6,
16487                                           ! 2628  0x0000);
16488                                           ! Debug: list int = const 0 (used reg = )
16489 4ADB           31C0                       xor	ax,ax
16490 4ADD           50                         push	ax
16491                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16492 4ADE           8B46         06            mov	ax,6[bp]
16493                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
16494                                           ! Debug: list unsigned int = ax+$26 (used reg = )
16495 4AE1           05                   0026  add	ax,*$26
16496 4AE4           50                         push	ax
16497                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16498 4AE5           FF76         14            push	$14[bp]
16499                                           ! Debug: func () void = write_word+0 (used reg = )
16500 4AE8           E8         BB47            call	_write_word
16501 4AEB           83C4                   06  add	sp,*6
16502                                           !BCC_EOS
16503                                           ! 2629       ss = get_SS();
16504                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
16505 4AEE           E8         BB5C            call	_get_SS
16506                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
16507 4AF1           8946         F6            mov	-$A[bp],ax
16508                                           !BCC_EOS
16509                                           ! 2630       base15_00 = ss << 4;
16510                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
16511 4AF4           8B46         F6            mov	ax,-$A[bp]
16512 4AF7           B1                     04  mov	cl,*4
16513 4AF9           D3E0                       shl	ax,cl
16514                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16515 4AFB           8946         FA            mov	-6[bp],ax
16516                                           !BCC_EOS
16517                                           ! 2631       base23_16 = ss >> 12;
16518                                           ! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
16519 4AFE           8B46         F6            mov	ax,-$A[bp]
16520 4B01           88E0                       mov	al,ah
16521 4B03           30E4                       xor	ah,ah
16522 4B05           B1                     04  mov	cl,*4
16523 4B07           D3E8                       shr	ax,cl
16524                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16525 4B09           8846         F9            mov	-7[bp],al
16526                                           !BCC_EOS
16527                                           ! 2632       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
16528                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16529 4B0C           B8                   FFFF  mov	ax,#$FFFF
16530 4B0F           50                         push	ax
16531                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16532 4B10           8B46         06            mov	ax,6[bp]
16533                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
16534                                           ! Debug: list unsigned int = ax+$28 (used reg = )
16535 4B13           05                   0028  add	ax,*$28
16536 4B16           50                         push	ax
16537                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16538 4B17           FF76         14            push	$14[bp]
16539                                           ! Debug: func () void = write_word+0 (used reg = )
16540 4B1A           E8         BB15            call	_write_word
16541 4B1D           83C4                   06  add	sp,*6
16542                                           !BCC_EOS
16543                                           ! 2633       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
16544                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16545 4B20           FF76         FA            push	-6[bp]
16546                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16547 4B23           8B46         06            mov	ax,6[bp]
16548                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
16549                                           ! Debug: list unsigned int = ax+$2A (used reg = )
16550 4B26           05                   002A  add	ax,*$2A
16551 4B29           50                         push	ax
16552                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16553 4B2A           FF76         14            push	$14[bp]
16554                                           ! Debug: func () void = write_word+0 (used reg = )
16555 4B2D           E8         BB02            call	_write_word
16556 4B30           83C4                   06  add	sp,*6
16557                                           !BCC_EOS
16558                                           ! 2634       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
16559                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16560 4B33           8A46         F9            mov	al,-7[bp]
16561 4B36           30E4                       xor	ah,ah
16562 4B38           50                         push	ax
16563                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16564 4B39           8B46         06            mov	ax,6[bp]
16565                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
16566                                           ! Debug: list unsigned int = ax+$2C (used reg = )
16567 4B3C           05                   002C  add	ax,*$2C
16568 4B3F           50                         push	ax
16569                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16570 4B40           FF76         14            push	$14[bp]
16571                                           ! Debug: func () void = write_byte+0 (used reg = )
16572 4B43           E8         BAD4            call	_write_byte
16573 4B46           83C4                   06  add	sp,*6
16574                                           !BCC_EOS
16575                                           ! 2635       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
16576                                           ! Debug: list int = const $93 (used reg = )
16577 4B49           B8                   0093  mov	ax,#$93
16578 4B4C           50                         push	ax
16579                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16580 4B4D           8B46         06            mov	ax,6[bp]
16581                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
16582                                           ! Debug: list unsigned int = ax+$2D (used reg = )
16583 4B50           05                   002D  add	ax,*$2D
16584 4B53           50                         push	ax
16585                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16586 4B54           FF76         14            push	$14[bp]
16587                                           ! Debug: func () void = write_byte+0 (used reg = )
16588 4B57           E8         BAC0            call	_write_byte
16589 4B5A           83C4                   06  add	sp,*6
16590                                           !BCC_EOS
16591                                           ! 2636       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
16592                                           ! Debug: list int = const 0 (used reg = )
16593 4B5D           31C0                       xor	ax,ax
16594 4B5F           50                         push	ax
16595                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16596 4B60           8B46         06            mov	ax,6[bp]
16597                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
16598                                           ! Debug: list unsigned int = ax+$2E (used reg = )
16599 4B63           05                   002E  add	ax,*$2E
16600 4B66           50                         push	ax
16601                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16602 4B67           FF76         14            push	$14[bp]
16603                                           ! Debug: func () void = write_word+0 (used reg = )
16604 4B6A           E8         BAC5            call	_write_word
16605 4B6D           83C4                   06  add	sp,*6
16606                                           !BCC_EOS
16607                                           ! 2637       CX = regs.u.r16.cx;
16608                                           ! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
16609 4B70           8B46         10            mov	ax,$10[bp]
16610 4B73           8946         F4            mov	-$C[bp],ax
16611                                           !BCC_EOS
16612                                           ! 2638 #asm
16613                                           !BCC_EOS
16614                                           !BCC_ASM
16615                       00000006            _int15_function.CX	set	6
16616                       FFFFFFF4            .int15_function.CX	set	-$C
16617                       0000002A            _int15_function.FLAGS	set	$2A
16618                       00000018            .int15_function.FLAGS	set	$18
16619                       00000001            _int15_function.irqDisable	set	1
16620                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16621                       00000028            _int15_function.DS	set	$28
16622                       00000016            .int15_function.DS	set	$16
16623                       00000004            _int15_function.DX	set	4
16624                       FFFFFFF2            .int15_function.DX	set	-$E
16625                       0000000B            _int15_function.base23_16	set	$B
16626                       FFFFFFF9            .int15_function.base23_16	set	-7
16627                       00000002            _int15_function.bRegister	set	2
16628                       FFFFFFF0            .int15_function.bRegister	set	-$10
16629                       00000026            _int15_function.ES	set	$26
16630                       00000014            .int15_function.ES	set	$14
16631                       00000010            _int15_function.ebda_seg	set	$10
16632                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16633                       0000000C            _int15_function.base15_00	set	$C
16634                       FFFFFFFA            .int15_function.base15_00	set	-6
16635                       00000008            _int15_function.ss	set	8
16636                       FFFFFFF6            .int15_function.ss	set	-$A
16637                       00000016            _int15_function.regs	set	$16
16638                       00000004            .int15_function.regs	set	4
16639                       0000000E            _int15_function.prev_a20_enable	set	$E
16640                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16641 4B76           89E3                             mov bx, sp
16642 4B78           36                               SEG SS
16643 4B79           8B4F         06                    mov cx, _int15_function.CX [bx]
16644 4B7C     66    50                               push eax
16645 4B7E     66    31C0                             xor eax, eax
16646 4B81           8ED8                             mov ds, ax
16647 4B83           8C16       0469                  mov 0x0469, ss
16648 4B87           8926       0467                  mov 0x0467, sp
16649 4B8B           26                               SEG ES
16650 4B8C         0F0154         08                    lgdt [si + 0x08]
16651 4B90           2E                               SEG CS
16652 4B91         0F011E       F88C                    lidt [pmode_IDT_info]
16653                                                 ;; perhaps do something with IDT here
16654                                                 ;; set PE bit in CR0
16655 4B96         0F20C0                             mov eax, cr0
16656 4B99           0C                     01        or al, #0x01
16657 4B9B         0F22C0                             mov cr0, eax
16658                                                 ;; far jump to flush CPU queue after transition to protected mode
16659                                                 JMP_AP(0x0020, protected_mode)
 +a   4B9E                        EA              db 0xea
 +a   4B9F                      4BA3              dw  protected_mode
 +a   4BA1                      0020              dw 0x0020
16660                       00004BA3            protected_mode:
16661                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
16662 4BA3           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
16663 4BA6           8ED0                             mov ss, ax
16664 4BA8           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
16665 4BAB           8ED8                             mov ds, ax
16666 4BAD           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
16667 4BB0           8EC0                             mov es, ax
16668 4BB2           31F6                             xor si, si
16669 4BB4           31FF                             xor di, di
16670 4BB6           FC                               cld
16671 4BB7           F3                               rep
16672 4BB8           A5                                 movsw ;; move CX words from DS:SI to ES:DI
16673                                                 ;; make sure DS and ES limits are 64KB
16674 4BB9           B8                   0028        mov ax, #0x28
16675 4BBC           8ED8                             mov ds, ax
16676 4BBE           8EC0                             mov es, ax
16677                                                 ;; reset PG bit in CR0 ???
16678 4BC0         0F20C0                             mov eax, cr0
16679 4BC3           24                     FE        and al, #0xFE
16680 4BC5         0F22C0                             mov cr0, eax
16681                                                 ;; far jump to flush CPU queue after transition to real mode
16682                                                 JMP_AP(0xf000, real_mode)
 +a   4BC8                        EA              db 0xea
 +a   4BC9                      4BCD              dw  real_mode
 +a   4BCB                      F000              dw 0xf000
16683                       00004BCD            real_mode:
16684                                                 ;; restore IDT to normal real-mode defaults
16685 4BCD           2E                               SEG CS
16686 4BCE         0F011E       F891                    lidt [rmode_IDT_info]
16687 4BD3           31C0                             xor ax, ax
16688 4BD5           8ED8                             mov ds, ax
16689 4BD7           8E16       0469                  mov ss, 0x0469
16690 4BDB           8B26       0467                  mov sp, 0x0467
16691 4BDF     66    58                               pop eax
16692                                           ! 2690 endasm
16693                                           !BCC_ENDASM
16694                                           !BCC_EOS
16695                                           ! 2691       set_enable_a20(prev_a20_enable);
16696                                           ! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
16697 4BE1           FF76         FC            push	-4[bp]
16698                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16699 4BE4           E8         CCE1            call	_set_enable_a20
16700 4BE7           44                         inc	sp
16701 4BE8           44                         inc	sp
16702                                           !BCC_EOS
16703                                           ! 2692 #asm
16704                                           !BCC_EOS
16705                                           !BCC_ASM
16706                       00000006            _int15_function.CX	set	6
16707                       FFFFFFF4            .int15_function.CX	set	-$C
16708                       0000002A            _int15_function.FLAGS	set	$2A
16709                       00000018            .int15_function.FLAGS	set	$18
16710                       00000001            _int15_function.irqDisable	set	1
16711                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16712                       00000028            _int15_function.DS	set	$28
16713                       00000016            .int15_function.DS	set	$16
16714                       00000004            _int15_function.DX	set	4
16715                       FFFFFFF2            .int15_function.DX	set	-$E
16716                       0000000B            _int15_function.base23_16	set	$B
16717                       FFFFFFF9            .int15_function.base23_16	set	-7
16718                       00000002            _int15_function.bRegister	set	2
16719                       FFFFFFF0            .int15_function.bRegister	set	-$10
16720                       00000026            _int15_function.ES	set	$26
16721                       00000014            .int15_function.ES	set	$14
16722                       00000010            _int15_function.ebda_seg	set	$10
16723                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16724                       0000000C            _int15_function.base15_00	set	$C
16725                       FFFFFFFA            .int15_function.base15_00	set	-6
16726                       00000008            _int15_function.ss	set	8
16727                       FFFFFFF6            .int15_function.ss	set	-$A
16728                       00000016            _int15_function.regs	set	$16
16729                       00000004            .int15_function.regs	set	4
16730                       0000000E            _int15_function.prev_a20_enable	set	$E
16731                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16732 4BE9           FB                           sti
16733                                           ! 2694 endasm
16734                                           !BCC_ENDASM
16735                                           !BCC_EOS
16736                                           ! 2695       regs.u.r8.ah = 0;
16737                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16738 4BEA           30C0                       xor	al,al
16739 4BEC           8846         13            mov	$13[bp],al
16740                                           !BCC_EOS
16741                                           ! 2696       FLAGS &= 0xfffe;
16742                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16743 4BEF           8B46         18            mov	ax,$18[bp]
16744 4BF2           24                     FE  and	al,#$FE
16745 4BF4           8946         18            mov	$18[bp],ax
16746                                           !BCC_EOS
16747                                           ! 2697       break;
16748 4BF7           E9         00F2            br 	.341
16749                                           !BCC_EOS
16750                                           ! 2698     case 0x88:
16751                                           ! 2699       regs.u.r8.al = inb_cmos(0x30);
16752                       00004BFA            .35D:
16753                                           ! Debug: list int = const $30 (used reg = )
16754 4BFA           B8                   0030  mov	ax,*$30
16755 4BFD           50                         push	ax
16756                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16757 4BFE           E8         B982            call	_inb_cmos
16758 4C01           44                         inc	sp
16759 4C02           44                         inc	sp
16760                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
16761 4C03           8846         12            mov	$12[bp],al
16762                                           !BCC_EOS
16763                                           ! 2700       regs.u.r8.ah = inb_cmos(0x31);
16764                                           ! Debug: list int = const $31 (used reg = )
16765 4C06           B8                   0031  mov	ax,*$31
16766 4C09           50                         push	ax
16767                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16768 4C0A           E8         B976            call	_inb_cmos
16769 4C0D           44                         inc	sp
16770 4C0E           44                         inc	sp
16771                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
16772 4C0F           8846         13            mov	$13[bp],al
16773                                           !BCC_EOS
16774                                           ! 2701       if(regs.u.r16.ax > 0xffc
16775                                           ! 2701 0)
16776                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
16777 4C12           8B46         12            mov	ax,$12[bp]
16778 4C15           3D                   FFC0  cmp	ax,#$FFC0
16779 4C18           76           06            jbe 	.35E
16780                       00004C1A            .35F:
16781                                           ! 2702         regs.u.r16.ax = 0xffc0;
16782                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
16783 4C1A           B8                   FFC0  mov	ax,#$FFC0
16784 4C1D           8946         12            mov	$12[bp],ax
16785                                           !BCC_EOS
16786                                           ! 2703       FLAGS &= 0xfffe;
16787                       00004C20            .35E:
16788                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16789 4C20           8B46         18            mov	ax,$18[bp]
16790 4C23           24                     FE  and	al,#$FE
16791 4C25           8946         18            mov	$18[bp],ax
16792                                           !BCC_EOS
16793                                           ! 2704       break;
16794 4C28           E9         00C1            br 	.341
16795                                           !BCC_EOS
16796                                           ! 2705     case 0x90:
16797                                           ! 2706       break;
16798                       00004C2B            .360:
16799 4C2B           E9         00BE            br 	.341
16800                                           !BCC_EOS
16801                                           ! 2707     case 0x91:
16802                                           ! 2708       break;
16803                       00004C2E            .361:
16804 4C2E           E9         00BB            br 	.341
16805                                           !BCC_EOS
16806                                           ! 2709     case 0xbf:
16807                                           ! 2710       ;
16808                       00004C31            .362:
16809                                           !BCC_EOS
16810                                           ! 2711       FLAGS |= 0x0001;
16811                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16812 4C31           8B46         18            mov	ax,$18[bp]
16813 4C34           0C                     01  or	al,*1
16814 4C36           8946         18            mov	$18[bp],ax
16815                                           !BCC_EOS
16816                                           ! 2712       regs.u.r8.ah = 0x86;
16817                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16818 4C39           B0                     86  mov	al,#$86
16819 4C3B           8846         13            mov	$13[bp],al
16820                                           !BCC_EOS
16821                                           ! 2713       break;
16822 4C3E           E9         00AB            br 	.341
16823                                           !BCC_EOS
16824                                           ! 2714     case 0xC0:
16825                                           ! 2715       FLAGS &= 0xfffe;
16826                       00004C41            .363:
16827                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16828 4C41           8B46         18            mov	ax,$18[bp]
16829 4C44           24                     FE  and	al,#$FE
16830 4C46           8946         18            mov	$18[bp],ax
16831                                           !BCC_EOS
16832                                           ! 2716       regs.u.r8.ah = 0;
16833                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16834 4C49           30C0                       xor	al,al
16835 4C4B           8846         13            mov	$13[bp],al
16836                                           !BCC_EOS
16837                                           ! 2717       regs.u.r16.bx = 0xe6f5;
16838                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
16839 4C4E           B8                   E6F5  mov	ax,#$E6F5
16840 4C51           8946         0C            mov	$C[bp],ax
16841                                           !BCC_EOS
16842                                           ! 2718       ES = 0xF000;
16843                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
16844 4C54           B8                   F000  mov	ax,#$F000
16845 4C57           8946         14            mov	$14[bp],ax
16846                                           !BCC_EOS
16847                                           ! 2719       break;
16848 4C5A           E9         008F            br 	.341
16849                                           !BCC_EOS
16850                                           ! 2720     case 0xc1:
16851                                           ! 2721       ES = ebda_seg;
16852                       00004C5D            .364:
16853                                           ! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
16854 4C5D           8B46         FE            mov	ax,-2[bp]
16855 4C60           8946         14            mov	$14[bp],ax
16856                                           !BCC_EOS
16857                                           ! 2722       FLAGS &= 0xfffe;
16858                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16859 4C63           8B46         18            mov	ax,$18[bp]
16860 4C66           24                     FE  and	al,#$FE
16861 4C68           8946         18            mov	$18[bp],ax
16862                                           !BCC_EOS
16863                                           ! 2723       break;
16864 4C6B           E9         007E            br 	.341
16865                                           !BCC_EOS
16866                                           ! 2724     case 0xd8:
16867                                           ! 2725       bios_printf(8, "EISA BIOS not present\n");
16868                       00004C6E            .365:
16869                                           ! Debug: list * char = .366+0 (used reg = )
16870 4C6E           BB                   D2D6  mov	bx,#.366
16871 4C71           53                         push	bx
16872                                           ! Debug: list int = const 8 (used reg = )
16873 4C72           B8                   0008  mov	ax,*8
16874 4C75           50                         push	ax
16875                                           ! Debug: func () void = bios_printf+0 (used reg = )
16876 4C76           E8         BDA2            call	_bios_printf
16877 4C79           83C4                   04  add	sp,*4
16878                                           !BCC_EOS
16879                                           ! 2726       FLAGS |= 0x0001;
16880                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16881 4C7C           8B46         18            mov	ax,$18[bp]
16882 4C7F           0C                     01  or	al,*1
16883 4C81           8946         18            mov	$18[bp],ax
16884                                           !BCC_EOS
16885                                           ! 2727       regs.u.r8.ah = 0x86;
16886                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16887 4C84           B0                     86  mov	al,#$86
16888 4C86           8846         13            mov	$13[bp],al
16889                                           !BCC_EOS
16890                                           ! 2728       break;
16891 4C89           EB           61            jmp .341
16892                                           !BCC_EOS
16893                                           ! 2729     default:
16894                                           ! 2730       ;
16895                       00004C8B            .367:
16896                                           !BCC_EOS
16897                                           ! 2731       FLAGS |= 0x0001;
16898                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16899 4C8B           8B46         18            mov	ax,$18[bp]
16900 4C8E           0C                     01  or	al,*1
16901 4C90           8946         18            mov	$18[bp],ax
16902                                           !BCC_EOS
16903                                           ! 2732       regs.u.r8.ah = 0x86;
16904                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16905 4C93           B0                     86  mov	al,#$86
16906 4C95           8846         13            mov	$13[bp],al
16907                                           !BCC_EOS
16908                                           ! 2733       break;
16909 4C98           EB           52            jmp .341
16910                                           !BCC_EOS
16911                                           ! 2734     }
16912                                           ! 2735 }
16913 4C9A           EB           50            jmp .341
16914                       00004C9C            .343:
16915 4C9C           2C                     24  sub	al,*$24
16916 4C9E         0F84         FB71            beq 	.344
16917 4CA2           2C                     1D  sub	al,*$1D
16918 4CA4         0F84         FBF9            beq 	.34D
16919 4CA8           2C                     0E  sub	al,*$E
16920 4CAA         0F84         FC03            beq 	.34E
16921 4CAE           2C                     03  sub	al,*3
16922 4CB0         0F84         FC08            beq 	.34F
16923 4CB4           2C                     31  sub	al,*$31
16924 4CB6         0F84         FC12            beq 	.350
16925 4CBA           2C                     04  sub	al,*4
16926 4CBC         0F84         FD2D            beq 	.35A
16927 4CC0           2C                     01  sub	al,*1
16928 4CC2         0F84         FF34            beq 	.35D
16929 4CC6           2C                     08  sub	al,*8
16930 4CC8         0F84         FF5F            beq 	.360
16931 4CCC           2C                     01  sub	al,*1
16932 4CCE         0F84         FF5C            beq 	.361
16933 4CD2           2C                     2E  sub	al,*$2E
16934 4CD4         0F84         FF59            beq 	.362
16935 4CD8           2C                     01  sub	al,*1
16936 4CDA         0F84         FF63            beq 	.363
16937 4CDE           2C                     01  sub	al,*1
16938 4CE0         0F84         FF79            beq 	.364
16939 4CE4           2C                     17  sub	al,*$17
16940 4CE6         0F84         FF84            beq 	.365
16941 4CEA           EB           9F            jmp	.367
16942                       00004CEC            .341:
16943                       FFFFFFEC            ..FFF7	=	-$14
16944 4CEC           89EC                       mov	sp,bp
16945 4CEE           5D                         pop	bp
16946 4CEF           C3                         ret
16947                                           ! 2736   void
16948                                           ! Register BX used in function int15_function
16949                                           ! 2737 int15_function_mouse(regs, ES, DS, FLAGS)
16950                                           ! 2738   pusha_regs_t regs;
16951                                           export	_int15_function_mouse
16952                       00004CF0            _int15_function_mouse:
16953                                           !BCC_EOS
16954                                           ! 2739   Bit16u ES, DS, FLAGS;
16955                                           !BCC_EOS
16956                                           ! 2740 {
16957                                           ! 2741   Bit16u ebda_seg=read_word(0x0040,0x000E);
16958 4CF0           55                         push	bp
16959 4CF1           89E5                       mov	bp,sp
16960 4CF3           4C                         dec	sp
16961 4CF4           4C                         dec	sp
16962                                           ! Debug: list int = const $E (used reg = )
16963 4CF5           B8                   000E  mov	ax,*$E
16964 4CF8           50                         push	ax
16965                                           ! Debug: list int = const $40 (used reg = )
16966 4CF9           B8                   0040  mov	ax,*$40
16967 4CFC           50                         push	ax
16968                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
16969 4CFD           E8         B907            call	_read_word
16970 4D00           83C4                   04  add	sp,*4
16971                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
16972 4D03           8946         FE            mov	-2[bp],ax
16973                                           !BCC_EOS
16974                                           ! 2742   Bit8u mouse_flags_1, mouse_flags_2;
16975                                           !BCC_EOS
16976                                           ! 2743   Bit16u mouse_driver_seg;
16977                                           !BCC_EOS
16978                                           ! 2744   Bit16u mouse_driver_offset;
16979                                           !BCC_EOS
16980                                           ! 2745   Bit8u comm_byte, prev_command_byte;
16981                                           !BCC_EOS
16982                                           ! 2746   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
16983                                           !BCC_EOS
16984                                           ! 2747 ;
16985 4D06           83C4                   F4  add	sp,*-$C
16986                                           !BCC_EOS
16987                                           ! 2748   switch (regs.u.r8.ah) {
16988 4D09           8A46         13            mov	al,$13[bp]
16989 4D0C           E9         063C            br 	.36A
16990                                           ! 2749     case 0xC2:
16991                                           ! 2750       switch (regs.u.r8.al) {
16992                       00004D0F            .36B:
16993 4D0F           8A46         12            mov	al,$12[bp]
16994 4D12           E9         05FE            br 	.36E
16995                                           ! 2751         case 0:
16996                                           ! 2752 ;
16997                       00004D15            .36F:
16998                                           !BCC_EOS
16999                                           ! 2753           switch (regs.u.r8.bh) {
17000 4D15           8A46         0D            mov	al,$D[bp]
17001 4D18           E9         00E9            br 	.372
17002                                           ! 2754             case 0:
17003                                           ! 2755 ;
17004                       00004D1B            .373:
17005                                           !BCC_EOS
17006                                           ! 2756               inhibit_mouse_int_and_events();
17007                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17008 4D1B           E8         0FAF            call	_inhibit_mouse_int_and_events
17009                                           !BCC_EOS
17010                                           ! 2757               ret = send_to_mouse_ctrl(0xF5);
17011                                           ! Debug: list int = const $F5 (used reg = )
17012 4D1E           B8                   00F5  mov	ax,#$F5
17013 4D21           50                         push	ax
17014                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17015 4D22           E8         10F9            call	_send_to_mouse_ctrl
17016 4D25           44                         inc	sp
17017 4D26           44                         inc	sp
17018                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17019 4D27           8846         F5            mov	-$B[bp],al
17020                                           !BCC_EOS
17021                                           ! 2758               if (ret == 0) {
17022                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17023 4D2A           8A46         F5            mov	al,-$B[bp]
17024 4D2D           84C0                       test	al,al
17025 4D2F           75           2B            jne 	.374
17026                       00004D31            .375:
17027                                           ! 2759                 ret = get_mouse_data(&mouse_data1);
17028                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17029 4D31           8D5E         F4            lea	bx,-$C[bp]
17030 4D34           53                         push	bx
17031                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17032 4D35           E8         1130            call	_get_mouse_data
17033 4D38           44                         inc	sp
17034 4D39           44                         inc	sp
17035                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17036 4D3A           8846         F5            mov	-$B[bp],al
17037                                           !BCC_EOS
17038                                           ! 2760                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
17039                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17040 4D3D           8A46         F5            mov	al,-$B[bp]
17041 4D40           84C0                       test	al,al
17042 4D42           74           07            je  	.377
17043                       00004D44            .378:
17044                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17045 4D44           8A46         F4            mov	al,-$C[bp]
17046 4D47           3C                     FA  cmp	al,#$FA
17047 4D49           75           11            jne 	.376
17048                       00004D4B            .377:
17049                                           ! 2761                   FLAGS &= 0xfffe;
17050                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17051 4D4B           8B46         18            mov	ax,$18[bp]
17052 4D4E           24                     FE  and	al,#$FE
17053 4D50           8946         18            mov	$18[bp],ax
17054                                           !BCC_EOS
17055                                           ! 2762                   regs.u.r8.ah = 0;
17056                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17057 4D53           30C0                       xor	al,al
17058 4D55           8846         13            mov	$13[bp],al
17059                                           !BCC_EOS
17060                                           ! 2763                   return;
17061 4D58           89EC                       mov	sp,bp
17062 4D5A           5D                         pop	bp
17063 4D5B           C3                         ret
17064                                           !BCC_EOS
17065                                           ! 2764                   }
17066                                           ! 2765                 }
17067                       00004D5C            .376:
17068                                           ! 2766               FLAGS |= 0x0001;
17069                       00004D5C            .374:
17070                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17071 4D5C           8B46         18            mov	ax,$18[bp]
17072 4D5F           0C                     01  or	al,*1
17073 4D61           8946         18            mov	$18[bp],ax
17074                                           !BCC_EOS
17075                                           ! 2767               regs.u.r8.ah = ret;
17076                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17077 4D64           8A46         F5            mov	al,-$B[bp]
17078 4D67           8846         13            mov	$13[bp],al
17079                                           !BCC_EOS
17080                                           ! 2768               return;
17081 4D6A           89EC                       mov	sp,bp
17082 4D6C           5D                         pop	bp
17083 4D6D           C3                         ret
17084                                           !BCC_EOS
17085                                           ! 2769               break;
17086 4D6E           E9         00A1            br 	.370
17087                                           !BCC_EOS
17088                                           ! 2770             case 1:
17089                                           ! 2771 ;
17090                       00004D71            .379:
17091                                           !BCC_EOS
17092                                           ! 2772               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17093                                           ! Debug: list int = const $27 (used reg = )
17094 4D71           B8                   0027  mov	ax,*$27
17095 4D74           50                         push	ax
17096                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17097 4D75           FF76         FE            push	-2[bp]
17098                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17099 4D78           E8         B879            call	_read_byte
17100 4D7B           83C4                   04  add	sp,*4
17101                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17102 4D7E           8846         FC            mov	-4[bp],al
17103                                           !BCC_EOS
17104                                           ! 2773               if ( (mouse_flags_2 & 0x80) == 0 ) {
17105                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17106 4D81           8A46         FC            mov	al,-4[bp]
17107 4D84           24                     80  and	al,#$80
17108                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17109 4D86           84C0                       test	al,al
17110 4D88           75           11            jne 	.37A
17111                       00004D8A            .37B:
17112                                           ! 2774                 ;
17113                                           !BCC_EOS
17114                                           ! 2775                 FLAGS |= 0x0001;
17115                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17116 4D8A           8B46         18            mov	ax,$18[bp]
17117 4D8D           0C                     01  or	al,*1
17118 4D8F           8946         18            mov	$18[bp],ax
17119                                           !BCC_EOS
17120                                           ! 2776                 regs.u.r8.ah = 5;
17121                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
17122 4D92           B0                     05  mov	al,*5
17123 4D94           8846         13            mov	$13[bp],al
17124                                           !BCC_EOS
17125                                           ! 2777                 return;
17126 4D97           89EC                       mov	sp,bp
17127 4D99           5D                         pop	bp
17128 4D9A           C3                         ret
17129                                           !BCC_EOS
17130                                           ! 2778                 }
17131                                           ! 2779               inhibit_mouse_int_and_events();
17132                       00004D9B            .37A:
17133                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17134 4D9B           E8         0F2F            call	_inhibit_mouse_int_and_events
17135                                           !BCC_EOS
17136                                           ! 2780               ret = send_to_mouse_ctrl(0xF4);
17137                                           ! Debug: list int = const $F4 (used reg = )
17138 4D9E           B8                   00F4  mov	ax,#$F4
17139 4DA1           50                         push	ax
17140                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17141 4DA2           E8         1079            call	_send_to_mouse_ctrl
17142 4DA5           44                         inc	sp
17143 4DA6           44                         inc	sp
17144                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17145 4DA7           8846         F5            mov	-$B[bp],al
17146                                           !BCC_EOS
17147                                           ! 2781               if (ret == 0) {
17148                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17149 4DAA           8A46         F5            mov	al,-$B[bp]
17150 4DAD           84C0                       test	al,al
17151 4DAF           75           2E            jne 	.37C
17152                       00004DB1            .37D:
17153                                           ! 2782                 ret = get_mouse_data(&mouse_data1);
17154                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17155 4DB1           8D5E         F4            lea	bx,-$C[bp]
17156 4DB4           53                         push	bx
17157                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17158 4DB5           E8         10B0            call	_get_mouse_data
17159 4DB8           44                         inc	sp
17160 4DB9           44                         inc	sp
17161                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17162 4DBA           8846         F5            mov	-$B[bp],al
17163                                           !BCC_EOS
17164                                           ! 2783                 if ( (ret == 0) && (m
17165                                           ! 2783 ouse_data1 == 0xFA) ) {
17166                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17167 4DBD           8A46         F5            mov	al,-$B[bp]
17168 4DC0           84C0                       test	al,al
17169 4DC2           75           1B            jne 	.37E
17170                       00004DC4            .380:
17171                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17172 4DC4           8A46         F4            mov	al,-$C[bp]
17173 4DC7           3C                     FA  cmp	al,#$FA
17174 4DC9           75           14            jne 	.37E
17175                       00004DCB            .37F:
17176                                           ! 2784                   enable_mouse_int_and_events();
17177                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17178 4DCB           E8         0FAC            call	_enable_mouse_int_and_events
17179                                           !BCC_EOS
17180                                           ! 2785                   FLAGS &= 0xfffe;
17181                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17182 4DCE           8B46         18            mov	ax,$18[bp]
17183 4DD1           24                     FE  and	al,#$FE
17184 4DD3           8946         18            mov	$18[bp],ax
17185                                           !BCC_EOS
17186                                           ! 2786                   regs.u.r8.ah = 0;
17187                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17188 4DD6           30C0                       xor	al,al
17189 4DD8           8846         13            mov	$13[bp],al
17190                                           !BCC_EOS
17191                                           ! 2787                   return;
17192 4DDB           89EC                       mov	sp,bp
17193 4DDD           5D                         pop	bp
17194 4DDE           C3                         ret
17195                                           !BCC_EOS
17196                                           ! 2788                   }
17197                                           ! 2789                 }
17198                       00004DDF            .37E:
17199                                           ! 2790               FLAGS |= 0x0001;
17200                       00004DDF            .37C:
17201                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17202 4DDF           8B46         18            mov	ax,$18[bp]
17203 4DE2           0C                     01  or	al,*1
17204 4DE4           8946         18            mov	$18[bp],ax
17205                                           !BCC_EOS
17206                                           ! 2791               regs.u.r8.ah = ret;
17207                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17208 4DE7           8A46         F5            mov	al,-$B[bp]
17209 4DEA           8846         13            mov	$13[bp],al
17210                                           !BCC_EOS
17211                                           ! 2792               return;
17212 4DED           89EC                       mov	sp,bp
17213 4DEF           5D                         pop	bp
17214 4DF0           C3                         ret
17215                                           !BCC_EOS
17216                                           ! 2793             default:
17217                                           ! 2794               ;
17218                       00004DF1            .381:
17219                                           !BCC_EOS
17220                                           ! 2795               FLAGS |= 0x0001;
17221                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17222 4DF1           8B46         18            mov	ax,$18[bp]
17223 4DF4           0C                     01  or	al,*1
17224 4DF6           8946         18            mov	$18[bp],ax
17225                                           !BCC_EOS
17226                                           ! 2796               regs.u.r8.ah = 1;
17227                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
17228 4DF9           B0                     01  mov	al,*1
17229 4DFB           8846         13            mov	$13[bp],al
17230                                           !BCC_EOS
17231                                           ! 2797               return;
17232 4DFE           89EC                       mov	sp,bp
17233 4E00           5D                         pop	bp
17234 4E01           C3                         ret
17235                                           !BCC_EOS
17236                                           ! 2798             }
17237                                           ! 2799           break;
17238 4E02           EB           0E            jmp .370
17239                       00004E04            .372:
17240 4E04           2C                     00  sub	al,*0
17241 4E06         0F84         FF11            beq 	.373
17242 4E0A           2C                     01  sub	al,*1
17243 4E0C         0F84         FF61            beq 	.379
17244 4E10           EB           DF            jmp	.381
17245                       00004E12            .370:
17246 4E12           E9         0523            br 	.36C
17247                                           !BCC_EOS
17248                                           ! 2800         case 1:
17249                                           ! 2801         case 5:
17250                       00004E15            .382:
17251                                           ! 2802 ;
17252                       00004E15            .383:
17253                                           !BCC_EOS
17254                                           ! 2803           if (regs.u.r8.al == 5) {
17255                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
17256 4E15           8A46         12            mov	al,$12[bp]
17257 4E18           3C                     05  cmp	al,*5
17258 4E1A           75           5E            jne 	.384
17259                       00004E1C            .385:
17260                                           ! 2804             if (regs.u.r8.bh != 3) {
17261                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
17262 4E1C           8A46         0D            mov	al,$D[bp]
17263 4E1F           3C                     03  cmp	al,*3
17264 4E21           74           11            je  	.386
17265                       00004E23            .387:
17266                                           ! 2805               FLAGS |= 0x0001;
17267                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17268 4E23           8B46         18            mov	ax,$18[bp]
17269 4E26           0C                     01  or	al,*1
17270 4E28           8946         18            mov	$18[bp],ax
17271                                           !BCC_EOS
17272                                           ! 2806               regs.u.r8.ah = 0x02;
17273                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
17274 4E2B           B0                     02  mov	al,*2
17275 4E2D           8846         13            mov	$13[bp],al
17276                                           !BCC_EOS
17277                                           ! 2807               return;
17278 4E30           89EC                       mov	sp,bp
17279 4E32           5D                         pop	bp
17280 4E33           C3                         ret
17281                                           !BCC_EOS
17282                                           ! 2808             }
17283                                           ! 2809             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17284                       00004E34            .386:
17285                                           ! Debug: list int = const $27 (used reg = )
17286 4E34           B8                   0027  mov	ax,*$27
17287 4E37           50                         push	ax
17288                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17289 4E38           FF76         FE            push	-2[bp]
17290                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17291 4E3B           E8         B7B6            call	_read_byte
17292 4E3E           83C4                   04  add	sp,*4
17293                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17294 4E41           8846         FC            mov	-4[bp],al
17295                                           !BCC_EOS
17296                                           ! 2810             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
17297                                           ! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17298 4E44           8A46         FC            mov	al,-4[bp]
17299 4E47           30C0                       xor	al,al
17300                                           ! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
17301 4E49           0A46         0D            or	al,$D[bp]
17302                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17303 4E4C           8846         FC            mov	-4[bp],al
17304                                           !BCC_EOS
17305                                           ! 2811             mouse_flags_1 = 0x00;
17306                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17307 4E4F           30C0                       xor	al,al
17308 4E51           8846         FD            mov	-3[bp],al
17309                                           !BCC_EOS
17310                                           ! 2812             write_byte(ebda_seg, 0x0026, mouse_flags_1);
17311                                           ! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17312 4E54           8A46         FD            mov	al,-3[bp]
17313 4E57           30E4                       xor	ah,ah
17314 4E59           50                         push	ax
17315                                           ! Debug: list int = const $26 (used reg = )
17316 4E5A           B8                   0026  mov	ax,*$26
17317 4E5D           50                         push	ax
17318                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17319 4E5E           FF76         FE            push	-2[bp]
17320                                           ! Debug: func () void = write_byte+0 (used reg = )
17321 4E61           E8         B7B6            call	_write_byte
17322 4E64           83C4                   06  add	sp,*6
17323                                           !BCC_EOS
17324                                           ! 2813             write_byte(ebda_seg, 0x0027, mouse_flags_2);
17325                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17326 4E67           8A46         FC            mov	al,-4[bp]
17327 4E6A           30E4                       xor	ah,ah
17328 4E6C           50                         push	ax
17329                                           ! Debug: list int = const $27 (used reg = )
17330 4E6D           B8                   0027  mov	ax,*$27
17331 4E70           50                         push	ax
17332                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17333 4E71           FF76         FE            push	-2[bp]
17334                                           ! Debug: func () void = write_byte+0 (used reg = )
17335 4E74           E8         B7A3            call	_write_byte
17336 4E77           83C4                   06  add	sp,*6
17337                                           !BCC_EOS
17338                                           ! 2814           }
17339                                           ! 2815           inhibit_mouse_int_and_events();
17340                       00004E7A            .384:
17341                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17342 4E7A           E8         0E50            call	_inhibit_mouse_int_and_events
17343                                           !BCC_EOS
17344                                           ! 2816           ret = send_to_mouse_ctrl(0xFF);
17345                                           ! Debug: list int = const $FF (used reg = )
17346 4E7D           B8                   00FF  mov	ax,#$FF
17347 4E80           50                         push	ax
17348                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17349 4E81           E8         0F9A            call	_send_to_mouse_ctrl
17350 4E84           44                         inc	sp
17351 4E85           44                         inc	sp
17352                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17353 4E86           8846         F5            mov	-$B[bp],al
17354                                           !BCC_EOS
17355                                           ! 2817           if (ret == 0) {
17356                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17357 4E89           8A46         F5            mov	al,-$B[bp]
17358 4E8C           84C0                       test	al,al
17359 4E8E         0F85         0087            bne 	.388
17360                       00004E92            .389:
17361                                           ! 2818             ret = get_mouse_data(&mouse_data3);
17362                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
17363 4E92           8D5E         F2            lea	bx,-$E[bp]
17364 4E95           53                         push	bx
17365                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17366 4E96           E8         0FCF            call	_get_mouse_data
17367 4E99           44                         inc	sp
17368 4E9A           44                         inc	sp
17369                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17370 4E9B           8846         F5            mov	-$B[bp],al
17371                                           !BCC_EOS
17372                                           ! 2819             if (mouse_data3 == 0xfe) {
17373                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17374 4E9E           8A46         F2            mov	al,-$E[bp]
17375 4EA1           3C                     FE  cmp	al,#$FE
17376 4EA3           75           0C            jne 	.38A
17377                       00004EA5            .38B:
17378                                           ! 2820               FLAGS |= 0x0001;
17379                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17380 4EA5           8B46         18            mov	ax,$18[bp]
17381 4EA8           0C                     01  or	al,*1
17382 4EAA           8946         18            mov	$18[bp],ax
17383                                           !BCC_EOS
17384                                           ! 2821               return;
17385 4EAD           89EC                       mov	sp,bp
17386 4EAF           5D                         pop	bp
17387 4EB0           C3                         ret
17388                                           !BCC_EOS
17389                                           ! 2822             }
17390                                           ! 2823             if (mouse_data3 != 0xfa)
17391                       00004EB1            .38A:
17392                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17393 4EB1           8A46         F2            mov	al,-$E[bp]
17394 4EB4           3C                     FA  cmp	al,#$FA
17395 4EB6           74           14            je  	.38C
17396                       00004EB8            .38D:
17397                                           ! 2824               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
17398                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17399 4EB8           8A46         F2            mov	al,-$E[bp]
17400 4EBB           30E4                       xor	ah,ah
17401 4EBD           50                         push	ax
17402                                           ! Debug: list * char = .38E+0 (used reg = )
17403 4EBE           BB                   D2AB  mov	bx,#.38E
17404 4EC1           53                         push	bx
17405                                           ! Debug: list int = const 7 (used reg = )
17406 4EC2           B8                   0007  mov	ax,*7
17407 4EC5           50                         push	ax
17408                                           ! Debug: func () void = bios_printf+0 (used reg = )
17409 4EC6           E8         BB52            call	_bios_printf
17410 4EC9           83C4                   06  add	sp,*6
17411                                           !BCC_EOS
17412                                           ! 2825             if ( ret == 0 ) {
17413                       00004ECC            .38C:
17414                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17415 4ECC           8A46         F5            mov	al,-$B[bp]
17416 4ECF           84C0                       test	al,al
17417 4ED1           75           46            jne 	.38F
17418                       00004ED3            .390:
17419                                           ! 2826               ret = get_mouse_data(&mouse_data1);
17420                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17421 4ED3           8D5E         F4            lea	bx,-$C[bp]
17422 4ED6           53                         push	bx
17423                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17424 4ED7           E8         0F8E            call	_get_mouse_data
17425 4EDA           44                         inc	sp
17426 4EDB           44                         inc	sp
17427                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17428 4EDC           8846         F5            mov	-$B[bp],al
17429                                           !BCC_EOS
17430                                           ! 2827               if ( ret == 0 ) {
17431                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17432 4EDF           8A46         F5            mov	al,-$B[bp]
17433 4EE2           84C0                       test	al,al
17434 4EE4           75           33            jne 	.391
17435                       00004EE6            .392:
17436                                           ! 2828                 ret = get_mouse_data(&mouse_data2);
17437                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17438 4EE6           8D5E         F3            lea	bx,-$D[bp]
17439 4EE9           53                         push	bx
17440                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17441 4EEA           E8         0F7B            call	_get_mouse_data
17442 4EED           44                         inc	sp
17443 4EEE           44                         inc	sp
17444                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17445 4EEF           8846         F5            mov	-$B[bp],al
17446                                           !BCC_EOS
17447                                           ! 2829                 if ( ret == 0 ) {
17448                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17449 4EF2           8A46         F5            mov	al,-$B[bp]
17450 4EF5           84C0                       test	al,al
17451 4EF7           75           20            jne 	.393
17452                       00004EF9            .394:
17453                                           ! 2830                   enable_mouse_int_and_events();
17454                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17455 4EF9           E8         0E7E            call	_enable_mouse_int_and_events
17456                                           !BCC_EOS
17457                                           ! 2831                   FLAGS &= 0xfffe;
17458                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17459 4EFC           8B46         18            mov	ax,$18[bp]
17460 4EFF           24                     FE  and	al,#$FE
17461 4F01           8946         18            mov	$18[bp],ax
17462                                           !BCC_EOS
17463                                           ! 2832                   regs.u.r8.ah = 0;
17464                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17465 4F04           30C0                       xor	al,al
17466 4F06           8846         13            mov	$13[bp],al
17467                                           !BCC_EOS
17468                                           ! 2833                   regs.u.r8.bl = mouse_data1;
17469                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
17470 4F09           8A46         F4            mov	al,-$C[bp]
17471 4F0C           8846         0C            mov	$C[bp],al
17472                                           !BCC_EOS
17473                                           ! 2834                   regs.u.r8.bh = mouse_data2;
17474                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
17475 4F0F           8A46         F3            mov	al,-$D[bp]
17476 4F12           8846         0D            mov	$D[bp],al
17477                                           !BCC_EOS
17478                                           ! 2835                   return;
17479 4F15           89EC                       mov	sp,bp
17480 4F17           5D                         pop	bp
17481 4F18           C3                         ret
17482                                           !BCC_EOS
17483                                           ! 2836                   }
17484                                           ! 2837                 }
17485                       00004F19            .393:
17486                                           ! 2838               }
17487                       00004F19            .391:
17488                                           ! 2839             }
17489                       00004F19            .38F:
17490                                           ! 2840           FLAGS |= 0x0001;
17491                       00004F19            .388:
17492                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17493 4F19           8B46         18            mov	ax,$18[bp]
17494 4F1C           0C                     01  or	al,*1
17495 4F1E           8946         18            mov	$18[bp],ax
17496                                           !BCC_EOS
17497                                           ! 2841           regs.u.r8.ah = ret;
17498                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17499 4F21           8A46         F5            mov	al,-$B[bp]
17500 4F24           8846         13            mov	$13[bp],al
17501                                           !BCC_EOS
17502                                           ! 2842           return;
17503 4F27           89EC                       mov	sp,bp
17504 4F29           5D                         pop	bp
17505 4F2A           C3                         ret
17506                                           !BCC_EOS
17507                                           ! 2843         case 2:
17508                                           ! 2844 ;
17509                       00004F2B            .395:
17510                                           !BCC_EOS
17511                                           ! 2845           switch (regs.u.r8.bh) {
17512 4F2B           8A46         0D            mov	al,$D[bp]
17513 4F2E           EB           38            jmp .398
17514                                           ! 2846             case 0: mouse_data1 = 10; break;
17515                       00004F30            .399:
17516                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17517 4F30           B0                     0A  mov	al,*$A
17518 4F32           8846         F4            mov	-$C[bp],al
17519                                           !BCC_EOS
17520 4F35           EB           54            jmp .396
17521                                           !BCC_EOS
17522                                           ! 2847             case 1: m
17523                                           ! 2847 ouse_data1 = 20; break;
17524                       00004F37            .39A:
17525                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17526 4F37           B0                     14  mov	al,*$14
17527 4F39           8846         F4            mov	-$C[bp],al
17528                                           !BCC_EOS
17529 4F3C           EB           4D            jmp .396
17530                                           !BCC_EOS
17531                                           ! 2848             case 2: mouse_data1 = 40; break;
17532                       00004F3E            .39B:
17533                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17534 4F3E           B0                     28  mov	al,*$28
17535 4F40           8846         F4            mov	-$C[bp],al
17536                                           !BCC_EOS
17537 4F43           EB           46            jmp .396
17538                                           !BCC_EOS
17539                                           ! 2849             case 3: mouse_data1 = 60; break;
17540                       00004F45            .39C:
17541                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17542 4F45           B0                     3C  mov	al,*$3C
17543 4F47           8846         F4            mov	-$C[bp],al
17544                                           !BCC_EOS
17545 4F4A           EB           3F            jmp .396
17546                                           !BCC_EOS
17547                                           ! 2850             case 4: mouse_data1 = 80; break;
17548                       00004F4C            .39D:
17549                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17550 4F4C           B0                     50  mov	al,*$50
17551 4F4E           8846         F4            mov	-$C[bp],al
17552                                           !BCC_EOS
17553 4F51           EB           38            jmp .396
17554                                           !BCC_EOS
17555                                           ! 2851             case 5: mouse_data1 = 100; break;
17556                       00004F53            .39E:
17557                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17558 4F53           B0                     64  mov	al,*$64
17559 4F55           8846         F4            mov	-$C[bp],al
17560                                           !BCC_EOS
17561 4F58           EB           31            jmp .396
17562                                           !BCC_EOS
17563                                           ! 2852             case 6: mouse_data1 = 200; break;
17564                       00004F5A            .39F:
17565                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17566 4F5A           B0                     C8  mov	al,#$C8
17567 4F5C           8846         F4            mov	-$C[bp],al
17568                                           !BCC_EOS
17569 4F5F           EB           2A            jmp .396
17570                                           !BCC_EOS
17571                                           ! 2853             default: mouse_data1 = 0;
17572                       00004F61            .3A0:
17573                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17574 4F61           30C0                       xor	al,al
17575 4F63           8846         F4            mov	-$C[bp],al
17576                                           !BCC_EOS
17577                                           ! 2854           }
17578                                           ! 2855           if (mouse_data1 > 0) {
17579 4F66           EB           23            jmp .396
17580                       00004F68            .398:
17581 4F68           2C                     00  sub	al,*0
17582 4F6A           72           F5            jb 	.3A0
17583 4F6C           3C                     06  cmp	al,*6
17584 4F6E           77           19            ja  	.3A1
17585 4F70           30E4                       xor	ah,ah
17586 4F72           D1E0                       shl	ax,*1
17587 4F74           89C3                       mov	bx,ax
17588 4F76           2E                         seg	cs
17589 4F77           FFA7       4F7B            br	.3A2[bx]
17590                       00004F7B            .3A2:
17591 4F7B                      4F30            .word	.399
17592 4F7D                      4F37            .word	.39A
17593 4F7F                      4F3E            .word	.39B
17594 4F81                      4F45            .word	.39C
17595 4F83                      4F4C            .word	.39D
17596 4F85                      4F53            .word	.39E
17597 4F87                      4F5A            .word	.39F
17598                       00004F89            .3A1:
17599 4F89           EB           D6            jmp	.3A0
17600                       00004F8B            .396:
17601                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17602 4F8B           8A46         F4            mov	al,-$C[bp]
17603 4F8E           84C0                       test	al,al
17604 4F90           74           57            je  	.3A3
17605                       00004F92            .3A4:
17606                                           ! 2856             ret = send_to_mouse_ctrl(0xF3);
17607                                           ! Debug: list int = const $F3 (used reg = )
17608 4F92           B8                   00F3  mov	ax,#$F3
17609 4F95           50                         push	ax
17610                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17611 4F96           E8         0E85            call	_send_to_mouse_ctrl
17612 4F99           44                         inc	sp
17613 4F9A           44                         inc	sp
17614                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17615 4F9B           8846         F5            mov	-$B[bp],al
17616                                           !BCC_EOS
17617                                           ! 2857             if (ret == 0) {
17618                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17619 4F9E           8A46         F5            mov	al,-$B[bp]
17620 4FA1           84C0                       test	al,al
17621 4FA3           75           35            jne 	.3A5
17622                       00004FA5            .3A6:
17623                                           ! 2858               ret = get_mouse_data(&mouse_data2);
17624                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17625 4FA5           8D5E         F3            lea	bx,-$D[bp]
17626 4FA8           53                         push	bx
17627                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17628 4FA9           E8         0EBC            call	_get_mouse_data
17629 4FAC           44                         inc	sp
17630 4FAD           44                         inc	sp
17631                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17632 4FAE           8846         F5            mov	-$B[bp],al
17633                                           !BCC_EOS
17634                                           ! 2859               ret = send_to_mouse_ctrl(mouse_data1);
17635                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17636 4FB1           8A46         F4            mov	al,-$C[bp]
17637 4FB4           30E4                       xor	ah,ah
17638 4FB6           50                         push	ax
17639                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17640 4FB7           E8         0E64            call	_send_to_mouse_ctrl
17641 4FBA           44                         inc	sp
17642 4FBB           44                         inc	sp
17643                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17644 4FBC           8846         F5            mov	-$B[bp],al
17645                                           !BCC_EOS
17646                                           ! 2860               ret = get_mouse_data(&mouse_data2);
17647                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17648 4FBF           8D5E         F3            lea	bx,-$D[bp]
17649 4FC2           53                         push	bx
17650                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17651 4FC3           E8         0EA2            call	_get_mouse_data
17652 4FC6           44                         inc	sp
17653 4FC7           44                         inc	sp
17654                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17655 4FC8           8846         F5            mov	-$B[bp],al
17656                                           !BCC_EOS
17657                                           ! 2861               FLAGS &= 0xfffe;
17658                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17659 4FCB           8B46         18            mov	ax,$18[bp]
17660 4FCE           24                     FE  and	al,#$FE
17661 4FD0           8946         18            mov	$18[bp],ax
17662                                           !BCC_EOS
17663                                           ! 2862               regs.u.r8.ah = 0;
17664                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17665 4FD3           30C0                       xor	al,al
17666 4FD5           8846         13            mov	$13[bp],al
17667                                           !BCC_EOS
17668                                           ! 2863             } else {
17669 4FD8           EB           0D            jmp .3A7
17670                       00004FDA            .3A5:
17671                                           ! 2864               FLAGS |= 0x0001;
17672                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17673 4FDA           8B46         18            mov	ax,$18[bp]
17674 4FDD           0C                     01  or	al,*1
17675 4FDF           8946         18            mov	$18[bp],ax
17676                                           !BCC_EOS
17677                                           ! 2865               regs.u.r8.ah = 0x86;
17678                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17679 4FE2           B0                     86  mov	al,#$86
17680 4FE4           8846         13            mov	$13[bp],al
17681                                           !BCC_EOS
17682                                           ! 2866             }
17683                                           ! 2867           } else {
17684                       00004FE7            .3A7:
17685 4FE7           EB           0D            jmp .3A8
17686                       00004FE9            .3A3:
17687                                           ! 2868             FLAGS |= 0x0001;
17688                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17689 4FE9           8B46         18            mov	ax,$18[bp]
17690 4FEC           0C                     01  or	al,*1
17691 4FEE           8946         18            mov	$18[bp],ax
17692                                           !BCC_EOS
17693                                           ! 2869             regs.u.r8.ah = 0x86;
17694                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17695 4FF1           B0                     86  mov	al,#$86
17696 4FF3           8846         13            mov	$13[bp],al
17697                                           !BCC_EOS
17698                                           ! 2870           }
17699                                           ! 2871           break;
17700                       00004FF6            .3A8:
17701 4FF6           E9         033F            br 	.36C
17702                                           !BCC_EOS
17703                                           ! 2872         case 3:
17704                                           ! 2873 ;
17705                       00004FF9            .3A9:
17706                                           !BCC_EOS
17707                                           ! 2874           comm_byte = inhibit_mouse_int_and_events();
17708                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17709 4FF9           E8         0CD1            call	_inhibit_mouse_int_and_events
17710                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
17711 4FFC           8846         F7            mov	-9[bp],al
17712                                           !BCC_EOS
17713                                           ! 2875           if (regs.u.r8.bh < 4) {
17714                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
17715 4FFF           8A46         0D            mov	al,$D[bp]
17716 5002           3C                     04  cmp	al,*4
17717 5004         0F83         008D            bhis	.3AA
17718                       00005008            .3AB:
17719                                           ! 2876             ret = send_to_mouse_ctrl(0xE8);
17720                                           ! Debug: list int = const $E8 (used reg = )
17721 5008           B8                   00E8  mov	ax,#$E8
17722 500B           50                         push	ax
17723                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17724 500C           E8         0E0F            call	_send_to_mouse_ctrl
17725 500F           44                         inc	sp
17726 5010           44                         inc	sp
17727                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17728 5011           8846         F5            mov	-$B[bp],al
17729                                           !BCC_EOS
17730                                           ! 2877             if (ret == 0) {
17731                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17732 5014           8A46         F5            mov	al,-$B[bp]
17733 5017           84C0                       test	al,al
17734 5019           75           6B            jne 	.3AC
17735                       0000501B            .3AD:
17736                                           ! 2878               ret = get_mouse_data(&mouse_data1);
17737                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17738 501B           8D5E         F4            lea	bx,-$C[bp]
17739 501E           53                         push	bx
17740                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17741 501F           E8         0E46            call	_get_mouse_data
17742 5022           44                         inc	sp
17743 5023           44                         inc	sp
17744                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17745 5024           8846         F5            mov	-$B[bp],al
17746                                           !BCC_EOS
17747                                           ! 2879               if (mouse_data1 != 0xfa)
17748                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17749 5027           8A46         F4            mov	al,-$C[bp]
17750 502A           3C                     FA  cmp	al,#$FA
17751 502C           74           14            je  	.3AE
17752                       0000502E            .3AF:
17753                                           ! 2880                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
17754                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17755 502E           8A46         F4            mov	al,-$C[bp]
17756 5031           30E4                       xor	ah,ah
17757 5033           50                         push	ax
17758                                           ! Debug: list * char = .3B0+0 (used reg = )
17759 5034           BB                   D27F  mov	bx,#.3B0
17760 5037           53                         push	bx
17761                                           ! Debug: list int = const 7 (used reg = )
17762 5038           B8                   0007  mov	ax,*7
17763 503B           50                         push	ax
17764                                           ! Debug: func () void = bios_printf+0 (used reg = )
17765 503C           E8         B9DC            call	_bios_printf
17766 503F           83C4                   06  add	sp,*6
17767                                           !BCC_EOS
17768                                           ! 2881               ret = send_to_mouse_ctrl(regs.u.r8.bh);
17769                       00005042            .3AE:
17770                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
17771 5042           8A46         0D            mov	al,$D[bp]
17772 5045           30E4                       xor	ah,ah
17773 5047           50                         push	ax
17774                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17775 5048           E8         0DD3            call	_send_to_mouse_ctrl
17776 504B           44                         inc	sp
17777 504C           44                         inc	sp
17778                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17779 504D           8846         F5            mov	-$B[bp],al
17780                                           !BCC_EOS
17781                                           ! 2882               ret = get_mouse_data(&mouse_data1);
17782                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17783 5050           8D5E         F4            lea	bx,-$C[bp]
17784 5053           53                         push	bx
17785                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17786 5054           E8         0E11            call	_get_mouse_data
17787 5057           44                         inc	sp
17788 5058           44                         inc	sp
17789                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17790 5059           8846         F5            mov	-$B[bp],al
17791                                           !BCC_EOS
17792                                           ! 2883               if (mouse_data1 != 0xfa)
17793                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17794 505C           8A46         F4            mov	al,-$C[bp]
17795 505F           3C                     FA  cmp	al,#$FA
17796 5061           74           14            je  	.3B1
17797                       00005063            .3B2:
17798                                           ! 2884                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
17799                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17800 5063           8A46         F4            mov	al,-$C[bp]
17801 5066           30E4                       xor	ah,ah
17802 5068           50                         push	ax
17803                                           ! Debug: list * char = .3B3+0 (used reg = )
17804 5069           BB                   D253  mov	bx,#.3B3
17805 506C           53                         push	bx
17806                                           ! Debug: list int = const 7 (used reg = )
17807 506D           B8                   0007  mov	ax,*7
17808 5070           50                         push	ax
17809                                           ! Debug: func () void = bios_printf+0 (used reg = )
17810 5071           E8         B9A7            call	_bios_printf
17811 5074           83C4                   06  add	sp,*6
17812                                           !BCC_EOS
17813                                           ! 2885               FLAGS &= 0xfffe;
17814                       00005077            .3B1:
17815                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17816 5077           8B46         18            mov	ax,$18[bp]
17817 507A           24                     FE  and	al,#$FE
17818 507C           8946         18            mov	$18[bp],ax
17819                                           !BCC_EOS
17820                                           ! 2886               regs.u.r8.ah = 0;
17821                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17822 507F           30C0                       xor	al,al
17823 5081           8846         13            mov	$13[bp],al
17824                                           !BCC_EOS
17825                                           ! 2887             } else {
17826 5084           EB           0D            jmp .3B4
17827                       00005086            .3AC:
17828                                           ! 2888               FLAGS |= 0x0001;
17829                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17830 5086           8B46         18            mov	ax,$18[bp]
17831 5089           0C                     01  or	al,*1
17832 508B           8946         18            mov	$18[bp],ax
17833                                           !BCC_EOS
17834                                           ! 2889               regs.u.r8.ah = 0x86;
17835                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17836 508E           B0                     86  mov	al,#$86
17837 5090           8846         13            mov	$13[bp],al
17838                                           !BCC_EOS
17839                                           ! 2890             }
17840                                           ! 2891           } else {
17841                       00005093            .3B4:
17842 5093           EB           0D            jmp .3B5
17843                       00005095            .3AA:
17844                                           ! 2892             FLAGS |= 0x0001;
17845                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17846 5095           8B46         18            mov	ax,$18[bp]
17847 5098           0C                     01  or	al,*1
17848 509A           8946         18            mov	$18[bp],ax
17849                                           !BCC_EOS
17850                                           ! 2893             regs.u.r8.ah = 0x86;
17851                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17852 509D           B0                     86  mov	al,#$86
17853 509F           8846         13            mov	$13[bp],al
17854                                           !BCC_EOS
17855                                           ! 2894           }
17856                                           ! 2895           set_kbd_command_byte(comm_byte);
17857                       000050A2            .3B5:
17858                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
17859 50A2           8A46         F7            mov	al,-9[bp]
17860 50A5           30E4                       xor	ah,ah
17861 50A7           50                         push	ax
17862                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
17863 50A8           E8         0DFE            call	_set_kbd_command_byte
17864 50AB           44                         inc	sp
17865 50AC           44                         inc	sp
17866                                           !BCC_EOS
17867                                           ! 2896           break;
17868 50AD           E9         0288            br 	.36C
17869                                           !BCC_EOS
17870                                           ! 2897         case 4:
17871                                           ! 2898 ;
17872                       000050B0            .3B6:
17873                                           !BCC_EOS
17874                                           ! 2899           inhibit_mouse_int_and_events();
17875                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17876 50B0           E8         0C1A            call	_inhibit_mouse_int_and_events
17877                                           !BCC_EOS
17878                                           ! 2900           ret = send_to_mouse_ctrl(0xF2);
17879                                           ! Debug: list int = const $F2 (used reg = )
17880 50B3           B8                   00F2  mov	ax,#$F2
17881 50B6           50                         push	ax
17882                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17883 50B7           E8         0D64            call	_send_to_mouse_ctrl
17884 50BA           44                         inc	sp
17885 50BB           44                         inc	sp
17886                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17887 50BC           8846         F5            mov	-$B[bp],al
17888                                           !BCC_EOS
17889                                           ! 2901           if (ret == 0) {
17890                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17891 50BF           8A46         F5            mov	al,-$B[bp]
17892 50C2           84C0                       test	al,al
17893 50C4           75           2D            jne 	.3B7
17894                       000050C6            .3B8:
17895                                           ! 2902             ret = get_mouse_data(&mouse_data1);
17896                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17897 50C6           8D5E         F4            lea	bx,-$C[bp]
17898 50C9           53                         push	bx
17899                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17900 50CA           E8         0D9B            call	_get_mouse_data
17901 50CD           44                         inc	sp
17902 50CE           44                         inc	sp
17903                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17904 50CF           8846         F5            mov	-$B[bp],al
17905                                           !BCC_EOS
17906                                           ! 2903             ret = get_mouse_data(&mouse_data2);
17907                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17908 50D2           8D5E         F3            lea	bx,-$D[bp]
17909 50D5           53                         push	bx
17910                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17911 50D6           E8         0D8F            call	_get_mouse_data
17912 50D9           44                         inc	sp
17913 50DA           44                         inc	sp
17914                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17915 50DB           8846         F5            mov	-$B[bp],al
17916                                           !BCC_EOS
17917                                           ! 2904             FLAGS &= 0xfffe;
17918                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17919 50DE           8B46         18            mov	ax,$18[bp]
17920 50E1           24                     FE  and	al,#$FE
17921 50E3           8946         18            mov	$18[bp],ax
17922                                           !BCC_EOS
17923                                           ! 2905          
17924                                           ! 2905    regs.u.r8.ah = 0;
17925                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17926 50E6           30C0                       xor	al,al
17927 50E8           8846         13            mov	$13[bp],al
17928                                           !BCC_EOS
17929                                           ! 2906             regs.u.r8.bh = mouse_data2;
17930                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
17931 50EB           8A46         F3            mov	al,-$D[bp]
17932 50EE           8846         0D            mov	$D[bp],al
17933                                           !BCC_EOS
17934                                           ! 2907           } else {
17935 50F1           EB           0D            jmp .3B9
17936                       000050F3            .3B7:
17937                                           ! 2908             FLAGS |= 0x0001;
17938                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17939 50F3           8B46         18            mov	ax,$18[bp]
17940 50F6           0C                     01  or	al,*1
17941 50F8           8946         18            mov	$18[bp],ax
17942                                           !BCC_EOS
17943                                           ! 2909             regs.u.r8.ah = 0x86;
17944                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17945 50FB           B0                     86  mov	al,#$86
17946 50FD           8846         13            mov	$13[bp],al
17947                                           !BCC_EOS
17948                                           ! 2910           }
17949                                           ! 2911           break;
17950                       00005100            .3B9:
17951 5100           E9         0235            br 	.36C
17952                                           !BCC_EOS
17953                                           ! 2912         case 6:
17954                                           ! 2913 ;
17955                       00005103            .3BA:
17956                                           !BCC_EOS
17957                                           ! 2914           switch (regs.u.r8.bh) {
17958 5103           8A46         0D            mov	al,$D[bp]
17959 5106           E9         015A            br 	.3BD
17960                                           ! 2915             case 0:
17961                                           ! 2916               comm_byte = inhibit_mouse_int_and_events();
17962                       00005109            .3BE:
17963                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17964 5109           E8         0BC1            call	_inhibit_mouse_int_and_events
17965                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
17966 510C           8846         F7            mov	-9[bp],al
17967                                           !BCC_EOS
17968                                           ! 2917               ret = send_to_mouse_ctrl(0xE9);
17969                                           ! Debug: list int = const $E9 (used reg = )
17970 510F           B8                   00E9  mov	ax,#$E9
17971 5112           50                         push	ax
17972                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17973 5113           E8         0D08            call	_send_to_mouse_ctrl
17974 5116           44                         inc	sp
17975 5117           44                         inc	sp
17976                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17977 5118           8846         F5            mov	-$B[bp],al
17978                                           !BCC_EOS
17979                                           ! 2918               if (ret == 0) {
17980                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17981 511B           8A46         F5            mov	al,-$B[bp]
17982 511E           84C0                       test	al,al
17983 5120         0F85         0095            bne 	.3BF
17984                       00005124            .3C0:
17985                                           ! 2919                 ret = get_mouse_data(&mouse_data1);
17986                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17987 5124           8D5E         F4            lea	bx,-$C[bp]
17988 5127           53                         push	bx
17989                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17990 5128           E8         0D3D            call	_get_mouse_data
17991 512B           44                         inc	sp
17992 512C           44                         inc	sp
17993                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17994 512D           8846         F5            mov	-$B[bp],al
17995                                           !BCC_EOS
17996                                           ! 2920                 if (mouse_data1 != 0xfa)
17997                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17998 5130           8A46         F4            mov	al,-$C[bp]
17999 5133           3C                     FA  cmp	al,#$FA
18000 5135           74           14            je  	.3C1
18001                       00005137            .3C2:
18002                                           ! 2921                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18003                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18004 5137           8A46         F4            mov	al,-$C[bp]
18005 513A           30E4                       xor	ah,ah
18006 513C           50                         push	ax
18007                                           ! Debug: list * char = .3C3+0 (used reg = )
18008 513D           BB                   D227  mov	bx,#.3C3
18009 5140           53                         push	bx
18010                                           ! Debug: list int = const 7 (used reg = )
18011 5141           B8                   0007  mov	ax,*7
18012 5144           50                         push	ax
18013                                           ! Debug: func () void = bios_printf+0 (used reg = )
18014 5145           E8         B8D3            call	_bios_printf
18015 5148           83C4                   06  add	sp,*6
18016                                           !BCC_EOS
18017                                           ! 2922                 if (ret == 0) {
18018                       0000514B            .3C1:
18019                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18020 514B           8A46         F5            mov	al,-$B[bp]
18021 514E           84C0                       test	al,al
18022 5150           75           67            jne 	.3C4
18023                       00005152            .3C5:
18024                                           ! 2923                   ret = get_mouse_data(&mouse_data1);
18025                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18026 5152           8D5E         F4            lea	bx,-$C[bp]
18027 5155           53                         push	bx
18028                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18029 5156           E8         0D0F            call	_get_mouse_data
18030 5159           44                         inc	sp
18031 515A           44                         inc	sp
18032                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18033 515B           8846         F5            mov	-$B[bp],al
18034                                           !BCC_EOS
18035                                           ! 2924                   if ( ret == 0 ) {
18036                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18037 515E           8A46         F5            mov	al,-$B[bp]
18038 5161           84C0                       test	al,al
18039 5163           75           54            jne 	.3C6
18040                       00005165            .3C7:
18041                                           ! 2925                     ret = get_mouse_data(&mouse_data2);
18042                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18043 5165           8D5E         F3            lea	bx,-$D[bp]
18044 5168           53                         push	bx
18045                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18046 5169           E8         0CFC            call	_get_mouse_data
18047 516C           44                         inc	sp
18048 516D           44                         inc	sp
18049                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18050 516E           8846         F5            mov	-$B[bp],al
18051                                           !BCC_EOS
18052                                           ! 2926                     if ( ret == 0 ) {
18053                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18054 5171           8A46         F5            mov	al,-$B[bp]
18055 5174           84C0                       test	al,al
18056 5176           75           41            jne 	.3C8
18057                       00005178            .3C9:
18058                                           ! 2927                       ret = get_mouse_data(&mouse_data3);
18059                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
18060 5178           8D5E         F2            lea	bx,-$E[bp]
18061 517B           53                         push	bx
18062                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18063 517C           E8         0CE9            call	_get_mouse_data
18064 517F           44                         inc	sp
18065 5180           44                         inc	sp
18066                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18067 5181           8846         F5            mov	-$B[bp],al
18068                                           !BCC_EOS
18069                                           ! 2928                       if ( ret == 0 ) {
18070                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18071 5184           8A46         F5            mov	al,-$B[bp]
18072 5187           84C0                       test	al,al
18073 5189           75           2E            jne 	.3CA
18074                       0000518B            .3CB:
18075                                           ! 2929                         FLAGS &= 0xfffe;
18076                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18077 518B           8B46         18            mov	ax,$18[bp]
18078 518E           24                     FE  and	al,#$FE
18079 5190           8946         18            mov	$18[bp],ax
18080                                           !BCC_EOS
18081                                           ! 2930                         regs.u.r8.ah = 0;
18082                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18083 5193           30C0                       xor	al,al
18084 5195           8846         13            mov	$13[bp],al
18085                                           !BCC_EOS
18086                                           ! 2931                         regs.u.r8.bl = mouse_data1;
18087                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
18088 5198           8A46         F4            mov	al,-$C[bp]
18089 519B           8846         0C            mov	$C[bp],al
18090                                           !BCC_EOS
18091                                           ! 2932                         regs.u.r8.cl = mouse_data2;
18092                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
18093 519E           8A46         F3            mov	al,-$D[bp]
18094 51A1           8846         10            mov	$10[bp],al
18095                                           !BCC_EOS
18096                                           ! 2933                         regs.u.r8.dl = mouse_data3;
18097                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
18098 51A4           8A46         F2            mov	al,-$E[bp]
18099 51A7           8846         0E            mov	$E[bp],al
18100                                           !BCC_EOS
18101                                           ! 2934                         set_kbd_command_byte(comm_byte);
18102                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18103 51AA           8A46         F7            mov	al,-9[bp]
18104 51AD           30E4                       xor	ah,ah
18105 51AF           50                         push	ax
18106                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18107 51B0           E8         0CF6            call	_set_kbd_command_byte
18108 51B3           44                         inc	sp
18109 51B4           44                         inc	sp
18110                                           !BCC_EOS
18111                                           ! 2935                         return;
18112 51B5           89EC                       mov	sp,bp
18113 51B7           5D                         pop	bp
18114 51B8           C3                         ret
18115                                           !BCC_EOS
18116                                           ! 2936                         }
18117                                           ! 2937                       }
18118                       000051B9            .3CA:
18119                                           ! 2938                     }
18120                       000051B9            .3C8:
18121                                           ! 2939                   }
18122                       000051B9            .3C6:
18123                                           ! 2940                 }
18124                       000051B9            .3C4:
18125                                           ! 2941               FLAGS |= 0x0001;
18126                       000051B9            .3BF:
18127                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18128 51B9           8B46         18            mov	ax,$18[bp]
18129 51BC           0C                     01  or	al,*1
18130 51BE           8946         18            mov	$18[bp],ax
18131                                           !BCC_EOS
18132                                           ! 2942               regs.u.r8.ah = ret;
18133                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
18134 51C1           8A46         F5            mov	al,-$B[bp]
18135 51C4           8846         13            mov	$13[bp],al
18136                                           !BCC_EOS
18137                                           ! 2943               set_kbd_command_byte(comm_byte);
18138                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18139 51C7           8A46         F7            mov	al,-9[bp]
18140 51CA           30E4                       xor	ah,ah
18141 51CC           50                         push	ax
18142                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18143 51CD           E8         0CD9            call	_set_kbd_command_byte
18144 51D0           44                         inc	sp
18145 51D1           44                         inc	sp
18146                                           !BCC_EOS
18147                                           ! 2944               return;
18148 51D2           89EC                       mov	sp,bp
18149 51D4           5D                         pop	bp
18150 51D5           C3                         ret
18151                                           !BCC_EOS
18152                                           ! 2945             case 1:
18153                                           ! 2946             case 2:
18154                       000051D6            .3CC:
18155                                           ! 2947               comm_byte = inhibit_mouse_int_and_events();
18156                       000051D6            .3CD:
18157                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18158 51D6           E8         0AF4            call	_inhibit_mouse_int_and_events
18159                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18160 51D9           8846         F7            mov	-9[bp],al
18161                                           !BCC_EOS
18162                                           ! 2948               if (regs.u.r8.bh == 1) {
18163                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
18164 51DC           8A46         0D            mov	al,$D[bp]
18165 51DF           3C                     01  cmp	al,*1
18166 51E1           75           0E            jne 	.3CE
18167                       000051E3            .3CF:
18168                                           ! 2949                 ret = send_to_mouse_ctrl(0xE6);
18169                                           ! Debug: list int = const $E6 (used reg = )
18170 51E3           B8                   00E6  mov	ax,#$E6
18171 51E6           50                         push	ax
18172                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18173 51E7           E8         0C34            call	_send_to_mouse_ctrl
18174 51EA           44                         inc	sp
18175 51EB           44                         inc	sp
18176                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18177 51EC           8846         F5            mov	-$B[bp],al
18178                                           !BCC_EOS
18179                                           ! 2950               } else {
18180 51EF           EB           0C            jmp .3D0
18181                       000051F1            .3CE:
18182                                           ! 2951                 ret = send_to_mouse_ctrl(0xE7);
18183                                           ! Debug: list int = const $E7 (used reg = )
18184 51F1           B8                   00E7  mov	ax,#$E7
18185 51F4           50                         push	ax
18186                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18187 51F5           E8         0C26            call	_send_to_mouse_ctrl
18188 51F8           44                         inc	sp
18189 51F9           44                         inc	sp
18190                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18191 51FA           8846         F5            mov	-$B[bp],al
18192                                           !BCC_EOS
18193                                           ! 2952               }
18194                                           ! 2953               if (ret == 0) {
18195                       000051FD            .3D0:
18196                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18197 51FD           8A46         F5            mov	al,-$B[bp]
18198 5200           84C0                       test	al,al
18199 5202           75           19            jne 	.3D1
18200                       00005204            .3D2:
18201                                           ! 2954                 get_mouse_data(&mouse_data1);
18202                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18203 5204           8D5E         F4            lea	bx,-$C[bp]
18204 5207           53                         push	bx
18205                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18206 5208           E8         0C5D            call	_get_mouse_data
18207 520B           44                         inc	sp
18208 520C           44                         inc	sp
18209                                           !BCC_EOS
18210                                           ! 2955                 ret = (mouse_data1 != 0xFA);
18211                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18212 520D           8A46         F4            mov	al,-$C[bp]
18213 5210           3C                     FA  cmp	al,#$FA
18214 5212           74           04            je 	.3D3
18215 5214           B0                     01  mov	al,*1
18216 5216           EB           02            jmp	.3D4
18217                       00005218            .3D3:
18218 5218           30C0                       xor	al,al
18219                       0000521A            .3D4:
18220                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18221 521A           8846         F5            mov	-$B[bp],al
18222                                           !BCC_EOS
18223                                           ! 2956               }
18224                                           ! 2957               if (ret == 0) {
18225                       0000521D            .3D1:
18226                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18227 521D           8A46         F5            mov	al,-$B[bp]
18228 5220           84C0                       test	al,al
18229 5222           75           0F            jne 	.3D5
18230                       00005224            .3D6:
18231                                           ! 2958                 FLAGS &= 0xfffe;
18232                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18233 5224           8B46         18            mov	ax,$18[bp]
18234 5227           24                     FE  and	al,#$FE
18235 5229           8946         18            mov	$18[bp],ax
18236                                           !BCC_EOS
18237                                           ! 2959                 regs.u.r8.ah = 0;
18238                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18239 522C           30C0                       xor	al,al
18240 522E           8846         13            mov	$13[bp],al
18241                                           !BCC_EOS
18242                                           ! 2960               } else {
18243 5231           EB           0D            jmp .3D7
18244                       00005233            .3D5:
18245                                           ! 2961                 FLAGS |= 0x0001;
18246                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18247 5233           8B46         18            mov	ax,$18[bp]
18248 5236           0C                     01  or	al,*1
18249 5238           8946         18            mov	$18[bp],ax
18250                                           !BCC_EOS
18251                                           ! 2962                
18252                                           ! 2962  regs.u.r8.ah = 0x86;
18253                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18254 523B           B0                     86  mov	al,#$86
18255 523D           8846         13            mov	$13[bp],al
18256                                           !BCC_EOS
18257                                           ! 2963               }
18258                                           ! 2964               set_kbd_command_byte(comm_byte);
18259                       00005240            .3D7:
18260                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18261 5240           8A46         F7            mov	al,-9[bp]
18262 5243           30E4                       xor	ah,ah
18263 5245           50                         push	ax
18264                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18265 5246           E8         0C60            call	_set_kbd_command_byte
18266 5249           44                         inc	sp
18267 524A           44                         inc	sp
18268                                           !BCC_EOS
18269                                           ! 2965               break;
18270 524B           EB           2A            jmp .3BB
18271                                           !BCC_EOS
18272                                           ! 2966             default:
18273                                           ! 2967               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
18274                       0000524D            .3D8:
18275                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18276 524D           8A46         0D            mov	al,$D[bp]
18277 5250           30E4                       xor	ah,ah
18278 5252           50                         push	ax
18279                                           ! Debug: list * char = .3D9+0 (used reg = )
18280 5253           BB                   D20D  mov	bx,#.3D9
18281 5256           53                         push	bx
18282                                           ! Debug: list int = const 7 (used reg = )
18283 5257           B8                   0007  mov	ax,*7
18284 525A           50                         push	ax
18285                                           ! Debug: func () void = bios_printf+0 (used reg = )
18286 525B           E8         B7BD            call	_bios_printf
18287 525E           83C4                   06  add	sp,*6
18288                                           !BCC_EOS
18289                                           ! 2968             }
18290                                           ! 2969           break;
18291 5261           EB           14            jmp .3BB
18292                       00005263            .3BD:
18293 5263           2C                     00  sub	al,*0
18294 5265         0F84         FEA0            beq 	.3BE
18295 5269           2C                     01  sub	al,*1
18296 526B         0F84         FF67            beq 	.3CC
18297 526F           2C                     01  sub	al,*1
18298 5271         0F84         FF61            beq 	.3CD
18299 5275           EB           D6            jmp	.3D8
18300                       00005277            .3BB:
18301 5277           E9         00BE            br 	.36C
18302                                           !BCC_EOS
18303                                           ! 2970         case 7:
18304                                           ! 2971 ;
18305                       0000527A            .3DA:
18306                                           !BCC_EOS
18307                                           ! 2972           mouse_driver_seg = ES;
18308                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18309 527A           8B46         14            mov	ax,$14[bp]
18310 527D           8946         FA            mov	-6[bp],ax
18311                                           !BCC_EOS
18312                                           ! 2973           mouse_driver_offset = regs.u.r16.bx;
18313                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18314 5280           8B46         0C            mov	ax,$C[bp]
18315 5283           8946         F8            mov	-8[bp],ax
18316                                           !BCC_EOS
18317                                           ! 2974           write_word(ebda_seg, 0x0022, mouse_driver_offset);
18318                                           ! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18319 5286           FF76         F8            push	-8[bp]
18320                                           ! Debug: list int = const $22 (used reg = )
18321 5289           B8                   0022  mov	ax,*$22
18322 528C           50                         push	ax
18323                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18324 528D           FF76         FE            push	-2[bp]
18325                                           ! Debug: func () void = write_word+0 (used reg = )
18326 5290           E8         B39F            call	_write_word
18327 5293           83C4                   06  add	sp,*6
18328                                           !BCC_EOS
18329                                           ! 2975           write_word(ebda_seg, 0x0024, mouse_driver_seg);
18330                                           ! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18331 5296           FF76         FA            push	-6[bp]
18332                                           ! Debug: list int = const $24 (used reg = )
18333 5299           B8                   0024  mov	ax,*$24
18334 529C           50                         push	ax
18335                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18336 529D           FF76         FE            push	-2[bp]
18337                                           ! Debug: func () void = write_word+0 (used reg = )
18338 52A0           E8         B38F            call	_write_word
18339 52A3           83C4                   06  add	sp,*6
18340                                           !BCC_EOS
18341                                           ! 2976           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
18342                                           ! Debug: list int = const $27 (used reg = )
18343 52A6           B8                   0027  mov	ax,*$27
18344 52A9           50                         push	ax
18345                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
18346 52AA           FF76         FE            push	-2[bp]
18347                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18348 52AD           E8         B344            call	_read_byte
18349 52B0           83C4                   04  add	sp,*4
18350                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18351 52B3           8846         FC            mov	-4[bp],al
18352                                           !BCC_EOS
18353                                           ! 2977           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
18354                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18355 52B6           8B46         F8            mov	ax,-8[bp]
18356 52B9           85C0                       test	ax,ax
18357 52BB           75           1D            jne 	.3DB
18358                       000052BD            .3DD:
18359                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18360 52BD           8B46         FA            mov	ax,-6[bp]
18361 52C0           85C0                       test	ax,ax
18362 52C2           75           16            jne 	.3DB
18363                       000052C4            .3DC:
18364                                           ! 2978             if ( (mouse_flags_2 & 0x80) != 0 ) {
18365                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18366 52C4           8A46         FC            mov	al,-4[bp]
18367 52C7           24                     80  and	al,#$80
18368                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
18369 52C9           84C0                       test	al,al
18370 52CB           74           0B            je  	.3DE
18371                       000052CD            .3DF:
18372                                           ! 2979               mouse_flags_2 &= ~0x80;
18373                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18374 52CD           8A46         FC            mov	al,-4[bp]
18375 52D0           24                     7F  and	al,*$7F
18376 52D2           8846         FC            mov	-4[bp],al
18377                                           !BCC_EOS
18378                                           ! 2980               inhibit_mouse_int_and_events();
18379                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18380 52D5           E8         09F5            call	_inhibit_mouse_int_and_events
18381                                           !BCC_EOS
18382                                           ! 2981               }
18383                                           ! 2982             }
18384                       000052D8            .3DE:
18385                                           ! 2983           else {
18386 52D8           EB           08            jmp .3E0
18387                       000052DA            .3DB:
18388                                           ! 2984             mouse_flags_2 |= 0x80;
18389                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18390 52DA           8A46         FC            mov	al,-4[bp]
18391 52DD           0C                     80  or	al,#$80
18392 52DF           8846         FC            mov	-4[bp],al
18393                                           !BCC_EOS
18394                                           ! 2985             }
18395                                           ! 2986           write_byte(ebda_seg, 0x0027, mouse_flags_2);
18396                       000052E2            .3E0:
18397                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18398 52E2           8A46         FC            mov	al,-4[bp]
18399 52E5           30E4                       xor	ah,ah
18400 52E7           50                         push	ax
18401                                           ! Debug: list int = const $27 (used reg = )
18402 52E8           B8                   0027  mov	ax,*$27
18403 52EB           50                         push	ax
18404                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18405 52EC           FF76         FE            push	-2[bp]
18406                                           ! Debug: func () void = write_byte+0 (used reg = )
18407 52EF           E8         B328            call	_write_byte
18408 52F2           83C4                   06  add	sp,*6
18409                                           !BCC_EOS
18410                                           ! 2987           FLAGS &= 0xfffe;
18411                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18412 52F5           8B46         18            mov	ax,$18[bp]
18413 52F8           24                     FE  and	al,#$FE
18414 52FA           8946         18            mov	$18[bp],ax
18415                                           !BCC_EOS
18416                                           ! 2988           regs.u.r8.ah = 0;
18417                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18418 52FD           30C0                       xor	al,al
18419 52FF           8846         13            mov	$13[bp],al
18420                                           !BCC_EOS
18421                                           ! 2989           break;
18422 5302           EB           34            jmp .36C
18423                                           !BCC_EOS
18424                                           ! 2990         default:
18425                                           ! 2991 ;
18426                       00005304            .3E1:
18427                                           !BCC_EOS
18428                                           ! 2992           regs.u.r8.ah = 1;
18429                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
18430 5304           B0                     01  mov	al,*1
18431 5306           8846         13            mov	$13[bp],al
18432                                           !BCC_EOS
18433                                           ! 2993           FLAGS |= 0x0001;
18434                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18435 5309           8B46         18            mov	ax,$18[bp]
18436 530C           0C                     01  or	al,*1
18437 530E           8946         18            mov	$18[bp],ax
18438                                           !BCC_EOS
18439                                           ! 2994         }
18440                                           ! 2995       break;
18441 5311           EB           25            jmp .36C
18442                       00005313            .36E:
18443 5313           2C                     00  sub	al,*0
18444 5315           72           ED            jb 	.3E1
18445 5317           3C                     07  cmp	al,*7
18446 5319           77           1B            ja  	.3E2
18447 531B           30E4                       xor	ah,ah
18448 531D           D1E0                       shl	ax,*1
18449 531F           89C3                       mov	bx,ax
18450 5321           2E                         seg	cs
18451 5322           FFA7       5326            br	.3E3[bx]
18452                       00005326            .3E3:
18453 5326                      4D15            .word	.36F
18454 5328                      4E15            .word	.382
18455 532A                      4F2B            .word	.395
18456 532C                      4FF9            .word	.3A9
18457 532E                      50B0            .word	.3B6
18458 5330                      4E15            .word	.383
18459 5332                      5103            .word	.3BA
18460 5334                      527A            .word	.3DA
18461                       00005336            .3E2:
18462 5336           EB           CC            jmp	.3E1
18463                       00005338            .36C:
18464 5338           EB           19            jmp .368
18465                                           !BCC_EOS
18466                                           ! 2996     default:
18467                                           ! 2997       ;
18468                       0000533A            .3E4:
18469                                           !BCC_EOS
18470                                           ! 2998       FLAGS |= 0x0001;
18471                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18472 533A           8B46         18            mov	ax,$18[bp]
18473 533D           0C                     01  or	al,*1
18474 533F           8946         18            mov	$18[bp],ax
18475                                           !BCC_EOS
18476                                           ! 2999       regs.u.r8.ah = 0x86;
18477                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18478 5342           B0                     86  mov	al,#$86
18479 5344           8846         13            mov	$13[bp],al
18480                                           !BCC_EOS
18481                                           ! 3000       break;
18482 5347           EB           0A            jmp .368
18483                                           !BCC_EOS
18484                                           ! 3001     }
18485                                           ! 3002 }
18486 5349           EB           08            jmp .368
18487                       0000534B            .36A:
18488 534B           2C                     C2  sub	al,#$C2
18489 534D         0F84         F9BE            beq 	.36B
18490 5351           EB           E7            jmp	.3E4
18491                       00005353            .368:
18492                       FFFFFFF0            ..FFF6	=	-$10
18493 5353           89EC                       mov	sp,bp
18494 5355           5D                         pop	bp
18495 5356           C3                         ret
18496                                           ! 3003 void set_e820_range(ES, DI, start, end, type)
18497                                           ! Register BX used in function int15_function_mouse
18498                                           ! 3004      Bit16u ES;
18499                                           export	_set_e820_range
18500                       00005357            _set_e820_range:
18501                                           !BCC_EOS
18502                                           ! 3005      Bit16u DI;
18503                                           !BCC_EOS
18504                                           ! 3006      Bit32u start;
18505                                           !BCC_EOS
18506                                           ! 3007      Bit32u end;
18507                                           !BCC_EOS
18508                                           ! 3008      Bit16u type;
18509                                           !BCC_EOS
18510                                           ! 3009 {
18511                                           ! 3010     write_word(ES, DI, start);
18512 5357           55                         push	bp
18513 5358           89E5                       mov	bp,sp
18514                                           ! Debug: list unsigned long start = [S+2+6] (used reg = )
18515 535A           FF76         0A            push	$A[bp]
18516 535D           FF76         08            push	8[bp]
18517                                           ! Debug: list unsigned short DI = [S+6+4] (used reg = )
18518 5360           FF76         06            push	6[bp]
18519                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18520 5363           FF76         04            push	4[bp]
18521                                           ! Debug: func () void = write_word+0 (used reg = )
18522 5366           E8         B2C9            call	_write_word
18523 5369           89EC                       mov	sp,bp
18524                                           !BCC_EOS
18525                                           ! 3011     write_word(ES, DI+2, start >> 16);
18526                                           ! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
18527 536B           8B46         08            mov	ax,8[bp]
18528 536E           8B5E         0A            mov	bx,$A[bp]
18529 5371           93                         xchg	bx,ax
18530 5372           31DB                       xor	bx,bx
18531                                           ! Debug: list unsigned long = bx+0 (used reg = )
18532 5374           53                         push	bx
18533 5375           50                         push	ax
18534                                           ! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
18535 5376           8B46         06            mov	ax,6[bp]
18536                                           ! Debug: list unsigned int = ax+2 (used reg = )
18537 5379           40                         inc	ax
18538 537A           40                         inc	ax
18539 537B           50                         push	ax
18540                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18541 537C           FF76         04            push	4[bp]
18542                                           ! Debug: func () void = write_word+0 (used reg = )
18543 537F           E8         B2B0            call	_write_word
18544 5382           89EC                       mov	sp,bp
18545                                           !BCC_EOS
18546                                           ! 3012     write_word(ES, DI+4, 0x00);
18547                                           ! Debug: list int = const 0 (used reg = )
18548 5384           31C0                       xor	ax,ax
18549 5386           50                         push	ax
18550                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
18551 5387           8B46         06            mov	ax,6[bp]
18552                                           ! Debug: list unsigned int = ax+4 (used reg = )
18553 538A           05                   0004  add	ax,*4
18554 538D           50                         push	ax
18555                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18556 538E           FF76         04            push	4[bp]
18557                                           ! Debug: func () void = write_word+0 (used reg = )
18558 5391           E8         B29E            call	_write_word
18559 5394           89EC                       mov	sp,bp
18560                                           !BCC_EOS
18561                                           ! 3013     write_word(ES, DI+6, 0x00);
18562                                           ! Debug: list int = const 0 (used reg = )
18563 5396           31C0                       xor	ax,ax
18564 5398           50                         push	ax
18565                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
18566 5399           8B46         06            mov	ax,6[bp]
18567                                           ! Debug: list unsigned int = ax+6 (used reg = )
18568 539C           05                   0006  add	ax,*6
18569 539F           50                         push	ax
18570                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18571 53A0           FF76         04            push	4[bp]
18572                                           ! Debug: func () void = write_word+0 (used reg = )
18573 53A3           E8         B28C            call	_write_word
18574 53A6           89EC                       mov	sp,bp
18575                                           !BCC_EOS
18576                                           ! 3014     end -= start;
18577                                           ! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
18578 53A8           8B46         0C            mov	ax,$C[bp]
18579 53AB           8B5E         0E            mov	bx,$E[bp]
18580 53AE           8D7E         08            lea	di,8[bp]
18581 53B1           E8         AD2D            call	lsubul
18582 53B4           8946         0C            mov	$C[bp],ax
18583 53B7           895E         0E            mov	$E[bp],bx
18584                                           !BCC_EOS
18585                                           ! 3015     write_word(ES, DI+8, end);
18586                                           ! Debug: list unsigned long end = [S+2+$A] (used reg = )
18587 53BA           FF76         0E            push	$E[bp]
18588 53BD           FF76         0C            push	$C[bp]
18589                                           ! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
18590 53C0           8B46         06            mov	ax,6[bp]
18591                                           ! Debug: list unsigned int = ax+8 (used reg = )
18592 53C3           05                   0008  add	ax,*8
18593 53C6           50                         push	ax
18594                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18595 53C7           FF76         04            push	4[bp]
18596                                           ! Debug: func () void = write_word+0 (used reg = )
18597 53CA           E8         B265            call	_write_word
18598 53CD           89EC                       mov	sp,bp
18599                                           !BCC_EOS
18600                                           ! 3016     write_word(ES, DI+10, end >> 16);
18601                                           ! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
18602 53CF           8B46         0C            mov	ax,$C[bp]
18603 53D2           8B5E         0E            mov	bx,$E[bp]
18604 53D5           93                         xchg	bx,ax
18605 53D6           31DB                       xor	bx,bx
18606                                           ! Debug: list unsigned long = bx+0 (used reg = )
18607 53D8           53                         push	bx
18608 53D9           50                         push	ax
18609                                           ! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
18610 53DA           8B46         06            mov	ax,6[bp]
18611                                           ! Debug: list unsigned int = ax+$A (used reg = )
18612 53DD           05                   000A  add	ax,*$A
18613 53E0           50                         push	ax
18614                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18615 53E1           FF76         04            push	4[bp]
18616                                           ! Debug: func () void = write_word+0 (used reg = )
18617 53E4           E8         B24B            call	_write_word
18618 53E7           89EC                       mov	sp,bp
18619                                           !BCC_EOS
18620                                           ! 3017     write_word(ES, DI+12, 0x0000);
18621                                           ! Debug: list int = const 0 (used reg = )
18622 53E9           31C0                       xor	ax,ax
18623 53EB           50                         push	ax
18624                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
18625 53EC           8B46         06            mov	ax,6[bp]
18626                                           ! Debug: list unsigned int = ax+$C (used reg = )
18627 53EF           05                   000C  add	ax,*$C
18628 53F2           50                         push	ax
18629                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18630 53F3           FF76         04            push	4[bp]
18631                                           ! Debug: func () void = write_word+0 (used reg = )
18632 53F6           E8         B239            call	_write_word
18633 53F9           89EC                       mov	sp,bp
18634                                           !BCC_EOS
18635                                           ! 3018     write_word(ES, DI+14, 0x0000);
18636                                           ! Debug: list int = const 0 (used reg = )
18637 53FB           31C0                       xor	ax,ax
18638 53FD           50                         push	ax
18639                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
18640 53FE           8B46         06            mov	ax,6[bp]
18641                                           ! Debug: list unsigned int = ax+$E (used reg = )
18642 5401           05                   000E  add	ax,*$E
18643 5404           50                         push	ax
18644                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18645 5405           FF76         04            push	4[bp]
18646                                           ! Debug: func () void = write_word+0 (used reg = )
18647 5408           E8         B227            call	_write_word
18648 540B           89EC                       mov	sp,bp
18649                                           !BCC_EOS
18650                                           ! 3019     write_word(ES, DI+16, type);
18651                                           ! Debug: list unsigned short type = [S+2+$E] (used reg = )
18652 540D           FF76         10            push	$10[bp]
18653                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
18654 5410           8B46         06            mov	ax,6[bp]
18655                                           ! Debug: list unsigned int = ax+$10 (used reg = )
18656 5413           05                   0010  add	ax,*$10
18657 5416           50                         push	ax
18658                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18659 5417           FF76         04            push	4[bp]
18660                                           ! Debug: func () void = write_word+0 (used reg = )
18661 541A           E8         B215            call	_write_word
18662 541D           89EC                       mov	sp,bp
18663                                           !BCC_EOS
18664                                           ! 3020     write_word(ES, DI+18, 0x0);
18665                                           ! Debug: list int = const 0 (used reg = )
18666 541F           31C0                       xor	ax,ax
18667 5421           50                         push	ax
18668                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
18669 5422           8B46         06            mov	ax,6[bp]
18670                                           ! Debug: list unsigned int = ax+$12 (used reg = )
18671 5425           05                   0012  add	ax,*$12
18672 5428           50                         push	ax
18673                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18674 5429           FF76         04            push	4[bp]
18675                                           ! Debug: func () void = write_word+0 (used reg = )
18676 542C           E8         B203            call	_write_word
18677 542F           89EC                       mov	sp,bp
18678                                           !BCC_EOS
18679                                           ! 3021 }
18680 5431           5D                         pop	bp
18681 5432           C3                         ret
18682                                           ! 3022   void
18683                                           ! Register BX used in function set_e820_range
18684                                           ! 3023 int15_function32(regs, ES, DS, FLAGS)
18685                                           ! 3024   pushad_regs_t regs;
18686                                           export	_int15_function32
18687                       00005433            _int15_function32:
18688                                           !BCC_EOS
18689                                           ! 3025   Bit16u ES, DS, FLAGS;
18690                                           !BCC_EOS
18691                                           ! 3026 {
18692                                           ! 3027   Bit32u extended_memory_size=0;
18693 5433           55                         push	bp
18694 5434           89E5                       mov	bp,sp
18695 5436           83C4                   FC  add	sp,*-4
18696                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
18697 5439           31C0                       xor	ax,ax
18698 543B           31DB                       xor	bx,bx
18699 543D           8946         FC            mov	-4[bp],ax
18700 5440           895E         FE            mov	-2[bp],bx
18701                                           !BCC_EOS
18702                                           ! 3028   Bit16u CX,DX;
18703                                           !BCC_EOS
18704                                           ! 3029   Bit16u off, e820_table_size;
18705                                           !BCC_EOS
18706                                           ! 3030   Bit32u base, type, size;
18707                                           !BCC_EOS
18708                                           ! 3031 ;
18709 5443           83C4                   EC  add	sp,*-$14
18710                                           !BCC_EOS
18711                                           ! 3032   switch (regs.u.r8.ah) {
18712 5446           8A46         21            mov	al,$21[bp]
18713 5449           E9         0341            br 	.3E7
18714                                           ! 3033     case 0x86:
18715                                           ! 3034       CX = regs.u.r16.cx;
18716                       0000544C            .3E8:
18717                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
18718 544C           8B46         1C            mov	ax,$1C[bp]
18719 544F           8946         FA            mov	-6[bp],ax
18720                                           !BCC_EOS
18721                                           ! 3035       DX = regs.u.r16.dx;
18722                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
18723 5452           8B46         18            mov	ax,$18[bp]
18724 5455           8946         F8            mov	-8[bp],ax
18725                                           !BCC_EOS
18726                                           ! 3036 #asm
18727                                           !BCC_EOS
18728                                           !BCC_ASM
18729                       00000012            _int15_function32.CX	set	$12
18730                       FFFFFFFA            .int15_function32.CX	set	-6
18731                       00000014            _int15_function32.extended_memory_size	set	$14
18732                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
18733                       00000040            _int15_function32.FLAGS	set	$40
18734                       00000028            .int15_function32.FLAGS	set	$28
18735                       00000004            _int15_function32.type	set	4
18736                       FFFFFFEC            .int15_function32.type	set	-$14
18737                       0000003E            _int15_function32.DS	set	$3E
18738                       00000026            .int15_function32.DS	set	$26
18739                       00000010            _int15_function32.DX	set	$10
18740                       FFFFFFF8            .int15_function32.DX	set	-8
18741                       00000000            _int15_function32.size	set	0
18742                       FFFFFFE8            .int15_function32.size	set	-$18
18743                       0000003C            _int15_function32.ES	set	$3C
18744                       00000024            .int15_function32.ES	set	$24
18745                       0000000C            _int15_function32.e820_table_size	set	$C
18746                       FFFFFFF4            .int15_function32.e820_table_size	set	-$C
18747                       00000008            _int15_function32.base	set	8
18748                       FFFFFFF0            .int15_function32.base	set	-$10
18749                       0000001C            _int15_function32.regs	set	$1C
18750                       00000004            .int15_function32.regs	set	4
18751                       0000000E            _int15_function32.off	set	$E
18752                       FFFFFFF6            .int15_function32.off	set	-$A
18753 5458           FB                               sti
18754                                                 ;; Get the count in eax
18755 5459           89E3                             mov bx, sp
18756 545B           36                         SEG SS
18757 545C           8B47         12                  mov ax, _int15_function32.CX [bx]
18758 545F     66    C1E0                   10        shl eax, #16
18759 5463           36                         SEG SS
18760 5464           8B47         10                  mov ax, _int15_function32.DX [bx]
18761                                                 ;; convert to numbers of 15usec ticks
18762 5467     66    BB               0000000F        mov ebx, #15
18763 546D     66    31D2                             xor edx, edx
18764 5470     66    F7F3                             div eax, ebx
18765 5473     66    89C1                             mov ecx, eax
18766                                                 ;; wait for ecx number of refresh requests
18767 5476           E4                     61        in al, #0x61
18768 5478           24                     10        and al,#0x10
18769 547A           88C4                             mov ah, al
18770 547C     66    09C9                             or ecx, ecx
18771 547F           74           0E                  je int1586_tick_end
18772                       00005481            int1586_tick:
18773 5481           E4                     61        in al, #0x61
18774 5483           24                     10        and al,#0x10
18775 5485           38E0                             cmp al, ah
18776 5487           74           F8                  je int1586_tick
18777 5489           88C4                             mov ah, al
18778 548B     66    49                               dec ecx
18779 548D           75           F2                  jnz int1586_tick
18780                       0000548F            int1586_tick_end:
18781                                           ! 3065 endasm
18782                                           !BCC_ENDASM
18783                                           !BCC_EOS
18784                                           ! 3066       break;
18785 548F           E9         0309            br 	.3E5
18786                                           !BCC_EOS
18787                                           ! 3067     case 0xe8:
18788                                           ! 3068         switch(regs.u.r8.al)
18789                       00005492            .3E9:
18790 5492           8A46         20            mov	al,$20[bp]
18791                                           ! 3069         {
18792 5495           E9         02D4            br 	.3EC
18793                                           ! 3070        case 0x20: {
18794                       00005498            .3ED:
18795                                           ! 3071             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
18796                                           ! Debug: list int = const 0 (used reg = )
18797 5498           31C0                       xor	ax,ax
18798 549A           50                         push	ax
18799                                           ! Debug: list unsigned short = const $EA10 (used reg = )
18800 549B           B8                   EA10  mov	ax,#$EA10
18801 549E           50                         push	ax
18802                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
18803 549F           E8         B165            call	_read_word
18804 54A2           83C4                   04  add	sp,*4
18805                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
18806 54A5           B9                   0014  mov	cx,*$14
18807 54A8           F7E9                       imul	cx
18808                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
18809 54AA           8946         F4            mov	-$C[bp],ax
18810                                           !BCC_EOS
18811                                           ! 3072             if (regs.u.r32.edx != 0x534D4150)
18812                                           ! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
18813                                           ! Debug: expression subtree swapping
18814 54AD           B8                   4150  mov	ax,#$4150
18815 54B0           BB                   534D  mov	bx,#$534D
18816 54B3           53                         push	bx
18817 54B4           50                         push	ax
18818 54B5           8B46         18            mov	ax,$18[bp]
18819 54B8           8B5E         1A            mov	bx,$1A[bp]
18820 54BB           8D7E         E4            lea	di,-2+..FFF5[bp]
18821 54BE           E8         AC0A            call	lcmpul
18822 54C1           8D66         E8            lea	sp,2+..FFF5[bp]
18823 54C4           74           06            je  	.3EE
18824                       000054C6            .3EF:
18825                                           ! 3073                 goto int15_unimplemented;
18826 54C6           83C4                   00  add	sp,#..FFF4-..FFF5
18827 54C9           E9         02B0            br 	.FFF4
18828                                           !BCC_EOS
18829                                           ! 3074             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
18830                       000054CC            .3EE:
18831                                           ! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
18832 54CC           8B46         14            mov	ax,$14[bp]
18833 54CF           BB                   0014  mov	bx,*$14
18834 54D2           E8         AC94            call	idiv_u
18835                                           ! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
18836 54D5           B9                   0014  mov	cx,*$14
18837 54D8           F7E9                       imul	cx
18838                                           ! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
18839 54DA           3B46         14            cmp	ax,$14[bp]
18840 54DD         0F85         0084            bne 	.3F0
18841                       000054E1            .3F1:
18842                                           ! 3075                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
18843                                           ! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
18844 54E1           8B46         14            mov	ax,$14[bp]
18845                                           ! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
18846 54E4           05                   0014  add	ax,*$14
18847 54E7           3B46         F4            cmp	ax,-$C[bp]
18848 54EA           77           1B            ja  	.3F2
18849                       000054EC            .3F3:
18850                                           ! 3076                     memcpyb(ES, regs.u.r16.di,
18851                                           ! 3077                             (Bit16u)(0x000EA100 >> 4), 0x8 + regs.u.r16.bx, 0x14);
18852                                           ! Debug: list int = const $14 (used reg = )
18853 54EC           B8                   0014  mov	ax,*$14
18854 54EF           50                         push	ax
18855                                           ! Debug: add unsigned short regs = [S+$1C+$12] to int = const 8 (used reg = )
18856                                           ! Debug: expression subtree swapping
18857 54F0           8B46         14            mov	ax,$14[bp]
18858                                           ! Debug: list unsigned int = ax+8 (used reg = )
18859 54F3           05                   0008  add	ax,*8
18860 54F6           50                         push	ax
18861                                           ! Debug: list unsigned short = const $EA10 (used reg = )
18862 54F7           B8                   EA10  mov	ax,#$EA10
18863 54FA           50                         push	ax
18864                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
18865 54FB           FF76         04            push	4[bp]
18866                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
18867 54FE           FF76         24            push	$24[bp]
18868                                           ! Debug: func () void = memcpyb+0 (used reg = )
18869 5501           E8         AB20            call	_memcpyb
18870 5504           83C4                   0A  add	sp,*$A
18871                                           !BCC_EOS
18872                                           ! 3078                 regs.u.r32.ebx += 0x14;
18873                       00005507            .3F2:
18874                                           ! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
18875 5507           B8                   0014  mov	ax,*$14
18876 550A           31DB                       xor	bx,bx
18877 550C           53                         push	bx
18878 550D           50                         push	ax
18879 550E           8B46         14            mov	ax,$14[bp]
18880 5511           8B5E         16            mov	bx,$16[bp]
18881 5514           8D7E         E4            lea	di,-2+..FFF5[bp]
18882 5517           E8         ABA9            call	laddul
18883 551A           8946         14            mov	$14[bp],ax
18884 551D           895E         16            mov	$16[bp],bx
18885 5520           83C4                   04  add	sp,*4
18886                                           !BCC_EOS
18887                                           ! 3079                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
18888                                           ! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
18889 5523           8B46         F4            mov	ax,-$C[bp]
18890 5526           31DB                       xor	bx,bx
18891 5528           53                         push	bx
18892 5529           50                         push	ax
18893                                           ! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
18894                                           ! Debug: expression subtree swapping
18895 552A           B8                   0014  mov	ax,*$14
18896 552D           31DB                       xor	bx,bx
18897 552F           8D7E         14            lea	di,$14[bp]
18898 5532           E8         AB8E            call	laddul
18899                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
18900 5535           53                         push	bx
18901 5536           50                         push	ax
18902 5537           B8                   0001  mov	ax,*1
18903 553A           31DB                       xor	bx,bx
18904 553C           53                         push	bx
18905 553D           50                         push	ax
18906 553E           8B46         E0            mov	ax,-6+..FFF5[bp]
18907 5541           8B5E         E2            mov	bx,-4+..FFF5[bp]
18908 5544           8D7E         DC            lea	di,-$A+..FFF5[bp]
18909 5547           E8         AB97            call	lsubul
18910 554A           83C4                   08  add	sp,*8
18911                                           ! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
18912 554D           8D7E         E4            lea	di,-2+..FFF5[bp]
18913 5550           E8         AB78            call	lcmpul
18914 5553           8D66         E8            lea	sp,2+..FFF5[bp]
18915 5556           76           0A            jbe 	.3F4
18916                       00005558            .3F5:
18917                                           ! 3080                     regs.u.r32.ebx = 0;
18918                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
18919 5558           31C0                       xor	ax,ax
18920 555A           31DB                       xor	bx,bx
18921 555C           8946         14            mov	$14[bp],ax
18922 555F           895E         16            mov	$16[bp],bx
18923                                           !BCC_EOS
18924                                           ! 3081             } else if (regs.u.r16.bx == 1) {
18925                       00005562            .3F4:
18926 5562           E9         00BB            br 	.3F6
18927                       00005565            .3F0:
18928                                           ! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
18929 5565           8B46         14            mov	ax,$14[bp]
18930 5568           3D                   0001  cmp	ax,*1
18931 556B         0F85         00AB            bne 	.3F7
18932                       0000556F            .3F8:
18933                                           ! 3082                 for (off = 0; off < e820_table_size; off += 0x14) {
18934                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
18935 556F           31C0                       xor	ax,ax
18936 5571           8946         F6            mov	-$A[bp],ax
18937                                           !BCC_EOS
18938                                           !BCC_EOS
18939 5574           EB           62            jmp .3FB
18940                       00005576            .3FC:
18941                                           ! 3083                     base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
18942                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
18943                                           ! Debug: expression subtree swapping
18944 5576           8B46         F6            mov	ax,-$A[bp]
18945                                           ! Debug: list unsigned int = ax+8 (used reg = )
18946 5579           05                   0008  add	ax,*8
18947 557C           50                         push	ax
18948                                           ! Debug: list unsigned short = const $EA10 (used reg = )
18949 557D           B8                   EA10  mov	ax,#$EA10
18950 5580           50                         push	ax
18951                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
18952 5581           E8         AAFF            call	_read_dword
18953 5584           89D3                       mov	bx,dx
18954 5586           83C4                   04  add	sp,*4
18955                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
18956 5589           8946         F0            mov	-$10[bp],ax
18957 558C           895E         F2            mov	-$E[bp],bx
18958                                           !BCC_EOS
18959                                           ! 3084                     type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
18960                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
18961                                           ! Debug: expression subtree swapping
18962 558F           8B46         F6            mov	ax,-$A[bp]
18963                                           ! Debug: list unsigned int = ax+$18 (used reg = )
18964 5592           05                   0018  add	ax,*$18
18965 5595           50                         push	ax
18966                                           ! Debug: list unsigned short = const $EA10 (used reg = )
18967 5596           B8                   EA10  mov	ax,#$EA10
18968 5599           50                         push	ax
18969                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
18970 559A           E8         AAE6            call	_read_dword
18971 559D           89D3                       mov	bx,dx
18972 559F           83C4                   04  add	sp,*4
18973                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
18974 55A2           8946         EC            mov	-$14[bp],ax
18975 55A5           895E         EE            mov	-$12[bp],bx
18976                                           !BCC_EOS
18977                                           ! 3085                     if ((base >= 0x100000) && (type == 1))
18978                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
18979 55A8           31C0                       xor	ax,ax
18980 55AA           BB                   0010  mov	bx,*$10
18981 55AD           8D7E         F0            lea	di,-$10[bp]
18982 55B0           E8         AB18            call	lcmpul
18983 55B3           77           1A            ja  	.3FD
18984                       000055B5            .3FF:
18985                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
18986                                           ! Debug: expression subtree swapping
18987 55B5           B8                   0001  mov	ax,*1
18988 55B8           31DB                       xor	bx,bx
18989 55BA           53                         push	bx
18990 55BB           50                         push	ax
18991 55BC           8B46         EC            mov	ax,-$14[bp]
18992 55BF           8B5E         EE            mov	bx,-$12[bp]
18993 55C2           8D7E         E4            lea	di,-2+..FFF5[bp]
18994 55C5           E8         AB03            call	lcmpul
18995 55C8           8D66         E8            lea	sp,2+..FFF5[bp]
18996 55CB           75           02            jne 	.3FD
18997                       000055CD            .3FE:
18998                                           ! 3086                         break;
18999 55CD           EB           11            jmp .3F9
19000                                           !BCC_EOS
19001                                           ! 3087                 }
19002                       000055CF            .3FD:
19003                                           ! 3088                 if (off == e820_table_size) {
19004                       000055CF            .3FA:
19005                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19006 55CF           8B46         F6            mov	ax,-$A[bp]
19007 55D2           05                   0014  add	ax,*$14
19008 55D5           8946         F6            mov	-$A[bp],ax
19009                       000055D8            .3FB:
19010                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19011 55D8           8B46         F6            mov	ax,-$A[bp]
19012 55DB           3B46         F4            cmp	ax,-$C[bp]
19013 55DE           72           96            jb 	.3FC
19014                       000055E0            .400:
19015                       000055E0            .3F9:
19016                                           ! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19017 55E0           8B46         F6            mov	ax,-$A[bp]
19018 55E3           3B46         F4            cmp	ax,-$C[bp]
19019 55E6           75           0B            jne 	.401
19020                       000055E8            .402:
19021                                           ! 3089                     FLAGS |= 0x0001;
19022                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19023 55E8           8B46         28            mov	ax,$28[bp]
19024 55EB           0C                     01  or	al,*1
19025 55ED           8946         28            mov	$28[bp],ax
19026                                           !BCC_EOS
19027                                           ! 3090                     break;
19028 55F0           E9         0187            br 	.3EA
19029                                           !BCC_EOS
19030                                           ! 3091                 }
19031                                           ! 3092                 memcpyb(ES, regs.u.r16.di, (Bit16u)(0x000EA100 >> 4), 0x8 + off, 0x14);
19032                       000055F3            .401:
19033                                           ! Debug: list int = const $14 (used reg = )
19034 55F3           B8                   0014  mov	ax,*$14
19035 55F6           50                         push	ax
19036                                           ! Debug: add unsigned short off = [S+$1C-$C] to int = const 8 (used reg = )
19037                                           ! Debug: expression subtree swapping
19038 55F7           8B46         F6            mov	ax,-$A[bp]
19039                                           ! Debug: list unsigned int = ax+8 (used reg = )
19040 55FA           05                   0008  add	ax,*8
19041 55FD           50                         push	ax
19042                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19043 55FE           B8                   EA10  mov	ax,#$EA10
19044 5601           50                         push	ax
19045                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
19046 5602           FF76         04            push	4[bp]
19047                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
19048 5605           FF76         24            push	$24[bp]
19049                                           ! Debug: func () void = memcpyb+0 (used reg = )
19050 5608           E8         AA19            call	_memcpyb
19051 560B           83C4                   0A  add	sp,*$A
19052                                           !BCC_EOS
19053                                           ! 3093                 regs.u.r32.ebx = 0;
19054                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
19055 560E           31C0                       xor	ax,ax
19056 5610           31DB                       xor	bx,bx
19057 5612           8946         14            mov	$14[bp],ax
19058 5615           895E         16            mov	$16[bp],bx
19059                                           !BCC_EOS
19060                                           ! 3094             } else {
19061 5618           EB           06            jmp .403
19062                       0000561A            .3F7:
19063                                           ! 3095                 goto int15_unimplemented;
19064 561A           83C4                   00  add	sp,#..FFF4-..FFF5
19065 561D           E9         015C            br 	.FFF4
19066                                           !BCC_EOS
19067                                           ! 3096             }
19068                                           ! 3097             regs.u.r32.eax = 0x534D4150;
19069                       00005620            .403:
19070                       00005620            .3F6:
19071                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
19072 5620           B8                   4150  mov	ax,#$4150
19073 5623           BB                   534D  mov	bx,#$534D
19074 5626           8946         20            mov	$20[bp],ax
19075 5629           895E         22            mov	$22[bp],bx
19076                                           !BCC_EOS
19077                                           ! 3098             regs.u.r32.ecx = 0x14;
19078                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
19079 562C           B8                   0014  mov	ax,*$14
19080 562F           31DB                       xor	bx,bx
19081 5631           8946         1C            mov	$1C[bp],ax
19082 5634           895E         1E            mov	$1E[bp],bx
19083                                           !BCC_EOS
19084                                           ! 3099             FLAGS &= 0xfffe;
19085                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19086 5637           8B46         28            mov	ax,$28[bp]
19087 563A           24                     FE  and	al,#$FE
19088 563C           8946         28            mov	$28[bp],ax
19089                                           !BCC_EOS
19090                                           ! 3100             break;
19091 563F           E9         0138            br 	.3EA
19092                                           !BCC_EOS
19093                                           ! 3101         }
19094                                           ! 3102         case 0x01: {
19095                       00005642            .404:
19096                                           ! 3103             e820_table_size = rea
19097                                           ! 3103 d_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
19098                                           ! Debug: list int = const 0 (used reg = )
19099 5642           31C0                       xor	ax,ax
19100 5644           50                         push	ax
19101                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19102 5645           B8                   EA10  mov	ax,#$EA10
19103 5648           50                         push	ax
19104                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
19105 5649           E8         AFBB            call	_read_word
19106 564C           83C4                   04  add	sp,*4
19107                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
19108 564F           B9                   0014  mov	cx,*$14
19109 5652           F7E9                       imul	cx
19110                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19111 5654           8946         F4            mov	-$C[bp],ax
19112                                           !BCC_EOS
19113                                           ! 3104             FLAGS &= 0xfffe;
19114                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19115 5657           8B46         28            mov	ax,$28[bp]
19116 565A           24                     FE  and	al,#$FE
19117 565C           8946         28            mov	$28[bp],ax
19118                                           !BCC_EOS
19119                                           ! 3105             regs.u.r8.cl = inb_cmos(0x30);
19120                                           ! Debug: list int = const $30 (used reg = )
19121 565F           B8                   0030  mov	ax,*$30
19122 5662           50                         push	ax
19123                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19124 5663           E8         AF1D            call	_inb_cmos
19125 5666           44                         inc	sp
19126 5667           44                         inc	sp
19127                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
19128 5668           8846         1C            mov	$1C[bp],al
19129                                           !BCC_EOS
19130                                           ! 3106             regs.u.r8.ch = inb_cmos(0x31);
19131                                           ! Debug: list int = const $31 (used reg = )
19132 566B           B8                   0031  mov	ax,*$31
19133 566E           50                         push	ax
19134                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19135 566F           E8         AF11            call	_inb_cmos
19136 5672           44                         inc	sp
19137 5673           44                         inc	sp
19138                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
19139 5674           8846         1D            mov	$1D[bp],al
19140                                           !BCC_EOS
19141                                           ! 3107             if (regs.u.r16.cx > (15*1024))
19142                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19143 5677           8B46         1C            mov	ax,$1C[bp]
19144 567A           3D                   3C00  cmp	ax,#$3C00
19145 567D           76           06            jbe 	.405
19146                       0000567F            .406:
19147                                           ! 3108                 regs.u.r16.cx = 15*1024;
19148                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19149 567F           B8                   3C00  mov	ax,#$3C00
19150 5682           8946         1C            mov	$1C[bp],ax
19151                                           !BCC_EOS
19152                                           ! 3109             for (off = 0; off < e820_table_size; off += 0x14) {
19153                       00005685            .405:
19154                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
19155 5685           31C0                       xor	ax,ax
19156 5687           8946         F6            mov	-$A[bp],ax
19157                                           !BCC_EOS
19158                                           !BCC_EOS
19159 568A           EB           62            jmp .409
19160                       0000568C            .40A:
19161                                           ! 3110                 base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
19162                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
19163                                           ! Debug: expression subtree swapping
19164 568C           8B46         F6            mov	ax,-$A[bp]
19165                                           ! Debug: list unsigned int = ax+8 (used reg = )
19166 568F           05                   0008  add	ax,*8
19167 5692           50                         push	ax
19168                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19169 5693           B8                   EA10  mov	ax,#$EA10
19170 5696           50                         push	ax
19171                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19172 5697           E8         A9E9            call	_read_dword
19173 569A           89D3                       mov	bx,dx
19174 569C           83C4                   04  add	sp,*4
19175                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19176 569F           8946         F0            mov	-$10[bp],ax
19177 56A2           895E         F2            mov	-$E[bp],bx
19178                                           !BCC_EOS
19179                                           ! 3111                 type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
19180                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
19181                                           ! Debug: expression subtree swapping
19182 56A5           8B46         F6            mov	ax,-$A[bp]
19183                                           ! Debug: list unsigned int = ax+$18 (used reg = )
19184 56A8           05                   0018  add	ax,*$18
19185 56AB           50                         push	ax
19186                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19187 56AC           B8                   EA10  mov	ax,#$EA10
19188 56AF           50                         push	ax
19189                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19190 56B0           E8         A9D0            call	_read_dword
19191 56B3           89D3                       mov	bx,dx
19192 56B5           83C4                   04  add	sp,*4
19193                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
19194 56B8           8946         EC            mov	-$14[bp],ax
19195 56BB           895E         EE            mov	-$12[bp],bx
19196                                           !BCC_EOS
19197                                           ! 3112                 if ((base >= 0x100000) && (type == 1))
19198                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
19199 56BE           31C0                       xor	ax,ax
19200 56C0           BB                   0010  mov	bx,*$10
19201 56C3           8D7E         F0            lea	di,-$10[bp]
19202 56C6           E8         AA02            call	lcmpul
19203 56C9           77           1A            ja  	.40B
19204                       000056CB            .40D:
19205                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
19206                                           ! Debug: expression subtree swapping
19207 56CB           B8                   0001  mov	ax,*1
19208 56CE           31DB                       xor	bx,bx
19209 56D0           53                         push	bx
19210 56D1           50                         push	ax
19211 56D2           8B46         EC            mov	ax,-$14[bp]
19212 56D5           8B5E         EE            mov	bx,-$12[bp]
19213 56D8           8D7E         E4            lea	di,-2+..FFF5[bp]
19214 56DB           E8         A9ED            call	lcmpul
19215 56DE           8D66         E8            lea	sp,2+..FFF5[bp]
19216 56E1           75           02            jne 	.40B
19217                       000056E3            .40C:
19218                                           ! 3113                     break;
19219 56E3           EB           11            jmp .407
19220                                           !BCC_EOS
19221                                           ! 3114             }
19222                       000056E5            .40B:
19223                                           ! 3115             regs.u.r16.dx = 0;
19224                       000056E5            .408:
19225                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19226 56E5           8B46         F6            mov	ax,-$A[bp]
19227 56E8           05                   0014  add	ax,*$14
19228 56EB           8946         F6            mov	-$A[bp],ax
19229                       000056EE            .409:
19230                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19231 56EE           8B46         F6            mov	ax,-$A[bp]
19232 56F1           3B46         F4            cmp	ax,-$C[bp]
19233 56F4           72           96            jb 	.40A
19234                       000056F6            .40E:
19235                       000056F6            .407:
19236                                           ! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
19237 56F6           31C0                       xor	ax,ax
19238 56F8           8946         18            mov	$18[bp],ax
19239                                           !BCC_EOS
19240                                           ! 3116             if (off != e820_table_size) {
19241                                           ! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19242 56FB           8B46         F6            mov	ax,-$A[bp]
19243 56FE           3B46         F4            cmp	ax,-$C[bp]
19244 5701           74           54            je  	.40F
19245                       00005703            .410:
19246                                           ! 3117                 size = base + read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x8 + off);
19247                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
19248                                           ! Debug: expression subtree swapping
19249 5703           8B46         F6            mov	ax,-$A[bp]
19250                                           ! Debug: list unsigned int = ax+$10 (used reg = )
19251 5706           05                   0010  add	ax,*$10
19252 5709           50                         push	ax
19253                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19254 570A           B8                   EA10  mov	ax,#$EA10
19255 570D           50                         push	ax
19256                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19257 570E           E8         A972            call	_read_dword
19258 5711           89D3                       mov	bx,dx
19259 5713           83C4                   04  add	sp,*4
19260                                           ! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19261                                           ! Debug: expression subtree swapping
19262 5716           8D7E         F0            lea	di,-$10[bp]
19263 5719           E8         A9A7            call	laddul
19264                                           ! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
19265 571C           8946         E8            mov	-$18[bp],ax
19266 571F           895E         EA            mov	-$16[bp],bx
19267                                           !BCC_EOS
19268                                           ! 3118                 if (size > 0x1000000) {
19269                                           ! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19270 5722           31C0                       xor	ax,ax
19271 5724           BB                   0100  mov	bx,#$100
19272 5727           8D7E         E8            lea	di,-$18[bp]
19273 572A           E8         A99E            call	lcmpul
19274 572D           73           28            jae 	.411
19275                       0000572F            .412:
19276                                           ! 3119                     size -= 0x1000000;
19277                                           ! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19278 572F           31C0                       xor	ax,ax
19279 5731           BB                   0100  mov	bx,#$100
19280 5734           53                         push	bx
19281 5735           50                         push	ax
19282 5736           8B46         E8            mov	ax,-$18[bp]
19283 5739           8B5E         EA            mov	bx,-$16[bp]
19284 573C           8D7E         E4            lea	di,-2+..FFF5[bp]
19285 573F           E8         A99F            call	lsubul
19286 5742           8946         E8            mov	-$18[bp],ax
19287 5745           895E         EA            mov	-$16[bp],bx
19288 5748           83C4                   04  add	sp,*4
19289                                           !BCC_EOS
19290                                           ! 3120                     regs.u.r16.dx = (Bit16u)(size >> 16);
19291                                           ! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
19292 574B           8B46         E8            mov	ax,-$18[bp]
19293 574E           8B5E         EA            mov	bx,-$16[bp]
19294 5751           93                         xchg	bx,ax
19295 5752           31DB                       xor	bx,bx
19296                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
19297                                           ! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
19298 5754           8946         18            mov	$18[bp],ax
19299                                           !BCC_EOS
19300                                           ! 3121                 }
19301                                           ! 3122             }
19302                       00005757            .411:
19303                                           ! 3123             regs.u.r16.ax = regs.u.r16.cx;
19304                       00005757            .40F:
19305                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
19306 5757           8B46         1C            mov	ax,$1C[bp]
19307 575A           8946         20            mov	$20[bp],ax
19308                                           !BCC_EOS
19309                                           ! 3124             regs.u.r16.bx = regs.u.r16.dx;
19310                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
19311 575D           8B46         18            mov	ax,$18[bp]
19312 5760           8946         14            mov	$14[bp],ax
19313                                           !BCC_EOS
19314                                           ! 3125             break;
19315 5763           EB           15            jmp .3EA
19316                                           !BCC_EOS
19317                                           ! 3126         }
19318                                           ! 3127         default:
19319                                           ! 3128             goto int15_unimplemented;
19320                       00005765            .413:
19321 5765           83C4                   00  add	sp,#..FFF4-..FFF5
19322 5768           EB           12            jmp .FFF4
19323                                           !BCC_EOS
19324                                           ! 3129         }
19325                                           ! 3130         break;
19326 576A           EB           0E            jmp .3EA
19327                       0000576C            .3EC:
19328 576C           2C                     01  sub	al,*1
19329 576E         0F84         FED0            beq 	.404
19330 5772           2C                     1F  sub	al,*$1F
19331 5774         0F84         FD20            beq 	.3ED
19332 5778           EB           EB            jmp	.413
19333                       0000577A            .3EA:
19334 577A           EB           1F            jmp .3E5
19335                                           !BCC_EOS
19336                                           ! 3131     int15_unimplemented:
19337                       0000577C            .FFF4:
19338                                           ! 3132     default:
19339                                           ! 3133       ;
19340                       0000577C            .414:
19341                                           !BCC_EOS
19342                                           ! 3134       FLAGS |= 0x0001;
19343                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19344 577C           8B46         28            mov	ax,$28[bp]
19345 577F           0C                     01  or	al,*1
19346 5781           8946         28            mov	$28[bp],ax
19347                                           !BCC_EOS
19348                                           ! 3135       regs.u.r8.ah = 0x86;
19349                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
19350 5784           B0                     86  mov	al,#$86
19351 5786           8846         21            mov	$21[bp],al
19352                                           !BCC_EOS
19353                                           ! 3136       break;
19354 5789           EB           10            jmp .3E5
19355                                           !BCC_EOS
19356                                           ! 3137     }
19357                                           ! 3138 }
19358 578B           EB           0E            jmp .3E5
19359                       0000578D            .3E7:
19360 578D           2C                     86  sub	al,#$86
19361 578F         0F84         FCB9            beq 	.3E8
19362 5793           2C                     62  sub	al,*$62
19363 5795         0F84         FCF9            beq 	.3E9
19364 5799           EB           E1            jmp	.414
19365                       0000579B            .3E5:
19366                       FFFFFFE6            ..FFF5	=	-$1A
19367                       FFFFFFE6            ..FFF4	=	-$1A
19368 579B           89EC                       mov	sp,bp
19369 579D           5D                         pop	bp
19370 579E           C3                         ret
19371                                           ! 3139   void
19372                                           ! Register BX used in function int15_function32
19373                                           ! 3140 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
19374                                           ! 3141   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
19375                                           export	_int16_function
19376                       0000579F            _int16_function:
19377                                           !BCC_EOS
19378                                           ! 3142 {
19379                                           ! 3143   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
19380                                           !BCC_EOS
19381                                           ! 3144   Bit16u kbd_code, max;
19382                                           !BCC_EOS
19383                                           ! 3145   ;
19384 579F           55                         push	bp
19385 57A0           89E5                       mov	bp,sp
19386 57A2           83C4                   F6  add	sp,*-$A
19387                                           !BCC_EOS
19388                                           ! 3146   shift_flags = read_byte(0x0040, 0x17);
19389                                           ! Debug: list int = const $17 (used reg = )
19390 57A5           B8                   0017  mov	ax,*$17
19391 57A8           50                         push	ax
19392                                           ! Debug: list int = const $40 (used reg = )
19393 57A9           B8                   0040  mov	ax,*$40
19394 57AC           50                         push	ax
19395                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19396 57AD           E8         AE44            call	_read_byte
19397 57B0           83C4                   04  add	sp,*4
19398                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
19399 57B3           8846         FD            mov	-3[bp],al
19400                                           !BCC_EOS
19401                                           ! 3147   led_flags = read_byte(0x0040, 0x97);
19402                                           ! Debug: list int = const $97 (used reg = )
19403 57B6           B8                   0097  mov	ax,#$97
19404 57B9           50                         push	ax
19405                                           ! Debug: list int = const $40 (used reg = )
19406 57BA           B8                   0040  mov	ax,*$40
19407 57BD           50                         push	ax
19408                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19409 57BE           E8         AE33            call	_read_byte
19410 57C1           83C4                   04  add	sp,*4
19411                                           ! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
19412 57C4           8846         FC            mov	-4[bp],al
19413                                           !BCC_EOS
19414                                           ! 3148   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
19415                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
19416 57C7           8A46         FC            mov	al,-4[bp]
19417 57CA           24                     07  and	al,*7
19418 57CC           50                         push	ax
19419                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
19420 57CD           8A46         FD            mov	al,-3[bp]
19421 57D0           30E4                       xor	ah,ah
19422 57D2           B1                     04  mov	cl,*4
19423 57D4           D3E8                       shr	ax,cl
19424                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
19425 57D6           24                     07  and	al,*7
19426                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
19427 57D8           3246         F4            xor	al,-$C[bp]
19428 57DB           44                         inc	sp
19429 57DC           44                         inc	sp
19430                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
19431 57DD           84C0                       test	al,al
19432 57DF         0F84         00A3            beq 	.415
19433                       000057E3            .416:
19434                                           ! 3149 #asm
19435                                           !BCC_EOS
19436                                           !BCC_ASM
19437                       00000012            _int16_function.BP	set	$12
19438                       00000008            .int16_function.BP	set	8
19439                       00000005            _int16_function.count	set	5
19440                       FFFFFFFB            .int16_function.count	set	-5
19441                       0000001A            _int16_function.CX	set	$1A
19442                       00000010            .int16_function.CX	set	$10
19443                       00000008            _int16_function.ascii_code	set	8
19444                       FFFFFFFE            .int16_function.ascii_code	set	-2
19445                       0000000E            _int16_function.DI	set	$E
19446                       00000004            .int16_function.DI	set	4
19447                       0000001E            _int16_function.FLAGS	set	$1E
19448                       00000014            .int16_function.FLAGS	set	$14
19449                       00000002            _int16_function.kbd_code	set	2
19450                       FFFFFFF8            .int16_function.kbd_code	set	-8
19451                       00000009            _int16_function.scan_code	set	9
19452                       FFFFFFFF            .int16_function.scan_code	set	-1
19453                       00000018            _int16_function.DX	set	$18
19454                       0000000E            .int16_function.DX	set	$E
19455                       00000006            _int16_function.led_flags	set	6
19456                       FFFFFFFC            .int16_function.led_flags	set	-4
19457                       00000010            _int16_function.SI	set	$10
19458                       00000006            .int16_function.SI	set	6
19459                       0000001C            _int16_function.AX	set	$1C
19460                       00000012            .int16_function.AX	set	$12
19461                       00000014            _int16_function.SP	set	$14
19462                       0000000A            .int16_function.SP	set	$A
19463                       00000016            _int16_function.BX	set	$16
19464                       0000000C            .int16_function.BX	set	$C
19465                       00000007            _int16_function.shift_flags	set	7
19466                       FFFFFFFD            .int16_function.shift_flags	set	-3
19467                       00000000            _int16_function.max	set	0
19468                       FFFFFFF6            .int16_function.max	set	-$A
19469 57E3           FA                             cli
19470                                           ! 3151 endasm
19471                                           !BCC_ENDASM
19472                                           !BCC_EOS
19473                                           ! 3152     outb(0x60, 0xed);
19474                                           ! Debug: list int = const $ED (used reg = )
19475 57E4           B8                   00ED  mov	ax,#$ED
19476 57E7           50                         push	ax
19477                                           ! Debug: list int = const $60 (used reg = )
19478 57E8           B8                   0060  mov	ax,*$60
19479 57EB           50                         push	ax
19480                                           ! Debug: func () void = outb+0 (used reg = )
19481 57EC           E8         AD65            call	_outb
19482 57EF           83C4                   04  add	sp,*4
19483                                           !BCC_EOS
19484                                           ! 3153     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
19485 57F2           EB           0E            jmp .418
19486                       000057F4            .419:
19487                                           ! Debug: list int = const $21 (used reg = )
19488 57F4           B8                   0021  mov	ax,*$21
19489 57F7           50                         push	ax
19490                                           ! Debug: list int = const $80 (used reg = )
19491 57F8           B8                   0080  mov	ax,#$80
19492 57FB           50                         push	ax
19493                                           ! Debug: func () void = outb+0 (used reg = )
19494 57FC           E8         AD55            call	_outb
19495 57FF           83C4                   04  add	sp,*4
19496                                           !BCC_EOS
19497                                           ! 3154     if ((inb(0x60) == 0xfa)) {
19498                       00005802            .418:
19499                                           ! Debug: list int = const $64 (used reg = )
19500 5802           B8                   0064  mov	ax,*$64
19501 5805           50                         push	ax
19502                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19503 5806           E8         AD35            call	_inb
19504 5809           44                         inc	sp
19505 580A           44                         inc	sp
19506                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19507 580B           24                     01  and	al,*1
19508                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19509 580D           84C0                       test	al,al
19510 580F           74           E3            je 	.419
19511                       00005811            .41A:
19512                       00005811            .417:
19513                                           ! Debug: list int = const $60 (used reg = )
19514 5811           B8                   0060  mov	ax,*$60
19515 5814           50                         push	ax
19516                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19517 5815           E8         AD26            call	_inb
19518 5818           44                         inc	sp
19519 5819           44                         inc	sp
19520                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
19521 581A           3C                     FA  cmp	al,#$FA
19522 581C           75           67            jne 	.41B
19523                       0000581E            .41C:
19524                                           ! 3155       led_flags &= 0xf8;
19525                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
19526 581E           8A46         FC            mov	al,-4[bp]
19527 5821           24                     F8  and	al,#$F8
19528 5823           8846         FC            mov	-4[bp],al
19529                                           !BCC_EOS
19530                                           ! 3156       led_flags |= ((shift_flags >> 4) & 0x07);
19531                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
19532 5826           8A46         FD            mov	al,-3[bp]
19533 5829           30E4                       xor	ah,ah
19534 582B           B1                     04  mov	cl,*4
19535 582D           D3E8                       shr	ax,cl
19536                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
19537 582F           24                     07  and	al,*7
19538                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
19539 5831           0A46         FC            or	al,-4[bp]
19540 5834           8846         FC            mov	-4[bp],al
19541                                           !BCC_EOS
19542                                           ! 3157       outb(0x60, led_flags & 0x07);
19543                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
19544 5837           8A46         FC            mov	al,-4[bp]
19545 583A           24                     07  and	al,*7
19546                                           ! Debug: list unsigned char = al+0 (used reg = )
19547 583C           30E4                       xor	ah,ah
19548 583E           50                         push	ax
19549                                           ! Debug: list int = const $60 (used reg = )
19550 583F           B8                   0060  mov	ax,*$60
19551 5842           50                         push	ax
19552                                           ! Debug: func () void = outb+0 (used reg = )
19553 5843           E8         AD0E            call	_outb
19554 5846           83C4                   04  add	sp,*4
19555                                           !BCC_EOS
19556                                           ! 3158       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
19557 5849           EB           0E            jmp .41E
19558                       0000584B            .41F:
19559                                           ! Debug: list int = const $21 (used reg = )
19560 584B           B8                   0021  mov	ax,*$21
19561 584E           50                         push	ax
19562                                           ! Debug: list int = const $80 (used reg = )
19563 584F           B8                   0080  mov	ax,#$80
19564 5852           50                         push	ax
19565                                           ! Debug: func () void = outb+0 (used reg = )
19566 5853           E8         ACFE            call	_outb
19567 5856           83C4                   04  add	sp,*4
19568                                           !BCC_EOS
19569                                           ! 3159       inb(0x60);
19570                       00005859            .41E:
19571                                           ! Debug: list int = const $64 (used reg = )
19572 5859           B8                   0064  mov	ax,*$64
19573 585C           50                         push	ax
19574                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19575 585D           E8         ACDE            call	_inb
19576 5860           44                         inc	sp
19577 5861           44                         inc	sp
19578                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19579 5862           24                     01  and	al,*1
19580                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19581 5864           84C0                       test	al,al
19582 5866           74           E3            je 	.41F
19583                       00005868            .420:
19584                       00005868            .41D:
19585                                           ! Debug: list int = const $60 (used reg = )
19586 5868           B8                   0060  mov	ax,*$60
19587 586B           50                         push	ax
19588                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19589 586C           E8         ACCF            call	_inb
19590 586F           44                         inc	sp
19591 5870           44                         inc	sp
19592                                           !BCC_EOS
19593                                           ! 3160       write_byte(0x0040, 0x97, led_flags);
19594                                           ! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
19595 5871           8A46         FC            mov	al,-4[bp]
19596 5874           30E4                       xor	ah,ah
19597 5876           50                         push	ax
19598                                           ! Debug: list int = const $97 (used reg = )
19599 5877           B8                   0097  mov	ax,#$97
19600 587A           50                         push	ax
19601                                           ! Debug: list int = const $40 (used reg = )
19602 587B           B8                   0040  mov	ax,*$40
19603 587E           50                         push	ax
19604                                           ! Debug: func () void = write_byte+0 (used reg = )
19605 587F           E8         AD98            call	_write_byte
19606 5882           83C4                   06  add	sp,*6
19607                                           !BCC_EOS
19608                                           ! 3161     }
19609                                           ! 3162 #asm
19610                       00005885            .41B:
19611                                           !BCC_EOS
19612                                           !BCC_ASM
19613                       00000012            _int16_function.BP	set	$12
19614                       00000008            .int16_function.BP	set	8
19615                       00000005            _int16_function.count	set	5
19616                       FFFFFFFB            .int16_function.count	set	-5
19617                       0000001A            _int16_function.CX	set	$1A
19618                       00000010            .int16_function.CX	set	$10
19619                       00000008            _int16_function.ascii_code	set	8
19620                       FFFFFFFE            .int16_function.ascii_code	set	-2
19621                       0000000E            _int16_function.DI	set	$E
19622                       00000004            .int16_function.DI	set	4
19623                       0000001E            _int16_function.FLAGS	set	$1E
19624                       00000014            .int16_function.FLAGS	set	$14
19625                       00000002            _int16_function.kbd_code	set	2
19626                       FFFFFFF8            .int16_function.kbd_code	set	-8
19627                       00000009            _int16_function.scan_code	set	9
19628                       FFFFFFFF            .int16_function.scan_code	set	-1
19629                       00000018            _int16_function.DX	set	$18
19630                       0000000E            .int16_function.DX	set	$E
19631                       00000006            _int16_function.led_flags	set	6
19632                       FFFFFFFC            .int16_function.led_flags	set	-4
19633                       00000010            _int16_function.SI	set	$10
19634                       00000006            .int16_function.SI	set	6
19635                       0000001C            _int16_function.AX	set	$1C
19636                       00000012            .int16_function.AX	set	$12
19637                       00000014            _int16_function.SP	set	$14
19638                       0000000A            .int16_function.SP	set	$A
19639                       00000016            _int16_function.BX	set	$16
19640                       0000000C            .int16_function.BX	set	$C
19641                       00000007            _int16_function.shift_flags	set	7
19642                       FFFFFFFD            .int16_function.shift_flags	set	-3
19643                       00000000            _int16_function.max	set	0
19644                       FFFFFFF6            .int16_function.max	set	-$A
19645 5885           FB                             sti
19646                                           ! 3164 endasm
19647                                           !BCC_ENDASM
19648                                           !BCC_EOS
19649                                           ! 3165   }
19650                                           ! 3166   switch (( AX >> 8 )) {
19651                       00005886            .415:
19652                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
19653 5886           8B46         12            mov	ax,$12[bp]
19654 5889           88E0                       mov	al,ah
19655 588B           30E4                       xor	ah,ah
19656 588D           E9         02EE            br 	.423
19657                                           ! 3167     case 0x00:
19658                                           ! 3168       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
19659                       00005890            .424:
19660                                           ! Debug: list int = const 1 (used reg = )
19661 5890           B8                   0001  mov	ax,*1
19662 5893           50                         push	ax
19663                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
19664 5894           8D5E         FE            lea	bx,-2[bp]
19665 5897           53                         push	bx
19666                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
19667 5898           8D5E         FF            lea	bx,-1[bp]
19668 589B           53                         push	bx
19669                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
19670 589C           E8         032D            call	_dequeue_key
19671 589F           83C4                   06  add	sp,*6
19672 58A2           85C0                       test	ax,ax
19673 58A4           75           0E            jne 	.425
19674                       000058A6            .426:
19675                                           ! 3169         bios_printf((2 
19676                                           ! 3169 | 4 | 1), "KBD: int16h: out of keyboard input\n");
19677                                           ! Debug: list * char = .427+0 (used reg = )
19678 58A6           BB                   D1E9  mov	bx,#.427
19679 58A9           53                         push	bx
19680                                           ! Debug: list int = const 7 (used reg = )
19681 58AA           B8                   0007  mov	ax,*7
19682 58AD           50                         push	ax
19683                                           ! Debug: func () void = bios_printf+0 (used reg = )
19684 58AE           E8         B16A            call	_bios_printf
19685 58B1           83C4                   04  add	sp,*4
19686                                           !BCC_EOS
19687                                           ! 3170         }
19688                                           ! 3171       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
19689                       000058B4            .425:
19690                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
19691 58B4           8A46         FF            mov	al,-1[bp]
19692 58B7           84C0                       test	al,al
19693 58B9           74           0E            je  	.428
19694                       000058BB            .42A:
19695                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19696 58BB           8A46         FE            mov	al,-2[bp]
19697 58BE           3C                     F0  cmp	al,#$F0
19698 58C0           75           07            jne 	.428
19699                       000058C2            .429:
19700                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19701 58C2           30C0                       xor	al,al
19702 58C4           8846         FE            mov	-2[bp],al
19703                                           !BCC_EOS
19704                                           ! 3172       else if (ascii_code == 0xE0) ascii_code = 0;
19705 58C7           EB           0C            jmp .42B
19706                       000058C9            .428:
19707                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19708 58C9           8A46         FE            mov	al,-2[bp]
19709 58CC           3C                     E0  cmp	al,#$E0
19710 58CE           75           05            jne 	.42C
19711                       000058D0            .42D:
19712                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19713 58D0           30C0                       xor	al,al
19714 58D2           8846         FE            mov	-2[bp],al
19715                                           !BCC_EOS
19716                                           ! 3173       AX = (scan_code << 8) | ascii_code;
19717                       000058D5            .42C:
19718                       000058D5            .42B:
19719                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
19720 58D5           8A46         FF            mov	al,-1[bp]
19721 58D8           30E4                       xor	ah,ah
19722 58DA           88C4                       mov	ah,al
19723 58DC           30C0                       xor	al,al
19724                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
19725 58DE           0A46         FE            or	al,-2[bp]
19726                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19727 58E1           8946         12            mov	$12[bp],ax
19728                                           !BCC_EOS
19729                                           ! 3174       break;
19730 58E4           E9         02E1            br 	.421
19731                                           !BCC_EOS
19732                                           ! 3175     case 0x01:
19733                                           ! 3176       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
19734                       000058E7            .42E:
19735                                           ! Debug: list int = const 0 (used reg = )
19736 58E7           31C0                       xor	ax,ax
19737 58E9           50                         push	ax
19738                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
19739 58EA           8D5E         FE            lea	bx,-2[bp]
19740 58ED           53                         push	bx
19741                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
19742 58EE           8D5E         FF            lea	bx,-1[bp]
19743 58F1           53                         push	bx
19744                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
19745 58F2           E8         02D7            call	_dequeue_key
19746 58F5           83C4                   06  add	sp,*6
19747 58F8           85C0                       test	ax,ax
19748 58FA           75           0C            jne 	.42F
19749                       000058FC            .430:
19750                                           ! 3177         FLAGS |= 0x0040;
19751                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
19752 58FC           8B46         14            mov	ax,$14[bp]
19753 58FF           0C                     40  or	al,*$40
19754 5901           8946         14            mov	$14[bp],ax
19755                                           !BCC_EOS
19756                                           ! 3178         return;
19757 5904           89EC                       mov	sp,bp
19758 5906           5D                         pop	bp
19759 5907           C3                         ret
19760                                           !BCC_EOS
19761                                           ! 3179         }
19762                                           ! 3180       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
19763                       00005908            .42F:
19764                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
19765 5908           8A46         FF            mov	al,-1[bp]
19766 590B           84C0                       test	al,al
19767 590D           74           0E            je  	.431
19768                       0000590F            .433:
19769                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19770 590F           8A46         FE            mov	al,-2[bp]
19771 5912           3C                     F0  cmp	al,#$F0
19772 5914           75           07            jne 	.431
19773                       00005916            .432:
19774                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19775 5916           30C0                       xor	al,al
19776 5918           8846         FE            mov	-2[bp],al
19777                                           !BCC_EOS
19778                                           ! 3181       else if (ascii_code == 0xE0) ascii_code = 0;
19779 591B           EB           0C            jmp .434
19780                       0000591D            .431:
19781                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19782 591D           8A46         FE            mov	al,-2[bp]
19783 5920           3C                     E0  cmp	al,#$E0
19784 5922           75           05            jne 	.435
19785                       00005924            .436:
19786                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19787 5924           30C0                       xor	al,al
19788 5926           8846         FE            mov	-2[bp],al
19789                                           !BCC_EOS
19790                                           ! 3182       AX = (scan_code << 8) | ascii_code;
19791                       00005929            .435:
19792                       00005929            .434:
19793                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
19794 5929           8A46         FF            mov	al,-1[bp]
19795 592C           30E4                       xor	ah,ah
19796 592E           88C4                       mov	ah,al
19797 5930           30C0                       xor	al,al
19798                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
19799 5932           0A46         FE            or	al,-2[bp]
19800                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19801 5935           8946         12            mov	$12[bp],ax
19802                                           !BCC_EOS
19803                                           ! 3183       FLAGS &= 0xffbf;
19804                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
19805 5938           8B46         14            mov	ax,$14[bp]
19806 593B           24                     BF  and	al,#$BF
19807 593D           8946         14            mov	$14[bp],ax
19808                                           !BCC_EOS
19809                                           ! 3184       break;
19810 5940           E9         0285            br 	.421
19811                                           !BCC_EOS
19812                                           ! 3185     case 0x02:
19813                                           ! 3186       shift_flags = read_byte(0x0040, 0x17);
19814                       00005943            .437:
19815                                           ! Debug: list int = const $17 (used reg = )
19816 5943           B8                   0017  mov	ax,*$17
19817 5946           50                         push	ax
19818                                           ! Debug: list int = const $40 (used reg = )
19819 5947           B8                   0040  mov	ax,*$40
19820 594A           50                         push	ax
19821                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19822 594B           E8         ACA6            call	_read_byte
19823 594E           83C4                   04  add	sp,*4
19824                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
19825 5951           8846         FD            mov	-3[bp],al
19826                                           !BCC_EOS
19827                                           ! 3187       AX = ((AX & 0xff00) | (shift_flags));
19828                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
19829 5954           8B46         12            mov	ax,$12[bp]
19830 5957           30C0                       xor	al,al
19831                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
19832 5959           0A46         FD            or	al,-3[bp]
19833                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19834 595C           8946         12            mov	$12[bp],ax
19835                                           !BCC_EOS
19836                                           ! 3188       break;
19837 595F           E9         0266            br 	.421
19838                                           !BCC_EOS
19839                                           ! 3189     case 0x05:
19840                                           ! 3190       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
19841                       00005962            .438:
19842                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
19843 5962           8A46         10            mov	al,$10[bp]
19844                                           ! Debug: list unsigned char = al+0 (used reg = )
19845 5965           30E4                       xor	ah,ah
19846 5967           50                         push	ax
19847                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
19848 5968           8B46         10            mov	ax,$10[bp]
19849 596B           88E0                       mov	al,ah
19850 596D           30E4                       xor	ah,ah
19851                                           ! Debug: list unsigned int = ax+0 (used reg = )
19852 596F           50                         push	ax
19853                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
19854 5970           E8         0BD7            call	_enqueue_key
19855 5973           83C4                   04  add	sp,*4
19856 5976           85C0                       test	ax,ax
19857 5978           75           0C            jne 	.439
19858                       0000597A            .43A:
19859                                           ! 3191         AX = ((AX & 0xff00) | (1));
19860                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
19861 597A           8B46         12            mov	ax,$12[bp]
19862 597D           30C0                       xor	al,al
19863                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
19864 597F           0C                     01  or	al,*1
19865                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19866 5981           8946         12            mov	$12[bp],ax
19867                                           !BCC_EOS
19868                                           ! 3192         }
19869                                           ! 3193       else {
19870 5984           EB           0A            jmp .43B
19871                       00005986            .439:
19872                                           ! 3194         AX = ((AX & 0xff00) | (0));
19873                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
19874 5986           8B46         12            mov	ax,$12[bp]
19875 5989           30C0                       xor	al,al
19876                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
19877 598B           0C                     00  or	al,*0
19878                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19879 598D           8946         12            mov	$12[bp],ax
19880                                           !BCC_EOS
19881                                           ! 3195         }
19882                                           ! 3196       break;
19883                       00005990            .43B:
19884 5990           E9         0235            br 	.421
19885                                           !BCC_EOS
19886                                           ! 3197     case 0x09:
19887                                           ! 3198       AX = ((AX & 0xff00) | (0x30));
19888                       00005993            .43C:
19889                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
19890 5993           8B46         12            mov	ax,$12[bp]
19891 5996           30C0                       xor	al,al
19892                                           ! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
19893 5998           0C                     30  or	al,*$30
19894                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19895 599A           8946         12            mov	$12[bp],ax
19896                                           !BCC_EOS
19897                                           ! 3199       break;
19898 599D           E9         0228            br 	.421
19899                                           !BCC_EOS
19900                                           ! 3200     case 0x0A:
19901                                           ! 3201       count = 2;
19902                       000059A0            .43D:
19903                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
19904 59A0           B0                     02  mov	al,*2
19905 59A2           8846         FB            mov	-5[bp],al
19906                                           !BCC_EOS
19907                                           ! 3202       kbd_code = 0x0;
19908                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
19909 59A5           31C0                       xor	ax,ax
19910 59A7           8946         F8            mov	-8[bp],ax
19911                                           !BCC_EOS
19912                                           ! 3203       outb(0x60, 0xf2);
19913                                           ! Debug: list int = const $F2 (used reg = )
19914 59AA           B8                   00F2  mov	ax,#$F2
19915 59AD           50                         push	ax
19916                                           ! Debug: list int = const $60 (used reg = )
19917 59AE           B8                   0060  mov	ax,*$60
19918 59B1           50                         push	ax
19919                                           ! Debug: func () void = outb+0 (used reg = )
19920 59B2           E8         AB9F            call	_outb
19921 59B5           83C4                   04  add	sp,*4
19922                                           !BCC_EOS
19923                                           ! 3204       max=0xffff;
19924                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
19925 59B8           B8                   FFFF  mov	ax,#$FFFF
19926 59BB           8946         F6            mov	-$A[bp],ax
19927                                           !BCC_EOS
19928                                           ! 3205       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
19929 59BE           EB           0D            jmp .43F
19930                       000059C0            .440:
19931                                           ! Debug: list int = const 0 (used reg = )
19932 59C0           31C0                       xor	ax,ax
19933 59C2           50                         push	ax
19934                                           ! Debug: list int = const $80 (used reg = )
19935 59C3           B8                   0080  mov	ax,#$80
19936 59C6           50                         push	ax
19937                                           ! Debug: func () void = outb+0 (used reg = )
19938 59C7           E8         AB8A            call	_outb
19939 59CA           83C4                   04  add	sp,*4
19940                                           !BCC_EOS
19941                                           ! 3206       if (max>0x0) {
19942                       000059CD            .43F:
19943                                           ! Debug: list int = const $64 (used reg = )
19944 59CD           B8                   0064  mov	ax,*$64
19945 59D0           50                         push	ax
19946                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19947 59D1           E8         AB6A            call	_inb
19948 59D4           44                         inc	sp
19949 59D5           44                         inc	sp
19950                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19951 59D6           24                     01  and	al,*1
19952                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19953 59D8           84C0                       test	al,al
19954 59DA           75           0B            jne 	.441
19955                       000059DC            .442:
19956                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
19957 59DC           8B46         F6            mov	ax,-$A[bp]
19958 59DF           48                         dec	ax
19959 59E0           8946         F6            mov	-$A[bp],ax
19960                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
19961 59E3           85C0                       test	ax,ax
19962 59E5           75           D9            jne	.440
19963                       000059E7            .441:
19964                       000059E7            .43E:
19965                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
19966 59E7           8B46         F6            mov	ax,-$A[bp]
19967 59EA           85C0                       test	ax,ax
19968 59EC         0F84         006D            beq 	.443
19969                       000059F0            .444:
19970                                           ! 3207         if ((inb(0x60) == 0xfa)) {
19971                                           ! Debug: list int = const $60 (used reg = )
19972 59F0           B8                   0060  mov	ax,*$60
19973 59F3           50                         push	ax
19974                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19975 59F4           E8         AB47            call	_inb
19976 59F7           44                         inc	sp
19977 59F8           44                         inc	sp
19978                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
19979 59F9           3C                     FA  cmp	al,#$FA
19980 59FB           75           60            jne 	.445
19981                       000059FD            .446:
19982                                           ! 3208           do {
19983                       000059FD            .449:
19984                                           ! 3209             max=0xffff;
19985                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
19986 59FD           B8                   FFFF  mov	ax,#$FFFF
19987 5A00           8946         F6            mov	-$A[bp],ax
19988                                           !BCC_EOS
19989                                           ! 3210             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
19990 5A03           EB           0D            jmp .44B
19991                       00005A05            .44C:
19992                                           ! Debug: list int = const 0 (used reg = )
19993 5A05           31C0                       xor	ax,ax
19994 5A07           50                         push	ax
19995                                           ! Debug: list int = const $80 (used reg = )
19996 5A08           B8                   0080  mov	ax,#$80
19997 5A0B           50                         push	ax
19998                                           ! Debug: func () void = outb+0 (used reg = )
19999 5A0C           E8         AB45            call	_outb
20000 5A0F           83C4                   04  add	sp,*4
20001                                           !BCC_EOS
20002                                           ! 3211             if (max>0x0) {
20003                       00005A12            .44B:
20004                                           ! Debug: list int = const $64 (used reg = )
20005 5A12           B8                   0064  mov	ax,*$64
20006 5A15           50                         push	ax
20007                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20008 5A16           E8         AB25            call	_inb
20009 5A19           44                         inc	sp
20010 5A1A           44                         inc	sp
20011                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20012 5A1B           24                     01  and	al,*1
20013                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20014 5A1D           84C0                       test	al,al
20015 5A1F           75           0B            jne 	.44D
20016                       00005A21            .44E:
20017                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20018 5A21           8B46         F6            mov	ax,-$A[bp]
20019 5A24           48                         dec	ax
20020 5A25           8946         F6            mov	-$A[bp],ax
20021                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20022 5A28           85C0                       test	ax,ax
20023 5A2A           75           D9            jne	.44C
20024                       00005A2C            .44D:
20025                       00005A2C            .44A:
20026                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20027 5A2C           8B46         F6            mov	ax,-$A[bp]
20028 5A2F           85C0                       test	ax,ax
20029 5A31           74           1F            je  	.44F
20030                       00005A33            .450:
20031                                           ! 3212               kbd_code >>= 8;
20032                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20033 5A33           8B46         F8            mov	ax,-8[bp]
20034 5A36           88E0                       mov	al,ah
20035 5A38           30E4                       xor	ah,ah
20036 5A3A           8946         F8            mov	-8[bp],ax
20037                                           !BCC_EOS
20038                                           ! 3213               kbd_code |= (inb(0x60) << 8);
20039                                           ! Debug: list int = const $60 (used reg = )
20040 5A3D           B8                   0060  mov	ax,*$60
20041 5A40           50                         push	ax
20042                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20043 5A41           E8         AAFA            call	_inb
20044 5A44           44                         inc	sp
20045 5A45           44                         inc	sp
20046                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
20047 5A46           30E4                       xor	ah,ah
20048 5A48           88C4                       mov	ah,al
20049 5A4A           30C0                       xor	al,al
20050                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20051 5A4C           0B46         F8            or	ax,-8[bp]
20052 5A4F           8946         F8            mov	-8[bp],ax
20053                                           !BCC_EOS
20054                                           ! 3214             }
20055                                           ! 3215           } while (--count>0);
20056                       00005A52            .44F:
20057                       00005A52            .448:
20058                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
20059 5A52           8A46         FB            mov	al,-5[bp]
20060 5A55           48                         dec	ax
20061 5A56           8846         FB            mov	-5[bp],al
20062                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20063 5A59           84C0                       test	al,al
20064 5A5B           75           A0            jne	.449
20065                       00005A5D            .451:
20066                                           !BCC_EOS
20067                                           ! 3216         }
20068                       00005A5D            .447:
20069                                           ! 3217       }
20070                       00005A5D            .445:
20071                                           ! 3218       BX=kbd_code;
20072                       00005A5D            .443:
20073                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
20074 5A5D           8B46         F8            mov	ax,-8[bp]
20075 5A60           8946         0C            mov	$C[bp],ax
20076                                           !BCC_EOS
20077                                           ! 3219       break;
20078 5A63           E9         0162            br 	.421
20079                                           !BCC_EOS
20080                                           ! 3220     case 0x10:
20081                                           ! 3221       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20082                       00005A66            .452:
20083                                           ! Debug: list int = const 1 (used reg = )
20084 5A66           B8                   0001  mov	ax,*1
20085 5A69           50                         push	ax
20086                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20087 5A6A           8D5E         FE            lea	bx,-2[bp]
20088 5A6D           53                         push	bx
20089                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20090 5A6E           8D5E         FF            lea	bx,-1[bp]
20091 5A71           53                         push	bx
20092                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20093 5A72           E8         0157            call	_dequeue_key
20094 5A75           83C4                   06  add	sp,*6
20095 5A78           85C0                       test	ax,ax
20096 5A7A           75           0E            jne 	.453
20097                       00005A7C            .454:
20098                                           ! 3222         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
20099                                           ! Debug: list * char = .455+0 (used reg = )
20100 5A7C           BB                   D1C5  mov	bx,#.455
20101 5A7F           53                         push	bx
20102                                           ! Debug: list int = const 7 (used reg = )
20103 5A80           B8                   0007  mov	ax,*7
20104 5A83           50                         push	ax
20105                                           ! Debug: func () void = bios_printf+0 (used reg = )
20106 5A84           E8         AF94            call	_bios_printf
20107 5A87           83C4                   04  add	sp,*4
20108                                           !BCC_EOS
20109                                           ! 3223         }
20110                                           ! 3224       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20111                       00005A8A            .453:
20112                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20113 5A8A           8A46         FF            mov	al,-1[bp]
20114 5A8D           84C0                       test	al,al
20115 5A8F           74           0C            je  	.456
20116                       00005A91            .458:
20117                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20118 5A91           8A46         FE            mov	al,-2[bp]
20119 5A94           3C                     F0  cmp	al,#$F0
20120 5A96           75           05            jne 	.456
20121                       00005A98            .457:
20122                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20123 5A98           30C0                       xor	al,al
20124 5A9A           8846         FE            mov	-2[bp],al
20125                                           !BCC_EOS
20126                                           ! 3225       AX = (scan_code << 8) | ascii_code;
20127                       00005A9D            .456:
20128                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20129 5A9D           8A46         FF            mov	al,-1[bp]
20130 5AA0           30E4                       xor	ah,ah
20131 5AA2           88C4                       mov	ah,al
20132 5AA4           30C0                       xor	al,al
20133                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20134 5AA6           0A46         FE            or	al,-2[bp]
20135                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20136 5AA9           8946         12            mov	$12[bp],ax
20137                                           !BCC_EOS
20138                                           ! 3226       break;
20139 5AAC           E9         0119            br 	.421
20140                                           !BCC_EOS
20141                                           ! 3227     case 0x11:
20142                                           ! 3228       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20143                       00005AAF            .459:
20144                                           ! Debug: list int = const 0 (used reg = )
20145 5AAF           31C0                       xor	ax,ax
20146 5AB1           50                         push	ax
20147                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20148 5AB2           8D5E         FE            lea	bx,-2[bp]
20149 5AB5           53                         push	bx
20150                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20151 5AB6           8D5E         FF            lea	bx,-1[bp]
20152 5AB9           53                         push	bx
20153                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20154 5ABA           E8         010F            call	_dequeue_key
20155 5ABD           83C4                   06  add	sp,*6
20156 5AC0           85C0                       test	ax,ax
20157 5AC2           75           0C            jne 	.45A
20158                       00005AC4            .45B:
20159                                           ! 3229         FLAGS |= 0x0040;
20160                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20161 5AC4           8B46         14            mov	ax,$14[bp]
20162 5AC7           0C                     40  or	al,*$40
20163 5AC9           8946         14            mov	$14[bp],ax
20164                                           !BCC_EOS
20165                                           ! 3230         return;
20166 5ACC           89EC                       mov	sp,bp
20167 5ACE           5D                         pop	bp
20168 5ACF           C3                         ret
20169                                           !BCC_EOS
20170                                           ! 3231         }
20171                                           ! 3232       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20172                       00005AD0            .45A:
20173                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20174 5AD0           8A46         FF            mov	al,-1[bp]
20175 5AD3           84C0                       test	al,al
20176 5AD5           74           0C            je  	.45C
20177                       00005AD7            .45E:
20178                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20179 5AD7           8A46         FE            mov	al,-2[bp]
20180 5ADA           3C                     F0  cmp	al,#$F0
20181 5ADC           75           05            jne 	.45C
20182                       00005ADE            .45D:
20183                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20184 5ADE           30C0                       xor	al,al
20185 5AE0           8846         FE            mov	-2[bp],al
20186                                           !BCC_EOS
20187                                           ! 3233       AX = (scan_code << 8) | ascii_code;
20188                       00005AE3            .45C:
20189                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20190 5AE3           8A46         FF            mov	al,-1[bp]
20191 5AE6           30E4                       xor	ah,ah
20192 5AE8           88C4                       mov	ah,al
20193 5AEA           30C0                       xor	al,al
20194                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20195 5AEC           0A46         FE            or	al,-2[bp]
20196                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20197 5AEF           8946         12            mov	$12[bp],ax
20198                                           !BCC_EOS
20199                                           ! 3234       FLAGS &= 0xffbf;
20200                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20201 5AF2           8B46         14            mov	ax,$14[bp]
20202 5AF5           24                     BF  and	al,#$BF
20203 5AF7           8946         14            mov	$14[bp],ax
20204                                           !BCC_EOS
20205                                           ! 3235       break;
20206 5AFA           E9         00CB            br 	.421
20207                                           !BCC_EOS
20208                                           ! 3236     case 0x12:
20209                                           ! 3237       shift_flags = read_byte(0x0040, 0x1
20210                       00005AFD            .45F:
20211                                           ! 3237 7);
20212                                           ! Debug: list int = const $17 (used reg = )
20213 5AFD           B8                   0017  mov	ax,*$17
20214 5B00           50                         push	ax
20215                                           ! Debug: list int = const $40 (used reg = )
20216 5B01           B8                   0040  mov	ax,*$40
20217 5B04           50                         push	ax
20218                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20219 5B05           E8         AAEC            call	_read_byte
20220 5B08           83C4                   04  add	sp,*4
20221                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20222 5B0B           8846         FD            mov	-3[bp],al
20223                                           !BCC_EOS
20224                                           ! 3238       AX = ((AX & 0xff00) | (shift_flags));
20225                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20226 5B0E           8B46         12            mov	ax,$12[bp]
20227 5B11           30C0                       xor	al,al
20228                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20229 5B13           0A46         FD            or	al,-3[bp]
20230                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20231 5B16           8946         12            mov	$12[bp],ax
20232                                           !BCC_EOS
20233                                           ! 3239       shift_flags = read_byte(0x0040, 0x18) & 0x73;
20234                                           ! Debug: list int = const $18 (used reg = )
20235 5B19           B8                   0018  mov	ax,*$18
20236 5B1C           50                         push	ax
20237                                           ! Debug: list int = const $40 (used reg = )
20238 5B1D           B8                   0040  mov	ax,*$40
20239 5B20           50                         push	ax
20240                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20241 5B21           E8         AAD0            call	_read_byte
20242 5B24           83C4                   04  add	sp,*4
20243                                           ! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
20244 5B27           24                     73  and	al,*$73
20245                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20246 5B29           8846         FD            mov	-3[bp],al
20247                                           !BCC_EOS
20248                                           ! 3240       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
20249                                           ! Debug: list int = const $96 (used reg = )
20250 5B2C           B8                   0096  mov	ax,#$96
20251 5B2F           50                         push	ax
20252                                           ! Debug: list int = const $40 (used reg = )
20253 5B30           B8                   0040  mov	ax,*$40
20254 5B33           50                         push	ax
20255                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20256 5B34           E8         AABD            call	_read_byte
20257 5B37           83C4                   04  add	sp,*4
20258                                           ! Debug: and int = const $C to unsigned char = al+0 (used reg = )
20259 5B3A           24                     0C  and	al,*$C
20260                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20261 5B3C           0A46         FD            or	al,-3[bp]
20262 5B3F           8846         FD            mov	-3[bp],al
20263                                           !BCC_EOS
20264                                           ! 3241       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
20265                                           ! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
20266 5B42           8A46         FD            mov	al,-3[bp]
20267 5B45           30E4                       xor	ah,ah
20268 5B47           88C4                       mov	ah,al
20269 5B49           30C0                       xor	al,al
20270 5B4B           50                         push	ax
20271                                           ! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
20272 5B4C           8A46         12            mov	al,$12[bp]
20273                                           ! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20274 5B4F           30E4                       xor	ah,ah
20275 5B51           0B46         F4            or	ax,0+..FFF3[bp]
20276 5B54           44                         inc	sp
20277 5B55           44                         inc	sp
20278                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20279 5B56           8946         12            mov	$12[bp],ax
20280                                           !BCC_EOS
20281                                           ! 3242       ;
20282                                           !BCC_EOS
20283                                           ! 3243       break;
20284 5B59           EB           6D            jmp .421
20285                                           !BCC_EOS
20286                                           ! 3244     case 0x92:
20287                                           ! 3245       AX = ((AX & 0x00ff) | ((0x80) << 8));
20288                       00005B5B            .460:
20289                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20290 5B5B           8A46         12            mov	al,$12[bp]
20291                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
20292 5B5E           30E4                       xor	ah,ah
20293 5B60           0D                   8000  or	ax,#-$8000
20294                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20295 5B63           8946         12            mov	$12[bp],ax
20296                                           !BCC_EOS
20297                                           ! 3246       break;
20298 5B66           EB           60            jmp .421
20299                                           !BCC_EOS
20300                                           ! 3247     case 0xA2:
20301                                           ! 3248       break;
20302                       00005B68            .461:
20303 5B68           EB           5E            jmp .421
20304                                           !BCC_EOS
20305                                           ! 3249     case 0x6F:
20306                                           ! 3250       if (( AX & 0x00ff ) == 0x08)
20307                       00005B6A            .462:
20308                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20309 5B6A           8A46         12            mov	al,$12[bp]
20310                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
20311 5B6D           3C                     08  cmp	al,*8
20312 5B6F           75           0B            jne 	.463
20313                       00005B71            .464:
20314                                           ! 3251         AX = ((AX & 0x00ff) | ((0x02) << 8));
20315                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20316 5B71           8A46         12            mov	al,$12[bp]
20317                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
20318 5B74           30E4                       xor	ah,ah
20319 5B76           0D                   0200  or	ax,#$200
20320                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20321 5B79           8946         12            mov	$12[bp],ax
20322                                           !BCC_EOS
20323                                           ! 3252     default:
20324                       00005B7C            .463:
20325                                           ! 3253       ;
20326                       00005B7C            .465:
20327                                           !BCC_EOS
20328                                           ! 3254     }
20329                                           ! 3255 }
20330 5B7C           EB           4A            jmp .421
20331                       00005B7E            .423:
20332 5B7E           2D                   0000  sub	ax,*0
20333 5B81           7C           F9            jl 	.465
20334 5B83           3D                   0012  cmp	ax,*$12
20335 5B86           77           2F            ja  	.466
20336 5B88           D1E0                       shl	ax,*1
20337 5B8A           89C3                       mov	bx,ax
20338 5B8C           2E                         seg	cs
20339 5B8D           FFA7       5B91            br	.467[bx]
20340                       00005B91            .467:
20341 5B91                      5890            .word	.424
20342 5B93                      58E7            .word	.42E
20343 5B95                      5943            .word	.437
20344 5B97                      5B7C            .word	.465
20345 5B99                      5B7C            .word	.465
20346 5B9B                      5962            .word	.438
20347 5B9D                      5B7C            .word	.465
20348 5B9F                      5B7C            .word	.465
20349 5BA1                      5B7C            .word	.465
20350 5BA3                      5993            .word	.43C
20351 5BA5                      59A0            .word	.43D
20352 5BA7                      5B7C            .word	.465
20353 5BA9                      5B7C            .word	.465
20354 5BAB                      5B7C            .word	.465
20355 5BAD                      5B7C            .word	.465
20356 5BAF                      5B7C            .word	.465
20357 5BB1                      5A66            .word	.452
20358 5BB3                      5AAF            .word	.459
20359 5BB5                      5AFD            .word	.45F
20360                       00005BB7            .466:
20361 5BB7           2D                   006F  sub	ax,*$6F
20362 5BBA           74           AE            je 	.462
20363 5BBC           2D                   0023  sub	ax,*$23
20364 5BBF           74           9A            je 	.460
20365 5BC1           2D                   0010  sub	ax,*$10
20366 5BC4           74           A2            je 	.461
20367 5BC6           EB           B4            jmp	.465
20368                       00005BC8            .421:
20369                       FFFFFFF4            ..FFF3	=	-$C
20370 5BC8           89EC                       mov	sp,bp
20371 5BCA           5D                         pop	bp
20372 5BCB           C3                         ret
20373                                           ! 3256   unsigned int
20374                                           ! Register BX used in function int16_function
20375                                           ! 3257 dequeue_key(scan_code, ascii_code, incr)
20376                                           ! 3258   Bit8u *scan_code;
20377                                           export	_dequeue_key
20378                       00005BCC            _dequeue_key:
20379                                           !BCC_EOS
20380                                           ! 3259   Bit8u *ascii_code;
20381                                           !BCC_EOS
20382                                           ! 3260   unsigned int incr;
20383                                           !BCC_EOS
20384                                           ! 3261 {
20385                                           ! 3262   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
20386                                           !BCC_EOS
20387                                           ! 3263   Bit16u ss;
20388                                           !BCC_EOS
20389                                           ! 3264   Bit8u acode, scode;
20390                                           !BCC_EOS
20391                                           ! 3265   buffer_start = read_word(0x0040, 0x0080);
20392 5BCC           55                         push	bp
20393 5BCD           89E5                       mov	bp,sp
20394 5BCF           83C4                   F4  add	sp,*-$C
20395                                           ! Debug: list int = const $80 (used reg = )
20396 5BD2           B8                   0080  mov	ax,#$80
20397 5BD5           50                         push	ax
20398                                           ! Debug: list int = const $40 (used reg = )
20399 5BD6           B8                   0040  mov	ax,*$40
20400 5BD9           50                         push	ax
20401                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20402 5BDA           E8         AA2A            call	_read_word
20403 5BDD           83C4                   04  add	sp,*4
20404                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
20405 5BE0           8946         FE            mov	-2[bp],ax
20406                                           !BCC_EOS
20407                                           ! 3266   buffer_end = read_word(0x0040, 0x0082);
20408                                           ! Debug: list int = const $82 (used reg = )
20409 5BE3           B8                   0082  mov	ax,#$82
20410 5BE6           50                         push	ax
20411                                           ! Debug: list int = const $40 (used reg = )
20412 5BE7           B8                   0040  mov	ax,*$40
20413 5BEA           50                         push	ax
20414                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20415 5BEB           E8         AA19            call	_read_word
20416 5BEE           83C4                   04  add	sp,*4
20417                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
20418 5BF1           8946         FC            mov	-4[bp],ax
20419                                           !BCC_EOS
20420                                           ! 3267   buffer_head = read_word(0x0040, 0x001a);
20421                                           ! Debug: list int = const $1A (used reg = )
20422 5BF4           B8                   001A  mov	ax,*$1A
20423 5BF7           50                         push	ax
20424                                           ! Debug: list int = const $40 (used reg = )
20425 5BF8           B8                   0040  mov	ax,*$40
20426 5BFB           50                         push	ax
20427                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20428 5BFC           E8         AA08            call	_read_word
20429 5BFF           83C4                   04  add	sp,*4
20430                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
20431 5C02           8946         FA            mov	-6[bp],ax
20432                                           !BCC_EOS
20433                                           ! 3268   buffer_tail = read_word(0x0040, 0x001c);
20434                                           ! Debug: list int = const $1C (used reg = )
20435 5C05           B8                   001C  mov	ax,*$1C
20436 5C08           50                         push	ax
20437                                           ! Debug: list int = const $40 (used reg = )
20438 5C09           B8                   0040  mov	ax,*$40
20439 5C0C           50                         push	ax
20440                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20441 5C0D           E8         A9F7            call	_read_word
20442 5C10           83C4                   04  add	sp,*4
20443                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20444 5C13           8946         F8            mov	-8[bp],ax
20445                                           !BCC_EOS
20446                                           ! 3269   if (buffer_head != buffer_tail) {
20447                                           ! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20448 5C16           8B46         FA            mov	ax,-6[bp]
20449 5C19           3B46         F8            cmp	ax,-8[bp]
20450 5C1C         0F84         0083            beq 	.468
20451                       00005C20            .469:
20452                                           ! 3270     ss = get_SS();
20453                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
20454 5C20           E8         AA2A            call	_get_SS
20455                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
20456 5C23           8946         F6            mov	-$A[bp],ax
20457                                           !BCC_EOS
20458                                           ! 3271     acode = read_byte(0x0040, buffer_head);
20459                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
20460 5C26           FF76         FA            push	-6[bp]
20461                                           ! Debug: list int = const $40 (used reg = )
20462 5C29           B8                   0040  mov	ax,*$40
20463 5C2C           50                         push	ax
20464                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20465 5C2D           E8         A9C4            call	_read_byte
20466 5C30           83C4                   04  add	sp,*4
20467                                           ! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
20468 5C33           8846         F5            mov	-$B[bp],al
20469                                           !BCC_EOS
20470                                           ! 3272     scode = read_byte(0x0040, buffer_head+1);
20471                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
20472 5C36           8B46         FA            mov	ax,-6[bp]
20473                                           ! Debug: list unsigned int = ax+1 (used reg = )
20474 5C39           40                         inc	ax
20475 5C3A           50                         push	ax
20476                                           ! Debug: list int = const $40 (used reg = )
20477 5C3B           B8                   0040  mov	ax,*$40
20478 5C3E           50                         push	ax
20479                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20480 5C3F           E8         A9B2            call	_read_byte
20481 5C42           83C4                   04  add	sp,*4
20482                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
20483 5C45           8846         F4            mov	-$C[bp],al
20484                                           !BCC_EOS
20485                                           ! 3273     write_byte(ss, ascii_code, acode);
20486                                           ! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
20487 5C48           8A46         F5            mov	al,-$B[bp]
20488 5C4B           30E4                       xor	ah,ah
20489 5C4D           50                         push	ax
20490                                           ! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
20491 5C4E           FF76         06            push	6[bp]
20492                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20493 5C51           FF76         F6            push	-$A[bp]
20494                                           ! Debug: func () void = write_byte+0 (used reg = )
20495 5C54           E8         A9C3            call	_write_byte
20496 5C57           83C4                   06  add	sp,*6
20497                                           !BCC_EOS
20498                                           ! 3274     write_byte(ss, scan_code, scode);
20499                                           ! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
20500 5C5A           8A46         F4            mov	al,-$C[bp]
20501 5C5D           30E4                       xor	ah,ah
20502 5C5F           50                         push	ax
20503                                           ! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
20504 5C60           FF76         04            push	4[bp]
20505                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20506 5C63           FF76         F6            push	-$A[bp]
20507                                           ! Debug: func () void = write_byte+0 (used reg = )
20508 5C66           E8         A9B1            call	_write_byte
20509 5C69           83C4                   06  add	sp,*6
20510                                           !BCC_EOS
20511                                           ! 3275     if (incr) {
20512 5C6C           8B46         08            mov	ax,8[bp]
20513 5C6F           85C0                       test	ax,ax
20514 5C71           74           27            je  	.46A
20515                       00005C73            .46B:
20516                                           ! 3276       buffer_head += 2;
20517                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
20518 5C73           8B46         FA            mov	ax,-6[bp]
20519 5C76           40                         inc	ax
20520 5C77           40                         inc	ax
20521 5C78           8946         FA            mov	-6[bp],ax
20522                                           !BCC_EOS
20523                                           ! 3277       if (buffer_head >= buffer_end)
20524                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
20525 5C7B           8B46         FA            mov	ax,-6[bp]
20526 5C7E           3B46         FC            cmp	ax,-4[bp]
20527 5C81           72           06            jb  	.46C
20528                       00005C83            .46D:
20529                                           ! 3278         buffer_head = buffer_start;
20530                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
20531 5C83           8B46         FE            mov	ax,-2[bp]
20532 5C86           8946         FA            mov	-6[bp],ax
20533                                           !BCC_EOS
20534                                           ! 3279       write_word(0x0040, 0x001a, buffer_head);
20535                       00005C89            .46C:
20536                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
20537 5C89           FF76         FA            push	-6[bp]
20538                                           ! Debug: list int = const $1A (used reg = )
20539 5C8C           B8                   001A  mov	ax,*$1A
20540 5C8F           50                         push	ax
20541                                           ! Debug: list int = const $40 (used reg = )
20542 5C90           B8                   0040  mov	ax,*$40
20543 5C93           50                         push	ax
20544                                           ! Debug: func () void = write_word+0 (used reg = )
20545 5C94           E8         A99B            call	_write_word
20546 5C97           83C4                   06  add	sp,*6
20547                                           !BCC_EOS
20548                                           ! 3280       }
20549                                           ! 3281     return(1);
20550                       00005C9A            .46A:
20551 5C9A           B8                   0001  mov	ax,*1
20552 5C9D           89EC                       mov	sp,bp
20553 5C9F           5D                         pop	bp
20554 5CA0           C3                         ret
20555                                           !BCC_EOS
20556                                           ! 3282     }
20557                                           ! 3283   else {
20558 5CA1           EB           06            jmp .46E
20559                       00005CA3            .468:
20560                                           ! 3284     return(0);
20561 5CA3           31C0                       xor	ax,ax
20562 5CA5           89EC                       mov	sp,bp
20563 5CA7           5D                         pop	bp
20564 5CA8           C3                         ret
20565                                           !BCC_EOS
20566                                           ! 3285     }
20567                                           ! 3286 }
20568                       00005CA9            .46E:
20569 5CA9           89EC                       mov	sp,bp
20570 5CAB           5D                         pop	bp
20571 5CAC           C3                         ret
20572                                           ! 3287 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
20573                                           
20574                       00005CAD            _panic_msg_keyb_buffer_full:
20575                       00005CAD            .46F:
20576 5CAD                        25            .ascii	"%s: keyboard input buffer full"
20577 5CCB                        0A            .byte	$A
20578 5CCC                        00            .byte	0
20579                                           !BCC_EOS
20580                                           ! 3288   Bit8u
20581                                           ! 3289 inhibit_mouse_int_and_events()
20582                                           ! 3290 {
20583                                           
20584                                           export	_inhibit_mouse_int_and_events
20585                       00005CCD            _inhibit_mouse_int_and_events:
20586                                           ! 3291   Bit8u command_byte, prev_command_byte;
20587                                           !BCC_EOS
20588                                           ! 3292   if ( inb(0x64) & 0x02 )
20589 5CCD           55                         push	bp
20590 5CCE           89E5                       mov	bp,sp
20591 5CD0           4C                         dec	sp
20592 5CD1           4C                         dec	sp
20593                                           ! Debug: list int = const $64 (used reg = )
20594 5CD2           B8                   0064  mov	ax,*$64
20595 5CD5           50                         push	ax
20596                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20597 5CD6           E8         A865            call	_inb
20598 5CD9           44                         inc	sp
20599 5CDA           44                         inc	sp
20600                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20601 5CDB           24                     02  and	al,*2
20602 5CDD           84C0                       test	al,al
20603 5CDF           74           12            je  	.470
20604                       00005CE1            .471:
20605                                           ! 3293     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
20606                                           ! Debug: list * char = .472+0 (used reg = )
20607 5CE1           BB                   D1BA  mov	bx,#.472
20608 5CE4           53                         push	bx
20609                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20610 5CE5           BB                   5CAD  mov	bx,#_panic_msg_keyb_buffer_full
20611 5CE8           53                         push	bx
20612                                           ! Debug: list int = const 7 (used reg = )
20613 5CE9           B8                   0007  mov	ax,*7
20614 5CEC           50                         push	ax
20615                                           ! Debug: func () void = bios_printf+0 (used reg = )
20616 5CED           E8         AD2B            call	_bios_printf
20617 5CF0           83C4                   06  add	sp,*6
20618                                           !BCC_EOS
20619                                           ! 3294   outb(0x64, 0x20);
20620                       00005CF3            .470:
20621                                           ! Debug: list int = const $20 (used reg = )
20622 5CF3           B8                   0020  mov	ax,*$20
20623 5CF6           50                         push	ax
20624                                           ! Debug: list int = const $64 (used reg = )
20625 5CF7           B8                   0064  mov	ax,*$64
20626 5CFA           50                         push	ax
20627                                           ! Debug: func () void = outb+0 (used reg = )
20628 5CFB           E8         A856            call	_outb
20629 5CFE           83C4                   04  add	sp,*4
20630                                           !BCC_EOS
20631                                           ! 3295   while ( (inb(0x64) & 0x01) != 0x01 );
20632 5D01           EB           00            jmp .474
20633                       00005D03            .475:
20634                                           !BCC_EOS
20635                                           ! 3296   prev_command_byte = inb(0x60);
20636                       00005D03            .474:
20637                                           ! Debug: list int = const $64 (used reg = )
20638 5D03           B8                   0064  mov	ax,*$64
20639 5D06           50                         push	ax
20640                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20641 5D07           E8         A834            call	_inb
20642 5D0A           44                         inc	sp
20643 5D0B           44                         inc	sp
20644                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20645 5D0C           24                     01  and	al,*1
20646                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
20647 5D0E           3C                     01  cmp	al,*1
20648 5D10           75           F1            jne	.475
20649                       00005D12            .476:
20650                       00005D12            .473:
20651                                           ! Debug: list int = const $60 (used reg = )
20652 5D12           B8                   0060  mov	ax,*$60
20653 5D15           50                         push	ax
20654                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20655 5D16           E8         A825            call	_inb
20656 5D19           44                         inc	sp
20657 5D1A           44                         inc	sp
20658                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
20659 5D1B           8846         FE            mov	-2[bp],al
20660                                           !BCC_EOS
20661                                           ! 3297   command_byte = prev_command_byte;
20662                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
20663 5D1E           8A46         FE            mov	al,-2[bp]
20664 5D21           8846         FF            mov	-1[bp],al
20665                                           !BCC_EOS
20666                                           ! 3298   if ( inb(0x64) & 0x02 )
20667                                           ! Debug: list int = const $64 (used reg = )
20668 5D24           B8                   0064  mov	ax,*$64
20669 5D27           50                         push	ax
20670                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20671 5D28           E8         A813            call	_inb
20672 5D2B           44                         inc	sp
20673 5D2C           44                         inc	sp
20674                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20675 5D2D           24                     02  and	al,*2
20676 5D2F           84C0                       test	al,al
20677 5D31           74           12            je  	.477
20678                       00005D33            .478:
20679                                           ! 3299     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
20680                                           ! Debug: list * char = .479+0 (used reg = )
20681 5D33           BB                   D1AF  mov	bx,#.479
20682 5D36           53                         push	bx
20683                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20684 5D37           BB                   5CAD  mov	bx,#_panic_msg_keyb_buffer_full
20685 5D3A           53                         push	bx
20686                                           ! Debug: list int = const 7 (used reg = )
20687 5D3B           B8                   0007  mov	ax,*7
20688 5D3E           50                         push	ax
20689                                           ! Debug: func () void = bios_printf+0 (used reg = )
20690 5D3F           E8         ACD9            call	_bios_printf
20691 5D42           83C4                   06  add	sp,*6
20692                                           !BCC_EOS
20693                                           ! 3300   command_byte &= 0xfd;
20694                       00005D45            .477:
20695                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
20696 5D45           8A46         FF            mov	al,-1[bp]
20697 5D48           24                     FD  and	al,#$FD
20698 5D4A           8846         FF            mov	-1[bp],al
20699                                           !BCC_EOS
20700                                           ! 3301   command_byte |= 0x20;
20701                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
20702 5D4D           8A46         FF            mov	al,-1[bp]
20703 5D50           0C                     20  or	al,*$20
20704 5D52           8846         FF            mov	-1[bp],al
20705                                           !BCC_EOS
20706                                           ! 3302   outb(0x64, 0x60);
20707                                           ! Debug: list int = const $60 (used reg = )
20708 5D55           B8                   0060  mov	ax,*$60
20709 5D58           50                         push	ax
20710                                           ! Debug: list int = const $64 (used reg = )
20711 5D59           B8                   0064  mov	ax,*$64
20712 5D5C           50                         push	ax
20713                                           ! Debug: func () void = outb+0 (used reg = )
20714 5D5D           E8         A7F4            call	_outb
20715 5D60           83C4                   04  add	sp,*4
20716                                           !BCC_EOS
20717                                           ! 3303   outb(0x60, command_byte);
20718                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
20719 5D63           8A46         FF            mov	al,-1[bp]
20720 5D66           30E4                       xor	ah,ah
20721 5D68           50                         push	ax
20722                                           ! Debug: list int = const $60 (used reg = )
20723 5D69           B8                   0060  mov	ax,*$60
20724 5D6C           50                         push	ax
20725                                           ! Debug: func () void = outb+0 (used reg = )
20726 5D6D           E8         A7E4            call	_outb
20727 5D70           83C4                   04  add	sp,*4
20728                                           !BCC_EOS
20729                                           ! 3304   return(prev_command_byte);
20730 5D73           8A46         FE            mov	al,-2[bp]
20731 5D76           89EC                       mov	sp,bp
20732 5D78           5D                         pop	bp
20733 5D79           C3                         ret
20734                                           !BCC_EOS
20735                                           ! 3305 }
20736                                           ! 3306   void
20737                                           ! Register BX used in function inhibit_mouse_int_and_events
20738                                           ! 3307 enable_mouse_int_and_events()
20739                                           ! 3308 {
20740                                           export	_enable_mouse_int_and_events
20741                       00005D7A            _enable_mouse_int_and_events:
20742                                           ! 3309   Bit8u command_byte;
20743                                           !BCC_EOS
20744                                           ! 3310   if ( inb(0x64) & 0x02 )
20745 5D7A           55                         push	bp
20746 5D7B           89E5                       mov	bp,sp
20747 5D7D           4C                         dec	sp
20748 5D7E           4C                         dec	sp
20749                                           ! Debug: list int = const $64 (used reg = )
20750 5D7F           B8                   0064  mov	ax,*$64
20751 5D82           50                         push	ax
20752                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20753 5D83           E8         A7B8            call	_inb
20754 5D86           44                         inc	sp
20755 5D87           44                         inc	sp
20756                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20757 5D88           24                     02  and	al,*2
20758 5D8A           84C0                       test	al,al
20759 5D8C           74           12            je  	.47A
20760                       00005D8E            .47B:
20761                                           ! 3311     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
20762                                           ! 3311 
20763                                           ! Debug: list * char = .47C+0 (used reg = )
20764 5D8E           BB                   D1A5  mov	bx,#.47C
20765 5D91           53                         push	bx
20766                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20767 5D92           BB                   5CAD  mov	bx,#_panic_msg_keyb_buffer_full
20768 5D95           53                         push	bx
20769                                           ! Debug: list int = const 7 (used reg = )
20770 5D96           B8                   0007  mov	ax,*7
20771 5D99           50                         push	ax
20772                                           ! Debug: func () void = bios_printf+0 (used reg = )
20773 5D9A           E8         AC7E            call	_bios_printf
20774 5D9D           83C4                   06  add	sp,*6
20775                                           !BCC_EOS
20776                                           ! 3312   outb(0x64, 0x20);
20777                       00005DA0            .47A:
20778                                           ! Debug: list int = const $20 (used reg = )
20779 5DA0           B8                   0020  mov	ax,*$20
20780 5DA3           50                         push	ax
20781                                           ! Debug: list int = const $64 (used reg = )
20782 5DA4           B8                   0064  mov	ax,*$64
20783 5DA7           50                         push	ax
20784                                           ! Debug: func () void = outb+0 (used reg = )
20785 5DA8           E8         A7A9            call	_outb
20786 5DAB           83C4                   04  add	sp,*4
20787                                           !BCC_EOS
20788                                           ! 3313   while ( (inb(0x64) & 0x01) != 0x01 );
20789 5DAE           EB           00            jmp .47E
20790                       00005DB0            .47F:
20791                                           !BCC_EOS
20792                                           ! 3314   command_byte = inb(0x60);
20793                       00005DB0            .47E:
20794                                           ! Debug: list int = const $64 (used reg = )
20795 5DB0           B8                   0064  mov	ax,*$64
20796 5DB3           50                         push	ax
20797                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20798 5DB4           E8         A787            call	_inb
20799 5DB7           44                         inc	sp
20800 5DB8           44                         inc	sp
20801                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20802 5DB9           24                     01  and	al,*1
20803                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
20804 5DBB           3C                     01  cmp	al,*1
20805 5DBD           75           F1            jne	.47F
20806                       00005DBF            .480:
20807                       00005DBF            .47D:
20808                                           ! Debug: list int = const $60 (used reg = )
20809 5DBF           B8                   0060  mov	ax,*$60
20810 5DC2           50                         push	ax
20811                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20812 5DC3           E8         A778            call	_inb
20813 5DC6           44                         inc	sp
20814 5DC7           44                         inc	sp
20815                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
20816 5DC8           8846         FF            mov	-1[bp],al
20817                                           !BCC_EOS
20818                                           ! 3315   if ( inb(0x64) & 0x02 )
20819                                           ! Debug: list int = const $64 (used reg = )
20820 5DCB           B8                   0064  mov	ax,*$64
20821 5DCE           50                         push	ax
20822                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20823 5DCF           E8         A76C            call	_inb
20824 5DD2           44                         inc	sp
20825 5DD3           44                         inc	sp
20826                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20827 5DD4           24                     02  and	al,*2
20828 5DD6           84C0                       test	al,al
20829 5DD8           74           12            je  	.481
20830                       00005DDA            .482:
20831                                           ! 3316     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
20832                                           ! Debug: list * char = .483+0 (used reg = )
20833 5DDA           BB                   D19B  mov	bx,#.483
20834 5DDD           53                         push	bx
20835                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20836 5DDE           BB                   5CAD  mov	bx,#_panic_msg_keyb_buffer_full
20837 5DE1           53                         push	bx
20838                                           ! Debug: list int = const 7 (used reg = )
20839 5DE2           B8                   0007  mov	ax,*7
20840 5DE5           50                         push	ax
20841                                           ! Debug: func () void = bios_printf+0 (used reg = )
20842 5DE6           E8         AC32            call	_bios_printf
20843 5DE9           83C4                   06  add	sp,*6
20844                                           !BCC_EOS
20845                                           ! 3317   command_byte |= 0x02;
20846                       00005DEC            .481:
20847                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
20848 5DEC           8A46         FF            mov	al,-1[bp]
20849 5DEF           0C                     02  or	al,*2
20850 5DF1           8846         FF            mov	-1[bp],al
20851                                           !BCC_EOS
20852                                           ! 3318   command_byte &= 0xdf;
20853                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
20854 5DF4           8A46         FF            mov	al,-1[bp]
20855 5DF7           24                     DF  and	al,#$DF
20856 5DF9           8846         FF            mov	-1[bp],al
20857                                           !BCC_EOS
20858                                           ! 3319   outb(0x64, 0x60);
20859                                           ! Debug: list int = const $60 (used reg = )
20860 5DFC           B8                   0060  mov	ax,*$60
20861 5DFF           50                         push	ax
20862                                           ! Debug: list int = const $64 (used reg = )
20863 5E00           B8                   0064  mov	ax,*$64
20864 5E03           50                         push	ax
20865                                           ! Debug: func () void = outb+0 (used reg = )
20866 5E04           E8         A74D            call	_outb
20867 5E07           83C4                   04  add	sp,*4
20868                                           !BCC_EOS
20869                                           ! 3320   outb(0x60, command_byte);
20870                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
20871 5E0A           8A46         FF            mov	al,-1[bp]
20872 5E0D           30E4                       xor	ah,ah
20873 5E0F           50                         push	ax
20874                                           ! Debug: list int = const $60 (used reg = )
20875 5E10           B8                   0060  mov	ax,*$60
20876 5E13           50                         push	ax
20877                                           ! Debug: func () void = outb+0 (used reg = )
20878 5E14           E8         A73D            call	_outb
20879 5E17           83C4                   04  add	sp,*4
20880                                           !BCC_EOS
20881                                           ! 3321 }
20882 5E1A           89EC                       mov	sp,bp
20883 5E1C           5D                         pop	bp
20884 5E1D           C3                         ret
20885                                           ! 3322   Bit8u
20886                                           ! Register BX used in function enable_mouse_int_and_events
20887                                           ! 3323 send_to_mouse_ctrl(sendbyte)
20888                                           ! 3324   Bit8u sendbyte;
20889                                           export	_send_to_mouse_ctrl
20890                       00005E1E            _send_to_mouse_ctrl:
20891                                           !BCC_EOS
20892                                           ! 3325 {
20893                                           ! 3326   Bit8u response;
20894                                           !BCC_EOS
20895                                           ! 3327   if ( inb(0x64) & 0x02 )
20896 5E1E           55                         push	bp
20897 5E1F           89E5                       mov	bp,sp
20898 5E21           4C                         dec	sp
20899 5E22           4C                         dec	sp
20900                                           ! Debug: list int = const $64 (used reg = )
20901 5E23           B8                   0064  mov	ax,*$64
20902 5E26           50                         push	ax
20903                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20904 5E27           E8         A714            call	_inb
20905 5E2A           44                         inc	sp
20906 5E2B           44                         inc	sp
20907                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20908 5E2C           24                     02  and	al,*2
20909 5E2E           84C0                       test	al,al
20910 5E30           74           12            je  	.484
20911                       00005E32            .485:
20912                                           ! 3328     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
20913                                           ! Debug: list * char = .486+0 (used reg = )
20914 5E32           BB                   D191  mov	bx,#.486
20915 5E35           53                         push	bx
20916                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20917 5E36           BB                   5CAD  mov	bx,#_panic_msg_keyb_buffer_full
20918 5E39           53                         push	bx
20919                                           ! Debug: list int = const 7 (used reg = )
20920 5E3A           B8                   0007  mov	ax,*7
20921 5E3D           50                         push	ax
20922                                           ! Debug: func () void = bios_printf+0 (used reg = )
20923 5E3E           E8         ABDA            call	_bios_printf
20924 5E41           83C4                   06  add	sp,*6
20925                                           !BCC_EOS
20926                                           ! 3329   outb(0x64, 0xD4);
20927                       00005E44            .484:
20928                                           ! Debug: list int = const $D4 (used reg = )
20929 5E44           B8                   00D4  mov	ax,#$D4
20930 5E47           50                         push	ax
20931                                           ! Debug: list int = const $64 (used reg = )
20932 5E48           B8                   0064  mov	ax,*$64
20933 5E4B           50                         push	ax
20934                                           ! Debug: func () void = outb+0 (used reg = )
20935 5E4C           E8         A705            call	_outb
20936 5E4F           83C4                   04  add	sp,*4
20937                                           !BCC_EOS
20938                                           ! 3330   outb(0x60, sendbyte);
20939                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
20940 5E52           8A46         04            mov	al,4[bp]
20941 5E55           30E4                       xor	ah,ah
20942 5E57           50                         push	ax
20943                                           ! Debug: list int = const $60 (used reg = )
20944 5E58           B8                   0060  mov	ax,*$60
20945 5E5B           50                         push	ax
20946                                           ! Debug: func () void = outb+0 (used reg = )
20947 5E5C           E8         A6F5            call	_outb
20948 5E5F           83C4                   04  add	sp,*4
20949                                           !BCC_EOS
20950                                           ! 3331   return(0);
20951 5E62           30C0                       xor	al,al
20952 5E64           89EC                       mov	sp,bp
20953 5E66           5D                         pop	bp
20954 5E67           C3                         ret
20955                                           !BCC_EOS
20956                                           ! 3332 }
20957                                           ! 3333   Bit8u
20958                                           ! Register BX used in function send_to_mouse_ctrl
20959                                           ! 3334 get_mouse_data(data)
20960                                           ! 3335   Bit8u *data;
20961                                           export	_get_mouse_data
20962                       00005E68            _get_mouse_data:
20963                                           !BCC_EOS
20964                                           ! 3336 {
20965                                           ! 3337   Bit8u response;
20966                                           !BCC_EOS
20967                                           ! 3338   Bit16u ss;
20968                                           !BCC_EOS
20969                                           ! 3339   while ( (inb(0x64) & 0x21) != 0x21 ) {
20970 5E68           55                         push	bp
20971 5E69           89E5                       mov	bp,sp
20972 5E6B           83C4                   FC  add	sp,*-4
20973 5E6E           EB           00            jmp .488
20974                       00005E70            .489:
20975                                           ! 3340     }
20976                                           ! 3341   response = inb(0x60);
20977                       00005E70            .488:
20978                                           ! Debug: list int = const $64 (used reg = )
20979 5E70           B8                   0064  mov	ax,*$64
20980 5E73           50                         push	ax
20981                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20982 5E74           E8         A6C7            call	_inb
20983 5E77           44                         inc	sp
20984 5E78           44                         inc	sp
20985                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
20986 5E79           24                     21  and	al,*$21
20987                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
20988 5E7B           3C                     21  cmp	al,*$21
20989 5E7D           75           F1            jne	.489
20990                       00005E7F            .48A:
20991                       00005E7F            .487:
20992                                           ! Debug: list int = const $60 (used reg = )
20993 5E7F           B8                   0060  mov	ax,*$60
20994 5E82           50                         push	ax
20995                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20996 5E83           E8         A6B8            call	_inb
20997 5E86           44                         inc	sp
20998 5E87           44                         inc	sp
20999                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
21000 5E88           8846         FF            mov	-1[bp],al
21001                                           !BCC_EOS
21002                                           ! 3342   ss = get_SS();
21003                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21004 5E8B           E8         A7BF            call	_get_SS
21005                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
21006 5E8E           8946         FC            mov	-4[bp],ax
21007                                           !BCC_EOS
21008                                           ! 3343   write_byte(ss, data, response);
21009                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
21010 5E91           8A46         FF            mov	al,-1[bp]
21011 5E94           30E4                       xor	ah,ah
21012 5E96           50                         push	ax
21013                                           ! Debug: list * unsigned char data = [S+8+2] (used reg = )
21014 5E97           FF76         04            push	4[bp]
21015                                           ! Debug: list unsigned short ss = [S+$A-6] (used reg = )
21016 5E9A           FF76         FC            push	-4[bp]
21017                                           ! Debug: func () void = write_byte+0 (used reg = )
21018 5E9D           E8         A77A            call	_write_byte
21019 5EA0           83C4                   06  add	sp,*6
21020                                           !BCC_EOS
21021                                           ! 3344   return(0);
21022 5EA3           30C0                       xor	al,al
21023 5EA5           89EC                       mov	sp,bp
21024 5EA7           5D                         pop	bp
21025 5EA8           C3                         ret
21026                                           !BCC_EOS
21027                                           ! 3345 }
21028                                           ! 3346   void
21029                                           ! 3347 set_kbd_command_byte(command_byte)
21030                                           ! 3348   Bit8u command_byte;
21031                                           export	_set_kbd_command_byte
21032                       00005EA9            _set_kbd_command_byte:
21033                                           !BCC_EOS
21034                                           ! 3349 {
21035                                           ! 3350   if ( inb(0x64) & 0x02 )
21036 5EA9           55                         push	bp
21037 5EAA           89E5                       mov	bp,sp
21038                                           ! Debug: list int = const $64 (used reg = )
21039 5EAC           B8                   0064  mov	ax,*$64
21040 5EAF           50                         push	ax
21041                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21042 5EB0           E8         A68B            call	_inb
21043 5EB3           89EC                       mov	sp,bp
21044                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21045 5EB5           24                     02  and	al,*2
21046 5EB7           84C0                       test	al,al
21047 5EB9           74           11            je  	.48B
21048                       00005EBB            .48C:
21049                                           ! 3351     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
21050                                           ! Debug: list * char = .48D+0 (used reg = )
21051 5EBB           BB                   D186  mov	bx,#.48D
21052 5EBE           53                         push	bx
21053                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21054 5EBF           BB                   5CAD  mov	bx,#_panic_msg_keyb_buffer_full
21055 5EC2           53                         push	bx
21056                                           ! Debug: list int = const 7 (used reg = )
21057 5EC3           B8                   0007  mov	ax,*7
21058 5EC6           50                         push	ax
21059                                           ! Debug: func () void = bios_printf+0 (used reg = )
21060 5EC7           E8         AB51            call	_bios_printf
21061 5ECA           89EC                       mov	sp,bp
21062                                           !BCC_EOS
21063                                           ! 3352   outb(0x64, 0xD4);
21064                       00005ECC            .48B:
21065                                           ! Debug: list int = const $D4 (used reg = )
21066 5ECC           B8                   00D4  mov	ax,#$D4
21067 5ECF           50                         push	ax
21068                                           ! Debug: list int = const $64 (used reg = )
21069 5ED0           B8                   0064  mov	ax,*$64
21070 5ED3           50                         push	ax
21071                                           ! Debug: func () void = outb+0 (used reg = )
21072 5ED4           E8         A67D            call	_outb
21073 5ED7           89EC                       mov	sp,bp
21074                                           !BCC_EOS
21075                                           ! 3353   outb(0x64, 0x60);
21076                                           ! Debug: list int = const $60 (used reg = )
21077 5ED9           B8                   0060  mov	ax,*$60
21078 5EDC           50                         push	ax
21079                                           ! Debug: list int = const $64 (used reg = )
21080 5EDD           B8                   0064  mov	ax,*$64
21081 5EE0           50                         push	ax
21082                                           ! Debug: func () void = outb+0 (used reg = )
21083 5EE1           E8         A670            call	_outb
21084 5EE4           89EC                       mov	sp,bp
21085                                           !BCC_EOS
21086                                           ! 3354   outb(0x60, command_byte);
21087                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
21088 5EE6           8A46         04            mov	al,4[bp]
21089 5EE9           30E4                       xor	ah,ah
21090 5EEB           50                         push	ax
21091                                           ! Debug: list int = const $60 (used reg = )
21092 5EEC           B8                   0060  mov	ax,*$60
21093 5EEF           50                         push	ax
21094                                           ! Debug: func () void = outb+0 (used reg = )
21095 5EF0           E8         A661            call	_outb
21096 5EF3           89EC                       mov	sp,bp
21097                                           !BCC_EOS
21098                                           ! 3355 }
21099 5EF5           5D                         pop	bp
21100 5EF6           C3                         ret
21101                                           ! 3356   void
21102                                           ! Register BX used in function set_kbd_command_byte
21103                                           ! 3357 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
21104                                           ! 3358   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
21105                                           export	_int09_function
21106                       00005EF7            _int09_function:
21107                                           !BCC_EOS
21108                                           ! 3359 {
21109                                           ! 3360   Bit8u scancode, asciicode, shift_flags;
21110                                           !BCC_EOS
21111                                           ! 3361   Bit8u mf2_flags, mf2_state;
21112                                           !BCC_EOS
21113                                           ! 3362   scancode = ( AX & 0x00ff );
21114 5EF7           55                         push	bp
21115 5EF8           89E5                       mov	bp,sp
21116 5EFA           83C4                   FA  add	sp,*-6
21117                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
21118 5EFD           8A46         12            mov	al,$12[bp]
21119                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
21120 5F00           8846         FF            mov	-1[bp],al
21121                                           !BCC_EOS
21122                                           ! 3363   if (scancode == 0) {
21123                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
21124 5F03           8A46         FF            mov	al,-1[bp]
21125 5F06           84C0                       test	al,al
21126 5F08           75           04            jne 	.48E
21127                       00005F0A            .48F:
21128                                           ! 3364     ;
21129                                           !BCC_EOS
21130                                           ! 3365     return;
21131 5F0A           89EC                       mov	sp,bp
21132 5F0C           5D                         pop	bp
21133 5F0D           C3                         ret
21134                                           !BCC_EOS
21135                                           ! 3366     }
21136                                           ! 3367   shift_flags = read_byte(0x0040, 0x17);
21137                       00005F0E            .48E:
21138                                           ! Debug: list int = const $17 (used reg = )
21139 5F0E           B8                   0017  mov	ax,*$17
21140 5F11           50                         push	ax
21141                                           ! Debug: list int = const $40 (used reg = )
21142 5F12           B8                   0040  mov	ax,*$40
21143 5F15           50                         push	ax
21144                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21145 5F16           E8         A6DB            call	_read_byte
21146 5F19           83C4                   04  add	sp,*4
21147                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
21148 5F1C           8846         FD            mov	-3[bp],al
21149                                           !BCC_EOS
21150                                           ! 3368   mf2_flags = read_byte(0x0040, 0x18);
21151                                           ! Debug: list int = const $18 (used reg = )
21152 5F1F           B8                   0018  mov	ax,*$18
21153 5F22           50                         push	ax
21154                                           ! Debug: list int = const $40 (used reg = )
21155 5F23           B8                   0040  mov	ax,*$40
21156 5F26           50                         push	ax
21157                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21158 5F27           E8         A6CA            call	_read_byte
21159 5F2A           83C4                   04  add	sp,*4
21160                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
21161 5F2D           8846         FC            mov	-4[bp],al
21162                                           !BCC_EOS
21163                                           ! 3369   mf2_state = read_byte(0x0040, 0x96);
21164                                           ! Debug: list int = const $96 (used reg = )
21165 5F30           B8                   0096  mov	ax,#$96
21166 5F33           50                         push	ax
21167                                           ! Debug: list int = const $40 (used reg = )
21168 5F34           B8                   0040  mov	ax,*$40
21169 5F37           50                         push	ax
21170                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21171 5F38           E8         A6B9            call	_read_byte
21172 5F3B           83C4                   04  add	sp,*4
21173                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
21174 5F3E           8846         FB            mov	-5[bp],al
21175                                           !BCC_EOS
21176                                           ! 3370   asciicode = 0;
21177                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
21178 5F41           30C0                       xor	al,al
21179 5F43           8846         FE            mov	-2[bp],al
21180                                           !BCC_EOS
21181                                           ! 3371   switch (scancode) {
21182 5F46           8A46         FF            mov	al,-1[bp]
21183 5F49           E9         0570            br 	.492
21184                                           ! 3372     case 0x3a:
21185                                           ! 3373       shift_flags ^= 0x40;
21186                       00005F4C            .493:
21187                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
21188 5F4C           8A46         FD            mov	al,-3[bp]
21189 5F4F           34                     40  xor	al,*$40
21190 5F51           8846         FD            mov	-3[bp],al
21191                                           !BCC_EOS
21192                                           ! 3374       write_byte(0x0040, 0x17, shift_flags);
21193                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21194 5F54           8A46         FD            mov	al,-3[bp]
21195 5F57           30E4                       xor	ah,ah
21196 5F59           50                         push	ax
21197                                           ! Debug: list int = const $17 (used reg = )
21198 5F5A           B8                   0017  mov	ax,*$17
21199 5F5D           50                         push	ax
21200                                           ! Debug: list int = const $40 (used reg = )
21201 5F5E           B8                   0040  mov	ax,*$40
21202 5F61           50                         push	ax
21203                                           ! Debug: func () void = write_byte+0 (used reg = )
21204 5F62           E8         A6B5            call	_write_byte
21205 5F65           83C4                   06  add	sp,*6
21206                                           !BCC_EOS
21207                                           ! 3375       mf2_flags |= 0x40;
21208                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
21209 5F68           8A46         FC            mov	al,-4[bp]
21210 5F6B           0C                     40  or	al,*$40
21211 5F6D           8846         FC            mov	-4[bp],al
21212                                           !BCC_EOS
21213                                           ! 3376       write_byte(0x0040, 0x18, mf2_flags);
21214                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21215 5F70           8A46         FC            mov	al,-4[bp]
21216 5F73           30E4                       xor	ah,ah
21217 5F75           50                         push	ax
21218                                           ! Debug: list int = const $18 (used reg = )
21219 5F76           B8                   0018  mov	ax,*$18
21220 5F79           50                         push	ax
21221                                           ! Debug: list int = const $40 (used reg = )
21222 5F7A           B8                   0040  mov	ax,*$40
21223 5F7D           50                         push	ax
21224                                           ! Debug: func () void = write_byte+0 (used reg = )
21225 5F7E           E8         A699            call	_write_byte
21226 5F81           83C4                   06  add	sp,*6
21227                                           !BCC_EOS
21228                                           ! 3377       break;
21229 5F84           E9         0592            br 	.490
21230                                           !BCC_EOS
21231                                           ! 3378     case 0xba:
21232                                           ! 3379       mf2_flags &= ~0x40;
21233                       00005F87            .494:
21234                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
21235 5F87           8A46         FC            mov	al,-4[bp]
21236 5F8A           24                     BF  and	al,#$BF
21237 5F8C           8846         FC            mov	-4[bp],al
21238                                           !BCC_EOS
21239                                           ! 3380       write_byte(0x0040, 0x18, mf2_flags);
21240                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21241 5F8F           8A46         FC            mov	al,-4[bp]
21242 5F92           30E4                       xor	ah,ah
21243 5F94           50                         push	ax
21244                                           ! Debug: list int = const $18 (used reg = )
21245 5F95           B8                   0018  mov	ax,*$18
21246 5F98           50                         push	ax
21247                                           ! Debug: list int = const $40 (used reg = )
21248 5F99           B8                   0040  mov	ax,*$40
21249 5F9C           50                         push	ax
21250                                           ! Debug: func () void = write_byte+0 (used reg = )
21251 5F9D           E8         A67A            call	_write_byte
21252 5FA0           83C4                   06  add	sp,*6
21253                                           !BCC_EOS
21254                                           ! 3381       break;
21255 5FA3           E9         0573            br 	.490
21256                                           !BCC_EOS
21257                                           ! 3382     case 0x2a:
21258                                           ! 3383       shift_flags |= 0x02;
21259                       00005FA6            .495:
21260                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
21261 5FA6           8A46         FD            mov	al,-3[bp]
21262 5FA9           0C                     02  or	al,*2
21263 5FAB           8846         FD            mov	-3[bp],al
21264                                           !BCC_EOS
21265                                           ! 3384       write_byte(0x0040, 0x17, shift_flags);
21266                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21267 5FAE           8A46         FD            mov	al,-3[bp]
21268 5FB1           30E4                       xor	ah,ah
21269 5FB3           50                         push	ax
21270                                           ! Debug: list int = const $17 (used reg = )
21271 5FB4           B8                   0017  mov	ax,*$17
21272 5FB7           50                         push	ax
21273                                           ! Debug: list int = const $40 (used reg = )
21274 5FB8           B8                   0040  mov	ax,*$40
21275 5FBB           50                         push	ax
21276                                           ! Debug: func () void = write_byte+0 (used reg = )
21277 5FBC           E8         A65B            call	_write_byte
21278 5FBF           83C4                   06  add	sp,*6
21279                                           !BCC_EOS
21280                                           ! 3385       break;
21281 5FC2           E9         0554            br 	.490
21282                                           !BCC_EOS
21283                                           ! 3386     case 0xaa:
21284                                           ! 3387       shift_flags &= ~0x02;
21285                       00005FC5            .496:
21286                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
21287 5FC5           8A46         FD            mov	al,-3[bp]
21288 5FC8           24                     FD  and	al,#$FD
21289 5FCA           8846         FD            mov	-3[bp],al
21290                                           !BCC_EOS
21291                                           ! 3388       write_byte(0x0040, 0x17, shift_flags);
21292                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21293 5FCD           8A46         FD            mov	al,-3[bp]
21294 5FD0           30E4                       xor	ah,ah
21295 5FD2           50                         push	ax
21296                                           ! Debug: list int = const $17 (used reg = )
21297 5FD3           B8                   0017  mov	ax,*$17
21298 5FD6           50                         push	ax
21299                                           ! Debug: list int = const $40 (used reg = )
21300 5FD7           B8                   0040  mov	ax,*$40
21301 5FDA           50                         push	ax
21302                                           ! Debug: func () void = write_byte+0 (used reg = )
21303 5FDB           E8         A63C            call	_write_byte
21304 5FDE           83C4                   06  add	sp,*6
21305                                           !BCC_EOS
21306                                           ! 3389       break;
21307 5FE1           E9         0535            br 	.490
21308                                           !BCC_EOS
21309                                           ! 3390     case 0x36:
21310                                           ! 3391       shift_flags |= 0x01;
21311                       00005FE4            .497:
21312                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
21313 5FE4           8A46         FD            mov	al,-3[bp]
21314 5FE7           0C                     01  or	al,*1
21315 5FE9           8846         FD            mov	-3[bp],al
21316                                           !BCC_EOS
21317                                           ! 3392       write_byte(0x0040, 0x17, shift_flags);
21318                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21319 5FEC           8A46         FD            mov	al,-3[bp]
21320 5FEF           30E4                       xor	ah,ah
21321 5FF1           50                         push	ax
21322                                           ! Debug: list int = const $17 (used reg = )
21323 5FF2           B8                   0017  mov	ax,*$17
21324 5FF5           50                         push	ax
21325                                           ! Debug: list int = const $40 (used reg = )
21326 5FF6           B8                   0040  mov	ax,*$40
21327 5FF9           50                         push	ax
21328                                           ! Debug: func () void = write_byte+0 (used reg = )
21329 5FFA           E8         A61D            call	_write_byte
21330 5FFD           83C4                   06  add	sp,*6
21331                                           !BCC_EOS
21332                                           ! 3393       break;
21333 6000           E9         0516            br 	.490
21334                                           !BCC_EOS
21335                                           ! 3394     case 0xb6:
21336                                           ! 3395       shift_flags &= ~0x01;
21337                       00006003            .498:
21338                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
21339 6003           8A46         FD            mov	al,-3[bp]
21340 6006           24                     FE  and	al,#$FE
21341 6008           8846         FD            mov	-3[bp],al
21342                                           !BCC_EOS
21343                                           ! 3396       write_byte(0x0040, 0x17, shift_flags);
21344                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21345 600B           8A46         FD            mov	al,-3[bp]
21346 600E           30E4                       xor	ah,ah
21347 6010           50                         push	ax
21348                                           ! Debug: list int = const $17 (used reg = )
21349 6011           B8                   0017  mov	ax,*$17
21350 6014           50                         push	ax
21351                                           ! Debug: list int = const $40 (used reg = )
21352 6015           B8                   0040  mov	ax,*$40
21353 6018           50                         push	ax
21354                                           ! Debug: func () void = write_byte+0 (used reg = )
21355 6019           E8         A5FE            call	_write_byte
21356 601C           83C4                   06  add	sp,*6
21357                                           !BCC_EOS
21358                                           ! 3397       break;
21359 601F           E9         04F7            br 	.490
21360                                           !BCC_EOS
21361                                           ! 3398     case 0x1d:
21362                                           ! 3399   
21363                                           ! 3399     if ((mf2_state & 0x01) == 0) {
21364                       00006022            .499:
21365                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21366 6022           8A46         FB            mov	al,-5[bp]
21367 6025           24                     01  and	al,*1
21368                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21369 6027           84C0                       test	al,al
21370 6029           75           5F            jne 	.49A
21371                       0000602B            .49B:
21372                                           ! 3400         shift_flags |= 0x04;
21373                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
21374 602B           8A46         FD            mov	al,-3[bp]
21375 602E           0C                     04  or	al,*4
21376 6030           8846         FD            mov	-3[bp],al
21377                                           !BCC_EOS
21378                                           ! 3401         write_byte(0x0040, 0x17, shift_flags);
21379                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21380 6033           8A46         FD            mov	al,-3[bp]
21381 6036           30E4                       xor	ah,ah
21382 6038           50                         push	ax
21383                                           ! Debug: list int = const $17 (used reg = )
21384 6039           B8                   0017  mov	ax,*$17
21385 603C           50                         push	ax
21386                                           ! Debug: list int = const $40 (used reg = )
21387 603D           B8                   0040  mov	ax,*$40
21388 6040           50                         push	ax
21389                                           ! Debug: func () void = write_byte+0 (used reg = )
21390 6041           E8         A5D6            call	_write_byte
21391 6044           83C4                   06  add	sp,*6
21392                                           !BCC_EOS
21393                                           ! 3402         if (mf2_state & 0x02) {
21394                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21395 6047           8A46         FB            mov	al,-5[bp]
21396 604A           24                     02  and	al,*2
21397 604C           84C0                       test	al,al
21398 604E           74           1E            je  	.49C
21399                       00006050            .49D:
21400                                           ! 3403           mf2_state |= 0x04;
21401                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
21402 6050           8A46         FB            mov	al,-5[bp]
21403 6053           0C                     04  or	al,*4
21404 6055           8846         FB            mov	-5[bp],al
21405                                           !BCC_EOS
21406                                           ! 3404           write_byte(0x0040, 0x96, mf2_state);
21407                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21408 6058           8A46         FB            mov	al,-5[bp]
21409 605B           30E4                       xor	ah,ah
21410 605D           50                         push	ax
21411                                           ! Debug: list int = const $96 (used reg = )
21412 605E           B8                   0096  mov	ax,#$96
21413 6061           50                         push	ax
21414                                           ! Debug: list int = const $40 (used reg = )
21415 6062           B8                   0040  mov	ax,*$40
21416 6065           50                         push	ax
21417                                           ! Debug: func () void = write_byte+0 (used reg = )
21418 6066           E8         A5B1            call	_write_byte
21419 6069           83C4                   06  add	sp,*6
21420                                           !BCC_EOS
21421                                           ! 3405         } else {
21422 606C           EB           1C            jmp .49E
21423                       0000606E            .49C:
21424                                           ! 3406           mf2_flags |= 0x01;
21425                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
21426 606E           8A46         FC            mov	al,-4[bp]
21427 6071           0C                     01  or	al,*1
21428 6073           8846         FC            mov	-4[bp],al
21429                                           !BCC_EOS
21430                                           ! 3407           write_byte(0x0040, 0x18, mf2_flags);
21431                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21432 6076           8A46         FC            mov	al,-4[bp]
21433 6079           30E4                       xor	ah,ah
21434 607B           50                         push	ax
21435                                           ! Debug: list int = const $18 (used reg = )
21436 607C           B8                   0018  mov	ax,*$18
21437 607F           50                         push	ax
21438                                           ! Debug: list int = const $40 (used reg = )
21439 6080           B8                   0040  mov	ax,*$40
21440 6083           50                         push	ax
21441                                           ! Debug: func () void = write_byte+0 (used reg = )
21442 6084           E8         A593            call	_write_byte
21443 6087           83C4                   06  add	sp,*6
21444                                           !BCC_EOS
21445                                           ! 3408         }
21446                                           ! 3409       }
21447                       0000608A            .49E:
21448                                           ! 3410       break;
21449                       0000608A            .49A:
21450 608A           E9         048C            br 	.490
21451                                           !BCC_EOS
21452                                           ! 3411     case 0x9d:
21453                                           ! 3412       if ((mf2_state & 0x01) == 0) {
21454                       0000608D            .49F:
21455                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21456 608D           8A46         FB            mov	al,-5[bp]
21457 6090           24                     01  and	al,*1
21458                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21459 6092           84C0                       test	al,al
21460 6094           75           5F            jne 	.4A0
21461                       00006096            .4A1:
21462                                           ! 3413         shift_flags &= ~0x04;
21463                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
21464 6096           8A46         FD            mov	al,-3[bp]
21465 6099           24                     FB  and	al,#$FB
21466 609B           8846         FD            mov	-3[bp],al
21467                                           !BCC_EOS
21468                                           ! 3414         write_byte(0x0040, 0x17, shift_flags);
21469                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21470 609E           8A46         FD            mov	al,-3[bp]
21471 60A1           30E4                       xor	ah,ah
21472 60A3           50                         push	ax
21473                                           ! Debug: list int = const $17 (used reg = )
21474 60A4           B8                   0017  mov	ax,*$17
21475 60A7           50                         push	ax
21476                                           ! Debug: list int = const $40 (used reg = )
21477 60A8           B8                   0040  mov	ax,*$40
21478 60AB           50                         push	ax
21479                                           ! Debug: func () void = write_byte+0 (used reg = )
21480 60AC           E8         A56B            call	_write_byte
21481 60AF           83C4                   06  add	sp,*6
21482                                           !BCC_EOS
21483                                           ! 3415         if (mf2_state & 0x02) {
21484                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21485 60B2           8A46         FB            mov	al,-5[bp]
21486 60B5           24                     02  and	al,*2
21487 60B7           84C0                       test	al,al
21488 60B9           74           1E            je  	.4A2
21489                       000060BB            .4A3:
21490                                           ! 3416           mf2_state &= ~0x04;
21491                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
21492 60BB           8A46         FB            mov	al,-5[bp]
21493 60BE           24                     FB  and	al,#$FB
21494 60C0           8846         FB            mov	-5[bp],al
21495                                           !BCC_EOS
21496                                           ! 3417           write_byte(0x0040, 0x96, mf2_state);
21497                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21498 60C3           8A46         FB            mov	al,-5[bp]
21499 60C6           30E4                       xor	ah,ah
21500 60C8           50                         push	ax
21501                                           ! Debug: list int = const $96 (used reg = )
21502 60C9           B8                   0096  mov	ax,#$96
21503 60CC           50                         push	ax
21504                                           ! Debug: list int = const $40 (used reg = )
21505 60CD           B8                   0040  mov	ax,*$40
21506 60D0           50                         push	ax
21507                                           ! Debug: func () void = write_byte+0 (used reg = )
21508 60D1           E8         A546            call	_write_byte
21509 60D4           83C4                   06  add	sp,*6
21510                                           !BCC_EOS
21511                                           ! 3418         } else {
21512 60D7           EB           1C            jmp .4A4
21513                       000060D9            .4A2:
21514                                           ! 3419           mf2_flags &= ~0x01;
21515                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
21516 60D9           8A46         FC            mov	al,-4[bp]
21517 60DC           24                     FE  and	al,#$FE
21518 60DE           8846         FC            mov	-4[bp],al
21519                                           !BCC_EOS
21520                                           ! 3420           write_byte(0x0040, 0x18, mf2_flags);
21521                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21522 60E1           8A46         FC            mov	al,-4[bp]
21523 60E4           30E4                       xor	ah,ah
21524 60E6           50                         push	ax
21525                                           ! Debug: list int = const $18 (used reg = )
21526 60E7           B8                   0018  mov	ax,*$18
21527 60EA           50                         push	ax
21528                                           ! Debug: list int = const $40 (used reg = )
21529 60EB           B8                   0040  mov	ax,*$40
21530 60EE           50                         push	ax
21531                                           ! Debug: func () void = write_byte+0 (used reg = )
21532 60EF           E8         A528            call	_write_byte
21533 60F2           83C4                   06  add	sp,*6
21534                                           !BCC_EOS
21535                                           ! 3421         }
21536                                           ! 3422       }
21537                       000060F5            .4A4:
21538                                           ! 3423       break;
21539                       000060F5            .4A0:
21540 60F5           E9         0421            br 	.490
21541                                           !BCC_EOS
21542                                           ! 3424     case 0x38:
21543                                           ! 3425       shift_flags |= 0x08;
21544                       000060F8            .4A5:
21545                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
21546 60F8           8A46         FD            mov	al,-3[bp]
21547 60FB           0C                     08  or	al,*8
21548 60FD           8846         FD            mov	-3[bp],al
21549                                           !BCC_EOS
21550                                           ! 3426       write_byte(0x0040, 0x17, shift_flags);
21551                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21552 6100           8A46         FD            mov	al,-3[bp]
21553 6103           30E4                       xor	ah,ah
21554 6105           50                         push	ax
21555                                           ! Debug: list int = const $17 (used reg = )
21556 6106           B8                   0017  mov	ax,*$17
21557 6109           50                         push	ax
21558                                           ! Debug: list int = const $40 (used reg = )
21559 610A           B8                   0040  mov	ax,*$40
21560 610D           50                         push	ax
21561                                           ! Debug: func () void = write_byte+0 (used reg = )
21562 610E           E8         A509            call	_write_byte
21563 6111           83C4                   06  add	sp,*6
21564                                           !BCC_EOS
21565                                           ! 3427       if (mf2_state & 0x02) {
21566                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21567 6114           8A46         FB            mov	al,-5[bp]
21568 6117           24                     02  and	al,*2
21569 6119           84C0                       test	al,al
21570 611B           74           1E            je  	.4A6
21571                       0000611D            .4A7:
21572                                           ! 3428         mf2_state |= 0x08;
21573                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
21574 611D           8A46         FB            mov	al,-5[bp]
21575 6120           0C                     08  or	al,*8
21576 6122           8846         FB            mov	-5[bp],al
21577                                           !BCC_EOS
21578                                           ! 3429         write_byte(0x0040, 0x96, mf2_state);
21579                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21580 6125           8A46         FB            mov	al,-5[bp]
21581 6128           30E4                       xor	ah,ah
21582 612A           50                         push	ax
21583                                           ! Debug: list int = const $96 (used reg = )
21584 612B           B8                   0096  mov	ax,#$96
21585 612E           50                         push	ax
21586                                           ! Debug: list int = const $40 (used reg = )
21587 612F           B8                   0040  mov	ax,*$40
21588 6132           50                         push	ax
21589                                           ! Debug: func () void = write_byte+0 (used reg = )
21590 6133           E8         A4E4            call	_write_byte
21591 6136           83C4                   06  add	sp,*6
21592                                           !BCC_EOS
21593                                           ! 3430       } else {
21594 6139           EB           1C            jmp .4A8
21595                       0000613B            .4A6:
21596                                           ! 3431         mf2_flags |= 0x02;
21597                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
21598 613B           8A46         FC            mov	al,-4[bp]
21599 613E           0C                     02  or	al,*2
21600 6140           8846         FC            mov	-4[bp],al
21601                                           !BCC_EOS
21602                                           ! 3432         write_byte(0x0040, 0x18, mf2_flags);
21603                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21604 6143           8A46         FC            mov	al,-4[bp]
21605 6146           30E4                       xor	ah,ah
21606 6148           50                         push	ax
21607                                           ! Debug: list int = const $18 (used reg = )
21608 6149           B8                   0018  mov	ax,*$18
21609 614C           50                         push	ax
21610                                           ! Debug: list int = const $40 (used reg = )
21611 614D           B8                   0040  mov	ax,*$40
21612 6150           50                         push	ax
21613                                           ! Debug: func () void = write_byte+0 (used reg = )
21614 6151           E8         A4C6            call	_write_byte
21615 6154           83C4                   06  add	sp,*6
21616                                           !BCC_EOS
21617                                           ! 3433       }
21618                                           ! 3434       break;
21619                       00006157            .4A8:
21620 6157           E9         03BF            br 	.490
21621                                           !BCC_EOS
21622                                           ! 3435     case 0xb8:
21623                                           ! 3436       shift_flags &= ~0x08;
21624                       0000615A            .4A9:
21625                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
21626 615A           8A46         FD            mov	al,-3[bp]
21627 615D           24                     F7  and	al,#$F7
21628 615F           8846         FD            mov	-3[bp],al
21629                                           !BCC_EOS
21630                                           ! 3437       write_byte(0x0040, 0x17, shift_flags);
21631                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21632 6162           8A46         FD            mov	al,-3[bp]
21633 6165           30E4                       xor	ah,ah
21634 6167           50                         push	ax
21635                                           ! Debug: list int = const $17 (used reg = )
21636 6168           B8                   0017  mov	ax,*$17
21637 616B           50                         push	ax
21638                                           ! Debug: list int = const $40 (used reg = )
21639 616C           B8                   0040  mov	ax,*$40
21640 616F           50                         push	ax
21641                                           ! Debug: func () void = write_byte+0 (used reg = )
21642 6170           E8         A4A7            call	_write_byte
21643 6173           83C4                   06  add	sp,*6
21644                                           !BCC_EOS
21645                                           ! 3438       if (mf2_state & 0x02) {
21646                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21647 6176           8A46         FB            mov	al,-5[bp]
21648 6179           24                     02  and	al,*2
21649 617B           84C0                       test	al,al
21650 617D           74           1E            je  	.4AA
21651                       0000617F            .4AB:
21652                                           ! 3439         mf2_state &= ~0x08;
21653                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
21654 617F           8A46         FB            mov	al,-5[bp]
21655 6182           24                     F7  and	al,#$F7
21656 6184           8846         FB            mov	-5[bp],al
21657                                           !BCC_EOS
21658                                           ! 3440         write_byte(0x0040, 0x96, mf2_state);
21659                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21660 6187           8A46         FB            mov	al,-5[bp]
21661 618A           30E4                       xor	ah,ah
21662 618C           50                         push	ax
21663                                           ! Debug: list int = const $96 (used reg = )
21664 618D           B8                   0096  mov	ax,#$96
21665 6190           50                         push	ax
21666                                           ! Debug: list int = const $40 (used reg = )
21667 6191           B8                   0040  mov	ax,*$40
21668 6194           50                         push	ax
21669                                           ! Debug: func () void = write_byte+0 (used reg = )
21670 6195           E8         A482            call	_write_byte
21671 6198           83C4                   06  add	sp,*6
21672                                           !BCC_EOS
21673                                           ! 3441       } else {
21674 619B           EB           1C            jmp .4AC
21675                       0000619D            .4AA:
21676                                           ! 3442         mf2_flags &= ~0x02;
21677                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
21678 619D           8A46         FC            mov	al,-4[bp]
21679 61A0           24                     FD  and	al,#$FD
21680 61A2           8846         FC            mov	-4[bp],al
21681                                           !BCC_EOS
21682                                           ! 3443         write_byte(0x0040, 0x18, mf2_flags);
21683                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21684 61A5           8A46         FC            mov	al,-4[bp]
21685 61A8           30E4                       xor	ah,ah
21686 61AA           50                         push	ax
21687                                           ! Debug: list int = const $18 (used reg = )
21688 61AB           B8                   0018  mov	ax,*$18
21689 61AE           50                         push	ax
21690                                           ! Debug: list int = const $40 (used reg = )
21691 61AF           B8                   0040  mov	ax,*$40
21692 61B2           50                         push	ax
21693                                           ! Debug: func () void = write_byte+0 (used reg = )
21694 61B3           E8         A464            call	_write_byte
21695 61B6           83C4                   06  add	sp,*6
21696                                           !BCC_EOS
21697                                           ! 3444       }
21698                                           ! 3445       break;
21699                       000061B9            .4AC:
21700 61B9           E9         035D            br 	.490
21701                                           !BCC_EOS
21702                                           ! 3446     case 0x45:
21703                                           ! 3447       if ((mf2_state & 0x03) == 0) {
21704                       000061BC            .4AD:
21705                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
21706 61BC           8A46         FB            mov	al,-5[bp]
21707 61BF           24                     03  and	al,*3
21708                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21709 61C1           84C0                       test	al,al
21710 61C3           75           38            jne 	.4AE
21711                       000061C5            .4AF:
21712                                           ! 3448         mf2_flags |= 0x20;
21713                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
21714 61C5           8A46         FC            mov	al,-4[bp]
21715 61C8           0C                     20  or	al,*$20
21716 61CA           8846         FC            mov	-4[bp],al
21717                                           !BCC_EOS
21718                                           ! 3449         write_byte(0x0040, 0x18, mf2_flags);
21719                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21720 61CD           8A46         FC            mov	al,-4[bp]
21721 61D0           30E4                       xor	ah,ah
21722 61D2           50                         push	ax
21723                                           ! Debug: list int = const $18 (used reg = )
21724 61D3           B8                   0018  mov	ax,*$18
21725 61D6           50                         push	ax
21726                                           ! Debug: list int = const $40 (used reg = )
21727 61D7           B8                   0040  mov	ax,*$40
21728 61DA           50                         push	ax
21729                                           ! Debug: func () void = write_byte+0 (used reg = )
21730 61DB           E8         A43C            call	_write_byte
21731 61DE           83C4                   06  add	sp,*6
21732                                           !BCC_EOS
21733                                           ! 3450         shift_flags ^= 0x20;
21734                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
21735 61E1           8A46         FD            mov	al,-3[bp]
21736 61E4           34                     20  xor	al,*$20
21737 61E6           8846         FD            mov	-3[bp],al
21738                                           !BCC_EOS
21739                                           ! 3451         write_byte(0x0040, 0x17, shift_flags);
21740                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21741 61E9           8A46         FD            mov	al,-3[bp]
21742 61EC           30E4                       xor	ah,ah
21743 61EE           50                         push	ax
21744                                           ! Debug: list int = const $17 (used reg = )
21745 61EF           B8                   0017  mov	ax,*$17
21746 61F2           50                         push	ax
21747                                           ! Debug: list int = const $40 (used reg = )
21748 61F3           B8                   0040  mov	ax,*$40
21749 61F6           50                         push	ax
21750                                           ! Debug: func () void = write_byte+0 (used reg = )
21751 61F7           E8         A420            call	_write_byte
21752 61FA           83C4                   06  add	sp,*6
21753                                           !BCC_EOS
21754                                           ! 3452       }
21755                                           ! 3453       break;
21756                       000061FD            .4AE:
21757 61FD           E9         0319            br 	.490
21758                                           !BCC_EOS
21759                                           ! 3454     case 0xc5:
21760                                           ! 3455       if ((mf2_state & 0x03) == 0) {
21761                       00006200            .4B0:
21762                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
21763 6200           8A46         FB            mov	al,-5[bp]
21764 6203           24                     03  and	al,*3
21765                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21766 6205           84C0                       test	al,al
21767 6207           75           1C            jne 	.4B1
21768                       00006209            .4B2:
21769                                           ! 3456         mf2_flags &= ~0x20;
21770                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
21771 6209           8A46         FC            mov	al,-4[bp]
21772 620C           24                     DF  and	al,#$DF
21773 620E           8846         FC            mov	-4[bp],al
21774                                           !BCC_EOS
21775                                           ! 3457         write_byte(0x0040, 0x18, mf2_flags);
21776                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21777 6211           8A46         FC            mov	al,-4[bp]
21778 6214           30E4                       xor	ah,ah
21779 6216           50                         push	ax
21780                                           ! Debug: list int = const $18 (used reg = )
21781 6217           B8                   0018  mov	ax,*$18
21782 621A           50                         push	ax
21783                                           ! Debug: list int = const $40 (used reg = )
21784 621B           B8                   0040  mov	ax,*$40
21785 621E           50                         push	ax
21786                                           ! Debug: func () void = write_byte+0 (used reg = )
21787 621F           E8         A3F8            call	_write_byte
21788 6222           83C4                   06  add	sp,*6
21789                                           !BCC_EOS
21790                                           ! 3458       }
21791                                           ! 3459       break;
21792                       00006225            .4B1:
21793 6225           E9         02F1            br 	.490
21794                                           !BCC_EOS
21795                                           ! 3460     case 0x46:
21796                                           ! 3461       mf2_flags |= 0x10;
21797                       00006228            .4B3:
21798                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
21799 6228           8A46         FC            mov	al,-4[bp]
21800 622B           0C                     10  or	al,*$10
21801 622D           8846         FC            mov	-4[bp],al
21802                                           !BCC_EOS
21803                                           ! 3462       write_byte(0x0040, 0x18, mf2_flags);
21804                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21805 6230           8A46         FC            mov	al,-4[bp]
21806 6233           30E4                       xor	ah,ah
21807 6235           50                         push	ax
21808                                           ! Debug: list int = const $18 (used reg = )
21809 6236           B8                   0018  mov	ax,*$18
21810 6239           50                         push	ax
21811                                           ! Debug: list int = const $40 (used reg = )
21812 623A           B8                   0040  mov	ax,*$40
21813 623D           50                         push	ax
21814                                           ! Debug: func () void = write_byte+0 (used reg = )
21815 623E           E8         A3D9            call	_write_byte
21816 6241           83C4                   06  add	sp,*6
21817                                           !BCC_EOS
21818                                           ! 3463       shift_flags ^= 0x10;
21819                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
21820 6244           8A46         FD            mov	al,-3[bp]
21821 6247           34                     10  xor	al,*$10
21822 6249           8846         FD            mov	-3[bp],al
21823                                           !BCC_EOS
21824                                           ! 3464       write_byte(0x0040, 0x17, shift_flags);
21825                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21826 624C           8A46         FD            mov	al,-3[bp]
21827 624F           30E4                       xor	ah,ah
21828 6251           50                         push	ax
21829                                           ! Debug: list int = const $17 (used reg = )
21830 6252           B8                   0017  mov	ax,*$17
21831 6255           50                         push	ax
21832                                           ! Debug: list int = const $40 (used reg = )
21833 6256           B8                   0040  mov	ax,*$40
21834 6259           50                         push	ax
21835                                           ! Debug: func () void = write_byte+0 (used reg = )
21836 625A           E8         A3BD            call	_write_byte
21837 625D           83C4                   06  add	sp,*6
21838                                           !BCC_EOS
21839                                           ! 3465       break;
21840 6260           E9         02B6            br 	.490
21841                                           !BCC_EOS
21842                                           ! 3466     case 0xc6:
21843                                           ! 3467       mf2_flags &= ~0x10;
21844                       00006263            .4B4:
21845                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
21846 6263           8A46         FC            mov	al,-4[bp]
21847 6266           24                     EF  and	al,#$EF
21848 6268           8846         FC            mov	-4[bp],al
21849                                           !BCC_EOS
21850                                           ! 3468       write_byte(0x0040, 0x18, mf2_flags);
21851                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21852 626B           8A46         FC            mov	al,-4[bp]
21853 626E           30E4                       xor	ah,ah
21854 6270           50                         push	ax
21855                                           ! Debug: list int = const $18 (used reg = )
21856 6271           B8                   0018  mov	ax,*$18
21857 6274           50                         push	ax
21858                                           ! Debug: list int = const $40 (used reg = )
21859 6275           B8                   0040  mov	ax,*$40
21860 6278           50                         push	ax
21861                                           ! Debug: func () void = write_byte+0 (used reg = )
21862 6279           E8         A39E            call	_write_byte
21863 627C           83C4                   06  add	sp,*6
21864                                           !BCC_EOS
21865                                           ! 3469       break;
21866 627F           E9         0297            br 	.490
21867                                           !BCC_EOS
21868                                           ! 3470     case 0x53:
21869                                           ! 3471         if ((shift_flags & 0x0c) == 0x0c)
21870                       00006282            .4B5:
21871                                           ! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
21872 6282           8A46         FD            mov	al,-3[bp]
21873 6285           24                     0C  and	al,*$C
21874                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
21875 6287           3C                     0C  cmp	al,*$C
21876 6289           75           03            jne 	.4B6
21877                       0000628B            .4B7:
21878                                           ! 3472             machine_reset();
21879                                           ! Debug: func () void = machine_reset+0 (used reg = )
21880 628B           E8         B039            call	_machine_reset
21881                                           !BCC_EOS
21882                                           ! 3473     default:
21883                       0000628E            .4B6:
21884                                           ! 3474       if (scan
21885                       0000628E            .4B8:
21886                                           ! 3474 code & 0x80) {
21887                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
21888 628E           8A46         FF            mov	al,-1[bp]
21889 6291           24                     80  and	al,#$80
21890 6293           84C0                       test	al,al
21891 6295           74           03            je  	.4B9
21892                       00006297            .4BA:
21893                                           ! 3475         break;
21894 6297           E9         027F            br 	.490
21895                                           !BCC_EOS
21896                                           ! 3476       }
21897                                           ! 3477       if (scancode > 0x58) {
21898                       0000629A            .4B9:
21899                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
21900 629A           8A46         FF            mov	al,-1[bp]
21901 629D           3C                     58  cmp	al,*$58
21902 629F           76           04            jbe 	.4BB
21903                       000062A1            .4BC:
21904                                           ! 3478         ;
21905                                           !BCC_EOS
21906                                           ! 3479         return;
21907 62A1           89EC                       mov	sp,bp
21908 62A3           5D                         pop	bp
21909 62A4           C3                         ret
21910                                           !BCC_EOS
21911                                           ! 3480       }
21912                                           ! 3481       if (shift_flags & 0x08) {
21913                       000062A5            .4BB:
21914                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
21915 62A5           8A46         FD            mov	al,-3[bp]
21916 62A8           24                     08  and	al,*8
21917 62AA           84C0                       test	al,al
21918 62AC           74           3D            je  	.4BD
21919                       000062AE            .4BE:
21920                                           ! 3482         asciicode = scan_to_scanascii[scancode].alt;
21921                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
21922 62AE           8A46         FF            mov	al,-1[bp]
21923 62B1           30E4                       xor	ah,ah
21924 62B3           89C2                       mov	dx,ax
21925 62B5           D1E0                       shl	ax,*1
21926 62B7           D1E0                       shl	ax,*1
21927 62B9           01D0                       add	ax,dx
21928 62BB           D1E0                       shl	ax,*1
21929 62BD           89C3                       mov	bx,ax
21930 62BF           81C3                 01C4  add	bx,#_scan_to_scanascii
21931                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
21932 62C3           8A47         06            mov	al,6[bx]
21933 62C6           8846         FE            mov	-2[bp],al
21934                                           !BCC_EOS
21935                                           ! 3483         scancode = scan_to_scanascii[scancode].alt >> 8;
21936                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
21937 62C9           8A46         FF            mov	al,-1[bp]
21938 62CC           30E4                       xor	ah,ah
21939 62CE           89C2                       mov	dx,ax
21940 62D0           D1E0                       shl	ax,*1
21941 62D2           D1E0                       shl	ax,*1
21942 62D4           01D0                       add	ax,dx
21943 62D6           D1E0                       shl	ax,*1
21944 62D8           89C3                       mov	bx,ax
21945 62DA           81C3                 01C4  add	bx,#_scan_to_scanascii
21946                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
21947 62DE           8B47         06            mov	ax,6[bx]
21948 62E1           88E0                       mov	al,ah
21949 62E3           30E4                       xor	ah,ah
21950                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
21951 62E5           8846         FF            mov	-1[bp],al
21952                                           !BCC_EOS
21953                                           ! 3484       } else if (shift_flags & 0x04) {
21954 62E8           E9         01AD            br 	.4BF
21955                       000062EB            .4BD:
21956                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
21957 62EB           8A46         FD            mov	al,-3[bp]
21958 62EE           24                     04  and	al,*4
21959 62F0           84C0                       test	al,al
21960 62F2           74           3D            je  	.4C0
21961                       000062F4            .4C1:
21962                                           ! 3485         asciicode = scan_to_scanascii[scancode].control;
21963                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
21964 62F4           8A46         FF            mov	al,-1[bp]
21965 62F7           30E4                       xor	ah,ah
21966 62F9           89C2                       mov	dx,ax
21967 62FB           D1E0                       shl	ax,*1
21968 62FD           D1E0                       shl	ax,*1
21969 62FF           01D0                       add	ax,dx
21970 6301           D1E0                       shl	ax,*1
21971 6303           89C3                       mov	bx,ax
21972 6305           81C3                 01C4  add	bx,#_scan_to_scanascii
21973                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
21974 6309           8A47         04            mov	al,4[bx]
21975 630C           8846         FE            mov	-2[bp],al
21976                                           !BCC_EOS
21977                                           ! 3486         scancode = scan_to_scanascii[scancode].control >> 8;
21978                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
21979 630F           8A46         FF            mov	al,-1[bp]
21980 6312           30E4                       xor	ah,ah
21981 6314           89C2                       mov	dx,ax
21982 6316           D1E0                       shl	ax,*1
21983 6318           D1E0                       shl	ax,*1
21984 631A           01D0                       add	ax,dx
21985 631C           D1E0                       shl	ax,*1
21986 631E           89C3                       mov	bx,ax
21987 6320           81C3                 01C4  add	bx,#_scan_to_scanascii
21988                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
21989 6324           8B47         04            mov	ax,4[bx]
21990 6327           88E0                       mov	al,ah
21991 6329           30E4                       xor	ah,ah
21992                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
21993 632B           8846         FF            mov	-1[bp],al
21994                                           !BCC_EOS
21995                                           ! 3487       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
21996 632E           E9         0167            br 	.4C2
21997                       00006331            .4C0:
21998                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21999 6331           8A46         FB            mov	al,-5[bp]
22000 6334           24                     02  and	al,*2
22001                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
22002 6336           84C0                       test	al,al
22003 6338           74           32            je  	.4C3
22004                       0000633A            .4C5:
22005                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
22006 633A           8A46         FF            mov	al,-1[bp]
22007 633D           3C                     47  cmp	al,*$47
22008 633F           72           2B            jb  	.4C3
22009                       00006341            .4C6:
22010                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
22011 6341           8A46         FF            mov	al,-1[bp]
22012 6344           3C                     53  cmp	al,*$53
22013 6346           77           24            ja  	.4C3
22014                       00006348            .4C4:
22015                                           ! 3488         asciicode = 0xe0;
22016                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
22017 6348           B0                     E0  mov	al,#$E0
22018 634A           8846         FE            mov	-2[bp],al
22019                                           !BCC_EOS
22020                                           ! 3489         scancode = scan_to_scanascii[scancode].normal >> 8;
22021                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22022 634D           8A46         FF            mov	al,-1[bp]
22023 6350           30E4                       xor	ah,ah
22024 6352           89C2                       mov	dx,ax
22025 6354           D1E0                       shl	ax,*1
22026 6356           D1E0                       shl	ax,*1
22027 6358           01D0                       add	ax,dx
22028 635A           D1E0                       shl	ax,*1
22029 635C           89C3                       mov	bx,ax
22030                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22031 635E           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22032 6362           88E0                       mov	al,ah
22033 6364           30E4                       xor	ah,ah
22034                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22035 6366           8846         FF            mov	-1[bp],al
22036                                           !BCC_EOS
22037                                           ! 3490       } else if (shift_flags & 0x03) {
22038 6369           E9         012C            br 	.4C7
22039                       0000636C            .4C3:
22040                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
22041 636C           8A46         FD            mov	al,-3[bp]
22042 636F           24                     03  and	al,*3
22043 6371           84C0                       test	al,al
22044 6373         0F84         0092            beq 	.4C8
22045                       00006377            .4C9:
22046                                           ! 3491         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22047                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22048 6377           8A46         FF            mov	al,-1[bp]
22049 637A           30E4                       xor	ah,ah
22050 637C           89C2                       mov	dx,ax
22051 637E           D1E0                       shl	ax,*1
22052 6380           D1E0                       shl	ax,*1
22053 6382           01D0                       add	ax,dx
22054 6384           D1E0                       shl	ax,*1
22055 6386           89C3                       mov	bx,ax
22056 6388           81C3                 01C4  add	bx,#_scan_to_scanascii
22057                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22058 638C           8A46         FD            mov	al,-3[bp]
22059 638F           2247         08            and	al,8[bx]
22060 6392           84C0                       test	al,al
22061 6394           74           36            je  	.4CA
22062                       00006396            .4CB:
22063                                           ! 3492           asciicode = scan_to_scanascii[scancode].normal;
22064                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22065 6396           8A46         FF            mov	al,-1[bp]
22066 6399           30E4                       xor	ah,ah
22067 639B           89C2                       mov	dx,ax
22068 639D           D1E0                       shl	ax,*1
22069 639F           D1E0                       shl	ax,*1
22070 63A1           01D0                       add	ax,dx
22071 63A3           D1E0                       shl	ax,*1
22072 63A5           89C3                       mov	bx,ax
22073                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22074 63A7           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22075 63AB           8846         FE            mov	-2[bp],al
22076                                           !BCC_EOS
22077                                           ! 3493           scancode = scan_to_scanascii[scancode].normal >> 8;
22078                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22079 63AE           8A46         FF            mov	al,-1[bp]
22080 63B1           30E4                       xor	ah,ah
22081 63B3           89C2                       mov	dx,ax
22082 63B5           D1E0                       shl	ax,*1
22083 63B7           D1E0                       shl	ax,*1
22084 63B9           01D0                       add	ax,dx
22085 63BB           D1E0                       shl	ax,*1
22086 63BD           89C3                       mov	bx,ax
22087                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22088 63BF           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22089 63C3           88E0                       mov	al,ah
22090 63C5           30E4                       xor	ah,ah
22091                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22092 63C7           8846         FF            mov	-1[bp],al
22093                                           !BCC_EOS
22094                                           ! 3494         } else {
22095 63CA           EB           3A            jmp .4CC
22096                       000063CC            .4CA:
22097                                           ! 3495           asciicode = scan_to_scanascii[scancode].shift;
22098                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22099 63CC           8A46         FF            mov	al,-1[bp]
22100 63CF           30E4                       xor	ah,ah
22101 63D1           89C2                       mov	dx,ax
22102 63D3           D1E0                       shl	ax,*1
22103 63D5           D1E0                       shl	ax,*1
22104 63D7           01D0                       add	ax,dx
22105 63D9           D1E0                       shl	ax,*1
22106 63DB           89C3                       mov	bx,ax
22107 63DD           81C3                 01C4  add	bx,#_scan_to_scanascii
22108                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22109 63E1           8A47         02            mov	al,2[bx]
22110 63E4           8846         FE            mov	-2[bp],al
22111                                           !BCC_EOS
22112                                           ! 3496           scancode = scan_to_scanascii[scancode].shift >> 8;
22113                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22114 63E7           8A46         FF            mov	al,-1[bp]
22115 63EA           30E4                       xor	ah,ah
22116 63EC           89C2                       mov	dx,ax
22117 63EE           D1E0                       shl	ax,*1
22118 63F0           D1E0                       shl	ax,*1
22119 63F2           01D0                       add	ax,dx
22120 63F4           D1E0                       shl	ax,*1
22121 63F6           89C3                       mov	bx,ax
22122 63F8           81C3                 01C4  add	bx,#_scan_to_scanascii
22123                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22124 63FC           8B47         02            mov	ax,2[bx]
22125 63FF           88E0                       mov	al,ah
22126 6401           30E4                       xor	ah,ah
22127                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22128 6403           8846         FF            mov	-1[bp],al
22129                                           !BCC_EOS
22130                                           ! 3497         }
22131                                           ! 3498       } else {
22132                       00006406            .4CC:
22133 6406           E9         008F            br 	.4CD
22134                       00006409            .4C8:
22135                                           ! 3499         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22136                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22137 6409           8A46         FF            mov	al,-1[bp]
22138 640C           30E4                       xor	ah,ah
22139 640E           89C2                       mov	dx,ax
22140 6410           D1E0                       shl	ax,*1
22141 6412           D1E0                       shl	ax,*1
22142 6414           01D0                       add	ax,dx
22143 6416           D1E0                       shl	ax,*1
22144 6418           89C3                       mov	bx,ax
22145 641A           81C3                 01C4  add	bx,#_scan_to_scanascii
22146                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22147 641E           8A46         FD            mov	al,-3[bp]
22148 6421           2247         08            and	al,8[bx]
22149 6424           84C0                       test	al,al
22150 6426           74           3C            je  	.4CE
22151                       00006428            .4CF:
22152                                           ! 3500           asciicode = scan_to_scanascii[scancode].shift;
22153                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22154 6428           8A46         FF            mov	al,-1[bp]
22155 642B           30E4                       xor	ah,ah
22156 642D           89C2                       mov	dx,ax
22157 642F           D1E0                       shl	ax,*1
22158 6431           D1E0                       shl	ax,*1
22159 6433           01D0                       add	ax,dx
22160 6435           D1E0                       shl	ax,*1
22161 6437           89C3                       mov	bx,ax
22162 6439           81C3                 01C4  add	bx,#_scan_to_scanascii
22163                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22164 643D           8A47         02            mov	al,2[bx]
22165 6440           8846         FE            mov	-2[bp],al
22166                                           !BCC_EOS
22167                                           ! 3501           scancode = scan_to_scanascii[scancode].shift >> 8;
22168                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22169 6443           8A46         FF            mov	al,-1[bp]
22170 6446           30E4                       xor	ah,ah
22171 6448           89C2                       mov	dx,ax
22172 644A           D1E0                       shl	ax,*1
22173 644C           D1E0                       shl	ax,*1
22174 644E           01D0                       add	ax,dx
22175 6450           D1E0                       shl	ax,*1
22176 6452           89C3                       mov	bx,ax
22177 6454           81C3                 01C4  add	bx,#_scan_to_scanascii
22178                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22179 6458           8B47         02            mov	ax,2[bx]
22180 645B           88E0                       mov	al,ah
22181 645D           30E4                       xor	ah,ah
22182                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22183 645F           8846         FF            mov	-1[bp],al
22184                                           !BCC_EOS
22185                                           ! 3502         } else {
22186 6462           EB           34            jmp .4D0
22187                       00006464            .4CE:
22188                                           ! 3503           asciicode = scan_to_scanascii[scancode].normal;
22189                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22190 6464           8A46         FF            mov	al,-1[bp]
22191 6467           30E4                       xor	ah,ah
22192 6469           89C2                       mov	dx,ax
22193 646B           D1E0                       shl	ax,*1
22194 646D           D1E0                       shl	ax,*1
22195 646F           01D0                       add	ax,dx
22196 6471           D1E0                       shl	ax,*1
22197 6473           89C3                       mov	bx,ax
22198                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22199 6475           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22200 6479           8846         FE            mov	-2[bp],al
22201                                           !BCC_EOS
22202                                           ! 3504           scancode = scan_to_scanascii[scancode].normal >> 8;
22203                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22204 647C           8A46         FF            mov	al,-1[bp]
22205 647F           30E4                       xor	ah,ah
22206 6481           89C2                       mov	dx,ax
22207 6483           D1E0                       shl	ax,*1
22208 6485           D1E0                       shl	ax,*1
22209 6487           01D0                       add	ax,dx
22210 6489           D1E0                       shl	ax,*1
22211 648B           89C3                       mov	bx,ax
22212                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22213 648D           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22214 6491           88E0                       mov	al,ah
22215 6493           30E4                       xor	ah,ah
22216                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22217 6495           8846         FF            mov	-1[bp],al
22218                                           !BCC_EOS
22219                                           ! 3505         }
22220                                           ! 3506       }
22221                       00006498            .4D0:
22222                                           ! 3507       if (scancode==0 && asciicode==0) {
22223                       00006498            .4CD:
22224                       00006498            .4C7:
22225                       00006498            .4C2:
22226                       00006498            .4BF:
22227                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
22228 6498           8A46         FF            mov	al,-1[bp]
22229 649B           84C0                       test	al,al
22230 649D           75           07            jne 	.4D1
22231                       0000649F            .4D3:
22232                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
22233 649F           8A46         FE            mov	al,-2[bp]
22234 64A2           84C0                       test	al,al
22235 64A4           75           00            jne 	.4D1
22236                       000064A6            .4D2:
22237                                           ! 3508         ;
22238                                           !BCC_EOS
22239                                           ! 3509       }
22240                                           ! 3510       enqueue_key(scancode, asciicode);
22241                       000064A6            .4D1:
22242                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
22243 64A6           8A46         FE            mov	al,-2[bp]
22244 64A9           30E4                       xor	ah,ah
22245 64AB           50                         push	ax
22246                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
22247 64AC           8A46         FF            mov	al,-1[bp]
22248 64AF           30E4                       xor	ah,ah
22249 64B1           50                         push	ax
22250                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
22251 64B2           E8         0095            call	_enqueue_key
22252 64B5           83C4                   04  add	sp,*4
22253                                           !BCC_EOS
22254                                           ! 3511       break;
22255 64B8           EB           5F            jmp .490
22256                                           !BCC_EOS
22257                                           ! 3512   }
22258                                           ! 3513   if ((scancode & 0x7f) != 0x1d) {
22259 64BA           EB           5D            jmp .490
22260                       000064BC            .492:
22261 64BC           2C                     1D  sub	al,*$1D
22262 64BE         0F84         FB60            beq 	.499
22263 64C2           2C                     0D  sub	al,*$D
22264 64C4         0F84         FADE            beq 	.495
22265 64C8           2C                     0C  sub	al,*$C
22266 64CA         0F84         FB16            beq 	.497
22267 64CE           2C                     02  sub	al,*2
22268 64D0         0F84         FC24            beq 	.4A5
22269 64D4           2C                     02  sub	al,*2
22270 64D6         0F84         FA72            beq 	.493
22271 64DA           2C                     0B  sub	al,*$B
22272 64DC         0F84         FCDC            beq 	.4AD
22273 64E0           2C                     01  sub	al,*1
22274 64E2         0F84         FD42            beq 	.4B3
22275 64E6           2C                     0D  sub	al,*$D
22276 64E8         0F84         FD96            beq 	.4B5
22277 64EC           2C                     4A  sub	al,*$4A
22278 64EE         0F84         FB9B            beq 	.49F
22279 64F2           2C                     0D  sub	al,*$D
22280 64F4         0F84         FACD            beq 	.496
22281 64F8           2C                     0C  sub	al,*$C
22282 64FA         0F84         FB05            beq 	.498
22283 64FE           2C                     02  sub	al,*2
22284 6500         0F84         FC56            beq 	.4A9
22285 6504           2C                     02  sub	al,*2
22286 6506         0F84         FA7D            beq 	.494
22287 650A           2C                     0B  sub	al,*$B
22288 650C         0F84         FCF0            beq 	.4B0
22289 6510           2C                     01  sub	al,*1
22290 6512         0F84         FD4D            beq 	.4B4
22291 6516           E9         FD75            br 	.4B8
22292                       00006519            .490:
22293                       FFFFFFF8            ..FFF2	=	-8
22294                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
22295 6519           8A46         FF            mov	al,-1[bp]
22296 651C           24                     7F  and	al,*$7F
22297                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
22298 651E           3C                     1D  cmp	al,*$1D
22299 6520           74           08            je  	.4D4
22300                       00006522            .4D5:
22301                                           ! 3514     mf2_state &= ~0x01;
22302                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
22303 6522           8A46         FB            mov	al,-5[bp]
22304 6525           24                     FE  and	al,#$FE
22305 6527           8846         FB            mov	-5[bp],al
22306                                           !BCC_EOS
22307                                           ! 3515   }
22308                                           ! 3516   mf2_state &= ~0x02;
22309                       0000652A            .4D4:
22310                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
22311 652A           8A46         FB            mov	al,-5[bp]
22312 652D           24                     FD  and	al,#$FD
22313 652F           8846         FB            mov	-5[bp],al
22314                                           !BCC_EOS
22315                                           ! 3517   write_byte(0x0040, 0x96, mf2_state);
22316                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22317 6532           8A46         FB            mov	al,-5[bp]
22318 6535           30E4                       xor	ah,ah
22319 6537           50                         push	ax
22320                                           ! Debug: list int = const $96 (used reg = )
22321 6538           B8                   0096  mov	ax,#$96
22322 653B           50                         push	ax
22323                                           ! Debug: list int = const $40 (used reg = )
22324 653C           B8                   0040  mov	ax,*$40
22325 653F           50                         push	ax
22326                                           ! Debug: func () void = write_byte+0 (used reg = )
22327 6540           E8         A0D7            call	_write_byte
22328 6543           83C4                   06  add	sp,*6
22329                                           !BCC_EOS
22330                                           ! 3518 }
22331 6546           89EC                       mov	sp,bp
22332 6548           5D                         pop	bp
22333 6549           C3                         ret
22334                                           ! 3519   unsigned int
22335                                           ! Register BX used in function int09_function
22336                                           ! 3520 enqueue_key(scan_code, ascii_code)
22337                                           ! 3521   Bit8u scan_code, ascii_code;
22338                                           export	_enqueue_key
22339                       0000654A            _enqueue_key:
22340                                           !BCC_EOS
22341                                           ! 3522 {
22342                                           ! 3523   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
22343                                           !BCC_EOS
22344                                           ! 3524   buffer_start = read_word(0x0040, 0x0080);
22345 654A           55                         push	bp
22346 654B           89E5                       mov	bp,sp
22347 654D           83C4                   F6  add	sp,*-$A
22348                                           ! Debug: list int = const $80 (used reg = )
22349 6550           B8                   0080  mov	ax,#$80
22350 6553           50                         push	ax
22351                                           ! Debug: list int = const $40 (used reg = )
22352 6554           B8                   0040  mov	ax,*$40
22353 6557           50                         push	ax
22354                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22355 6558           E8         A0AC            call	_read_word
22356 655B           83C4                   04  add	sp,*4
22357                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
22358 655E           8946         FE            mov	-2[bp],ax
22359                                           !BCC_EOS
22360                                           ! 3525   buffer_end = read_word(0x0040, 0x0082);
22361                                           ! Debug: list int = const $82 (used reg = )
22362 6561           B8                   0082  mov	ax,#$82
22363 6564           50                         push	ax
22364                                           ! Debug: list int = const $40 (used reg = )
22365 6565           B8                   0040  mov	ax,*$40
22366 6568           50                         push	ax
22367                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22368 6569           E8         A09B            call	_read_word
22369 656C           83C4                   04  add	sp,*4
22370                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
22371 656F           8946         FC            mov	-4[bp],ax
22372                                           !BCC_EOS
22373                                           ! 3526   buffer_head = read_word(0x0040, 0x001A);
22374                                           ! Debug: list int = const $1A (used reg = )
22375 6572           B8                   001A  mov	ax,*$1A
22376 6575           50                         push	ax
22377                                           ! Debug: list int = const $40 (used reg = )
22378 6576           B8                   0040  mov	ax,*$40
22379 6579           50                         push	ax
22380                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22381 657A           E8         A08A            call	_read_word
22382 657D           83C4                   04  add	sp,*4
22383                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
22384 6580           8946         FA            mov	-6[bp],ax
22385                                           !BCC_EOS
22386                                           ! 3527   buffer_tail = read_word(0x0040, 0x001C);
22387                                           ! Debug: list int = const $1C (used reg = )
22388 6583           B8                   001C  mov	ax,*$1C
22389 6586           50                         push	ax
22390                                           ! Debug: list int = const $40 (used reg = )
22391 6587           B8                   0040  mov	ax,*$40
22392 658A           50                         push	ax
22393                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22394 658B           E8         A079            call	_read_word
22395 658E           83C4                   04  add	sp,*4
22396                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22397 6591           8946         F8            mov	-8[bp],ax
22398                                           !BCC_EOS
22399                                           ! 3528   temp_tail = buffer_tail;
22400                                           ! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
22401 6594           8B46         F8            mov	ax,-8[bp]
22402 6597           8946         F6            mov	-$A[bp],ax
22403                                           !BCC_EOS
22404                                           ! 3529   buffer_tail += 2;
22405                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22406 659A           8B46         F8            mov	ax,-8[bp]
22407 659D           40                         inc	ax
22408 659E           40                         inc	ax
22409 659F           8946         F8            mov	-8[bp],ax
22410                                           !BCC_EOS
22411                                           ! 3530   if (buffer_tail >= buffer_end)
22412                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22413 65A2           8B46         F8            mov	ax,-8[bp]
22414 65A5           3B46         FC            cmp	ax,-4[bp]
22415 65A8           72           06            jb  	.4D6
22416                       000065AA            .4D7:
22417                                           ! 3531     buffer_tail = buffer_start;
22418                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22419 65AA           8B46         FE            mov	ax,-2[bp]
22420 65AD           8946         F8            mov	-8[bp],ax
22421                                           !BCC_EOS
22422                                           ! 3532   if (buffer_tail == buffer_head) {
22423                       000065B0            .4D6:
22424                                           ! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22425 65B0           8B46         F8            mov	ax,-8[bp]
22426 65B3           3B46         FA            cmp	ax,-6[bp]
22427 65B6           75           06            jne 	.4D8
22428                       000065B8            .4D9:
22429                                           ! 3533     return(0);
22430 65B8           31C0                       xor	ax,ax
22431 65BA           89EC                       mov	sp,bp
22432 65BC           5D                         pop	bp
22433 65BD           C3                         ret
22434                                           !BCC_EOS
22435                                           ! 3534     }
22436                                           ! 3535    wr
22437                                           ! 3535 ite_byte(0x0040, temp_tail, ascii_code);
22438                       000065BE            .4D8:
22439                                           ! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
22440 65BE           8A46         06            mov	al,6[bp]
22441 65C1           30E4                       xor	ah,ah
22442 65C3           50                         push	ax
22443                                           ! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
22444 65C4           FF76         F6            push	-$A[bp]
22445                                           ! Debug: list int = const $40 (used reg = )
22446 65C7           B8                   0040  mov	ax,*$40
22447 65CA           50                         push	ax
22448                                           ! Debug: func () void = write_byte+0 (used reg = )
22449 65CB           E8         A04C            call	_write_byte
22450 65CE           83C4                   06  add	sp,*6
22451                                           !BCC_EOS
22452                                           ! 3536    write_byte(0x0040, temp_tail+1, scan_code);
22453                                           ! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
22454 65D1           8A46         04            mov	al,4[bp]
22455 65D4           30E4                       xor	ah,ah
22456 65D6           50                         push	ax
22457                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
22458 65D7           8B46         F6            mov	ax,-$A[bp]
22459                                           ! Debug: list unsigned int = ax+1 (used reg = )
22460 65DA           40                         inc	ax
22461 65DB           50                         push	ax
22462                                           ! Debug: list int = const $40 (used reg = )
22463 65DC           B8                   0040  mov	ax,*$40
22464 65DF           50                         push	ax
22465                                           ! Debug: func () void = write_byte+0 (used reg = )
22466 65E0           E8         A037            call	_write_byte
22467 65E3           83C4                   06  add	sp,*6
22468                                           !BCC_EOS
22469                                           ! 3537    write_word(0x0040, 0x001C, buffer_tail);
22470                                           ! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
22471 65E6           FF76         F8            push	-8[bp]
22472                                           ! Debug: list int = const $1C (used reg = )
22473 65E9           B8                   001C  mov	ax,*$1C
22474 65EC           50                         push	ax
22475                                           ! Debug: list int = const $40 (used reg = )
22476 65ED           B8                   0040  mov	ax,*$40
22477 65F0           50                         push	ax
22478                                           ! Debug: func () void = write_word+0 (used reg = )
22479 65F1           E8         A03E            call	_write_word
22480 65F4           83C4                   06  add	sp,*6
22481                                           !BCC_EOS
22482                                           ! 3538    return(1);
22483 65F7           B8                   0001  mov	ax,*1
22484 65FA           89EC                       mov	sp,bp
22485 65FC           5D                         pop	bp
22486 65FD           C3                         ret
22487                                           !BCC_EOS
22488                                           ! 3539 }
22489                                           ! 3540   void
22490                                           ! 3541 int74_function(make_farcall, Z, Y, X, status)
22491                                           ! 3542   Bit16u make_farcall, Z, Y, X, status;
22492                                           export	_int74_function
22493                       000065FE            _int74_function:
22494                                           !BCC_EOS
22495                                           ! 3543 {
22496                                           ! 3544   Bit16u ebda_seg=read_word(0x0040,0x000E);
22497 65FE           55                         push	bp
22498 65FF           89E5                       mov	bp,sp
22499 6601           4C                         dec	sp
22500 6602           4C                         dec	sp
22501                                           ! Debug: list int = const $E (used reg = )
22502 6603           B8                   000E  mov	ax,*$E
22503 6606           50                         push	ax
22504                                           ! Debug: list int = const $40 (used reg = )
22505 6607           B8                   0040  mov	ax,*$40
22506 660A           50                         push	ax
22507                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22508 660B           E8         9FF9            call	_read_word
22509 660E           83C4                   04  add	sp,*4
22510                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
22511 6611           8946         FE            mov	-2[bp],ax
22512                                           !BCC_EOS
22513                                           ! 3545   Bit8u in_byte, index, package_count;
22514                                           !BCC_EOS
22515                                           ! 3546   Bit8u mouse_flags_1, mouse_flags_2;
22516                                           !BCC_EOS
22517                                           ! 3547 ;
22518 6614           83C4                   FA  add	sp,*-6
22519                                           !BCC_EOS
22520                                           ! 3548   make_farcall = 0;
22521                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
22522 6617           31C0                       xor	ax,ax
22523 6619           8946         04            mov	4[bp],ax
22524                                           !BCC_EOS
22525                                           ! 3549   in_byte = inb(0x64);
22526                                           ! Debug: list int = const $64 (used reg = )
22527 661C           B8                   0064  mov	ax,*$64
22528 661F           50                         push	ax
22529                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22530 6620           E8         9F1B            call	_inb
22531 6623           44                         inc	sp
22532 6624           44                         inc	sp
22533                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
22534 6625           8846         FD            mov	-3[bp],al
22535                                           !BCC_EOS
22536                                           ! 3550   if ( (in_byte & 0x21) != 0x21 ) {
22537                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
22538 6628           8A46         FD            mov	al,-3[bp]
22539 662B           24                     21  and	al,*$21
22540                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
22541 662D           3C                     21  cmp	al,*$21
22542 662F           74           04            je  	.4DA
22543                       00006631            .4DB:
22544                                           ! 3551     return;
22545 6631           89EC                       mov	sp,bp
22546 6633           5D                         pop	bp
22547 6634           C3                         ret
22548                                           !BCC_EOS
22549                                           ! 3552     }
22550                                           ! 3553   in_byte = inb(0x60);
22551                       00006635            .4DA:
22552                                           ! Debug: list int = const $60 (used reg = )
22553 6635           B8                   0060  mov	ax,*$60
22554 6638           50                         push	ax
22555                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22556 6639           E8         9F02            call	_inb
22557 663C           44                         inc	sp
22558 663D           44                         inc	sp
22559                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
22560 663E           8846         FD            mov	-3[bp],al
22561                                           !BCC_EOS
22562                                           ! 3554 ;
22563                                           !BCC_EOS
22564                                           ! 3555   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
22565                                           ! Debug: list int = const $26 (used reg = )
22566 6641           B8                   0026  mov	ax,*$26
22567 6644           50                         push	ax
22568                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22569 6645           FF76         FE            push	-2[bp]
22570                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22571 6648           E8         9FA9            call	_read_byte
22572 664B           83C4                   04  add	sp,*4
22573                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22574 664E           8846         FA            mov	-6[bp],al
22575                                           !BCC_EOS
22576                                           ! 3556   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
22577                                           ! Debug: list int = const $27 (used reg = )
22578 6651           B8                   0027  mov	ax,*$27
22579 6654           50                         push	ax
22580                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22581 6655           FF76         FE            push	-2[bp]
22582                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22583 6658           E8         9F99            call	_read_byte
22584 665B           83C4                   04  add	sp,*4
22585                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22586 665E           8846         F9            mov	-7[bp],al
22587                                           !BCC_EOS
22588                                           ! 3557   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
22589                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22590 6661           8A46         F9            mov	al,-7[bp]
22591 6664           24                     80  and	al,#$80
22592                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
22593 6666           3C                     80  cmp	al,#$80
22594 6668           74           04            je  	.4DC
22595                       0000666A            .4DD:
22596                                           ! 3558       return;
22597 666A           89EC                       mov	sp,bp
22598 666C           5D                         pop	bp
22599 666D           C3                         ret
22600                                           !BCC_EOS
22601                                           ! 3559   }
22602                                           ! 3560   package_count = mouse_flags_2 & 0x07;
22603                       0000666E            .4DC:
22604                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22605 666E           8A46         F9            mov	al,-7[bp]
22606 6671           24                     07  and	al,*7
22607                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
22608 6673           8846         FB            mov	-5[bp],al
22609                                           !BCC_EOS
22610                                           ! 3561   index = mouse_flags_1 & 0x07;
22611                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22612 6676           8A46         FA            mov	al,-6[bp]
22613 6679           24                     07  and	al,*7
22614                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
22615 667B           8846         FC            mov	-4[bp],al
22616                                           !BCC_EOS
22617                                           ! 3562   write_byte(ebda_seg, 0x28 + index, in_byte);
22618                                           ! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
22619 667E           8A46         FD            mov	al,-3[bp]
22620 6681           30E4                       xor	ah,ah
22621 6683           50                         push	ax
22622                                           ! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
22623                                           ! Debug: expression subtree swapping
22624 6684           8A46         FC            mov	al,-4[bp]
22625 6687           30E4                       xor	ah,ah
22626                                           ! Debug: list unsigned int = ax+$28 (used reg = )
22627 6689           05                   0028  add	ax,*$28
22628 668C           50                         push	ax
22629                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
22630 668D           FF76         FE            push	-2[bp]
22631                                           ! Debug: func () void = write_byte+0 (used reg = )
22632 6690           E8         9F87            call	_write_byte
22633 6693           83C4                   06  add	sp,*6
22634                                           !BCC_EOS
22635                                           ! 3563   if ( (index+1) >= package_count ) {
22636                                           ! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
22637 6696           8A46         FC            mov	al,-4[bp]
22638 6699           30E4                       xor	ah,ah
22639                                           ! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
22640 669B           40                         inc	ax
22641 669C           50                         push	ax
22642 669D           8A46         FB            mov	al,-5[bp]
22643 66A0           30E4                       xor	ah,ah
22644 66A2           3B46         F6            cmp	ax,-$A[bp]
22645 66A5           8D66         F8            lea	sp,-8[bp]
22646 66A8           77           51            ja  	.4DE
22647                       000066AA            .4DF:
22648                                           ! 3564 ;
22649                                           !BCC_EOS
22650                                           ! 3565     status = read_byte(ebda_seg, 0x0028 + 0);
22651                                           ! Debug: list int = const $28 (used reg = )
22652 66AA           B8                   0028  mov	ax,*$28
22653 66AD           50                         push	ax
22654                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22655 66AE           FF76         FE            push	-2[bp]
22656                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22657 66B1           E8         9F40            call	_read_byte
22658 66B4           83C4                   04  add	sp,*4
22659                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
22660 66B7           30E4                       xor	ah,ah
22661 66B9           8946         0C            mov	$C[bp],ax
22662                                           !BCC_EOS
22663                                           ! 3566     X = read_byte(ebda_seg, 0x0028 + 1);
22664                                           ! Debug: list int = const $29 (used reg = )
22665 66BC           B8                   0029  mov	ax,*$29
22666 66BF           50                         push	ax
22667                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22668 66C0           FF76         FE            push	-2[bp]
22669                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22670 66C3           E8         9F2E            call	_read_byte
22671 66C6           83C4                   04  add	sp,*4
22672                                           ! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
22673 66C9           30E4                       xor	ah,ah
22674 66CB           8946         0A            mov	$A[bp],ax
22675                                           !BCC_EOS
22676                                           ! 3567     Y = read_byte(ebda_seg, 0x0028 + 2);
22677                                           ! Debug: list int = const $2A (used reg = )
22678 66CE           B8                   002A  mov	ax,*$2A
22679 66D1           50                         push	ax
22680                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22681 66D2           FF76         FE            push	-2[bp]
22682                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22683 66D5           E8         9F1C            call	_read_byte
22684 66D8           83C4                   04  add	sp,*4
22685                                           ! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
22686 66DB           30E4                       xor	ah,ah
22687 66DD           8946         08            mov	8[bp],ax
22688                                           !BCC_EOS
22689                                           ! 3568     Z = 0;
22690                                           ! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
22691 66E0           31C0                       xor	ax,ax
22692 66E2           8946         06            mov	6[bp],ax
22693                                           !BCC_EOS
22694                                           ! 3569     mouse_flags_1 = 0;
22695                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22696 66E5           30C0                       xor	al,al
22697 66E7           8846         FA            mov	-6[bp],al
22698                                           !BCC_EOS
22699                                           ! 3570     if (mouse_flags_2 & 0x80)
22700                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22701 66EA           8A46         F9            mov	al,-7[bp]
22702 66ED           24                     80  and	al,#$80
22703 66EF           84C0                       test	al,al
22704 66F1           74           06            je  	.4E0
22705                       000066F3            .4E1:
22706                                           ! 3571       make_farcall = 1;
22707                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
22708 66F3           B8                   0001  mov	ax,*1
22709 66F6           8946         04            mov	4[bp],ax
22710                                           !BCC_EOS
22711                                           ! 3572     }
22712                       000066F9            .4E0:
22713                                           ! 3573   else {
22714 66F9           EB           07            jmp .4E2
22715                       000066FB            .4DE:
22716                                           ! 3574     mouse_flags_1++;
22717                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22718 66FB           8A46         FA            mov	al,-6[bp]
22719 66FE           40                         inc	ax
22720 66FF           8846         FA            mov	-6[bp],al
22721                                           !BCC_EOS
22722                                           ! 3575     }
22723                                           ! 3576   write_byte(ebda_seg, 0x0026, mouse_flags_1);
22724                       00006702            .4E2:
22725                                           ! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22726 6702           8A46         FA            mov	al,-6[bp]
22727 6705           30E4                       xor	ah,ah
22728 6707           50                         push	ax
22729                                           ! Debug: list int = const $26 (used reg = )
22730 6708           B8                   0026  mov	ax,*$26
22731 670B           50                         push	ax
22732                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
22733 670C           FF76         FE            push	-2[bp]
22734                                           ! Debug: func () void = write_byte+0 (used reg = )
22735 670F           E8         9F08            call	_write_byte
22736 6712           83C4                   06  add	sp,*6
22737                                           !BCC_EOS
22738                                           ! 3577 }
22739 6715           89EC                       mov	sp,bp
22740 6717           5D                         pop	bp
22741 6718           C3                         ret
22742                                           ! 3578   void
22743                                           ! 3579 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
22744                                           ! 3580   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
22745                                           export	_int13_harddisk
22746                       00006719            _int13_harddisk:
22747                                           !BCC_EOS
22748                                           ! 3581 {
22749                                           ! 3582   Bit32u lba_low, lba_high;
22750                                           !BCC_EOS
22751                                           ! 3583   Bit16u ebda_seg=read_word(0x0040,0x000E);
22752 6719           55                         push	bp
22753 671A           89E5                       mov	bp,sp
22754 671C           83C4                   F6  add	sp,*-$A
22755                                           ! Debug: list int = const $E (used reg = )
22756 671F           B8                   000E  mov	ax,*$E
22757 6722           50                         push	ax
22758                                           ! Debug: list int = const $40 (used reg = )
22759 6723           B8                   0040  mov	ax,*$40
22760 6726           50                         push	ax
22761                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22762 6727           E8         9EDD            call	_read_word
22763 672A           83C4                   04  add	sp,*4
22764                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
22765 672D           8946         F6            mov	-$A[bp],ax
22766                                           !BCC_EOS
22767                                           ! 3584   Bit16u cylinder, head, sector;
22768                                           !BCC_EOS
22769                                           ! 3585   Bit16u segment, offset;
22770                                           !BCC_EOS
22771                                           ! 3586   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
22772                                           !BCC_EOS
22773                                           ! 3587   Bit16u size, count;
22774                                           !BCC_EOS
22775                                           ! 3588   Bit8u device, status;
22776                                           !BCC_EOS
22777                                           ! 3589   ;
22778 6730           83C4                   E4  add	sp,*-$1C
22779                                           !BCC_EOS
22780                                           ! 3590   write_byte(0x0040, 0x008e, 0);
22781                                           ! Debug: list int = const 0 (used reg = )
22782 6733           31C0                       xor	ax,ax
22783 6735           50                         push	ax
22784                                           ! Debug: list int = const $8E (used reg = )
22785 6736           B8                   008E  mov	ax,#$8E
22786 6739           50                         push	ax
22787                                           ! Debug: list int = const $40 (used reg = )
22788 673A           B8                   0040  mov	ax,*$40
22789 673D           50                         push	ax
22790                                           ! Debug: func () void = write_byte+0 (used reg = )
22791 673E           E8         9ED9            call	_write_byte
22792 6741           83C4                   06  add	sp,*6
22793                                           !BCC_EOS
22794                                           ! 3591   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
22795                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22796 6744           8A46         10            mov	al,$10[bp]
22797                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
22798 6747           3C                     80  cmp	al,#$80
22799 6749           72           07            jb  	.4E4
22800                       0000674B            .4E5:
22801                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22802 674B           8A46         10            mov	al,$10[bp]
22803                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
22804 674E           3C                     88  cmp	al,#$88
22805 6750           72           06            jb  	.4E3
22806                       00006752            .4E4:
22807                                           ! 3592     ;
22808                                           !BCC_EOS
22809                                           ! 3593     goto int13_fail;
22810 6752           83C4                   00  add	sp,#..FFF1+$28
22811 6755           E9         0E52            br 	.FFF1
22812                                           !BCC_EOS
22813                                           ! 3594     }
22814                                           ! 3595   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
22815                       00006758            .4E3:
22816                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22817 6758           8A46         10            mov	al,$10[bp]
22818                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
22819 675B           30E4                       xor	ah,ah
22820                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
22821 675D           05                   FF80  add	ax,*-$80
22822 6760           89C3                       mov	bx,ax
22823                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
22824                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
22825 6762           81C3                 0233  add	bx,#$233
22826 6766           53                         push	bx
22827                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
22828 6767           FF76         F6            push	-$A[bp]
22829                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22830 676A           E8         9E87            call	_read_byte
22831 676D           83C4                   04  add	sp,*4
22832                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
22833 6770           8846         DB            mov	-$25[bp],al
22834                                           !BCC_EOS
22835                                           ! 3596   if (device >= (4*2)) {
22836                                           ! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
22837 6773           8A46         DB            mov	al,-$25[bp]
22838 6776           3C                     08  cmp	al,*8
22839 6778           72           06            jb  	.4E6
22840                       0000677A            .4E7:
22841                                           ! 3597     ;
22842                                           !BCC_EOS
22843                                           ! 3598     goto int13_fail;
22844 677A           83C4                   00  add	sp,#..FFF1+$28
22845 677D           E9         0E2A            br 	.FFF1
22846                                           !BCC_EOS
22847                                           ! 3599     }
22848                                           ! 3600   switch (( AX >> 8 )) {
22849                       00006780            .4E6:
22850                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
22851 6780           8B46         18            mov	ax,$18[bp]
22852 6783           88E0                       mov	al,ah
22853 6785           30E4                       xor	ah,ah
22854 6787           E9         0D9F            br 	.4EA
22855                                           ! 3601     case 0x00:
22856                                           ! 3602       ata_reset (device);
22857                       0000678A            .4EB:
22858                                           ! Debug: list unsigned char device = [S+$28-$27] (used reg = )
22859 678A           8A46         DB            mov	al,-$25[bp]
22860 678D           30E4                       xor	ah,ah
22861 678F           50                         push	ax
22862                                           ! Debug: func () void = ata_reset+0 (used reg = )
22863 6790           E8         C450            call	_ata_reset
22864 6793           44                         inc	sp
22865 6794           44                         inc	sp
22866                                           !BCC_EOS
22867                                           ! 3603       goto int13_success;
22868 6795           83C4                   0E  add	sp,#..FFEF-..FFF0
22869 6798           E9         0E3C            br 	.FFEF
22870                                           !BCC_EOS
22871                                           ! 3604       break;
22872 679B           E9         0E09            br 	.4E8
22873                                           !BCC_EOS
22874                                           ! 3605     case 0x01:
22875                                           ! 3606       status = read_byte(0x0040, 0x0074);
22876                       0000679E            .4EC:
22877                                           ! Debug: list int = const $74 (used reg = )
22878 679E           B8                   0074  mov	ax,*$74
22879 67A1           50                         push	ax
22880                                           ! Debug: list int = const $40 (used reg = )
22881 67A2           B8                   0040  mov	ax,*$40
22882 67A5           50                         push	ax
22883                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22884 67A6           E8         9E4B            call	_read_byte
22885 67A9           83C4                   04  add	sp,*4
22886                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
22887 67AC           8846         DA            mov	-$26[bp],al
22888                                           !BCC_EOS
22889                                           ! 3607       AX = ((AX & 0x00ff) | ((status) << 8));
22890                                           ! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
22891 67AF           8A46         DA            mov	al,-$26[bp]
22892 67B2           30E4                       xor	ah,ah
22893 67B4           88C4                       mov	ah,al
22894 67B6           30C0                       xor	al,al
22895 67B8           50                         push	ax
22896                                           ! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
22897 67B9           8A46         18            mov	al,$18[bp]
22898                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
22899 67BC           30E4                       xor	ah,ah
22900 67BE           0B46         CA            or	ax,0+..FFF0[bp]
22901 67C1           44                         inc	sp
22902 67C2           44                         inc	sp
22903                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
22904 67C3           8946         18            mov	$18[bp],ax
22905                                           !BCC_EOS
22906                                           ! 3608       write_byte(0x0040, 0x0074, 0);
22907                                           ! Debug: list int = const 0 (used reg = )
22908 67C6           31C0                       xor	ax,ax
22909 67C8           50                         push	ax
22910                                           ! Debug: list int = const $74 (used reg = )
22911 67C9           B8                   0074  mov	ax,*$74
22912 67CC           50                         push	ax
22913                                           ! Debug: list int = const $40 (used reg = )
22914 67CD           B8                   0040  mov	ax,*$40
22915 67D0           50                         push	ax
22916                                           ! Debug: func () void = write_byte+0 (used reg = )
22917 67D1           E8         9E46            call	_write_byte
22918 67D4           83C4                   06  add	sp,*6
22919                                           !BCC_EOS
22920                                           ! 3609       if (status) goto 
22921 67D7           8A46         DA            mov	al,-$26[bp]
22922 67DA           84C0                       test	al,al
22923 67DC           74           08            je  	.4ED
22924                       000067DE            .4EE:
22925                                           ! 3609 int13_fail_nostatus;
22926 67DE           83C4                   0E  add	sp,#..FFEE-..FFF0
22927 67E1           E9         0DE7            br 	.FFEE
22928                                           !BCC_EOS
22929                                           ! 3610       else goto int13_success_noah;
22930 67E4           EB           06            jmp .4EF
22931                       000067E6            .4ED:
22932 67E6           83C4                   0E  add	sp,#..FFED-..FFF0
22933 67E9           E9         0DF5            br 	.FFED
22934                                           !BCC_EOS
22935                                           ! 3611       break;
22936                       000067EC            .4EF:
22937 67EC           E9         0DB8            br 	.4E8
22938                                           !BCC_EOS
22939                                           ! 3612     case 0x02:
22940                                           ! 3613     case 0x03:
22941                       000067EF            .4F0:
22942                                           ! 3614     case 0x04:
22943                       000067EF            .4F1:
22944                                           ! 3615       count = ( AX & 0x00ff );
22945                       000067EF            .4F2:
22946                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
22947 67EF           8A46         18            mov	al,$18[bp]
22948                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
22949 67F2           30E4                       xor	ah,ah
22950 67F4           8946         DC            mov	-$24[bp],ax
22951                                           !BCC_EOS
22952                                           ! 3616       cylinder = ( CX >> 8 );
22953                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
22954 67F7           8B46         16            mov	ax,$16[bp]
22955 67FA           88E0                       mov	al,ah
22956 67FC           30E4                       xor	ah,ah
22957                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
22958 67FE           8946         F4            mov	-$C[bp],ax
22959                                           !BCC_EOS
22960                                           ! 3617       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
22961                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
22962 6801           8A46         16            mov	al,$16[bp]
22963                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
22964 6804           30E4                       xor	ah,ah
22965                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
22966 6806           D1E0                       shl	ax,*1
22967 6808           D1E0                       shl	ax,*1
22968                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
22969 680A           25                   0300  and	ax,#$300
22970                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
22971 680D           0B46         F4            or	ax,-$C[bp]
22972 6810           8946         F4            mov	-$C[bp],ax
22973                                           !BCC_EOS
22974                                           ! 3618       sector = (( CX & 0x00ff ) & 0x3f);
22975                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
22976 6813           8A46         16            mov	al,$16[bp]
22977                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
22978 6816           24                     3F  and	al,*$3F
22979                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
22980 6818           30E4                       xor	ah,ah
22981 681A           8946         F0            mov	-$10[bp],ax
22982                                           !BCC_EOS
22983                                           ! 3619       head = ( DX >> 8 );
22984                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
22985 681D           8B46         14            mov	ax,$14[bp]
22986 6820           88E0                       mov	al,ah
22987 6822           30E4                       xor	ah,ah
22988                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
22989 6824           8946         F2            mov	-$E[bp],ax
22990                                           !BCC_EOS
22991                                           ! 3620       segment = ES;
22992                                           ! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
22993 6827           8B46         08            mov	ax,8[bp]
22994 682A           8946         EE            mov	-$12[bp],ax
22995                                           !BCC_EOS
22996                                           ! 3621       offset = BX;
22997                                           ! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
22998 682D           8B46         12            mov	ax,$12[bp]
22999 6830           8946         EC            mov	-$14[bp],ax
23000                                           !BCC_EOS
23001                                           ! 3622       if ((count > 128) || (count == 0) || (sector == 0)) {
23002                                           ! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
23003 6833           8B46         DC            mov	ax,-$24[bp]
23004 6836           3D                   0080  cmp	ax,#$80
23005 6839           77           0E            ja  	.4F4
23006                       0000683B            .4F6:
23007                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
23008 683B           8B46         DC            mov	ax,-$24[bp]
23009 683E           85C0                       test	ax,ax
23010 6840           74           07            je  	.4F4
23011                       00006842            .4F5:
23012                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23013 6842           8B46         F0            mov	ax,-$10[bp]
23014 6845           85C0                       test	ax,ax
23015 6847           75           06            jne 	.4F3
23016                       00006849            .4F4:
23017                                           ! 3623         ;
23018                                           !BCC_EOS
23019                                           ! 3624         goto int13_fail;
23020 6849           83C4                   0E  add	sp,#..FFF1-..FFF0
23021 684C           E9         0D5B            br 	.FFF1
23022                                           !BCC_EOS
23023                                           ! 3625       }
23024                                           ! 3626       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23025                       0000684F            .4F3:
23026                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23027 684F           8A46         DB            mov	al,-$25[bp]
23028 6852           30E4                       xor	ah,ah
23029 6854           B9                   001E  mov	cx,*$1E
23030 6857           F7E9                       imul	cx
23031 6859           89C3                       mov	bx,ax
23032                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23033                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23034 685B           81C3                 014E  add	bx,#$14E
23035 685F           53                         push	bx
23036                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23037 6860           FF76         F6            push	-$A[bp]
23038                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23039 6863           E8         9DA1            call	_read_word
23040 6866           83C4                   04  add	sp,*4
23041                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23042 6869           8946         E4            mov	-$1C[bp],ax
23043                                           !BCC_EOS
23044                                           ! 3627       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23045                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23046 686C           8A46         DB            mov	al,-$25[bp]
23047 686F           30E4                       xor	ah,ah
23048 6871           B9                   001E  mov	cx,*$1E
23049 6874           F7E9                       imul	cx
23050 6876           89C3                       mov	bx,ax
23051                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23052                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23053 6878           81C3                 014C  add	bx,#$14C
23054 687C           53                         push	bx
23055                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23056 687D           FF76         F6            push	-$A[bp]
23057                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23058 6880           E8         9D84            call	_read_word
23059 6883           83C4                   04  add	sp,*4
23060                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23061 6886           8946         E2            mov	-$1E[bp],ax
23062                                           !BCC_EOS
23063                                           ! 3628       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23064                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23065 6889           8A46         DB            mov	al,-$25[bp]
23066 688C           30E4                       xor	ah,ah
23067 688E           B9                   001E  mov	cx,*$1E
23068 6891           F7E9                       imul	cx
23069 6893           89C3                       mov	bx,ax
23070                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23071                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23072 6895           81C3                 0150  add	bx,#$150
23073 6899           53                         push	bx
23074                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23075 689A           FF76         F6            push	-$A[bp]
23076                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23077 689D           E8         9D67            call	_read_word
23078 68A0           83C4                   04  add	sp,*4
23079                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23080 68A3           8946         E0            mov	-$20[bp],ax
23081                                           !BCC_EOS
23082                                           ! 3629       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
23083                                           ! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
23084 68A6           8B46         F4            mov	ax,-$C[bp]
23085 68A9           3B46         E4            cmp	ax,-$1C[bp]
23086 68AC           73           10            jae 	.4F8
23087                       000068AE            .4FA:
23088                                           ! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
23089 68AE           8B46         F2            mov	ax,-$E[bp]
23090 68B1           3B46         E2            cmp	ax,-$1E[bp]
23091 68B4           73           08            jae 	.4F8
23092                       000068B6            .4F9:
23093                                           ! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
23094 68B6           8B46         F0            mov	ax,-$10[bp]
23095 68B9           3B46         E0            cmp	ax,-$20[bp]
23096 68BC           76           06            jbe 	.4F7
23097                       000068BE            .4F8:
23098                                           ! 3630         ;
23099                                           !BCC_EOS
23100                                           ! 3631         goto int13_fail;
23101 68BE           83C4                   0E  add	sp,#..FFF1-..FFF0
23102 68C1           E9         0CE6            br 	.FFF1
23103                                           !BCC_EOS
23104                                           ! 3632         }
23105                                           ! 3633       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
23106                       000068C4            .4F7:
23107                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23108 68C4           8B46         18            mov	ax,$18[bp]
23109 68C7           88E0                       mov	al,ah
23110 68C9           30E4                       xor	ah,ah
23111                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
23112 68CB           3D                   0004  cmp	ax,*4
23113 68CE           75           06            jne 	.4FB
23114                       000068D0            .4FC:
23115 68D0           83C4                   0E  add	sp,#..FFEF-..FFF0
23116 68D3           E9         0D01            br 	.FFEF
23117                                           !BCC_EOS
23118                                           ! 3634       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
23119                       000068D6            .4FB:
23120                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23121 68D6           8A46         DB            mov	al,-$25[bp]
23122 68D9           30E4                       xor	ah,ah
23123 68DB           B9                   001E  mov	cx,*$1E
23124 68DE           F7E9                       imul	cx
23125 68E0           89C3                       mov	bx,ax
23126                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
23127                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
23128 68E2           81C3                 0152  add	bx,#$152
23129 68E6           53                         push	bx
23130                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23131 68E7           FF76         F6            push	-$A[bp]
23132                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23133 68EA           E8         9D1A            call	_read_word
23134 68ED           83C4                   04  add	sp,*4
23135                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
23136 68F0           8946         E8            mov	-$18[bp],ax
23137                                           !BCC_EOS
23138                                           ! 3635       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
23139                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23140 68F3           8A46         DB            mov	al,-$25[bp]
23141 68F6           30E4                       xor	ah,ah
23142 68F8           B9                   001E  mov	cx,*$1E
23143 68FB           F7E9                       imul	cx
23144 68FD           89C3                       mov	bx,ax
23145                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
23146                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
23147 68FF           81C3                 0156  add	bx,#$156
23148 6903           53                         push	bx
23149                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23150 6904           FF76         F6            push	-$A[bp]
23151                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23152 6907           E8         9CFD            call	_read_word
23153 690A           83C4                   04  add	sp,*4
23154                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
23155 690D           8946         E6            mov	-$1A[bp],ax
23156                                           !BCC_EOS
23157                                           ! 3636       if ( (nph != nlh) || (npspt != nlspt)) {
23158                                           ! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
23159 6910           8B46         E8            mov	ax,-$18[bp]
23160 6913           3B46         E2            cmp	ax,-$1E[bp]
23161 6916           75           08            jne 	.4FE
23162                       00006918            .4FF:
23163                                           ! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
23164 6918           8B46         E6            mov	ax,-$1A[bp]
23165 691B           3B46         E0            cmp	ax,-$20[bp]
23166 691E           74           72            je  	.4FD
23167                       00006920            .4FE:
23168                                           ! 3637         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
23169                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23170 6920           8B46         F0            mov	ax,-$10[bp]
23171 6923           31DB                       xor	bx,bx
23172 6925           53                         push	bx
23173 6926           50                         push	ax
23174                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
23175 6927           8B46         E0            mov	ax,-$20[bp]
23176 692A           31DB                       xor	bx,bx
23177 692C           53                         push	bx
23178 692D           50                         push	ax
23179                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
23180 692E           8B46         F2            mov	ax,-$E[bp]
23181 6931           31DB                       xor	bx,bx
23182 6933           53                         push	bx
23183 6934           50                         push	ax
23184                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
23185 6935           8B46         E2            mov	ax,-$1E[bp]
23186 6938           31DB                       xor	bx,bx
23187 693A           53                         push	bx
23188 693B           50                         push	ax
23189                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
23190 693C           8B46         F4            mov	ax,-$C[bp]
23191 693F           31DB                       xor	bx,bx
23192                                           ! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
23193 6941           8D7E         BC            lea	di,-$E+..FFF0[bp]
23194 6944           E8         97A2            call	lmulul
23195 6947           83C4                   04  add	sp,*4
23196                                           ! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
23197 694A           8D7E         C0            lea	di,-$A+..FFF0[bp]
23198 694D           E8         9773            call	laddul
23199 6950           83C4                   04  add	sp,*4
23200                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23201 6953           8D7E         C4            lea	di,-6+..FFF0[bp]
23202 6956           E8         9790            call	lmulul
23203 6959           83C4                   04  add	sp,*4
23204                                           ! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23205 695C           8D7E         C8            lea	di,-2+..FFF0[bp]
23206 695F           E8         9761            call	laddul
23207 6962           83C4                   04  add	sp,*4
23208                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
23209 6965           53                         push	bx
23210 6966           50                         push	ax
23211 6967           B8                   0001  mov	ax,*1
23212 696A           31DB                       xor	bx,bx
23213 696C           53                         push	bx
23214 696D           50                         push	ax
23215 696E           8B46         C8            mov	ax,-2+..FFF0[bp]
23216 6971           8B5E         CA            mov	bx,0+..FFF0[bp]
23217 6974           8D7E         C4            lea	di,-6+..FFF0[bp]
23218 6977           E8         9767            call	lsubul
23219 697A           83C4                   08  add	sp,*8
23220                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23221 697D           8946         FC            mov	-4[bp],ax
23222 6980           895E         FE            mov	-2[bp],bx
23223                                           !BCC_EOS
23224                                           ! 3638         lba_high = 0;
23225                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23226 6983           31C0                       xor	ax,ax
23227 6985           31DB                       xor	bx,bx
23228 6987           8946         F8            mov	-8[bp],ax
23229 698A           895E         FA            mov	-6[bp],bx
23230                                           !BCC_EOS
23231                                           ! 3639         sector = 0;
23232                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23233 698D           31C0                       xor	ax,ax
23234 698F           8946         F0            mov	-$10[bp],ax
23235                                           !BCC_EOS
23236                                           ! 3640         }
23237                                           ! 3641       if ( ( AX >> 8 ) == 0x02 )
23238                       00006992            .4FD:
23239                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23240 6992           8B46         18            mov	ax,$18[bp]
23241 6995           88E0                       mov	al,ah
23242 6997           30E4                       xor	ah,ah
23243                                           ! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
23244 6999           3D                   0002  cmp	ax,*2
23245 699C           75           34            jne 	.500
23246                       0000699E            .501:
23247                                           ! 3642         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
23248                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23249 699E           FF76         EC            push	-$14[bp]
23250                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23251 69A1           FF76         EE            push	-$12[bp]
23252                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23253 69A4           FF76         FA            push	-6[bp]
23254 69A7           FF76         F8            push	-8[bp]
23255                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23256 69AA           FF76         FE            push	-2[bp]
23257 69AD           FF76         FC            push	-4[bp]
23258                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23259 69B0           FF76         F0            push	-$10[bp]
23260                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23261 69B3           FF76         F2            push	-$E[bp]
23262                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23263 69B6           FF76         F4            push	-$C[bp]
23264                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23265 69B9           FF76         DC            push	-$24[bp]
23266                                           ! Debug: list int = const $20 (used reg = )
23267 69BC           B8                   0020  mov	ax,*$20
23268 69BF           50                         push	ax
23269                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23270 69C0           8A46         DB            mov	al,-$25[bp]
23271 69C3           30E4                       xor	ah,ah
23272 69C5           50                         push	ax
23273                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
23274 69C6           E8         C36E            call	_ata_cmd_data_in
23275 69C9           83C4                   18  add	sp,*$18
23276                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23277 69CC           8846         DA            mov	-$26[bp],al
23278                                           !BCC_EOS
23279                                           ! 3643       else
23280                                           ! 3644         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
23281 69CF           E9         0031            br 	.502
23282                       000069D2            .500:
23283                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23284 69D2           FF76         EC            push	-$14[bp]
23285                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23286 69D5           FF76         EE            push	-$12[bp]
23287                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23288 69D8           FF76         FA            push	-6[bp]
23289 69DB           FF76         F8            push	-8[bp]
23290                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23291 69DE           FF76         FE            push	-2[bp]
23292 69E1           FF76         FC            push	-4[bp]
23293                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23294 69E4           FF76         F0            push	-$10[bp]
23295                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23296 69E7           FF76         F2            push	-$E[bp]
23297                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23298 69EA           FF76         F4            push	-$C[bp]
23299                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23300 69ED           FF76         DC            push	-$24[bp]
23301                                           ! Debug: list int = const $30 (used reg = )
23302 69F0           B8                   0030  mov	ax,*$30
23303 69F3           50                         push	ax
23304                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23305 69F4           8A46         DB            mov	al,-$25[bp]
23306 69F7           30E4                       xor	ah,ah
23307 69F9           50                         push	ax
23308                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
23309 69FA           E8         C70B            call	_ata_cmd_data_out
23310 69FD           83C4                   18  add	sp,*$18
23311                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23312 6A00           8846         DA            mov	-$26[bp],al
23313                                           !BCC_EOS
23314                                           ! 3645       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
23315                       00006A03            .502:
23316                                           ! Debug: list * unsigned short = const $254 (used reg = )
23317 6A03           B8                   0254  mov	ax,#$254
23318 6A06           50                         push	ax
23319                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23320 6A07           FF76         F6            push	-$A[bp]
23321                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23322 6A0A           E8         9BFA            call	_read_word
23323 6A0D           83C4                   04  add	sp,*4
23324 6A10           50                         push	ax
23325                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
23326 6A11           8B46         18            mov	ax,$18[bp]
23327 6A14           30C0                       xor	al,al
23328                                           ! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
23329 6A16           0B46         CA            or	ax,0+..FFF0[bp]
23330 6A19           44                         inc	sp
23331 6A1A           44                         inc	sp
23332                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23333 6A1B           8946         18            mov	$18[bp],ax
23334                                           !BCC_EOS
23335                                           ! 3646       if (status != 0) {
23336                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
23337 6A1E           8A46         DA            mov	al,-$26[bp]
23338 6A21           84C0                       test	al,al
23339 6A23           74           11            je  	.503
23340                       00006A25            .504:
23341                                           ! 3647         ;
23342                                           !BCC_EOS
23343                                           ! 3648         AX = ((AX & 0x00ff) | ((0x0c) << 8));
23344                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23345 6A25           8A46         18            mov	al,$18[bp]
23346                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
23347 6A28           30E4                       xor	ah,ah
23348 6A2A           0D                   0C00  or	ax,#$C00
23349                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23350 6A2D           8946         18            mov	$18[bp],ax
23351                                           !BCC_EOS
23352                                           ! 3649         goto int13_fail_noah;
23353 6A30           83C4                   0E  add	sp,#..FFEC-..FFF0
23354 6A33           E9         0B7F            br 	.FFEC
23355                                           !BCC_EOS
23356                                           ! 3650         }
23357                                           ! 3651       goto int13_success;
23358                       00006A36            .503:
23359 6A36           83C4                   0E  add	sp,#..FFEF-..FFF0
23360 6A39           E9         0B9B            br 	.FFEF
23361                                           !BCC_EOS
23362                                           ! 3652       break;
23363 6A3C           E9         0B68            br 	.4E8
23364                                           !BCC_EOS
23365                                           ! 3653     case 0x05:
23366                                           ! 3654       ;
23367                       00006A3F            .505:
23368                                           !BCC_EOS
23369                                           ! 3655       goto int13_success;
23370 6A3F           83C4                   0E  add	sp,#..FFEF-..FFF0
23371 6A42           E9         0B92            br 	.FFEF
23372                                           !BCC_EOS
23373                                           ! 3656       return;
23374 6A45           89EC                       mov	sp,bp
23375 6A47           5D                         pop	bp
23376 6A48           C3                         ret
23377                                           !BCC_EOS
23378                                           ! 3657       break;
23379 6A49           E9         0B5B            br 	.4E8
23380                                           !BCC_EOS
23381                                           ! 3658     case 0x08:
23382                                           ! 3659       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23383                       00006A4C            .506:
23384                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23385 6A4C           8A46         DB            mov	al,-$25[bp]
23386 6A4F           30E4                       xor	ah,ah
23387 6A51           B9                   001E  mov	cx,*$1E
23388 6A54           F7E9                       imul	cx
23389 6A56           89C3                       mov	bx,ax
23390                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23391                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23392 6A58           81C3                 014E  add	bx,#$14E
23393 6A5C           53                         push	bx
23394                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23395 6A5D           FF76         F6            push	-$A[bp]
23396                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23397 6A60           E8         9BA4            call	_read_word
23398 6A63           83C4                   04  add	sp,*4
23399                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23400 6A66           8946         E4            mov	-$1C[bp],ax
23401                                           !BCC_EOS
23402                                           ! 3660       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads
23403                                           ! 3660 );
23404                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23405 6A69           8A46         DB            mov	al,-$25[bp]
23406 6A6C           30E4                       xor	ah,ah
23407 6A6E           B9                   001E  mov	cx,*$1E
23408 6A71           F7E9                       imul	cx
23409 6A73           89C3                       mov	bx,ax
23410                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23411                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23412 6A75           81C3                 014C  add	bx,#$14C
23413 6A79           53                         push	bx
23414                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23415 6A7A           FF76         F6            push	-$A[bp]
23416                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23417 6A7D           E8         9B87            call	_read_word
23418 6A80           83C4                   04  add	sp,*4
23419                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23420 6A83           8946         E2            mov	-$1E[bp],ax
23421                                           !BCC_EOS
23422                                           ! 3661       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23423                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23424 6A86           8A46         DB            mov	al,-$25[bp]
23425 6A89           30E4                       xor	ah,ah
23426 6A8B           B9                   001E  mov	cx,*$1E
23427 6A8E           F7E9                       imul	cx
23428 6A90           89C3                       mov	bx,ax
23429                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23430                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23431 6A92           81C3                 0150  add	bx,#$150
23432 6A96           53                         push	bx
23433                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23434 6A97           FF76         F6            push	-$A[bp]
23435                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23436 6A9A           E8         9B6A            call	_read_word
23437 6A9D           83C4                   04  add	sp,*4
23438                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23439 6AA0           8946         E0            mov	-$20[bp],ax
23440                                           !BCC_EOS
23441                                           ! 3662       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
23442                                           ! Debug: list * unsigned char = const $232 (used reg = )
23443 6AA3           B8                   0232  mov	ax,#$232
23444 6AA6           50                         push	ax
23445                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23446 6AA7           FF76         F6            push	-$A[bp]
23447                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23448 6AAA           E8         9B47            call	_read_byte
23449 6AAD           83C4                   04  add	sp,*4
23450                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23451 6AB0           30E4                       xor	ah,ah
23452 6AB2           8946         DC            mov	-$24[bp],ax
23453                                           !BCC_EOS
23454                                           ! 3663       nlc = nlc - 2;
23455                                           ! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
23456 6AB5           8B46         E4            mov	ax,-$1C[bp]
23457                                           ! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
23458 6AB8           48                         dec	ax
23459 6AB9           48                         dec	ax
23460 6ABA           8946         E4            mov	-$1C[bp],ax
23461                                           !BCC_EOS
23462                                           ! 3664       AX = ((AX & 0xff00) | (0));
23463                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
23464 6ABD           8B46         18            mov	ax,$18[bp]
23465 6AC0           30C0                       xor	al,al
23466                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
23467 6AC2           0C                     00  or	al,*0
23468                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23469 6AC4           8946         18            mov	$18[bp],ax
23470                                           !BCC_EOS
23471                                           ! 3665       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
23472                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
23473 6AC7           8A46         E4            mov	al,-$1C[bp]
23474                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
23475 6ACA           30E4                       xor	ah,ah
23476 6ACC           88C4                       mov	ah,al
23477 6ACE           30C0                       xor	al,al
23478 6AD0           50                         push	ax
23479                                           ! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
23480 6AD1           8A46         16            mov	al,$16[bp]
23481                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23482 6AD4           30E4                       xor	ah,ah
23483 6AD6           0B46         CA            or	ax,0+..FFF0[bp]
23484 6AD9           44                         inc	sp
23485 6ADA           44                         inc	sp
23486                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
23487 6ADB           8946         16            mov	$16[bp],ax
23488                                           !BCC_EOS
23489                                           ! 3666       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
23490                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
23491 6ADE           8A46         E0            mov	al,-$20[bp]
23492 6AE1           24                     3F  and	al,*$3F
23493 6AE3           50                         push	ax
23494                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
23495 6AE4           8B46         E4            mov	ax,-$1C[bp]
23496 6AE7           D1E8                       shr	ax,*1
23497 6AE9           D1E8                       shr	ax,*1
23498                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
23499 6AEB           24                     C0  and	al,#$C0
23500                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23501 6AED           0A46         CA            or	al,0+..FFF0[bp]
23502 6AF0           44                         inc	sp
23503 6AF1           44                         inc	sp
23504 6AF2           50                         push	ax
23505                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
23506 6AF3           8B46         16            mov	ax,$16[bp]
23507 6AF6           30C0                       xor	al,al
23508                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
23509 6AF8           0A46         CA            or	al,0+..FFF0[bp]
23510 6AFB           44                         inc	sp
23511 6AFC           44                         inc	sp
23512                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
23513 6AFD           8946         16            mov	$16[bp],ax
23514                                           !BCC_EOS
23515                                           ! 3667       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
23516                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
23517 6B00           8B46         E2            mov	ax,-$1E[bp]
23518                                           ! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
23519 6B03           48                         dec	ax
23520 6B04           88C4                       mov	ah,al
23521 6B06           30C0                       xor	al,al
23522 6B08           50                         push	ax
23523                                           ! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
23524 6B09           8A46         14            mov	al,$14[bp]
23525                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23526 6B0C           30E4                       xor	ah,ah
23527 6B0E           0B46         CA            or	ax,0+..FFF0[bp]
23528 6B11           44                         inc	sp
23529 6B12           44                         inc	sp
23530                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
23531 6B13           8946         14            mov	$14[bp],ax
23532                                           !BCC_EOS
23533                                           ! 3668       DX = ((DX & 0xff00) | (count));
23534                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
23535 6B16           8B46         14            mov	ax,$14[bp]
23536 6B19           30C0                       xor	al,al
23537                                           ! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
23538 6B1B           0B46         DC            or	ax,-$24[bp]
23539                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
23540 6B1E           8946         14            mov	$14[bp],ax
23541                                           !BCC_EOS
23542                                           ! 3669       goto int13_success;
23543 6B21           83C4                   0E  add	sp,#..FFEF-..FFF0
23544 6B24           E9         0AB0            br 	.FFEF
23545                                           !BCC_EOS
23546                                           ! 3670       break;
23547 6B27           E9         0A7D            br 	.4E8
23548                                           !BCC_EOS
23549                                           ! 3671     case 0x10:
23550                                           ! 3672       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
23551                       00006B2A            .507:
23552                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
23553 6B2A           8A46         DB            mov	al,-$25[bp]
23554 6B2D           30E4                       xor	ah,ah
23555 6B2F           D1E8                       shr	ax,*1
23556                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
23557 6B31           B1                     03  mov	cl,*3
23558 6B33           D3E0                       shl	ax,cl
23559 6B35           89C3                       mov	bx,ax
23560                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
23561                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
23562 6B37           81C3                 0124  add	bx,#$124
23563 6B3B           53                         push	bx
23564                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23565 6B3C           FF76         F6            push	-$A[bp]
23566                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23567 6B3F           E8         9AC5            call	_read_word
23568 6B42           83C4                   04  add	sp,*4
23569                                           ! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
23570                                           ! Debug: list unsigned int = ax+7 (used reg = )
23571 6B45           05                   0007  add	ax,*7
23572 6B48           50                         push	ax
23573                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23574 6B49           E8         99F2            call	_inb
23575 6B4C           44                         inc	sp
23576 6B4D           44                         inc	sp
23577                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23578 6B4E           8846         DA            mov	-$26[bp],al
23579                                           !BCC_EOS
23580                                           ! 3673       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
23581                                           ! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
23582 6B51           8A46         DA            mov	al,-$26[bp]
23583 6B54           24                     C0  and	al,#$C0
23584                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
23585 6B56           3C                     40  cmp	al,*$40
23586 6B58           75           08            jne 	.508
23587                       00006B5A            .509:
23588                                           ! 3674         goto int13_success;
23589 6B5A           83C4                   0E  add	sp,#..FFEF-..FFF0
23590 6B5D           E9         0A77            br 	.FFEF
23591                                           !BCC_EOS
23592                                           ! 3675         }
23593                                           ! 3676       else {
23594 6B60           EB           11            jmp .50A
23595                       00006B62            .508:
23596                                           ! 3677         AX = ((AX & 0x00ff) | ((0xAA) << 8));
23597                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23598 6B62           8A46         18            mov	al,$18[bp]
23599                                           ! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
23600 6B65           30E4                       xor	ah,ah
23601 6B67           0D                   AA00  or	ax,#-$5600
23602                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23603 6B6A           8946         18            mov	$18[bp],ax
23604                                           !BCC_EOS
23605                                           ! 3678         goto int13_fail_noah;
23606 6B6D           83C4                   0E  add	sp,#..FFEC-..FFF0
23607 6B70           E9         0A42            br 	.FFEC
23608                                           !BCC_EOS
23609                                           ! 3679         }
23610                                           ! 3680       break;
23611                       00006B73            .50A:
23612 6B73           E9         0A31            br 	.4E8
23613                                           !BCC_EOS
23614                                           ! 3681     case 0x15:
23615                                           ! 3682       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23616                       00006B76            .50B:
23617                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23618 6B76           8A46         DB            mov	al,-$25[bp]
23619 6B79           30E4                       xor	ah,ah
23620 6B7B           B9                   001E  mov	cx,*$1E
23621 6B7E           F7E9                       imul	cx
23622 6B80           89C3                       mov	bx,ax
23623                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23624                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23625 6B82           81C3                 014E  add	bx,#$14E
23626 6B86           53                         push	bx
23627                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23628 6B87           FF76         F6            push	-$A[bp]
23629                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23630 6B8A           E8         9A7A            call	_read_word
23631 6B8D           83C4                   04  add	sp,*4
23632                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23633 6B90           8946         E4            mov	-$1C[bp],ax
23634                                           !BCC_EOS
23635                                           ! 3683       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23636                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23637 6B93           8A46         DB            mov	al,-$25[bp]
23638 6B96           30E4                       xor	ah,ah
23639 6B98           B9                   001E  mov	cx,*$1E
23640 6B9B           F7E9                       imul	cx
23641 6B9D           89C3                       mov	bx,ax
23642                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23643                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23644 6B9F           81C3                 014C  add	bx,#$14C
23645 6BA3           53                         push	bx
23646                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23647 6BA4           FF76         F6            push	-$A[bp]
23648                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23649 6BA7           E8         9A5D            call	_read_word
23650 6BAA           83C4                   04  add	sp,*4
23651                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23652 6BAD           8946         E2            mov	-$1E[bp],ax
23653                                           !BCC_EOS
23654                                           ! 3684       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23655                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23656 6BB0           8A46         DB            mov	al,-$25[bp]
23657 6BB3           30E4                       xor	ah,ah
23658 6BB5           B9                   001E  mov	cx,*$1E
23659 6BB8           F7E9                       imul	cx
23660 6BBA           89C3                       mov	bx,ax
23661                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23662                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23663 6BBC           81C3                 0150  add	bx,#$150
23664 6BC0           53                         push	bx
23665                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23666 6BC1           FF76         F6            push	-$A[bp]
23667                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23668 6BC4           E8         9A40            call	_read_word
23669 6BC7           83C4                   04  add	sp,*4
23670                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23671 6BCA           8946         E0            mov	-$20[bp],ax
23672                                           !BCC_EOS
23673                                           ! 3685       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
23674                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23675 6BCD           8B46         E0            mov	ax,-$20[bp]
23676 6BD0           31DB                       xor	bx,bx
23677 6BD2           53                         push	bx
23678 6BD3           50                         push	ax
23679                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
23680 6BD4           8B46         E2            mov	ax,-$1E[bp]
23681 6BD7           31DB                       xor	bx,bx
23682 6BD9           53                         push	bx
23683 6BDA           50                         push	ax
23684                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
23685 6BDB           8B46         E4            mov	ax,-$1C[bp]
23686                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
23687 6BDE           48                         dec	ax
23688 6BDF           31DB                       xor	bx,bx
23689                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23690 6BE1           8D7E         C4            lea	di,-6+..FFF0[bp]
23691 6BE4           E8         9502            call	lmulul
23692 6BE7           83C4                   04  add	sp,*4
23693                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23694 6BEA           8D7E         C8            lea	di,-2+..FFF0[bp]
23695 6BED           E8         94F9            call	lmulul
23696 6BF0           83C4                   04  add	sp,*4
23697                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23698 6BF3           8946         FC            mov	-4[bp],ax
23699 6BF6           895E         FE            mov	-2[bp],bx
23700                                           !BCC_EOS
23701                                           ! 3686       CX = lba_low >> 16;
23702                                           ! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
23703 6BF9           8B46         FC            mov	ax,-4[bp]
23704 6BFC           8B5E         FE            mov	bx,-2[bp]
23705 6BFF           93                         xchg	bx,ax
23706 6C00           31DB                       xor	bx,bx
23707                                           ! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
23708 6C02           8946         16            mov	$16[bp],ax
23709                                           !BCC_EOS
23710                                           ! 3687       DX = lba_low & 0xffff;
23711                                           ! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
23712                                           ! Debug: expression subtree swapping
23713 6C05           B8                   FFFF  mov	ax,#$FFFF
23714 6C08           31DB                       xor	bx,bx
23715 6C0A           8D7E         FC            lea	di,-4[bp]
23716 6C0D           E8         94AB            call	landul
23717                                           ! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
23718 6C10           8946         14            mov	$14[bp],ax
23719                                           !BCC_EOS
23720                                           ! 3688       AX = ((AX & 0x00ff) | ((3) << 8));
23721                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23722 6C13           8A46         18            mov	al,$18[bp]
23723                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
23724 6C16           30E4                       xor	ah,ah
23725 6C18           0D                   0300  or	ax,#$300
23726                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23727 6C1B           8946         18            mov	$18[bp],ax
23728                                           !BCC_EOS
23729                                           ! 3689       goto int13_success_noah;
23730 6C1E           83C4                   0E  add	sp,#..FFED-..FFF0
23731 6C21           E9         09BD            br 	.FFED
23732                                           !BCC_EOS
23733                                           ! 3690       break;
23734 6C24           E9         0980            br 	.4E8
23735                                           !BCC_EOS
23736                                           ! 3691     case 0x41:
23737                                           ! 3692       BX=0xaa55;
23738                       00006C27            .50C:
23739                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
23740 6C27           B8                   AA55  mov	ax,#$AA55
23741 6C2A           8946         12            mov	$12[bp],ax
23742                                           !BCC_EOS
23743                                           ! 3693       AX = ((AX & 0x00ff) | ((0x30) << 8));
23744                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23745 6C2D           8A46         18            mov	al,$18[bp]
23746                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
23747 6C30           30E4                       xor	ah,ah
23748 6C32           0D                   3000  or	ax,#$3000
23749                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23750 6C35           8946         18            mov	$18[bp],ax
23751                                           !BCC_EOS
23752                                           ! 3694       CX=0x0007;
23753                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
23754 6C38           B8                   0007  mov	ax,*7
23755 6C3B           8946         16            mov	$16[bp],ax
23756                                           !BCC_EOS
23757                                           ! 3695       goto int13_success_noah;
23758 6C3E           83C4                   0E  add	sp,#..FFED-..FFF0
23759 6C41           E9         099D            br 	.FFED
23760                                           !BCC_EOS
23761                                           ! 3696       break;
23762 6C44           E9         0960            br 	.4E8
23763                                           !BCC_EOS
23764                                           ! 3697     case 0x42:
23765                                           ! 3698     case 0x43:
23766                       00006C47            .50D:
23767                                           ! 3699     case 0x44:
23768                       00006C47            .50E:
23769                                           ! 3700     case 0x47:
23770                       00006C47            .50F:
23771                                           ! 3701       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
23772                       00006C47            .510:
23773                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23774 6C47           8B46         0C            mov	ax,$C[bp]
23775                                           ! Debug: list unsigned int = ax+2 (used reg = )
23776 6C4A           40                         inc	ax
23777 6C4B           40                         inc	ax
23778 6C4C           50                         push	ax
23779                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23780 6C4D           FF76         06            push	6[bp]
23781                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23782 6C50           E8         99B4            call	_read_word
23783 6C53           83C4                   04  add	sp,*4
23784                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
23785 6C56           8946         DC            mov	-$24[bp],ax
23786                                           !BCC_EOS
23787                                           ! 3702       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
23788                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
23789 6C59           8B46         0C            mov	ax,$C[bp]
23790                                           ! Debug: list unsigned int = ax+6 (used reg = )
23791 6C5C           05                   0006  add	ax,*6
23792 6C5F           50                         push	ax
23793                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23794 6C60           FF76         06            push	6[bp]
23795                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23796 6C63           E8         99A1            call	_read_word
23797 6C66           83C4                   04  add	sp,*4
23798                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
23799 6C69           8946         EE            mov	-$12[bp],ax
23800                                           !BCC_EOS
23801                                           ! 3703       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
23802                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
23803 6C6C           8B46         0C            mov	ax,$C[bp]
23804                                           ! Debug: list unsigned int = ax+4 (used reg = )
23805 6C6F           05                   0004  add	ax,*4
23806 6C72           50                         push	ax
23807                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23808 6C73           FF76         06            push	6[bp]
23809                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23810 6C76           E8         998E            call	_read_word
23811 6C79           83C4                   04  add	sp,*4
23812                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
23813 6C7C           8946         EC            mov	-$14[bp],ax
23814                                           !BCC_EOS
23815                                           ! 3704       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
23816                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
23817 6C7F           8B46         0C            mov	ax,$C[bp]
23818                                           ! Debug: list unsigned int = ax+$C (used reg = )
23819 6C82           05                   000C  add	ax,*$C
23820 6C85           50                         push	ax
23821                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23822 6C86           FF76         06            push	6[bp]
23823                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
23824 6C89           E8         93F7            call	_read_dword
23825 6C8C           89D3                       mov	bx,dx
23826 6C8E           83C4                   04  add	sp,*4
23827                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23828 6C91           8946         F8            mov	-8[bp],ax
23829 6C94           895E         FA            mov	-6[bp],bx
23830                                           !BCC_EOS
23831                                           ! 3705       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
23832                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23833 6C97           8A46         DB            mov	al,-$25[bp]
23834 6C9A           30E4                       xor	ah,ah
23835 6C9C           B9                   001E  mov	cx,*$1E
23836 6C9F           F7E9                       imul	cx
23837 6CA1           89C3                       mov	bx,ax
23838                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23839                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
23840 6CA3           81C3                 015C  add	bx,#$15C
23841 6CA7           53                         push	bx
23842                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23843 6CA8           FF76         F6            push	-$A[bp]
23844                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
23845 6CAB           E8         93D5            call	_read_dword
23846 6CAE           89D3                       mov	bx,dx
23847 6CB0           83C4                   04  add	sp,*4
23848                                           ! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23849 6CB3           8D7E         F8            lea	di,-8[bp]
23850 6CB6           E8         9412            call	lcmpul
23851 6CB9           73           06            jae 	.511
23852                       00006CBB            .512:
23853                                           ! 3706         ;
23854                                           !BCC_EOS
23855                                           ! 3707         goto int13_fail;
23856 6CBB           83C4                   0E  add	sp,#..FFF1-..FFF0
23857 6CBE           E9         08E9            br 	.FFF1
23858                                           !BCC_EOS
23859                                           ! 3708         }
23860                                           ! 3709       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
23861                       00006CC1            .511:
23862                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
23863 6CC1           8B46         0C            mov	ax,$C[bp]
23864                                           ! Debug: list unsigned int = ax+8 (used reg = )
23865 6CC4           05                   0008  add	ax,*8
23866 6CC7           50                         push	ax
23867                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23868 6CC8           FF76         06            push	6[bp]
23869                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
23870 6CCB           E8         93B5            call	_read_dword
23871 6CCE           89D3                       mov	bx,dx
23872 6CD0           83C4                   04  add	sp,*4
23873                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23874 6CD3           8946         FC            mov	-4[bp],ax
23875 6CD6           895E         FE            mov	-2[bp],bx
23876                                           !BCC_EOS
23877                                           ! 3710       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
23878                                           ! 3711        
23879                                           ! 3711    && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
23880                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23881 6CD9           8A46         DB            mov	al,-$25[bp]
23882 6CDC           30E4                       xor	ah,ah
23883 6CDE           B9                   001E  mov	cx,*$1E
23884 6CE1           F7E9                       imul	cx
23885 6CE3           89C3                       mov	bx,ax
23886                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
23887                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
23888 6CE5           81C3                 015C  add	bx,#$15C
23889 6CE9           53                         push	bx
23890                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23891 6CEA           FF76         F6            push	-$A[bp]
23892                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
23893 6CED           E8         9393            call	_read_dword
23894 6CF0           89D3                       mov	bx,dx
23895 6CF2           83C4                   04  add	sp,*4
23896                                           ! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23897                                           ! Debug: expression subtree swapping
23898 6CF5           8D7E         F8            lea	di,-8[bp]
23899 6CF8           E8         93D0            call	lcmpul
23900 6CFB           75           2A            jne 	.513
23901                       00006CFD            .515:
23902                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23903 6CFD           8A46         DB            mov	al,-$25[bp]
23904 6D00           30E4                       xor	ah,ah
23905 6D02           B9                   001E  mov	cx,*$1E
23906 6D05           F7E9                       imul	cx
23907 6D07           89C3                       mov	bx,ax
23908                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
23909                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
23910 6D09           81C3                 0158  add	bx,#$158
23911 6D0D           53                         push	bx
23912                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23913 6D0E           FF76         F6            push	-$A[bp]
23914                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
23915 6D11           E8         936F            call	_read_dword
23916 6D14           89D3                       mov	bx,dx
23917 6D16           83C4                   04  add	sp,*4
23918                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23919 6D19           8D7E         FC            lea	di,-4[bp]
23920 6D1C           E8         93AC            call	lcmpul
23921 6D1F           77           06            ja  	.513
23922                       00006D21            .514:
23923                                           ! 3712         ;
23924                                           !BCC_EOS
23925                                           ! 3713         goto int13_fail;
23926 6D21           83C4                   0E  add	sp,#..FFF1-..FFF0
23927 6D24           E9         0883            br 	.FFF1
23928                                           !BCC_EOS
23929                                           ! 3714         }
23930                                           ! 3715       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
23931                       00006D27            .513:
23932                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23933 6D27           8B46         18            mov	ax,$18[bp]
23934 6D2A           88E0                       mov	al,ah
23935 6D2C           30E4                       xor	ah,ah
23936                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
23937 6D2E           3D                   0044  cmp	ax,*$44
23938 6D31           74           0C            je  	.517
23939                       00006D33            .518:
23940                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23941 6D33           8B46         18            mov	ax,$18[bp]
23942 6D36           88E0                       mov	al,ah
23943 6D38           30E4                       xor	ah,ah
23944                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
23945 6D3A           3D                   0047  cmp	ax,*$47
23946 6D3D           75           06            jne 	.516
23947                       00006D3F            .517:
23948                                           ! 3716         goto int13_success;
23949 6D3F           83C4                   0E  add	sp,#..FFEF-..FFF0
23950 6D42           E9         0892            br 	.FFEF
23951                                           !BCC_EOS
23952                                           ! 3717       if ( ( AX >> 8 ) == 0x42 )
23953                       00006D45            .516:
23954                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23955 6D45           8B46         18            mov	ax,$18[bp]
23956 6D48           88E0                       mov	al,ah
23957 6D4A           30E4                       xor	ah,ah
23958                                           ! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
23959 6D4C           3D                   0042  cmp	ax,*$42
23960 6D4F           75           33            jne 	.519
23961                       00006D51            .51A:
23962                                           ! 3718         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23963                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23964 6D51           FF76         EC            push	-$14[bp]
23965                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23966 6D54           FF76         EE            push	-$12[bp]
23967                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23968 6D57           FF76         FA            push	-6[bp]
23969 6D5A           FF76         F8            push	-8[bp]
23970                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23971 6D5D           FF76         FE            push	-2[bp]
23972 6D60           FF76         FC            push	-4[bp]
23973                                           ! Debug: list int = const 0 (used reg = )
23974 6D63           31C0                       xor	ax,ax
23975 6D65           50                         push	ax
23976                                           ! Debug: list int = const 0 (used reg = )
23977 6D66           31C0                       xor	ax,ax
23978 6D68           50                         push	ax
23979                                           ! Debug: list int = const 0 (used reg = )
23980 6D69           31C0                       xor	ax,ax
23981 6D6B           50                         push	ax
23982                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23983 6D6C           FF76         DC            push	-$24[bp]
23984                                           ! Debug: list int = const $20 (used reg = )
23985 6D6F           B8                   0020  mov	ax,*$20
23986 6D72           50                         push	ax
23987                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23988 6D73           8A46         DB            mov	al,-$25[bp]
23989 6D76           30E4                       xor	ah,ah
23990 6D78           50                         push	ax
23991                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
23992 6D79           E8         BFBB            call	_ata_cmd_data_in
23993 6D7C           83C4                   18  add	sp,*$18
23994                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23995 6D7F           8846         DA            mov	-$26[bp],al
23996                                           !BCC_EOS
23997                                           ! 3719       else
23998                                           ! 3720         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
23999 6D82           EB           31            jmp .51B
24000                       00006D84            .519:
24001                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24002 6D84           FF76         EC            push	-$14[bp]
24003                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24004 6D87           FF76         EE            push	-$12[bp]
24005                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24006 6D8A           FF76         FA            push	-6[bp]
24007 6D8D           FF76         F8            push	-8[bp]
24008                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24009 6D90           FF76         FE            push	-2[bp]
24010 6D93           FF76         FC            push	-4[bp]
24011                                           ! Debug: list int = const 0 (used reg = )
24012 6D96           31C0                       xor	ax,ax
24013 6D98           50                         push	ax
24014                                           ! Debug: list int = const 0 (used reg = )
24015 6D99           31C0                       xor	ax,ax
24016 6D9B           50                         push	ax
24017                                           ! Debug: list int = const 0 (used reg = )
24018 6D9C           31C0                       xor	ax,ax
24019 6D9E           50                         push	ax
24020                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24021 6D9F           FF76         DC            push	-$24[bp]
24022                                           ! Debug: list int = const $30 (used reg = )
24023 6DA2           B8                   0030  mov	ax,*$30
24024 6DA5           50                         push	ax
24025                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24026 6DA6           8A46         DB            mov	al,-$25[bp]
24027 6DA9           30E4                       xor	ah,ah
24028 6DAB           50                         push	ax
24029                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24030 6DAC           E8         C359            call	_ata_cmd_data_out
24031 6DAF           83C4                   18  add	sp,*$18
24032                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24033 6DB2           8846         DA            mov	-$26[bp],al
24034                                           !BCC_EOS
24035                                           ! 3721       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
24036                       00006DB5            .51B:
24037                                           ! Debug: list * unsigned short = const $254 (used reg = )
24038 6DB5           B8                   0254  mov	ax,#$254
24039 6DB8           50                         push	ax
24040                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24041 6DB9           FF76         F6            push	-$A[bp]
24042                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24043 6DBC           E8         9848            call	_read_word
24044 6DBF           83C4                   04  add	sp,*4
24045                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24046 6DC2           8946         DC            mov	-$24[bp],ax
24047                                           !BCC_EOS
24048                                           ! 3722       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
24049                                           ! Debug: list unsigned short count = [S+$28-$26] (used reg = )
24050 6DC5           FF76         DC            push	-$24[bp]
24051                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
24052 6DC8           8B46         0C            mov	ax,$C[bp]
24053                                           ! Debug: list unsigned int = ax+2 (used reg = )
24054 6DCB           40                         inc	ax
24055 6DCC           40                         inc	ax
24056 6DCD           50                         push	ax
24057                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
24058 6DCE           FF76         06            push	6[bp]
24059                                           ! Debug: func () void = write_word+0 (used reg = )
24060 6DD1           E8         985E            call	_write_word
24061 6DD4           83C4                   06  add	sp,*6
24062                                           !BCC_EOS
24063                                           ! 3723       if (status != 0) {
24064                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24065 6DD7           8A46         DA            mov	al,-$26[bp]
24066 6DDA           84C0                       test	al,al
24067 6DDC           74           11            je  	.51C
24068                       00006DDE            .51D:
24069                                           ! 3724         ;
24070                                           !BCC_EOS
24071                                           ! 3725         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24072                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24073 6DDE           8A46         18            mov	al,$18[bp]
24074                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24075 6DE1           30E4                       xor	ah,ah
24076 6DE3           0D                   0C00  or	ax,#$C00
24077                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24078 6DE6           8946         18            mov	$18[bp],ax
24079                                           !BCC_EOS
24080                                           ! 3726         goto int13_fail_noah;
24081 6DE9           83C4                   0E  add	sp,#..FFEC-..FFF0
24082 6DEC           E9         07C6            br 	.FFEC
24083                                           !BCC_EOS
24084                                           ! 3727         }
24085                                           ! 3728       goto int13_success;
24086                       00006DEF            .51C:
24087 6DEF           83C4                   0E  add	sp,#..FFEF-..FFF0
24088 6DF2           E9         07E2            br 	.FFEF
24089                                           !BCC_EOS
24090                                           ! 3729       break;
24091 6DF5           E9         07AF            br 	.4E8
24092                                           !BCC_EOS
24093                                           ! 3730     case 0x45:
24094                                           ! 3731     case 0x49:
24095                       00006DF8            .51E:
24096                                           ! 3732       goto int13_success;
24097                       00006DF8            .51F:
24098 6DF8           83C4                   0E  add	sp,#..FFEF-..FFF0
24099 6DFB           E9         07D9            br 	.FFEF
24100                                           !BCC_EOS
24101                                           ! 3733       break;
24102 6DFE           E9         07A6            br 	.4E8
24103                                           !BCC_EOS
24104                                           ! 3734     case 0x46:
24105                                           ! 3735       AX = ((AX & 0x00ff) | ((0xb2) << 8));
24106                       00006E01            .520:
24107                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24108 6E01           8A46         18            mov	al,$18[bp]
24109                                           ! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
24110 6E04           30E4                       xor	ah,ah
24111 6E06           0D                   B200  or	ax,#-$4E00
24112                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24113 6E09           8946         18            mov	$18[bp],ax
24114                                           !BCC_EOS
24115                                           ! 3736       goto int13_fail_noah;
24116 6E0C           83C4                   0E  add	sp,#..FFEC-..FFF0
24117 6E0F           E9         07A3            br 	.FFEC
24118                                           !BCC_EOS
24119                                           ! 3737       break;
24120 6E12           E9         0792            br 	.4E8
24121                                           !BCC_EOS
24122                                           ! 3738     case 0x48:
24123                                           ! 3739       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
24124                       00006E15            .521:
24125                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
24126 6E15           8B46         0C            mov	ax,$C[bp]
24127                                           ! Debug: list unsigned int = ax+0 (used reg = )
24128 6E18           50                         push	ax
24129                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24130 6E19           FF76         06            push	6[bp]
24131                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24132 6E1C           E8         97E8            call	_read_word
24133 6E1F           83C4                   04  add	sp,*4
24134                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
24135 6E22           8946         DE            mov	-$22[bp],ax
24136                                           !BCC_EOS
24137                                           ! 3740       if(size < 0x1a)
24138                                           ! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24139 6E25           8B46         DE            mov	ax,-$22[bp]
24140 6E28           3D                   001A  cmp	ax,*$1A
24141 6E2B           73           06            jae 	.522
24142                       00006E2D            .523:
24143                                           ! 3741         goto int13_fail;
24144 6E2D           83C4                   0E  add	sp,#..FFF1-..FFF0
24145 6E30           E9         0777            br 	.FFF1
24146                                           !BCC_EOS
24147                                           ! 3742       if(size >= 0x1a) {
24148                       00006E33            .522:
24149                                           ! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24150 6E33           8B46         DE            mov	ax,-$22[bp]
24151 6E36           3D                   001A  cmp	ax,*$1A
24152 6E39         0F82         01E3            blo 	.524
24153                       00006E3D            .525:
24154                                           ! 3743         Bit16u blksize;
24155                                           !BCC_EOS
24156                                           ! 3744         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
24157                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24158 6E3D           8A46         DB            mov	al,-$25[bp]
24159 6E40           30E4                       xor	ah,ah
24160 6E42           B9                   001E  mov	cx,*$1E
24161 6E45           F7E9                       imul	cx
24162 6E47           89C3                       mov	bx,ax
24163                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
24164                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
24165 6E49           81C3                 0154  add	bx,#$154
24166 6E4D           53                         push	bx
24167                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24168 6E4E           FF76         F6            push	-$A[bp]
24169                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24170 6E51           E8         97B3            call	_read_word
24171 6E54           83C4                   04  add	sp,*4
24172                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
24173 6E57           8946         EA            mov	-$16[bp],ax
24174                                           !BCC_EOS
24175                                           ! 3745         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
24176                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24177 6E5A           8A46         DB            mov	al,-$25[bp]
24178 6E5D           30E4                       xor	ah,ah
24179 6E5F           B9                   001E  mov	cx,*$1E
24180 6E62           F7E9                       imul	cx
24181 6E64           89C3                       mov	bx,ax
24182                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
24183                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
24184 6E66           81C3                 0152  add	bx,#$152
24185 6E6A           53                         push	bx
24186                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24187 6E6B           FF76         F6            push	-$A[bp]
24188                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24189 6E6E           E8         9796            call	_read_word
24190 6E71           83C4                   04  add	sp,*4
24191                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24192 6E74           8946         E8            mov	-$18[bp],ax
24193                                           !BCC_EOS
24194                                           ! 3746         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
24195                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24196 6E77           8A46         DB            mov	al,-$25[bp]
24197 6E7A           30E4                       xor	ah,ah
24198 6E7C           B9                   001E  mov	cx,*$1E
24199 6E7F           F7E9                       imul	cx
24200 6E81           89C3                       mov	bx,ax
24201                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
24202                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
24203 6E83           81C3                 0156  add	bx,#$156
24204 6E87           53                         push	bx
24205                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24206 6E88           FF76         F6            push	-$A[bp]
24207                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24208 6E8B           E8         9779            call	_read_word
24209 6E8E           83C4                   04  add	sp,*4
24210                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
24211 6E91           8946         E6            mov	-$1A[bp],ax
24212                                           !BCC_EOS
24213                                           ! 3747         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
24214                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24215 6E94           8A46         DB            mov	al,-$25[bp]
24216 6E97           30E4                       xor	ah,ah
24217 6E99           B9                   001E  mov	cx,*$1E
24218 6E9C           F7E9                       imul	cx
24219 6E9E           89C3                       mov	bx,ax
24220                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24221                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24222 6EA0           81C3                 0158  add	bx,#$158
24223 6EA4           53                         push	bx
24224                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24225 6EA5           FF76         F6            push	-$A[bp]
24226                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24227 6EA8           E8         91D8            call	_read_dword
24228 6EAB           89D3                       mov	bx,dx
24229 6EAD           83C4                   04  add	sp,*4
24230                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
24231 6EB0           8946         FC            mov	-4[bp],ax
24232 6EB3           895E         FE            mov	-2[bp],bx
24233                                           !BCC_EOS
24234                                           ! 3748         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
24235                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24236 6EB6           8A46         DB            mov	al,-$25[bp]
24237 6EB9           30E4                       xor	ah,ah
24238 6EBB           B9                   001E  mov	cx,*$1E
24239 6EBE           F7E9                       imul	cx
24240 6EC0           89C3                       mov	bx,ax
24241                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24242                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24243 6EC2           81C3                 015C  add	bx,#$15C
24244 6EC6           53                         push	bx
24245                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24246 6EC7           FF76         F6            push	-$A[bp]
24247                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24248 6ECA           E8         91B6            call	_read_dword
24249 6ECD           89D3                       mov	bx,dx
24250 6ECF           83C4                   04  add	sp,*4
24251                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
24252 6ED2           8946         F8            mov	-8[bp],ax
24253 6ED5           895E         FA            mov	-6[bp],bx
24254                                           !BCC_EOS
24255                                           ! 3749         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
24256                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24257 6ED8           8A46         DB            mov	al,-$25[bp]
24258 6EDB           30E4                       xor	ah,ah
24259 6EDD           B9                   001E  mov	cx,*$1E
24260 6EE0           F7E9                       imul	cx
24261 6EE2           89C3                       mov	bx,ax
24262                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
24263                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
24264 6EE4           81C3                 0148  add	bx,#$148
24265 6EE8           53                         push	bx
24266                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24267 6EE9           FF76         F6            push	-$A[bp]
24268                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24269 6EEC           E8         9718            call	_read_word
24270 6EEF           83C4                   04  add	sp,*4
24271                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
24272 6EF2           8946         D8            mov	-$28[bp],ax
24273                                           !BCC_EOS
24274                                           ! 3750         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
24275                                           ! Debug: list int = const $1A (used reg = )
24276 6EF5           B8                   001A  mov	ax,*$1A
24277 6EF8           50                         push	ax
24278                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
24279 6EF9           8B46         0C            mov	ax,$C[bp]
24280                                           ! Debug: list unsigned int = ax+0 (used reg = )
24281 6EFC           50                         push	ax
24282                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24283 6EFD           FF76         06            push	6[bp]
24284                                           ! Debug: func () void = write_word+0 (used reg = )
24285 6F00           E8         972F            call	_write_word
24286 6F03           83C4                   06  add	sp,*6
24287                                           !BCC_EOS
24288                                           ! 3751         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
24289 6F06           8B46         F8            mov	ax,-8[bp]
24290 6F09           8B5E         FA            mov	bx,-6[bp]
24291 6F0C           E8         9205            call	ltstl
24292 6F0F           75           50            jne 	.527
24293                       00006F11            .528:
24294                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24295 6F11           8B46         E8            mov	ax,-$18[bp]
24296 6F14           31DB                       xor	bx,bx
24297 6F16           53                         push	bx
24298 6F17           50                         push	ax
24299                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
24300 6F18           8B46         E6            mov	ax,-$1A[bp]
24301 6F1B           31DB                       xor	bx,bx
24302                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
24303 6F1D           53                         push	bx
24304 6F1E           50                         push	ax
24305 6F1F           8B46         FC            mov	ax,-4[bp]
24306 6F22           8B5E         FE            mov	bx,-2[bp]
24307 6F25           8D7E         C4            lea	di,-6+..FFF0[bp]
24308 6F28           E8         9243            call	ldivul
24309 6F2B           83C4                   04  add	sp,*4
24310                                           ! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
24311 6F2E           8D7E         C8            lea	di,-2+..FFF0[bp]
24312 6F31           E8         923A            call	ldivul
24313 6F34           83C4                   04  add	sp,*4
24314                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
24315 6F37           53                         push	bx
24316 6F38           50                         push	ax
24317 6F39           B8                   3FFF  mov	ax,#$3FFF
24318 6F3C           31DB                       xor	bx,bx
24319 6F3E           53                         push	bx
24320 6F3F           50                         push	ax
24321 6F40           8B46         C8            mov	ax,-2+..FFF0[bp]
24322 6F43           8B5E         CA            mov	bx,0+..FFF0[bp]
24323 6F46           8D7E         C4            lea	di,-6+..FFF0[bp]
24324 6F49           E8         917F            call	lcmpul
24325 6F4C           76           04            jbe	.529
24326 6F4E           B0                     01  mov	al,*1
24327 6F50           EB           02            jmp	.52A
24328                       00006F52            .529:
24329 6F52           30C0                       xor	al,al
24330                       00006F54            .52A:
24331 6F54           83C4                   08  add	sp,*8
24332                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
24333 6F57           30E4                       xor	ah,ah
24334 6F59           99                         cwd
24335 6F5A           89D3                       mov	bx,dx
24336 6F5C           E8         91B5            call	ltstl
24337 6F5F           74           28            je  	.526
24338                       00006F61            .527:
24339                                           ! 3752         {
24340                                           ! 3753           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
24341                                           ! Debug: list int = const 0 (used reg = )
24342 6F61           31C0                       xor	ax,ax
24343 6F63           50                         push	ax
24344                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
24345 6F64           8B46         0C            mov	ax,$C[bp]
24346                                           ! Debug: list unsigned int = ax+2 (used reg = )
24347 6F67           40                         inc	ax
24348 6F68           40                         inc	ax
24349 6F69           50                         push	ax
24350                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24351 6F6A           FF76         06            push	6[bp]
24352                                           ! Debug: func () void = write_word+0 (used reg = )
24353 6F6D           E8         96C2            call	_write_word
24354 6F70           83C4                   06  add	sp,*6
24355                                           !BCC_EOS
24356                                           ! 3754           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
24357                                           ! Debug: list int = const $3FFF (used reg = )
24358 6F73           B8                   3FFF  mov	ax,#$3FFF
24359 6F76           50                         push	ax
24360                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
24361 6F77           8B46         0C            mov	ax,$C[bp]
24362                                           ! Debug: list unsigned int = ax+4 (used reg = )
24363 6F7A           05                   0004  add	ax,*4
24364 6F7D           50                         push	ax
24365                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24366 6F7E           FF76         06            push	6[bp]
24367                                           ! Debug: func () void = write_dword+0 (used reg = )
24368 6F81           E8         9117            call	_write_dword
24369 6F84           83C4                   06  add	sp,*6
24370                                           !BCC_EOS
24371                                           ! 3755         }
24372                                           ! 3756         else
24373                                           ! 3757         {
24374 6F87           EB           2A            jmp .52C
24375                       00006F89            .526:
24376                                           ! 3758           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
24377                                           ! Debug: list int = const 2 (used reg = )
24378 6F89           B8                   0002  mov	ax,*2
24379 6F8C           50                         push	ax
24380                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
24381 6F8D           8B46         0C            mov	ax,$C[bp]
24382                                           ! Debug: list unsigned int = ax+2 (used reg = )
24383 6F90           40                         inc	ax
24384 6F91           40                         inc	ax
24385 6F92           50                         push	ax
24386                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24387 6F93           FF76         06            push	6[bp]
24388                                           ! Debug: func () void = write_word+0 (used reg = )
24389 6F96           E8         9699            call	_write_word
24390 6F99           83C4                   06  add	sp,*6
24391                                           !BCC_EOS
24392                                           ! 3759           write_dwo
24393                                           ! 3759 rd(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
24394                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
24395 6F9C           8B46         EA            mov	ax,-$16[bp]
24396 6F9F           31DB                       xor	bx,bx
24397                                           ! Debug: list unsigned long = bx+0 (used reg = )
24398 6FA1           53                         push	bx
24399 6FA2           50                         push	ax
24400                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
24401 6FA3           8B46         0C            mov	ax,$C[bp]
24402                                           ! Debug: list unsigned int = ax+4 (used reg = )
24403 6FA6           05                   0004  add	ax,*4
24404 6FA9           50                         push	ax
24405                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24406 6FAA           FF76         06            push	6[bp]
24407                                           ! Debug: func () void = write_dword+0 (used reg = )
24408 6FAD           E8         90EB            call	_write_dword
24409 6FB0           83C4                   08  add	sp,*8
24410                                           !BCC_EOS
24411                                           ! 3760         }
24412                                           ! 3761         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
24413                       00006FB3            .52C:
24414                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24415 6FB3           8B46         E8            mov	ax,-$18[bp]
24416 6FB6           31DB                       xor	bx,bx
24417                                           ! Debug: list unsigned long = bx+0 (used reg = )
24418 6FB8           53                         push	bx
24419 6FB9           50                         push	ax
24420                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
24421 6FBA           8B46         0C            mov	ax,$C[bp]
24422                                           ! Debug: list unsigned int = ax+8 (used reg = )
24423 6FBD           05                   0008  add	ax,*8
24424 6FC0           50                         push	ax
24425                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24426 6FC1           FF76         06            push	6[bp]
24427                                           ! Debug: func () void = write_dword+0 (used reg = )
24428 6FC4           E8         90D4            call	_write_dword
24429 6FC7           83C4                   08  add	sp,*8
24430                                           !BCC_EOS
24431                                           ! 3762         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
24432                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
24433 6FCA           8B46         E6            mov	ax,-$1A[bp]
24434 6FCD           31DB                       xor	bx,bx
24435                                           ! Debug: list unsigned long = bx+0 (used reg = )
24436 6FCF           53                         push	bx
24437 6FD0           50                         push	ax
24438                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
24439 6FD1           8B46         0C            mov	ax,$C[bp]
24440                                           ! Debug: list unsigned int = ax+$C (used reg = )
24441 6FD4           05                   000C  add	ax,*$C
24442 6FD7           50                         push	ax
24443                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24444 6FD8           FF76         06            push	6[bp]
24445                                           ! Debug: func () void = write_dword+0 (used reg = )
24446 6FDB           E8         90BD            call	_write_dword
24447 6FDE           83C4                   08  add	sp,*8
24448                                           !BCC_EOS
24449                                           ! 3763         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
24450                                           ! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
24451 6FE1           FF76         FE            push	-2[bp]
24452 6FE4           FF76         FC            push	-4[bp]
24453                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
24454 6FE7           8B46         0C            mov	ax,$C[bp]
24455                                           ! Debug: list unsigned int = ax+$10 (used reg = )
24456 6FEA           05                   0010  add	ax,*$10
24457 6FED           50                         push	ax
24458                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24459 6FEE           FF76         06            push	6[bp]
24460                                           ! Debug: func () void = write_dword+0 (used reg = )
24461 6FF1           E8         90A7            call	_write_dword
24462 6FF4           83C4                   08  add	sp,*8
24463                                           !BCC_EOS
24464                                           ! 3764         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
24465                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
24466 6FF7           FF76         FA            push	-6[bp]
24467 6FFA           FF76         F8            push	-8[bp]
24468                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
24469 6FFD           8B46         0C            mov	ax,$C[bp]
24470                                           ! Debug: list unsigned int = ax+$14 (used reg = )
24471 7000           05                   0014  add	ax,*$14
24472 7003           50                         push	ax
24473                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24474 7004           FF76         06            push	6[bp]
24475                                           ! Debug: func () void = write_dword+0 (used reg = )
24476 7007           E8         9091            call	_write_dword
24477 700A           83C4                   08  add	sp,*8
24478                                           !BCC_EOS
24479                                           ! 3765         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
24480                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
24481 700D           FF76         D8            push	-$28[bp]
24482                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
24483 7010           8B46         0C            mov	ax,$C[bp]
24484                                           ! Debug: list unsigned int = ax+$18 (used reg = )
24485 7013           05                   0018  add	ax,*$18
24486 7016           50                         push	ax
24487                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24488 7017           FF76         06            push	6[bp]
24489                                           ! Debug: func () void = write_word+0 (used reg = )
24490 701A           E8         9615            call	_write_word
24491 701D           83C4                   06  add	sp,*6
24492                                           !BCC_EOS
24493                                           ! 3766         }
24494                                           ! 3767       if(size >= 0x1e) {
24495                       00007020            .524:
24496                                           ! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
24497 7020           8B46         DE            mov	ax,-$22[bp]
24498 7023           3D                   001E  cmp	ax,*$1E
24499 7026         0F82         0273            blo 	.52D
24500                       0000702A            .52E:
24501                                           ! 3768         Bit8u channel, dev, irq, mode, checksum, i, translation;
24502                                           !BCC_EOS
24503                                           ! 3769         Bit16u iobase1, iobase2, options;
24504                                           !BCC_EOS
24505                                           ! 3770         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
24506                                           ! Debug: list int = const $1E (used reg = )
24507 702A           B8                   001E  mov	ax,*$1E
24508 702D           50                         push	ax
24509                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
24510 702E           8B46         0C            mov	ax,$C[bp]
24511                                           ! Debug: list unsigned int = ax+0 (used reg = )
24512 7031           50                         push	ax
24513                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24514 7032           FF76         06            push	6[bp]
24515                                           ! Debug: func () void = write_word+0 (used reg = )
24516 7035           E8         95FA            call	_write_word
24517 7038           83C4                   06  add	sp,*6
24518                                           !BCC_EOS
24519                                           ! 3771         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
24520                                           ! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
24521 703B           FF76         F6            push	-$A[bp]
24522                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
24523 703E           8B46         0C            mov	ax,$C[bp]
24524                                           ! Debug: list unsigned int = ax+$1C (used reg = )
24525 7041           05                   001C  add	ax,*$1C
24526 7044           50                         push	ax
24527                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24528 7045           FF76         06            push	6[bp]
24529                                           ! Debug: func () void = write_word+0 (used reg = )
24530 7048           E8         95E7            call	_write_word
24531 704B           83C4                   06  add	sp,*6
24532                                           !BCC_EOS
24533                                           ! 3772         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
24534                                           ! Debug: list * struct  = const $244 (used reg = )
24535 704E           B8                   0244  mov	ax,#$244
24536 7051           50                         push	ax
24537                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
24538 7052           8B46         0C            mov	ax,$C[bp]
24539                                           ! Debug: list unsigned int = ax+$1A (used reg = )
24540 7055           05                   001A  add	ax,*$1A
24541 7058           50                         push	ax
24542                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24543 7059           FF76         06            push	6[bp]
24544                                           ! Debug: func () void = write_word+0 (used reg = )
24545 705C           E8         95D3            call	_write_word
24546 705F           83C4                   06  add	sp,*6
24547                                           !BCC_EOS
24548                                           ! 3773         channel = device / 2;
24549                                           ! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
24550 7062           8A46         DB            mov	al,-$25[bp]
24551 7065           30E4                       xor	ah,ah
24552 7067           D1E8                       shr	ax,*1
24553                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
24554 7069           8846         D9            mov	-$27[bp],al
24555                                           !BCC_EOS
24556                                           ! 3774         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
24557                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24558 706C           8A46         D9            mov	al,-$27[bp]
24559 706F           30E4                       xor	ah,ah
24560 7071           B1                     03  mov	cl,*3
24561 7073           D3E0                       shl	ax,cl
24562 7075           89C3                       mov	bx,ax
24563                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
24564                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
24565 7077           81C3                 0124  add	bx,#$124
24566 707B           53                         push	bx
24567                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24568 707C           FF76         F6            push	-$A[bp]
24569                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24570 707F           E8         9585            call	_read_word
24571 7082           83C4                   04  add	sp,*4
24572                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
24573 7085           8946         D0            mov	-$30[bp],ax
24574                                           !BCC_EOS
24575                                           ! 3775         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
24576                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24577 7088           8A46         D9            mov	al,-$27[bp]
24578 708B           30E4                       xor	ah,ah
24579 708D           B1                     03  mov	cl,*3
24580 708F           D3E0                       shl	ax,cl
24581 7091           89C3                       mov	bx,ax
24582                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
24583                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
24584 7093           81C3                 0126  add	bx,#$126
24585 7097           53                         push	bx
24586                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24587 7098           FF76         F6            push	-$A[bp]
24588                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24589 709B           E8         9569            call	_read_word
24590 709E           83C4                   04  add	sp,*4
24591                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
24592 70A1           8946         CE            mov	-$32[bp],ax
24593                                           !BCC_EOS
24594                                           ! 3776         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
24595                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24596 70A4           8A46         D9            mov	al,-$27[bp]
24597 70A7           30E4                       xor	ah,ah
24598 70A9           B1                     03  mov	cl,*3
24599 70AB           D3E0                       shl	ax,cl
24600 70AD           89C3                       mov	bx,ax
24601                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
24602                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
24603 70AF           81C3                 0128  add	bx,#$128
24604 70B3           53                         push	bx
24605                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24606 70B4           FF76         F6            push	-$A[bp]
24607                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24608 70B7           E8         953A            call	_read_byte
24609 70BA           83C4                   04  add	sp,*4
24610                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
24611 70BD           8846         D7            mov	-$29[bp],al
24612                                           !BCC_EOS
24613                                           ! 3777         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
24614                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
24615 70C0           8A46         DB            mov	al,-$25[bp]
24616 70C3           30E4                       xor	ah,ah
24617 70C5           B9                   001E  mov	cx,*$1E
24618 70C8           F7E9                       imul	cx
24619 70CA           89C3                       mov	bx,ax
24620                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
24621                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
24622 70CC           81C3                 0146  add	bx,#$146
24623 70D0           53                         push	bx
24624                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24625 70D1           FF76         F6            push	-$A[bp]
24626                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24627 70D4           E8         951D            call	_read_byte
24628 70D7           83C4                   04  add	sp,*4
24629                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
24630 70DA           8846         D6            mov	-$2A[bp],al
24631                                           !BCC_EOS
24632                                           ! 3778         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
24633                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
24634 70DD           8A46         DB            mov	al,-$25[bp]
24635 70E0           30E4                       xor	ah,ah
24636 70E2           B9                   001E  mov	cx,*$1E
24637 70E5           F7E9                       imul	cx
24638 70E7           89C3                       mov	bx,ax
24639                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
24640                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
24641 70E9           81C3                 014A  add	bx,#$14A
24642 70ED           53                         push	bx
24643                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24644 70EE           FF76         F6            push	-$A[bp]
24645                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24646 70F1           E8         9500            call	_read_byte
24647 70F4           83C4                   04  add	sp,*4
24648                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
24649 70F7           8846         D3            mov	-$2D[bp],al
24650                                           !BCC_EOS
24651                                           ! 3779         options = (translation==0?0:1)<<3;
24652                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
24653 70FA           8A46         D3            mov	al,-$2D[bp]
24654 70FD           84C0                       test	al,al
24655 70FF           75           04            jne 	.52F
24656                       00007101            .530:
24657 7101           30C0                       xor	al,al
24658 7103           EB           02            jmp .531
24659                       00007105            .52F:
24660 7105           B0                     01  mov	al,*1
24661                       00007107            .531:
24662                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
24663 7107           30E4                       xor	ah,ah
24664 7109           B1                     03  mov	cl,*3
24665 710B           D3E0                       shl	ax,cl
24666                                           ! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24667 710D           8946         CC            mov	-$34[bp],ax
24668                                           !BCC_EOS
24669                                           ! 3780         options |= (1<<4);
24670                                           ! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
24671 7110           8B46         CC            mov	ax,-$34[bp]
24672 7113           0C                     10  or	al,*$10
24673 7115           8946         CC            mov	-$34[bp],ax
24674                                           !BCC_EOS
24675                                           ! 3781         options |= (mode==0x01?1:0)<<7;
24676                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
24677 7118           8A46         D6            mov	al,-$2A[bp]
24678 711B           3C                     01  cmp	al,*1
24679 711D           75           04            jne 	.532
24680                       0000711F            .533:
24681 711F           B0                     01  mov	al,*1
24682 7121           EB           02            jmp .534
24683                       00007123            .532:
24684 7123           30C0                       xor	al,al
24685                       00007125            .534:
24686                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
24687 7125           30E4                       xor	ah,ah
24688 7127           B1                     07  mov	cl,*7
24689 7129           D3E0                       shl	ax,cl
24690                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24691 712B           0B46         CC            or	ax,-$34[bp]
24692 712E           8946         CC            mov	-$34[bp],ax
24693                                           !BCC_EOS
24694                                           ! 3782         options |= (translation==1?1:0)<<9;
24695                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
24696 7131           8A46         D3            mov	al,-$2D[bp]
24697 7134           3C                     01  cmp	al,*1
24698 7136           75           04            jne 	.535
24699                       00007138            .536:
24700 7138           B0                     01  mov	al,*1
24701 713A           EB           02            jmp .537
24702                       0000713C            .535:
24703 713C           30C0                       xor	al,al
24704                       0000713E            .537:
24705                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
24706 713E           30E4                       xor	ah,ah
24707 7140           88C4                       mov	ah,al
24708 7142           30C0                       xor	al,al
24709 7144           D1E0                       shl	ax,*1
24710                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24711 7146           0B46         CC            or	ax,-$34[bp]
24712 7149           8946         CC            mov	-$34[bp],ax
24713                                           !BCC_EOS
24714                                           ! 3783         options |= (translation==3?3:0)<<9;
24715                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
24716 714C           8A46         D3            mov	al,-$2D[bp]
24717 714F           3C                     03  cmp	al,*3
24718 7151           75           04            jne 	.538
24719                       00007153            .539:
24720 7153           B0                     03  mov	al,*3
24721 7155           EB           02            jmp .53A
24722                       00007157            .538:
24723 7157           30C0                       xor	al,al
24724                       00007159            .53A:
24725                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
24726 7159           30E4                       xor	ah,ah
24727 715B           88C4                       mov	ah,al
24728 715D           30C0                       xor	al,al
24729 715F           D1E0                       shl	ax,*1
24730                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24731 7161           0B46         CC            or	ax,-$34[bp]
24732 7164           8946         CC            mov	-$34[bp],ax
24733                                           !BCC_EOS
24734                                           ! 3784         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
24735                                           ! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
24736 7167           FF76         D0            push	-$30[bp]
24737                                           ! Debug: list * unsigned short = const $244 (used reg = )
24738 716A           B8                   0244  mov	ax,#$244
24739 716D           50                         push	ax
24740                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24741 716E           FF76         F6            push	-$A[bp]
24742                                           ! Debug: func () void = write_word+0 (used reg = )
24743 7171           E8         94BE            call	_write_word
24744 7174           83C4                   06  add	sp,*6
24745                                           !BCC_EOS
24746                                           ! 3785         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
24747                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
24748 7177           8B46         CE            mov	ax,-$32[bp]
24749                                           ! Debug: list unsigned int = ax+6 (used reg = )
24750 717A           05                   0006  add	ax,*6
24751 717D           50                         push	ax
24752                                           ! Debug: list * unsigned short = const $246 (used reg = )
24753 717E           B8                   0246  mov	ax,#$246
24754 7181           50                         push	ax
24755                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24756 7182           FF76         F6            push	-$A[bp]
24757                                           ! Debug: func () void = write_word+0 (used reg = )
24758 7185           E8         94AA            call	_write_word
24759 7188           83C4                   06  add	sp,*6
24760                                           !BCC_EOS
24761                                           ! 3786         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
24762                                           ! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
24763 718B           8A46         DB            mov	al,-$25[bp]
24764 718E           30E4                       xor	ah,ah
24765 7190           24                     01  and	al,*1
24766                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
24767                                           ! Debug: expression subtree swapping
24768 7192           0C                     0E  or	al,*$E
24769                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
24770 7194           30E4                       xor	ah,ah
24771 7196           B1                     04  mov	cl,*4
24772 7198           D3E0                       shl	ax,cl
24773                                           ! Debug: list unsigned int = ax+0 (used reg = )
24774 719A           50                         push	ax
24775                                           ! Debug: list * unsigned char = const $248 (used reg = )
24776 719B           B8                   0248  mov	ax,#$248
24777 719E           50                         push	ax
24778                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24779 719F           FF76         F6            push	-$A[bp]
24780                                           ! Debug: func () void = write_byte+0 (used reg = )
24781 71A2           E8         9475            call	_write_byte
24782 71A5           83C4                   06  add	sp,*6
24783                                           !BCC_EOS
24784                                           ! 3787         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
24785                                           ! Debug: list int = const $CB (used reg = )
24786 71A8           B8                   00CB  mov	ax,#$CB
24787 71AB           50                         push	ax
24788                                           ! Debug: list * unsigned char = const $249 (used reg = )
24789 71AC           B8                   0249  mov	ax,#$249
24790 71AF           50                         push	ax
24791                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24792 71B0           FF76         F6            push	-$A[bp]
24793                                           ! Debug: func () void = write_byte+0 (used reg = )
24794 71B3           E8         9464            call	_write_byte
24795 71B6           83C4                   06  add	sp,*6
24796                                           !BCC_EOS
24797                                           ! 3788         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
24798                                           ! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
24799 71B9           8A46         D7            mov	al,-$29[bp]
24800 71BC           30E4                       xor	ah,ah
24801 71BE           50                         push	ax
24802                                           ! Debug: list * unsigned char = const $24A (used reg = )
24803 71BF           B8                   024A  mov	ax,#$24A
24804 71C2           50                         push	ax
24805                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24806 71C3           FF76         F6            push	-$A[bp]
24807                                           ! Debug: func () void = write_byte+0 (used reg = )
24808 71C6           E8         9451            call	_write_byte
24809 71C9           83C4                   06  add	sp,*6
24810                                           !BCC_EOS
24811                                           ! 3789         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
24812                                           ! Debug: list int = const 1 (used reg = )
24813 71CC           B8                   0001  mov	ax,*1
24814 71CF           50                         push	ax
24815                                           ! Debug: list * unsigned char = const $24B (used reg = )
24816 71D0           B8                   024B  mov	ax,#$24B
24817 71D3           50                         push	ax
24818                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24819 71D4           FF76         F6            push	-$A[bp]
24820                                           ! Debug: func () void = write_byte+0 (used reg = )
24821 71D7           E8         9440            call	_write_byte
24822 71DA           83C4                   06  add	sp,*6
24823                                           !BCC_EOS
24824                                           ! 3790         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
24825                                           ! Debug: list int = const 0 (used reg = )
24826 71DD           31C0                       xor	ax,ax
24827 71DF           50                         push	ax
24828                                           ! Debug: list * unsigned char = const $24C (used reg = )
24829 71E0           B8                   024C  mov	ax,#$24C
24830 71E3           50                         push	ax
24831                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24832 71E4           FF76         F6            push	-$A[bp]
24833                                           ! Debug: func () void = write_byte+0 (used reg = )
24834 71E7           E8         9430            call	_write_byte
24835 71EA           83C4                   06  add	sp,*6
24836                                           !BCC_EOS
24837                                           ! 3791         w
24838                                           ! 3791 rite_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
24839                                           ! Debug: list int = const 0 (used reg = )
24840 71ED           31C0                       xor	ax,ax
24841 71EF           50                         push	ax
24842                                           ! Debug: list * unsigned char = const $24D (used reg = )
24843 71F0           B8                   024D  mov	ax,#$24D
24844 71F3           50                         push	ax
24845                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24846 71F4           FF76         F6            push	-$A[bp]
24847                                           ! Debug: func () void = write_byte+0 (used reg = )
24848 71F7           E8         9420            call	_write_byte
24849 71FA           83C4                   06  add	sp,*6
24850                                           !BCC_EOS
24851                                           ! 3792         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
24852                                           ! Debug: list unsigned short options = [S+$36-$36] (used reg = )
24853 71FD           FF76         CC            push	-$34[bp]
24854                                           ! Debug: list * unsigned short = const $24E (used reg = )
24855 7200           B8                   024E  mov	ax,#$24E
24856 7203           50                         push	ax
24857                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24858 7204           FF76         F6            push	-$A[bp]
24859                                           ! Debug: func () void = write_word+0 (used reg = )
24860 7207           E8         9428            call	_write_word
24861 720A           83C4                   06  add	sp,*6
24862                                           !BCC_EOS
24863                                           ! 3793         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
24864                                           ! Debug: list int = const 0 (used reg = )
24865 720D           31C0                       xor	ax,ax
24866 720F           50                         push	ax
24867                                           ! Debug: list * unsigned short = const $250 (used reg = )
24868 7210           B8                   0250  mov	ax,#$250
24869 7213           50                         push	ax
24870                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24871 7214           FF76         F6            push	-$A[bp]
24872                                           ! Debug: func () void = write_word+0 (used reg = )
24873 7217           E8         9418            call	_write_word
24874 721A           83C4                   06  add	sp,*6
24875                                           !BCC_EOS
24876                                           ! 3794         if (size >=0x42)
24877                                           ! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
24878 721D           8B46         DE            mov	ax,-$22[bp]
24879 7220           3D                   0042  cmp	ax,*$42
24880 7223           72           13            jb  	.53B
24881                       00007225            .53C:
24882                                           ! 3795           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
24883                                           ! Debug: list int = const $11 (used reg = )
24884 7225           B8                   0011  mov	ax,*$11
24885 7228           50                         push	ax
24886                                           ! Debug: list * unsigned char = const $252 (used reg = )
24887 7229           B8                   0252  mov	ax,#$252
24888 722C           50                         push	ax
24889                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24890 722D           FF76         F6            push	-$A[bp]
24891                                           ! Debug: func () void = write_byte+0 (used reg = )
24892 7230           E8         93E7            call	_write_byte
24893 7233           83C4                   06  add	sp,*6
24894                                           !BCC_EOS
24895                                           ! 3796         else
24896                                           ! 3797           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
24897 7236           EB           11            jmp .53D
24898                       00007238            .53B:
24899                                           ! Debug: list int = const $10 (used reg = )
24900 7238           B8                   0010  mov	ax,*$10
24901 723B           50                         push	ax
24902                                           ! Debug: list * unsigned char = const $252 (used reg = )
24903 723C           B8                   0252  mov	ax,#$252
24904 723F           50                         push	ax
24905                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24906 7240           FF76         F6            push	-$A[bp]
24907                                           ! Debug: func () void = write_byte+0 (used reg = )
24908 7243           E8         93D4            call	_write_byte
24909 7246           83C4                   06  add	sp,*6
24910                                           !BCC_EOS
24911                                           ! 3798         checksum=0;
24912                       00007249            .53D:
24913                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
24914 7249           30C0                       xor	al,al
24915 724B           8846         D5            mov	-$2B[bp],al
24916                                           !BCC_EOS
24917                                           ! 3799         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
24918                                           ! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
24919 724E           30C0                       xor	al,al
24920 7250           8846         D4            mov	-$2C[bp],al
24921                                           !BCC_EOS
24922                                           !BCC_EOS
24923 7253           EB           24            jmp .540
24924                       00007255            .541:
24925                                           ! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
24926 7255           8A46         D4            mov	al,-$2C[bp]
24927 7258           30E4                       xor	ah,ah
24928                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
24929 725A           05                   0244  add	ax,#$244
24930 725D           50                         push	ax
24931                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24932 725E           FF76         F6            push	-$A[bp]
24933                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24934 7261           E8         9390            call	_read_byte
24935 7264           83C4                   04  add	sp,*4
24936                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
24937 7267           30E4                       xor	ah,ah
24938 7269           0246         D5            add	al,-$2B[bp]
24939 726C           80D4                   00  adc	ah,*0
24940 726F           8846         D5            mov	-$2B[bp],al
24941                                           !BCC_EOS
24942                                           ! 3800         checksum = ~checksum;
24943                       00007272            .53F:
24944                                           ! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
24945 7272           8A46         D4            mov	al,-$2C[bp]
24946 7275           40                         inc	ax
24947 7276           8846         D4            mov	-$2C[bp],al
24948                       00007279            .540:
24949                                           ! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
24950 7279           8A46         D4            mov	al,-$2C[bp]
24951 727C           3C                     0F  cmp	al,*$F
24952 727E           72           D5            jb 	.541
24953                       00007280            .542:
24954                       00007280            .53E:
24955                                           ! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
24956 7280           8A46         D5            mov	al,-$2B[bp]
24957 7283           30E4                       xor	ah,ah
24958 7285           F7D0                       not	ax
24959                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
24960 7287           8846         D5            mov	-$2B[bp],al
24961                                           !BCC_EOS
24962                                           ! 3801         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
24963                                           ! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
24964 728A           8A46         D5            mov	al,-$2B[bp]
24965 728D           30E4                       xor	ah,ah
24966 728F           50                         push	ax
24967                                           ! Debug: list * unsigned char = const $253 (used reg = )
24968 7290           B8                   0253  mov	ax,#$253
24969 7293           50                         push	ax
24970                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24971 7294           FF76         F6            push	-$A[bp]
24972                                           ! Debug: func () void = write_byte+0 (used reg = )
24973 7297           E8         9380            call	_write_byte
24974 729A           83C4                   06  add	sp,*6
24975                                           !BCC_EOS
24976                                           ! 3802         }
24977                                           ! 3803       if(size >= 0x42) {
24978                       0000729D            .52D:
24979                                           ! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
24980 729D           8B46         DE            mov	ax,-$22[bp]
24981 72A0           3D                   0042  cmp	ax,*$42
24982 72A3         0F82         023B            blo 	.543
24983                       000072A7            .544:
24984                                           ! 3804         Bit8u channel, iface, checksum, i;
24985                                           !BCC_EOS
24986                                           ! 3805         Bit16u iobase1;
24987                                           !BCC_EOS
24988                                           ! 3806         channel = device / 2;
24989                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
24990 72A7           8A46         DB            mov	al,-$25[bp]
24991 72AA           30E4                       xor	ah,ah
24992 72AC           D1E8                       shr	ax,*1
24993                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
24994 72AE           8846         D9            mov	-$27[bp],al
24995                                           !BCC_EOS
24996                                           ! 3807         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
24997                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
24998 72B1           8A46         D9            mov	al,-$27[bp]
24999 72B4           30E4                       xor	ah,ah
25000 72B6           B1                     03  mov	cl,*3
25001 72B8           D3E0                       shl	ax,cl
25002 72BA           89C3                       mov	bx,ax
25003                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
25004                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
25005 72BC           81C3                 0122  add	bx,#$122
25006 72C0           53                         push	bx
25007                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25008 72C1           FF76         F6            push	-$A[bp]
25009                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25010 72C4           E8         932D            call	_read_byte
25011 72C7           83C4                   04  add	sp,*4
25012                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25013 72CA           8846         D8            mov	-$28[bp],al
25014                                           !BCC_EOS
25015                                           ! 3808         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25016                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25017 72CD           8A46         D9            mov	al,-$27[bp]
25018 72D0           30E4                       xor	ah,ah
25019 72D2           B1                     03  mov	cl,*3
25020 72D4           D3E0                       shl	ax,cl
25021 72D6           89C3                       mov	bx,ax
25022                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25023                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25024 72D8           81C3                 0124  add	bx,#$124
25025 72DC           53                         push	bx
25026                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25027 72DD           FF76         F6            push	-$A[bp]
25028                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25029 72E0           E8         9324            call	_read_word
25030 72E3           83C4                   04  add	sp,*4
25031                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25032 72E6           8946         D4            mov	-$2C[bp],ax
25033                                           !BCC_EOS
25034                                           ! 3809         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
25035                                           ! Debug: list int = const $42 (used reg = )
25036 72E9           B8                   0042  mov	ax,*$42
25037 72EC           50                         push	ax
25038                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
25039 72ED           8B46         0C            mov	ax,$C[bp]
25040                                           ! Debug: list unsigned int = ax+0 (used reg = )
25041 72F0           50                         push	ax
25042                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25043 72F1           FF76         06            push	6[bp]
25044                                           ! Debug: func () void = write_word+0 (used reg = )
25045 72F4           E8         933B            call	_write_word
25046 72F7           83C4                   06  add	sp,*6
25047                                           !BCC_EOS
25048                                           ! 3810         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
25049                                           ! Debug: list unsigned int = const $BEDD (used reg = )
25050 72FA           B8                   BEDD  mov	ax,#$BEDD
25051 72FD           50                         push	ax
25052                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
25053 72FE           8B46         0C            mov	ax,$C[bp]
25054                                           ! Debug: list unsigned int = ax+$1E (used reg = )
25055 7301           05                   001E  add	ax,*$1E
25056 7304           50                         push	ax
25057                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25058 7305           FF76         06            push	6[bp]
25059                                           ! Debug: func () void = write_word+0 (used reg = )
25060 7308           E8         9327            call	_write_word
25061 730B           83C4                   06  add	sp,*6
25062                                           !BCC_EOS
25063                                           ! 3811         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
25064                                           ! Debug: list int = const $24 (used reg = )
25065 730E           B8                   0024  mov	ax,*$24
25066 7311           50                         push	ax
25067                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
25068 7312           8B46         0C            mov	ax,$C[bp]
25069                                           ! Debug: list unsigned int = ax+$20 (used reg = )
25070 7315           05                   0020  add	ax,*$20
25071 7318           50                         push	ax
25072                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25073 7319           FF76         06            push	6[bp]
25074                                           ! Debug: func () void = write_byte+0 (used reg = )
25075 731C           E8         92FB            call	_write_byte
25076 731F           83C4                   06  add	sp,*6
25077                                           !BCC_EOS
25078                                           ! 3812         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
25079                                           ! Debug: list int = const 0 (used reg = )
25080 7322           31C0                       xor	ax,ax
25081 7324           50                         push	ax
25082                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
25083 7325           8B46         0C            mov	ax,$C[bp]
25084                                           ! Debug: list unsigned int = ax+$21 (used reg = )
25085 7328           05                   0021  add	ax,*$21
25086 732B           50                         push	ax
25087                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25088 732C           FF76         06            push	6[bp]
25089                                           ! Debug: func () void = write_byte+0 (used reg = )
25090 732F           E8         92E8            call	_write_byte
25091 7332           83C4                   06  add	sp,*6
25092                                           !BCC_EOS
25093                                           ! 3813         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
25094                                           ! Debug: list int = const 0 (used reg = )
25095 7335           31C0                       xor	ax,ax
25096 7337           50                         push	ax
25097                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
25098 7338           8B46         0C            mov	ax,$C[bp]
25099                                           ! Debug: list unsigned int = ax+$22 (used reg = )
25100 733B           05                   0022  add	ax,*$22
25101 733E           50                         push	ax
25102                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25103 733F           FF76         06            push	6[bp]
25104                                           ! Debug: func () void = write_word+0 (used reg = )
25105 7342           E8         92ED            call	_write_word
25106 7345           83C4                   06  add	sp,*6
25107                                           !BCC_EOS
25108                                           ! 3814         if (iface==0x00) {
25109                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25110 7348           8A46         D8            mov	al,-$28[bp]
25111 734B           84C0                       test	al,al
25112 734D           75           51            jne 	.545
25113                       0000734F            .546:
25114                                           ! 3815           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
25115                                           ! Debug: list int = const $49 (used reg = )
25116 734F           B8                   0049  mov	ax,*$49
25117 7352           50                         push	ax
25118                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
25119 7353           8B46         0C            mov	ax,$C[bp]
25120                                           ! Debug: list unsigned int = ax+$24 (used reg = )
25121 7356           05                   0024  add	ax,*$24
25122 7359           50                         push	ax
25123                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25124 735A           FF76         06            push	6[bp]
25125                                           ! Debug: func () void = write_byte+0 (used reg = )
25126 735D           E8         92BA            call	_write_byte
25127 7360           83C4                   06  add	sp,*6
25128                                           !BCC_EOS
25129                                           ! 3816           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
25130                                           ! Debug: list int = const $53 (used reg = )
25131 7363           B8                   0053  mov	ax,*$53
25132 7366           50                         push	ax
25133                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
25134 7367           8B46         0C            mov	ax,$C[bp]
25135                                           ! Debug: list unsigned int = ax+$25 (used reg = )
25136 736A           05                   0025  add	ax,*$25
25137 736D           50                         push	ax
25138                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25139 736E           FF76         06            push	6[bp]
25140                                           ! Debug: func () void = write_byte+0 (used reg = )
25141 7371           E8         92A6            call	_write_byte
25142 7374           83C4                   06  add	sp,*6
25143                                           !BCC_EOS
25144                                           ! 3817           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
25145                                           ! Debug: list int = const $41 (used reg = )
25146 7377           B8                   0041  mov	ax,*$41
25147 737A           50                         push	ax
25148                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
25149 737B           8B46         0C            mov	ax,$C[bp]
25150                                           ! Debug: list unsigned int = ax+$26 (used reg = )
25151 737E           05                   0026  add	ax,*$26
25152 7381           50                         push	ax
25153                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25154 7382           FF76         06            push	6[bp]
25155                                           ! Debug: func () void = write_byte+0 (used reg = )
25156 7385           E8         9292            call	_write_byte
25157 7388           83C4                   06  add	sp,*6
25158                                           !BCC_EOS
25159                                           ! 3818           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
25160                                           ! Debug: list int = const 0 (used reg = )
25161 738B           31C0                       xor	ax,ax
25162 738D           50                         push	ax
25163                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
25164 738E           8B46         0C            mov	ax,$C[bp]
25165                                           ! Debug: list unsigned int = ax+$27 (used reg = )
25166 7391           05                   0027  add	ax,*$27
25167 7394           50                         push	ax
25168                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25169 7395           FF76         06            push	6[bp]
25170                                           ! Debug: func () void = write_byte+0 (used reg = )
25171 7398           E8         927F            call	_write_byte
25172 739B           83C4                   06  add	sp,*6
25173                                           !BCC_EOS
25174                                           ! 3819           }
25175                                           ! 3820         else {
25176 739E           EB           00            jmp .547
25177                       000073A0            .545:
25178                                           ! 3821           }
25179                                           ! 3822         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
25180                       000073A0            .547:
25181                                           ! Debug: list int = const $41 (used reg = )
25182 73A0           B8                   0041  mov	ax,*$41
25183 73A3           50                         push	ax
25184                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
25185 73A4           8B46         0C            mov	ax,$C[bp]
25186                                           ! Debug: list unsigned int = ax+$28 (used reg = )
25187 73A7           05                   0028  add	ax,*$28
25188 73AA           50                         push	ax
25189                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25190 73AB           FF76         06            push	6[bp]
25191                                           ! Debug: func () void = write_byte+0 (used reg = )
25192 73AE           E8         9269            call	_write_byte
25193 73B1           83C4                   06  add	sp,*6
25194                                           !BCC_EOS
25195                                           ! 3823         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
25196                                           ! Debug: list int = const $54 (used reg = )
25197 73B4           B8                   0054  mov	ax,*$54
25198 73B7           50                         push	ax
25199                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
25200 73B8           8B46         0C            mov	ax,$C[bp]
25201                                           ! Debug: list unsigned int = ax+$29 (used reg = )
25202 73BB           05                   0029  add	ax,*$29
25203 73BE           50                         push	ax
25204                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25205 73BF           FF76         06            push	6[bp]
25206                                           ! Debug: func () void = write_byte+0 (used reg = )
25207 73C2           E8         9255            call	_write_byte
25208 73C5           83C4                   06  add	sp,*6
25209                                           !BCC_EOS
25210                                           ! 3824         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
25211                                           ! Debug: list int = const $41 (used reg = )
25212 73C8           B8                   0041  mov	ax,*$41
25213 73CB           50                         push	ax
25214                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
25215 73CC           8B46         0C            mov	ax,$C[bp]
25216                                           ! Debug: list unsigned int = ax+$2A (used reg = )
25217 73CF           05                   002A  add	ax,*$2A
25218 73D2           50                         push	ax
25219                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25220 73D3           FF76         06            push	6[bp]
25221                                           ! Debug: func () void = write_byte+0 (used reg = )
25222 73D6           E8         9241            call	_write_byte
25223 73D9           83C4                   06  add	sp,*6
25224                                           !BCC_EOS
25225                                           ! 3825         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
25226                                           ! Debug: list int = const 0 (used reg = )
25227 73DC           31C0                       xor	ax,ax
25228 73DE           50                         push	ax
25229                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
25230 73DF           8B46         0C            mov	ax,$C[bp]
25231                                           ! Debug: list unsigned int = ax+$2B (used reg = )
25232 73E2           05                   002B  add	ax,*$2B
25233 73E5           50                         push	ax
25234                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25235 73E6           FF76         06            push	6[bp]
25236                                           ! Debug: func () void = write_byte+0 (used reg = )
25237 73E9           E8         922E            call	_write_byte
25238 73EC           83C4                   06  add	sp,*6
25239                                           !BCC_EOS
25240                                           ! 3826         if (iface==0x00) {
25241                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25242 73EF           8A46         D8            mov	al,-$28[bp]
25243 73F2           84C0                       test	al,al
25244 73F4           75           3E            jne 	.548
25245                       000073F6            .549:
25246                                           ! 3827           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
25247                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25248 73F6           FF76         D4            push	-$2C[bp]
25249                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
25250 73F9           8B46         0C            mov	ax,$C[bp]
25251                                           ! Debug: list unsigned int = ax+$30 (used reg = )
25252 73FC           05                   0030  add	ax,*$30
25253 73FF           50                         push	ax
25254                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25255 7400           FF76         06            push	6[bp]
25256                                           ! Debug: func () void = write_word+0 (used reg = )
25257 7403           E8         922C            call	_write_word
25258 7406           83C4                   06  add	sp,*6
25259                                           !BCC_EOS
25260                                           ! 3828           write_word(DS, SI
25261                                           ! 3828 +(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
25262                                           ! Debug: list int = const 0 (used reg = )
25263 7409           31C0                       xor	ax,ax
25264 740B           50                         push	ax
25265                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
25266 740C           8B46         0C            mov	ax,$C[bp]
25267                                           ! Debug: list unsigned int = ax+$32 (used reg = )
25268 740F           05                   0032  add	ax,*$32
25269 7412           50                         push	ax
25270                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25271 7413           FF76         06            push	6[bp]
25272                                           ! Debug: func () void = write_word+0 (used reg = )
25273 7416           E8         9219            call	_write_word
25274 7419           83C4                   06  add	sp,*6
25275                                           !BCC_EOS
25276                                           ! 3829           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
25277                                           ! Debug: list long = const 0 (used reg = )
25278 741C           31C0                       xor	ax,ax
25279 741E           31DB                       xor	bx,bx
25280 7420           53                         push	bx
25281 7421           50                         push	ax
25282                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
25283 7422           8B46         0C            mov	ax,$C[bp]
25284                                           ! Debug: list unsigned int = ax+$34 (used reg = )
25285 7425           05                   0034  add	ax,*$34
25286 7428           50                         push	ax
25287                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
25288 7429           FF76         06            push	6[bp]
25289                                           ! Debug: func () void = write_dword+0 (used reg = )
25290 742C           E8         8C6C            call	_write_dword
25291 742F           83C4                   08  add	sp,*8
25292                                           !BCC_EOS
25293                                           ! 3830           }
25294                                           ! 3831         else {
25295 7432           EB           00            jmp .54A
25296                       00007434            .548:
25297                                           ! 3832           }
25298                                           ! 3833         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
25299                       00007434            .54A:
25300                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25301 7434           8A46         DB            mov	al,-$25[bp]
25302 7437           30E4                       xor	ah,ah
25303 7439           24                     01  and	al,*1
25304                                           ! Debug: list unsigned char = al+0 (used reg = )
25305 743B           30E4                       xor	ah,ah
25306 743D           50                         push	ax
25307                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
25308 743E           8B46         0C            mov	ax,$C[bp]
25309                                           ! Debug: list unsigned int = ax+$38 (used reg = )
25310 7441           05                   0038  add	ax,*$38
25311 7444           50                         push	ax
25312                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25313 7445           FF76         06            push	6[bp]
25314                                           ! Debug: func () void = write_byte+0 (used reg = )
25315 7448           E8         91CF            call	_write_byte
25316 744B           83C4                   06  add	sp,*6
25317                                           !BCC_EOS
25318                                           ! 3834         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
25319                                           ! Debug: list int = const 0 (used reg = )
25320 744E           31C0                       xor	ax,ax
25321 7450           50                         push	ax
25322                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
25323 7451           8B46         0C            mov	ax,$C[bp]
25324                                           ! Debug: list unsigned int = ax+$39 (used reg = )
25325 7454           05                   0039  add	ax,*$39
25326 7457           50                         push	ax
25327                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25328 7458           FF76         06            push	6[bp]
25329                                           ! Debug: func () void = write_byte+0 (used reg = )
25330 745B           E8         91BC            call	_write_byte
25331 745E           83C4                   06  add	sp,*6
25332                                           !BCC_EOS
25333                                           ! 3835         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
25334                                           ! Debug: list int = const 0 (used reg = )
25335 7461           31C0                       xor	ax,ax
25336 7463           50                         push	ax
25337                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
25338 7464           8B46         0C            mov	ax,$C[bp]
25339                                           ! Debug: list unsigned int = ax+$3A (used reg = )
25340 7467           05                   003A  add	ax,*$3A
25341 746A           50                         push	ax
25342                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25343 746B           FF76         06            push	6[bp]
25344                                           ! Debug: func () void = write_word+0 (used reg = )
25345 746E           E8         91C1            call	_write_word
25346 7471           83C4                   06  add	sp,*6
25347                                           !BCC_EOS
25348                                           ! 3836         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
25349                                           ! Debug: list long = const 0 (used reg = )
25350 7474           31C0                       xor	ax,ax
25351 7476           31DB                       xor	bx,bx
25352 7478           53                         push	bx
25353 7479           50                         push	ax
25354                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
25355 747A           8B46         0C            mov	ax,$C[bp]
25356                                           ! Debug: list unsigned int = ax+$3C (used reg = )
25357 747D           05                   003C  add	ax,*$3C
25358 7480           50                         push	ax
25359                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
25360 7481           FF76         06            push	6[bp]
25361                                           ! Debug: func () void = write_dword+0 (used reg = )
25362 7484           E8         8C14            call	_write_dword
25363 7487           83C4                   08  add	sp,*8
25364                                           !BCC_EOS
25365                                           ! 3837         checksum=0;
25366                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25367 748A           30C0                       xor	al,al
25368 748C           8846         D7            mov	-$29[bp],al
25369                                           !BCC_EOS
25370                                           ! 3838         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
25371                                           ! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
25372 748F           B0                     1E  mov	al,*$1E
25373 7491           8846         D6            mov	-$2A[bp],al
25374                                           !BCC_EOS
25375                                           !BCC_EOS
25376 7494           EB           25            jmp .54D
25377                       00007496            .54E:
25378                                           ! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
25379 7496           8B46         0C            mov	ax,$C[bp]
25380 7499           0246         D6            add	al,-$2A[bp]
25381 749C           80D4                   00  adc	ah,*0
25382                                           ! Debug: list unsigned int = ax+0 (used reg = )
25383 749F           50                         push	ax
25384                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25385 74A0           FF76         06            push	6[bp]
25386                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25387 74A3           E8         914E            call	_read_byte
25388 74A6           83C4                   04  add	sp,*4
25389                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25390 74A9           30E4                       xor	ah,ah
25391 74AB           0246         D7            add	al,-$29[bp]
25392 74AE           80D4                   00  adc	ah,*0
25393 74B1           8846         D7            mov	-$29[bp],al
25394                                           !BCC_EOS
25395                                           ! 3839         checksum = ~checksum;
25396                       000074B4            .54C:
25397                                           ! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
25398 74B4           8A46         D6            mov	al,-$2A[bp]
25399 74B7           40                         inc	ax
25400 74B8           8846         D6            mov	-$2A[bp],al
25401                       000074BB            .54D:
25402                                           ! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
25403 74BB           8A46         D6            mov	al,-$2A[bp]
25404 74BE           3C                     40  cmp	al,*$40
25405 74C0           72           D4            jb 	.54E
25406                       000074C2            .54F:
25407                       000074C2            .54B:
25408                                           ! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
25409 74C2           8A46         D7            mov	al,-$29[bp]
25410 74C5           30E4                       xor	ah,ah
25411 74C7           F7D0                       not	ax
25412                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25413 74C9           8846         D7            mov	-$29[bp],al
25414                                           !BCC_EOS
25415                                           ! 3840         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
25416                                           ! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
25417 74CC           8A46         D7            mov	al,-$29[bp]
25418 74CF           30E4                       xor	ah,ah
25419 74D1           50                         push	ax
25420                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
25421 74D2           8B46         0C            mov	ax,$C[bp]
25422                                           ! Debug: list unsigned int = ax+$41 (used reg = )
25423 74D5           05                   0041  add	ax,*$41
25424 74D8           50                         push	ax
25425                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25426 74D9           FF76         06            push	6[bp]
25427                                           ! Debug: func () void = write_byte+0 (used reg = )
25428 74DC           E8         913B            call	_write_byte
25429 74DF           83C4                   06  add	sp,*6
25430                                           !BCC_EOS
25431                                           ! 3841         }
25432                                           ! 3842       goto int13_success;
25433                       000074E2            .543:
25434 74E2           83C4                   0E  add	sp,#..FFEF-..FFF0
25435 74E5           E9         00EF            br 	.FFEF
25436                                           !BCC_EOS
25437                                           ! 3843       break;
25438 74E8           E9         00BC            br 	.4E8
25439                                           !BCC_EOS
25440                                           ! 3844     case 0x4e:
25441                                           ! 3845       switch (( AX & 0x00ff )) {
25442                       000074EB            .550:
25443                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25444 74EB           8A46         18            mov	al,$18[bp]
25445 74EE           EB           10            jmp .553
25446                                           ! 3846         case 0x01:
25447                                           ! 3847         case 0x03:
25448                       000074F0            .554:
25449                                           ! 3848         case 0x04:
25450                       000074F0            .555:
25451                                           ! 3849         case 0x06:
25452                       000074F0            .556:
25453                                           ! 3850           goto int13_success;
25454                       000074F0            .557:
25455 74F0           83C4                   0E  add	sp,#..FFEF-..FFF0
25456 74F3           E9         00E1            br 	.FFEF
25457                                           !BCC_EOS
25458                                           ! 3851           break;
25459 74F6           EB           1A            jmp .551
25460                                           !BCC_EOS
25461                                           ! 3852         default :
25462                                           ! 3853           goto int13_fail;
25463                       000074F8            .558:
25464 74F8           83C4                   0E  add	sp,#..FFF1-..FFF0
25465 74FB           E9         00AC            br 	.FFF1
25466                                           !BCC_EOS
25467                                           ! 3854         }
25468                                           ! 3855       break;
25469 74FE           EB           12            jmp .551
25470                       00007500            .553:
25471 7500           2C                     01  sub	al,*1
25472 7502           74           EC            je 	.554
25473 7504           2C                     02  sub	al,*2
25474 7506           74           E8            je 	.555
25475 7508           2C                     01  sub	al,*1
25476 750A           74           E4            je 	.556
25477 750C           2C                     02  sub	al,*2
25478 750E           74           E0            je 	.557
25479 7510           EB           E6            jmp	.558
25480                       00007512            .551:
25481 7512           E9         0092            br 	.4E8
25482                                           !BCC_EOS
25483                                           ! 3856     case 0x09:
25484                                           ! 3857     case 0x0c:
25485                       00007515            .559:
25486                                           ! 3858     case 0x0d:
25487                       00007515            .55A:
25488                                           ! 3859     case 0x11:
25489                       00007515            .55B:
25490                                           ! 3860     case 0x14:
25491                       00007515            .55C:
25492                                           ! 3861       ;
25493                       00007515            .55D:
25494                                           !BCC_EOS
25495                                           ! 3862       goto int13_success;
25496 7515           83C4                   0E  add	sp,#..FFEF-..FFF0
25497 7518           E9         00BC            br 	.FFEF
25498                                           !BCC_EOS
25499                                           ! 3863       break;
25500 751B           E9         0089            br 	.4E8
25501                                           !BCC_EOS
25502                                           ! 3864     case 0x0a:
25503                                           ! 3865     case 0x0b:
25504                       0000751E            .55E:
25505                                           ! 3866     case 0x18:
25506                       0000751E            .55F:
25507                                           ! 3867     case 0x50:
25508                       0000751E            .560:
25509                                           ! 3868     default:
25510                       0000751E            .561:
25511                                           ! 3869       ;
25512                       0000751E            .562:
25513                                           !BCC_EOS
25514                                           ! 3870       goto int13_fail;
25515 751E           83C4                   0E  add	sp,#..FFF1-..FFF0
25516 7521           E9         0086            br 	.FFF1
25517                                           !BCC_EOS
25518                                           ! 3871       break;
25519 7524           E9         0080            br 	.4E8
25520                                           !BCC_EOS
25521                                           ! 3872     }
25522                                           ! 3873 int13_fail:
25523 7527           EB           7E            jmp .4E8
25524                       00007529            .4EA:
25525 7529           83C4                   F2  add	sp,*-$E
25526 752C           2D                   0000  sub	ax,*0
25527 752F           7C           ED            jl 	.562
25528 7531           3D                   0018  cmp	ax,*$18
25529 7534           77           3B            ja  	.563
25530 7536           D1E0                       shl	ax,*1
25531 7538           89C3                       mov	bx,ax
25532 753A           2E                         seg	cs
25533 753B           FFA7       753F            br	.564[bx]
25534                       0000753F            .564:
25535 753F                      678A            .word	.4EB
25536 7541                      679E            .word	.4EC
25537 7543                      67EF            .word	.4F0
25538 7545                      67EF            .word	.4F1
25539 7547                      67EF            .word	.4F2
25540 7549                      6A3F            .word	.505
25541 754B                      751E            .word	.562
25542 754D                      751E            .word	.562
25543 754F                      6A4C            .word	.506
25544 7551                      7515            .word	.559
25545 7553                      751E            .word	.55E
25546 7555                      751E            .word	.55F
25547 7557                      7515            .word	.55A
25548 7559                      7515            .word	.55B
25549 755B                      751E            .word	.562
25550 755D                      751E            .word	.562
25551 755F                      6B2A            .word	.507
25552 7561                      7515            .word	.55C
25553 7563                      751E            .word	.562
25554 7565                      751E            .word	.562
25555 7567                      7515            .word	.55D
25556 7569                      6B76            .word	.50B
25557 756B                      751E            .word	.562
25558 756D                      751E            .word	.562
25559 756F                      751E            .word	.560
25560                       00007571            .563:
25561 7571           2D                   0041  sub	ax,*$41
25562 7574           72           A8            jb 	.562
25563 7576           3D                   000F  cmp	ax,*$F
25564 7579           77           29            ja  	.565
25565 757B           D1E0                       shl	ax,*1
25566 757D           89C3                       mov	bx,ax
25567 757F           2E                         seg	cs
25568 7580           FFA7       7584            br	.566[bx]
25569                       00007584            .566:
25570 7584                      6C27            .word	.50C
25571 7586                      6C47            .word	.50D
25572 7588                      6C47            .word	.50E
25573 758A                      6C47            .word	.50F
25574 758C                      6DF8            .word	.51E
25575 758E                      6E01            .word	.520
25576 7590                      6C47            .word	.510
25577 7592                      6E15            .word	.521
25578 7594                      6DF8            .word	.51F
25579 7596                      751E            .word	.562
25580 7598                      751E            .word	.562
25581 759A                      751E            .word	.562
25582 759C                      751E            .word	.562
25583 759E                      74EB            .word	.550
25584 75A0                      751E            .word	.562
25585 75A2                      751E            .word	.561
25586                       000075A4            .565:
25587 75A4           E9         FF77            br 	.562
25588                       000075A7            .4E8:
25589                       FFFFFFCA            ..FFF0	=	-$36
25590 75A7           83C4                   0E  add	sp,*$E
25591                       000075AA            .FFF1:
25592                       FFFFFFD8            ..FFF1	=	-$28
25593                                           ! 3874     AX = ((AX & 0x00ff) | ((0x01) << 8));
25594                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25595 75AA           8A46         18            mov	al,$18[bp]
25596                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
25597 75AD           30E4                       xor	ah,ah
25598 75AF           0D                   0100  or	ax,#$100
25599                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
25600 75B2           8946         18            mov	$18[bp],ax
25601                                           !BCC_EOS
25602                                           ! 3875 int13_fail_noah:
25603                       000075B5            .FFEC:
25604                       FFFFFFD8            ..FFEC	=	-$28
25605                                           ! 3876     write_byte(0x0040, 0x0074, ( AX >> 8 ));
25606                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
25607 75B5           8B46         18            mov	ax,$18[bp]
25608 75B8           88E0                       mov	al,ah
25609 75BA           30E4                       xor	ah,ah
25610                                           ! Debug: list unsigned int = ax+0 (used reg = )
25611 75BC           50                         push	ax
25612                                           ! Debug: list int = const $74 (used reg = )
25613 75BD           B8                   0074  mov	ax,*$74
25614 75C0           50                         push	ax
25615                                           ! Debug: list int = const $40 (used reg = )
25616 75C1           B8                   0040  mov	ax,*$40
25617 75C4           50                         push	ax
25618                                           ! Debug: func () void = write_byte+0 (used reg = )
25619 75C5           E8         9052            call	_write_byte
25620 75C8           83C4                   06  add	sp,*6
25621                                           !BCC_EOS
25622                                           ! 3877 int13_fail_nostatus:
25623                       000075CB            .FFEE:
25624                       FFFFFFD8            ..FFEE	=	-$28
25625                                           ! 3878     FLAGS |= 0x0001;
25626                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
25627 75CB           8B46         1E            mov	ax,$1E[bp]
25628 75CE           0C                     01  or	al,*1
25629 75D0           8946         1E            mov	$1E[bp],ax
25630                                           !BCC_EOS
25631                                           ! 3879     return;
25632 75D3           89EC                       mov	sp,bp
25633 75D5           5D                         pop	bp
25634 75D6           C3                         ret
25635                                           !BCC_EOS
25636                                           ! 3880 int13_success:
25637                       000075D7            .FFEF:
25638                       FFFFFFD8            ..FFEF	=	-$28
25639                                           ! 3881     AX = ((AX & 0x00ff) | ((0x00) << 8));
25640                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25641 75D7           8A46         18            mov	al,$18[bp]
25642                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
25643 75DA           0C                     00  or	al,*0
25644                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
25645 75DC           30E4                       xor	ah,ah
25646 75DE           8946         18            mov	$18[bp],ax
25647                                           !BCC_EOS
25648                                           ! 3882 int13_success_noah:
25649                       000075E1            .FFED:
25650                       FFFFFFD8            ..FFED	=	-$28
25651                                           ! 3883     write_byte(0x0040, 0x0074, 0x00);
25652                                           ! Debug: list int = const 0 (used reg = )
25653 75E1           31C0                       xor	ax,ax
25654 75E3           50                         push	ax
25655                                           ! Debug: list int = const $74 (used reg = )
25656 75E4           B8                   0074  mov	ax,*$74
25657 75E7           50                         push	ax
25658                                           ! Debug: list int = const $40 (used reg = )
25659 75E8           B8                   0040  mov	ax,*$40
25660 75EB           50                         push	ax
25661                                           ! Debug: func () void = write_byte+0 (used reg = )
25662 75EC           E8         902B            call	_write_byte
25663 75EF           83C4                   06  add	sp,*6
25664                                           !BCC_EOS
25665                                           ! 3884     FLAGS &= 0xfffe;
25666                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
25667 75F2           8B46         1E            mov	ax,$1E[bp]
25668 75F5           24                     FE  and	al,#$FE
25669 75F7           8946         1E            mov	$1E[bp],ax
25670                                           !BCC_EOS
25671                                           ! 3885     return;
25672 75FA           89EC                       mov	sp,bp
25673 75FC           5D                         pop	bp
25674 75FD           C3                         ret
25675                                           !BCC_EOS
25676                                           ! 3886 }
25677                                           ! 3887   void
25678                                           ! Register BX used in function int13_harddisk
25679                                           ! 3888 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
25680                                           ! 3889   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
25681                                           export	_int13_cdrom
25682                       000075FE            _int13_cdrom:
25683                                           !BCC_EOS
25684                                           ! 3890 {
25685                                           ! 3891   Bit16u ebda_seg=read_word(0x0040,0x000E);
25686 75FE           55                         push	bp
25687 75FF           89E5                       mov	bp,sp
25688 7601           4C                         dec	sp
25689 7602           4C                         dec	sp
25690                                           ! Debug: list int = const $E (used reg = )
25691 7603           B8                   000E  mov	ax,*$E
25692 7606           50                         push	ax
25693                                           ! Debug: list int = const $40 (used reg = )
25694 7607           B8                   0040  mov	ax,*$40
25695 760A           50                         push	ax
25696                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25697 760B           E8         8FF9            call	_read_word
25698 760E           83C4                   04  add	sp,*4
25699                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
25700 7611           8946         FE            mov	-2[bp],ax
25701                                           !BCC_EOS
25702                                           ! 3892   Bit8u device, status, locks;
25703                                           !BCC_EOS
25704                                           ! 3893   Bit8u atacmd[12];
25705                                           !BCC_EOS
25706                                           ! 3894   Bit32u lba;
25707                                           !BCC_EOS
25708                                           ! 3895   Bit16u count, segment, offset, i, size;
25709                                           !BCC_EOS
25710                                           ! 3896   ;
25711 7614           83C4                   E2  add	sp,*-$1E
25712                                           !BCC_EOS
25713                                           ! 3897   write_byte(0x0040, 0x0074, 0x00);
25714                                           ! Debug: list int = const 0 (used reg = )
25715 7617           31C0                       xor	ax,ax
25716 7619           50                         push	ax
25717                                           ! Debug: list int = const $74 (used reg = )
25718 761A           B8                   0074  mov	ax,*$74
25719 761D           50                         push	ax
25720                                           ! Debug: list int = const $40 (used reg = )
25721 761E           B8                   0040  mov	ax,*$40
25722 7621           50                         push	ax
25723                                           ! Debug: func () void = write_byte+0 (used reg = )
25724 7622           E8         8FF5            call	_write_byte
25725 7625           83C4                   06  add	sp,*6
25726                                           !BCC_EOS
25727                                           ! 3898   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
25728                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25729 7628           8A46         10            mov	al,$10[bp]
25730                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
25731 762B           3C                     E0  cmp	al,#$E0
25732 762D           72           07            jb  	.568
25733                       0000762F            .569:
25734                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25735 762F           8A46         10            mov	al,$10[bp]
25736                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
25737 7632           3C                     E8  cmp	al,#$E8
25738 7634           72           06            jb  	.567
25739                       00007636            .568:
25740                                           ! 3899     ;
25741                                           !BCC_EOS
25742                                           ! 3900     goto int13_fail;
25743 7636           83C4                   00  add	sp,#..FFEB+$22
25744 7639           E9         0A33            br 	.FFEB
25745                                           !BCC_EOS
25746                                           ! 3901     }
25747                                           ! 3902   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
25748                       0000763C            .567:
25749                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25750 763C           8A46         10            mov	al,$10[bp]
25751                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
25752 763F           30E4                       xor	ah,ah
25753                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
25754 7641           05                   FF20  add	ax,#-$E0
25755 7644           89C3                       mov	bx,ax
25756                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
25757                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
25758 7646           81C3                 023C  add	bx,#$23C
25759 764A           53                         push	bx
25760                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
25761 764B           FF76         FE            push	-2[bp]
25762                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25763 764E           E8         8FA3            call	_read_byte
25764 7651           83C4                   04  add	sp,*4
25765                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
25766 7654           8846         FD            mov	-3[bp],al
25767                                           !BCC_EOS
25768                                           ! 3903   if (device >= (4*2)) {
25769                                           ! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
25770 7657           8A46         FD            mov	al,-3[bp]
25771 765A           3C                     08  cmp	al,*8
25772 765C           72           06            jb  	.56A
25773                       0000765E            .56B:
25774                                           ! 3903 
25775                                           ! 3904     ;
25776                                           !BCC_EOS
25777                                           ! 3905     goto int13_fail;
25778 765E           83C4                   00  add	sp,#..FFEB+$22
25779 7661           E9         0A0B            br 	.FFEB
25780                                           !BCC_EOS
25781                                           ! 3906     }
25782                                           ! 3907   switch (( AX >> 8 )) {
25783                       00007664            .56A:
25784                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
25785 7664           8B46         18            mov	ax,$18[bp]
25786 7667           88E0                       mov	al,ah
25787 7669           30E4                       xor	ah,ah
25788 766B           E9         0980            br 	.56E
25789                                           ! 3908     case 0x00:
25790                                           ! 3909     case 0x09:
25791                       0000766E            .56F:
25792                                           ! 3910     case 0x0c:
25793                       0000766E            .570:
25794                                           ! 3911     case 0x0d:
25795                       0000766E            .571:
25796                                           ! 3912     case 0x10:
25797                       0000766E            .572:
25798                                           ! 3913     case 0x11:
25799                       0000766E            .573:
25800                                           ! 3914     case 0x14:
25801                       0000766E            .574:
25802                                           ! 3915     case 0x16:
25803                       0000766E            .575:
25804                                           ! 3916       goto int13_success;
25805                       0000766E            .576:
25806 766E           83C4                   0C  add	sp,#..FFE9-..FFEA
25807 7671           E9         0A28            br 	.FFE9
25808                                           !BCC_EOS
25809                                           ! 3917       break;
25810 7674           E9         09F5            br 	.56C
25811                                           !BCC_EOS
25812                                           ! 3918     case 0x03:
25813                                           ! 3919     case 0x05:
25814                       00007677            .577:
25815                                           ! 3920     case 0x43:
25816                       00007677            .578:
25817                                           ! 3921       AX = ((AX & 0x00ff) | ((0x03) << 8));
25818                       00007677            .579:
25819                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
25820 7677           8A46         18            mov	al,$18[bp]
25821                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
25822 767A           30E4                       xor	ah,ah
25823 767C           0D                   0300  or	ax,#$300
25824                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
25825 767F           8946         18            mov	$18[bp],ax
25826                                           !BCC_EOS
25827                                           ! 3922       goto int13_fail_noah;
25828 7682           83C4                   0C  add	sp,#..FFE8-..FFEA
25829 7685           E9         09F2            br 	.FFE8
25830                                           !BCC_EOS
25831                                           ! 3923       break;
25832 7688           E9         09E1            br 	.56C
25833                                           !BCC_EOS
25834                                           ! 3924     case 0x01:
25835                                           ! 3925       status = read_byte(0x0040, 0x0074);
25836                       0000768B            .57A:
25837                                           ! Debug: list int = const $74 (used reg = )
25838 768B           B8                   0074  mov	ax,*$74
25839 768E           50                         push	ax
25840                                           ! Debug: list int = const $40 (used reg = )
25841 768F           B8                   0040  mov	ax,*$40
25842 7692           50                         push	ax
25843                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25844 7693           E8         8F5E            call	_read_byte
25845 7696           83C4                   04  add	sp,*4
25846                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
25847 7699           8846         FC            mov	-4[bp],al
25848                                           !BCC_EOS
25849                                           ! 3926       AX = ((AX & 0x00ff) | ((status) << 8));
25850                                           ! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
25851 769C           8A46         FC            mov	al,-4[bp]
25852 769F           30E4                       xor	ah,ah
25853 76A1           88C4                       mov	ah,al
25854 76A3           30C0                       xor	al,al
25855 76A5           50                         push	ax
25856                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
25857 76A6           8A46         18            mov	al,$18[bp]
25858                                           ! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
25859 76A9           30E4                       xor	ah,ah
25860 76AB           0B46         D2            or	ax,0+..FFEA[bp]
25861 76AE           44                         inc	sp
25862 76AF           44                         inc	sp
25863                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
25864 76B0           8946         18            mov	$18[bp],ax
25865                                           !BCC_EOS
25866                                           ! 3927       write_byte(0x0040, 0x0074, 0);
25867                                           ! Debug: list int = const 0 (used reg = )
25868 76B3           31C0                       xor	ax,ax
25869 76B5           50                         push	ax
25870                                           ! Debug: list int = const $74 (used reg = )
25871 76B6           B8                   0074  mov	ax,*$74
25872 76B9           50                         push	ax
25873                                           ! Debug: list int = const $40 (used reg = )
25874 76BA           B8                   0040  mov	ax,*$40
25875 76BD           50                         push	ax
25876                                           ! Debug: func () void = write_byte+0 (used reg = )
25877 76BE           E8         8F59            call	_write_byte
25878 76C1           83C4                   06  add	sp,*6
25879                                           !BCC_EOS
25880                                           ! 3928       if (status) goto int13_fail_nostatus;
25881 76C4           8A46         FC            mov	al,-4[bp]
25882 76C7           84C0                       test	al,al
25883 76C9           74           08            je  	.57B
25884                       000076CB            .57C:
25885 76CB           83C4                   0C  add	sp,#..FFE7-..FFEA
25886 76CE           E9         09BF            br 	.FFE7
25887                                           !BCC_EOS
25888                                           ! 3929       else goto int13_success_noah;
25889 76D1           EB           06            jmp .57D
25890                       000076D3            .57B:
25891 76D3           83C4                   0C  add	sp,#..FFE6-..FFEA
25892 76D6           E9         09CD            br 	.FFE6
25893                                           !BCC_EOS
25894                                           ! 3930       break;
25895                       000076D9            .57D:
25896 76D9           E9         0990            br 	.56C
25897                                           !BCC_EOS
25898                                           ! 3931     case 0x15:
25899                                           ! 3932       AX = ((AX & 0x00ff) | ((0x02) << 8));
25900                       000076DC            .57E:
25901                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
25902 76DC           8A46         18            mov	al,$18[bp]
25903                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
25904 76DF           30E4                       xor	ah,ah
25905 76E1           0D                   0200  or	ax,#$200
25906                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
25907 76E4           8946         18            mov	$18[bp],ax
25908                                           !BCC_EOS
25909                                           ! 3933       goto int13_fail_noah;
25910 76E7           83C4                   0C  add	sp,#..FFE8-..FFEA
25911 76EA           E9         098D            br 	.FFE8
25912                                           !BCC_EOS
25913                                           ! 3934       break;
25914 76ED           E9         097C            br 	.56C
25915                                           !BCC_EOS
25916                                           ! 3935     case 0x41:
25917                                           ! 3936       BX=0xaa55;
25918                       000076F0            .57F:
25919                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
25920 76F0           B8                   AA55  mov	ax,#$AA55
25921 76F3           8946         12            mov	$12[bp],ax
25922                                           !BCC_EOS
25923                                           ! 3937       AX = ((AX & 0x00ff) | ((0x30) << 8));
25924                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
25925 76F6           8A46         18            mov	al,$18[bp]
25926                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
25927 76F9           30E4                       xor	ah,ah
25928 76FB           0D                   3000  or	ax,#$3000
25929                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
25930 76FE           8946         18            mov	$18[bp],ax
25931                                           !BCC_EOS
25932                                           ! 3938       CX=0x0007;
25933                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
25934 7701           B8                   0007  mov	ax,*7
25935 7704           8946         16            mov	$16[bp],ax
25936                                           !BCC_EOS
25937                                           ! 3939       goto int13_success_noah;
25938 7707           83C4                   0C  add	sp,#..FFE6-..FFEA
25939 770A           E9         0999            br 	.FFE6
25940                                           !BCC_EOS
25941                                           ! 3940       break;
25942 770D           E9         095C            br 	.56C
25943                                           !BCC_EOS
25944                                           ! 3941     case 0x42:
25945                                           ! 3942     case 0x44:
25946                       00007710            .580:
25947                                           ! 3943     case 0x47:
25948                       00007710            .581:
25949                                           ! 3944       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
25950                       00007710            .582:
25951                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
25952 7710           8B46         0C            mov	ax,$C[bp]
25953                                           ! Debug: list unsigned int = ax+2 (used reg = )
25954 7713           40                         inc	ax
25955 7714           40                         inc	ax
25956 7715           50                         push	ax
25957                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
25958 7716           FF76         06            push	6[bp]
25959                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25960 7719           E8         8EEB            call	_read_word
25961 771C           83C4                   04  add	sp,*4
25962                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
25963 771F           8946         E8            mov	-$18[bp],ax
25964                                           !BCC_EOS
25965                                           ! 3945       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
25966                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
25967 7722           8B46         0C            mov	ax,$C[bp]
25968                                           ! Debug: list unsigned int = ax+6 (used reg = )
25969 7725           05                   0006  add	ax,*6
25970 7728           50                         push	ax
25971                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
25972 7729           FF76         06            push	6[bp]
25973                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25974 772C           E8         8ED8            call	_read_word
25975 772F           83C4                   04  add	sp,*4
25976                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
25977 7732           8946         E6            mov	-$1A[bp],ax
25978                                           !BCC_EOS
25979                                           ! 3946       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
25980                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
25981 7735           8B46         0C            mov	ax,$C[bp]
25982                                           ! Debug: list unsigned int = ax+4 (used reg = )
25983 7738           05                   0004  add	ax,*4
25984 773B           50                         push	ax
25985                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
25986 773C           FF76         06            push	6[bp]
25987                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25988 773F           E8         8EC5            call	_read_word
25989 7742           83C4                   04  add	sp,*4
25990                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
25991 7745           8946         E4            mov	-$1C[bp],ax
25992                                           !BCC_EOS
25993                                           ! 3947       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
25994                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
25995 7748           8B46         0C            mov	ax,$C[bp]
25996                                           ! Debug: list unsigned int = ax+$C (used reg = )
25997 774B           05                   000C  add	ax,*$C
25998 774E           50                         push	ax
25999                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26000 774F           FF76         06            push	6[bp]
26001                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26002 7752           E8         892E            call	_read_dword
26003 7755           89D3                       mov	bx,dx
26004 7757           83C4                   04  add	sp,*4
26005                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26006 775A           8946         EA            mov	-$16[bp],ax
26007 775D           895E         EC            mov	-$14[bp],bx
26008                                           !BCC_EOS
26009                                           ! 3948       if (lba != 0L) {
26010                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
26011                                           ! Debug: expression subtree swapping
26012 7760           31C0                       xor	ax,ax
26013 7762           31DB                       xor	bx,bx
26014 7764           53                         push	bx
26015 7765           50                         push	ax
26016 7766           8B46         EA            mov	ax,-$16[bp]
26017 7769           8B5E         EC            mov	bx,-$14[bp]
26018 776C           8D7E         D0            lea	di,-2+..FFEA[bp]
26019 776F           E8         8959            call	lcmpul
26020 7772           8D66         D4            lea	sp,2+..FFEA[bp]
26021 7775           74           1C            je  	.583
26022                       00007777            .584:
26023                                           ! 3949         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
26024                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26025 7777           8B46         18            mov	ax,$18[bp]
26026 777A           88E0                       mov	al,ah
26027 777C           30E4                       xor	ah,ah
26028                                           ! Debug: list unsigned int = ax+0 (used reg = )
26029 777E           50                         push	ax
26030                                           ! Debug: list * char = .585+0 (used reg = )
26031 777F           BB                   D154  mov	bx,#.585
26032 7782           53                         push	bx
26033                                           ! Debug: list int = const 7 (used reg = )
26034 7783           B8                   0007  mov	ax,*7
26035 7786           50                         push	ax
26036                                           ! Debug: func () void = bios_printf+0 (used reg = )
26037 7787           E8         9291            call	_bios_printf
26038 778A           83C4                   06  add	sp,*6
26039                                           !BCC_EOS
26040                                           ! 3950         goto int13_fail;
26041 778D           83C4                   0C  add	sp,#..FFEB-..FFEA
26042 7790           E9         08DC            br 	.FFEB
26043                                           !BCC_EOS
26044                                           ! 3951         }
26045                                           ! 3952       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
26046                       00007793            .583:
26047                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
26048 7793           8B46         0C            mov	ax,$C[bp]
26049                                           ! Debug: list unsigned int = ax+8 (used reg = )
26050 7796           05                   0008  add	ax,*8
26051 7799           50                         push	ax
26052                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26053 779A           FF76         06            push	6[bp]
26054                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26055 779D           E8         88E3            call	_read_dword
26056 77A0           89D3                       mov	bx,dx
26057 77A2           83C4                   04  add	sp,*4
26058                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26059 77A5           8946         EA            mov	-$16[bp],ax
26060 77A8           895E         EC            mov	-$14[bp],bx
26061                                           !BCC_EOS
26062                                           ! 3953       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
26063                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26064 77AB           8B46         18            mov	ax,$18[bp]
26065 77AE           88E0                       mov	al,ah
26066 77B0           30E4                       xor	ah,ah
26067                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
26068 77B2           3D                   0044  cmp	ax,*$44
26069 77B5           74           0C            je  	.587
26070                       000077B7            .588:
26071                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26072 77B7           8B46         18            mov	ax,$18[bp]
26073 77BA           88E0                       mov	al,ah
26074 77BC           30E4                       xor	ah,ah
26075                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
26076 77BE           3D                   0047  cmp	ax,*$47
26077 77C1           75           06            jne 	.586
26078                       000077C3            .587:
26079                                           ! 3954         goto int13_success;
26080 77C3           83C4                   0C  add	sp,#..FFE9-..FFEA
26081 77C6           E9         08D3            br 	.FFE9
26082                                           !BCC_EOS
26083                                           ! 3955       memsetb(get_SS(),atacmd,0,12);
26084                       000077C9            .586:
26085                                           ! Debug: list int = const $C (used reg = )
26086 77C9           B8                   000C  mov	ax,*$C
26087 77CC           50                         push	ax
26088                                           ! Debug: list int = const 0 (used reg = )
26089 77CD           31C0                       xor	ax,ax
26090 77CF           50                         push	ax
26091                                           ! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
26092 77D0           8D5E         EF            lea	bx,-$11[bp]
26093 77D3           53                         push	bx
26094                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26095 77D4           E8         8E76            call	_get_SS
26096                                           ! Debug: list unsigned short = ax+0 (used reg = )
26097 77D7           50                         push	ax
26098                                           ! Debug: func () void = memsetb+0 (used reg = )
26099 77D8           E8         8825            call	_memsetb
26100 77DB           83C4                   08  add	sp,*8
26101                                           !BCC_EOS
26102                                           ! 3956       atacmd[0]=0x28;
26103                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
26104 77DE           B0                     28  mov	al,*$28
26105 77E0           8846         EF            mov	-$11[bp],al
26106                                           !BCC_EOS
26107                                           ! 3957       atacmd[7]=(count & 0xff00) >> 8;
26108                                           ! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
26109 77E3           8B46         E8            mov	ax,-$18[bp]
26110 77E6           30C0                       xor	al,al
26111                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
26112 77E8           88E0                       mov	al,ah
26113 77EA           30E4                       xor	ah,ah
26114                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
26115 77EC           8846         F6            mov	-$A[bp],al
26116                                           !BCC_EOS
26117                                           ! 3958       atacmd[8]=(count & 0x00ff);
26118                                           ! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
26119 77EF           8A46         E8            mov	al,-$18[bp]
26120                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
26121 77F2           8846         F7            mov	-9[bp],al
26122                                           !BCC_EOS
26123                                           ! 3959       atacmd[2]=(lba & 0xff000000) >> 24;
26124                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
26125                                           ! Debug: expression subtree swapping
26126 77F5           31C0                       xor	ax,ax
26127 77F7           BB                   FF00  mov	bx,#$FF00
26128 77FA           8D7E         EA            lea	di,-$16[bp]
26129 77FD           E8         88BB            call	landul
26130                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
26131 7800           93                         xchg	bx,ax
26132 7801           88E0                       mov	al,ah
26133 7803           30E4                       xor	ah,ah
26134 7805           31DB                       xor	bx,bx
26135                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
26136 7807           8846         F1            mov	-$F[bp],al
26137                                           !BCC_EOS
26138                                           ! 3960       atacmd[3]=(lba & 0x00ff0000) >> 16;
26139                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
26140                                           ! Debug: expression subtree swapping
26141 780A           31C0                       xor	ax,ax
26142 780C           BB                   00FF  mov	bx,#$FF
26143 780F           8D7E         EA            lea	di,-$16[bp]
26144 7812           E8         88A6            call	landul
26145                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
26146 7815           93                         xchg	bx,ax
26147 7816           31DB                       xor	bx,bx
26148                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
26149 7818           8846         F2            mov	-$E[bp],al
26150                                           !BCC_EOS
26151                                           ! 3961       atacmd[4]=(lba & 0x0000ff00) >> 8;
26152                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
26153                                           ! Debug: expression subtree swapping
26154 781B           B8                   FF00  mov	ax,#$FF00
26155 781E           31DB                       xor	bx,bx
26156 7820           8D7E         EA            lea	di,-$16[bp]
26157 7823           E8         8895            call	landul
26158                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
26159 7826           88E0                       mov	al,ah
26160 7828           88DC                       mov	ah,bl
26161 782A           88FB                       mov	bl,bh
26162 782C           28FF                       sub	bh,bh
26163                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
26164 782E           8846         F3            mov	-$D[bp],al
26165                                           !BCC_EOS
26166                                           ! 3962       atacmd[5]=(lba & 0x000000ff);
26167                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
26168                                           ! Debug: expression subtree swapping
26169 7831           B8                   00FF  mov	ax,#$FF
26170 7834           31DB                       xor	bx,bx
26171 7836           8D7E         EA            lea	di,-$16[bp]
26172 7839           E8         887F            call	landul
26173                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
26174 783C           8846         F4            mov	-$C[bp],al
26175                                           !BCC_EOS
26176                                           ! 3963       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
26177                                           ! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
26178 783F           FF76         E4            push	-$1C[bp]
26179                                           ! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
26180 7842           FF76         E6            push	-$1A[bp]
26181                                           ! Debug: list int = const 1 (used reg = )
26182 7845           B8                   0001  mov	ax,*1
26183 7848           50                         push	ax
26184                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
26185 7849           8B46         E8            mov	ax,-$18[bp]
26186 784C           31DB                       xor	bx,bx
26187                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
26188 784E           53                         push	bx
26189 784F           50                         push	ax
26190 7850           B8                   0800  mov	ax,#$800
26191 7853           31DB                       xor	bx,bx
26192 7855           53                         push	bx
26193 7856           50                         push	ax
26194 7857           8B46         CA            mov	ax,-8+..FFEA[bp]
26195 785A           8B5E         CC            mov	bx,-6+..FFEA[bp]
26196 785D           8D7E         C6            lea	di,-$C+..FFEA[bp]
26197 7860           E8         8886            call	lmulul
26198 7863           83C4                   08  add	sp,*8
26199                                           ! Debug: list unsigned long = bx+0 (used reg = )
26200 7866           53                         push	bx
26201 7867           50                         push	ax
26202                                           ! Debug: list int = const 0 (used reg = )
26203 7868           31C0                       xor	ax,ax
26204 786A           50                         push	ax
26205                                           ! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
26206 786B           8D5E         EF            lea	bx,-$11[bp]
26207 786E           53                         push	bx
26208                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26209 786F           E8         8DDB            call	_get_SS
26210                                           ! Debug: list unsigned short = ax+0 (used reg = )
26211 7872           50                         push	ax
26212                                           ! Debug: list int = const $C (used reg = )
26213 7873           B8                   000C  mov	ax,*$C
26214 7876           50                         push	ax
26215                                           ! Debug: list unsigned char device = [S+$34-5] (used reg = )
26216 7877           8A46         FD            mov	al,-3[bp]
26217 787A           30E4                       xor	ah,ah
26218 787C           50                         push	ax
26219                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
26220 787D           E8         BC5B            call	_ata_cmd_packet
26221 7880           83C4                   14  add	sp,*$14
26222                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
26223 7883           8846         FC            mov	-4[bp],al
26224                                           !BCC_EOS
26225                                           ! 3964       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
26226                                           ! Debug: list * unsigned long = const $256 (used reg = )
26227 7886           B8                   0256  mov	ax,#$256
26228 7889           50                         push	ax
26229                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26230 788A           FF76         FE            push	-2[bp]
26231                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26232 788D           E8         87F3            call	_read_dword
26233 7890           89D3                       mov	bx,dx
26234 7892           83C4                   04  add	sp,*4
26235                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
26236 7895           88E0                       mov	al,ah
26237 7897           88DC                       mov	ah,bl
26238 7899           88FB                       mov	bl,bh
26239 789B           28FF                       sub	bh,bh
26240 789D           BF                   0003  mov	di,*3
26241 78A0           E8         8886            call	lsrul
26242                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
26243                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26244 78A3           8946         E8            mov	-$18[bp],ax
26245                                           !BCC_EOS
26246                                           ! 3965       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
26247                                           ! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
26248 78A6           FF76         E8            push	-$18[bp]
26249                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
26250 78A9           8B46         0C            mov	ax,$C[bp]
26251                                           ! Debug: list unsigned int = ax+2 (used reg = )
26252 78AC           40                         inc	ax
26253 78AD           40                         inc	ax
26254 78AE           50                         push	ax
26255                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
26256 78AF           FF76         06            push	6[bp]
26257                                           ! Debug: func () void = write_word+0 (used reg = )
26258 78B2           E8         8D7D            call	_write_word
26259 78B5           83C4                   06  add	sp,*6
26260                                           !BCC_EOS
26261                                           ! 3966       if (status != 0) {
26262                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
26263 78B8           8A46         FC            mov	al,-4[bp]
26264 78BB           84C0                       test	al,al
26265 78BD           74           11            je  	.589
26266                       000078BF            .58A:
26267                                           ! 3967         ;
26268                                           !BCC_EOS
26269                                           ! 3968         AX = ((AX & 0
26270                                           ! 3968 x00ff) | ((0x0c) << 8));
26271                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26272 78BF           8A46         18            mov	al,$18[bp]
26273                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
26274 78C2           30E4                       xor	ah,ah
26275 78C4           0D                   0C00  or	ax,#$C00
26276                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26277 78C7           8946         18            mov	$18[bp],ax
26278                                           !BCC_EOS
26279                                           ! 3969         goto int13_fail_noah;
26280 78CA           83C4                   0C  add	sp,#..FFE8-..FFEA
26281 78CD           E9         07AA            br 	.FFE8
26282                                           !BCC_EOS
26283                                           ! 3970         }
26284                                           ! 3971       goto int13_success;
26285                       000078D0            .589:
26286 78D0           83C4                   0C  add	sp,#..FFE9-..FFEA
26287 78D3           E9         07C6            br 	.FFE9
26288                                           !BCC_EOS
26289                                           ! 3972       break;
26290 78D6           E9         0793            br 	.56C
26291                                           !BCC_EOS
26292                                           ! 3973     case 0x45:
26293                                           ! 3974       if (( AX & 0x00ff ) > 2) goto int13_fail;
26294                       000078D9            .58B:
26295                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26296 78D9           8A46         18            mov	al,$18[bp]
26297                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
26298 78DC           3C                     02  cmp	al,*2
26299 78DE           76           06            jbe 	.58C
26300                       000078E0            .58D:
26301 78E0           83C4                   0C  add	sp,#..FFEB-..FFEA
26302 78E3           E9         0789            br 	.FFEB
26303                                           !BCC_EOS
26304                                           ! 3975       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
26305                       000078E6            .58C:
26306                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
26307 78E6           8A46         FD            mov	al,-3[bp]
26308 78E9           30E4                       xor	ah,ah
26309 78EB           B9                   001E  mov	cx,*$1E
26310 78EE           F7E9                       imul	cx
26311 78F0           89C3                       mov	bx,ax
26312                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26313                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26314 78F2           81C3                 0145  add	bx,#$145
26315 78F6           53                         push	bx
26316                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26317 78F7           FF76         FE            push	-2[bp]
26318                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26319 78FA           E8         8CF7            call	_read_byte
26320 78FD           83C4                   04  add	sp,*4
26321                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
26322 7900           8846         FB            mov	-5[bp],al
26323                                           !BCC_EOS
26324                                           ! 3976       switch (( AX & 0x00ff )) {
26325                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26326 7903           8A46         18            mov	al,$18[bp]
26327 7906           E9         00D5            br 	.590
26328                                           ! 3977         case 0 :
26329                                           ! 3978           if (locks == 0xff) {
26330                       00007909            .591:
26331                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
26332 7909           8A46         FB            mov	al,-5[bp]
26333 790C           3C                     FF  cmp	al,#$FF
26334 790E           75           1B            jne 	.592
26335                       00007910            .593:
26336                                           ! 3979             AX = ((AX & 0x00ff) | ((0xb4) << 8));
26337                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26338 7910           8A46         18            mov	al,$18[bp]
26339                                           ! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
26340 7913           30E4                       xor	ah,ah
26341 7915           0D                   B400  or	ax,#-$4C00
26342                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26343 7918           8946         18            mov	$18[bp],ax
26344                                           !BCC_EOS
26345                                           ! 3980             AX = ((AX & 0xff00) | (1));
26346                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26347 791B           8B46         18            mov	ax,$18[bp]
26348 791E           30C0                       xor	al,al
26349                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
26350 7920           0C                     01  or	al,*1
26351                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26352 7922           8946         18            mov	$18[bp],ax
26353                                           !BCC_EOS
26354                                           ! 3981             goto int13_fail_noah;
26355 7925           83C4                   0C  add	sp,#..FFE8-..FFEA
26356 7928           E9         074F            br 	.FFE8
26357                                           !BCC_EOS
26358                                           ! 3982             }
26359                                           ! 3983           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
26360                       0000792B            .592:
26361                                           ! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
26362 792B           8A46         FB            mov	al,-5[bp]
26363 792E           40                         inc	ax
26364 792F           8846         FB            mov	-5[bp],al
26365                                           ! Debug: list unsigned char = al+0 (used reg = )
26366 7932           30E4                       xor	ah,ah
26367 7934           50                         push	ax
26368                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
26369 7935           8A46         FD            mov	al,-3[bp]
26370 7938           30E4                       xor	ah,ah
26371 793A           B9                   001E  mov	cx,*$1E
26372 793D           F7E9                       imul	cx
26373 793F           89C3                       mov	bx,ax
26374                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26375                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26376 7941           81C3                 0145  add	bx,#$145
26377 7945           53                         push	bx
26378                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
26379 7946           FF76         FE            push	-2[bp]
26380                                           ! Debug: func () void = write_byte+0 (used reg = )
26381 7949           E8         8CCE            call	_write_byte
26382 794C           83C4                   06  add	sp,*6
26383                                           !BCC_EOS
26384                                           ! 3984           AX = ((AX & 0xff00) | (1));
26385                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26386 794F           8B46         18            mov	ax,$18[bp]
26387 7952           30C0                       xor	al,al
26388                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
26389 7954           0C                     01  or	al,*1
26390                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26391 7956           8946         18            mov	$18[bp],ax
26392                                           !BCC_EOS
26393                                           ! 3985           break;
26394 7959           E9         0092            br 	.58E
26395                                           !BCC_EOS
26396                                           ! 3986         case 1 :
26397                                           ! 3987           if (locks == 0x00) {
26398                       0000795C            .594:
26399                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26400 795C           8A46         FB            mov	al,-5[bp]
26401 795F           84C0                       test	al,al
26402 7961           75           1B            jne 	.595
26403                       00007963            .596:
26404                                           ! 3988             AX = ((AX & 0x00ff) | ((0xb0) << 8));
26405                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26406 7963           8A46         18            mov	al,$18[bp]
26407                                           ! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
26408 7966           30E4                       xor	ah,ah
26409 7968           0D                   B000  or	ax,#-$5000
26410                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26411 796B           8946         18            mov	$18[bp],ax
26412                                           !BCC_EOS
26413                                           ! 3989             AX = ((AX & 0xff00) | (0));
26414                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26415 796E           8B46         18            mov	ax,$18[bp]
26416 7971           30C0                       xor	al,al
26417                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
26418 7973           0C                     00  or	al,*0
26419                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26420 7975           8946         18            mov	$18[bp],ax
26421                                           !BCC_EOS
26422                                           ! 3990             goto int13_fail_noah;
26423 7978           83C4                   0C  add	sp,#..FFE8-..FFEA
26424 797B           E9         06FC            br 	.FFE8
26425                                           !BCC_EOS
26426                                           ! 3991             }
26427                                           ! 3992           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
26428                       0000797E            .595:
26429                                           ! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
26430 797E           8A46         FB            mov	al,-5[bp]
26431 7981           48                         dec	ax
26432 7982           8846         FB            mov	-5[bp],al
26433                                           ! Debug: list unsigned char = al+0 (used reg = )
26434 7985           30E4                       xor	ah,ah
26435 7987           50                         push	ax
26436                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
26437 7988           8A46         FD            mov	al,-3[bp]
26438 798B           30E4                       xor	ah,ah
26439 798D           B9                   001E  mov	cx,*$1E
26440 7990           F7E9                       imul	cx
26441 7992           89C3                       mov	bx,ax
26442                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26443                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26444 7994           81C3                 0145  add	bx,#$145
26445 7998           53                         push	bx
26446                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
26447 7999           FF76         FE            push	-2[bp]
26448                                           ! Debug: func () void = write_byte+0 (used reg = )
26449 799C           E8         8C7B            call	_write_byte
26450 799F           83C4                   06  add	sp,*6
26451                                           !BCC_EOS
26452                                           ! 3993           AX = ((AX & 0xff00) | (locks==0?0:1));
26453                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26454 79A2           8A46         FB            mov	al,-5[bp]
26455 79A5           84C0                       test	al,al
26456 79A7           75           04            jne 	.597
26457                       000079A9            .598:
26458 79A9           30C0                       xor	al,al
26459 79AB           EB           02            jmp .599
26460                       000079AD            .597:
26461 79AD           B0                     01  mov	al,*1
26462                       000079AF            .599:
26463 79AF           50                         push	ax
26464                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
26465 79B0           8B46         18            mov	ax,$18[bp]
26466 79B3           30C0                       xor	al,al
26467                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
26468 79B5           0A46         D2            or	al,0+..FFEA[bp]
26469 79B8           44                         inc	sp
26470 79B9           44                         inc	sp
26471                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26472 79BA           8946         18            mov	$18[bp],ax
26473                                           !BCC_EOS
26474                                           ! 3994           break;
26475 79BD           EB           2F            jmp .58E
26476                                           !BCC_EOS
26477                                           ! 3995         case 2 :
26478                                           ! 3996           AX = ((AX & 0xff00) | (locks==0?0:1));
26479                       000079BF            .59A:
26480                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26481 79BF           8A46         FB            mov	al,-5[bp]
26482 79C2           84C0                       test	al,al
26483 79C4           75           04            jne 	.59B
26484                       000079C6            .59C:
26485 79C6           30C0                       xor	al,al
26486 79C8           EB           02            jmp .59D
26487                       000079CA            .59B:
26488 79CA           B0                     01  mov	al,*1
26489                       000079CC            .59D:
26490 79CC           50                         push	ax
26491                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
26492 79CD           8B46         18            mov	ax,$18[bp]
26493 79D0           30C0                       xor	al,al
26494                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
26495 79D2           0A46         D2            or	al,0+..FFEA[bp]
26496 79D5           44                         inc	sp
26497 79D6           44                         inc	sp
26498                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26499 79D7           8946         18            mov	$18[bp],ax
26500                                           !BCC_EOS
26501                                           ! 3997           break;
26502 79DA           EB           12            jmp .58E
26503                                           !BCC_EOS
26504                                           ! 3998         }
26505                                           ! 3999       goto int13_success;
26506 79DC           EB           10            jmp .58E
26507                       000079DE            .590:
26508 79DE           2C                     00  sub	al,*0
26509 79E0         0F84         FF25            beq 	.591
26510 79E4           2C                     01  sub	al,*1
26511 79E6         0F84         FF72            beq 	.594
26512 79EA           2C                     01  sub	al,*1
26513 79EC           74           D1            je 	.59A
26514                       000079EE            .58E:
26515 79EE           83C4                   0C  add	sp,#..FFE9-..FFEA
26516 79F1           E9         06A8            br 	.FFE9
26517                                           !BCC_EOS
26518                                           ! 4000       break;
26519 79F4           E9         0675            br 	.56C
26520                                           !BCC_EOS
26521                                           ! 4001     case 0x46:
26522                                           ! 4002       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
26523                       000079F7            .59E:
26524                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
26525 79F7           8A46         FD            mov	al,-3[bp]
26526 79FA           30E4                       xor	ah,ah
26527 79FC           B9                   001E  mov	cx,*$1E
26528 79FF           F7E9                       imul	cx
26529 7A01           89C3                       mov	bx,ax
26530                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26531                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26532 7A03           81C3                 0145  add	bx,#$145
26533 7A07           53                         push	bx
26534                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26535 7A08           FF76         FE            push	-2[bp]
26536                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26537 7A0B           E8         8BE6            call	_read_byte
26538 7A0E           83C4                   04  add	sp,*4
26539                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
26540 7A11           8846         FB            mov	-5[bp],al
26541                                           !BCC_EOS
26542                                           ! 4003       if (locks != 0) {
26543                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26544 7A14           8A46         FB            mov	al,-5[bp]
26545 7A17           84C0                       test	al,al
26546 7A19           74           11            je  	.59F
26547                       00007A1B            .5A0:
26548                                           ! 4004         AX = ((AX & 0x00ff) | ((0xb1) << 8));
26549                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26550 7A1B           8A46         18            mov	al,$18[bp]
26551                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
26552 7A1E           30E4                       xor	ah,ah
26553 7A20           0D                   B100  or	ax,#-$4F00
26554                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26555 7A23           8946         18            mov	$18[bp],ax
26556                                           !BCC_EOS
26557                                           ! 4005         goto int13_fail_noah;
26558 7A26           83C4                   0C  add	sp,#..FFE8-..FFEA
26559 7A29           E9         064E            br 	.FFE8
26560                                           !BCC_EOS
26561                                           ! 4006         }
26562                                           ! 4007 #asm
26563                       00007A2C            .59F:
26564                                           !BCC_EOS
26565                                           !BCC_ASM
26566                       0000002E            _int13_cdrom.BP	set	$2E
26567                       0000000E            .int13_cdrom.BP	set	$E
26568                       00000024            _int13_cdrom.EHBX	set	$24
26569                       00000004            .int13_cdrom.EHBX	set	4
26570                       0000003C            _int13_cdrom.CS	set	$3C
26571                       0000001C            .int13_cdrom.CS	set	$1C
26572                       00000008            _int13_cdrom.count	set	8
26573                       FFFFFFE8            .int13_cdrom.count	set	-$18
26574                       00000036            _int13_cdrom.CX	set	$36
26575                       00000016            .int13_cdrom.CX	set	$16
26576                       00000006            _int13_cdrom.segment	set	6
26577                       FFFFFFE6            .int13_cdrom.segment	set	-$1A
26578                       0000002A            _int13_cdrom.DI	set	$2A
26579                       0000000A            .int13_cdrom.DI	set	$A
26580                       0000003E            _int13_cdrom.FLAGS	set	$3E
26581                       0000001E            .int13_cdrom.FLAGS	set	$1E
26582                       00000026            _int13_cdrom.DS	set	$26
26583                       00000006            .int13_cdrom.DS	set	6
26584                       00000030            _int13_cdrom.ELDX	set	$30
26585                       00000010            .int13_cdrom.ELDX	set	$10
26586                       00000034            _int13_cdrom.DX	set	$34
26587                       00000014            .int13_cdrom.DX	set	$14
26588                       00000000            _int13_cdrom.size	set	0
26589                       FFFFFFE0            .int13_cdrom.size	set	-$20
26590                       00000002            _int13_cdrom.i	set	2
26591                       FFFFFFE2            .int13_cdrom.i	set	-$1E
26592                       0000001D            _int13_cdrom.device	set	$1D
26593                       FFFFFFFD            .int13_cdrom.device	set	-3
26594                       00000028            _int13_cdrom.ES	set	$28
26595                       00000008            .int13_cdrom.ES	set	8
26596                       0000001E            _int13_cdrom.ebda_seg	set	$1E
26597                       FFFFFFFE            .int13_cdrom.ebda_seg	set	-2
26598                       0000002C            _int13_cdrom.SI	set	$2C
26599                       0000000C            .int13_cdrom.SI	set	$C
26600                       0000003A            _int13_cdrom.IP	set	$3A
26601                       0000001A            .int13_cdrom.IP	set	$1A
26602                       0000000A            _int13_cdrom.lba	set	$A
26603                       FFFFFFEA            .int13_cdrom.lba	set	-$16
26604                       0000001C            _int13_cdrom.status	set	$1C
26605                       FFFFFFFC            .int13_cdrom.status	set	-4
26606                       0000000F            _int13_cdrom.atacmd	set	$F
26607                       FFFFFFEF            .int13_cdrom.atacmd	set	-$11
26608                       00000038            _int13_cdrom.AX	set	$38
26609                       00000018            .int13_cdrom.AX	set	$18
26610                       00000004            _int13_cdrom.offset	set	4
26611                       FFFFFFE4            .int13_cdrom.offset	set	-$1C
26612                       00000032            _int13_cdrom.BX	set	$32
26613                       00000012            .int13_cdrom.BX	set	$12
26614                       0000001B            _int13_cdrom.locks	set	$1B
26615                       FFFFFFFB            .int13_cdrom.locks	set	-5
26616 7A2C           55                                 push bp
26617 7A2D           89E5                               mov bp, sp
26618 7A2F           B4                     52          mov ah, #0x52
26619 7A31           CD                     15          int #0x15
26620 7A33           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
26621 7A36           73           06                    jnc int13_cdrom_rme_end
26622 7A38           C706       001C      0001          mov _int13_cdrom.status, #1
26623                       00007A3E            int13_cdrom_rme_end:
26624 7A3E           5D                                 pop bp
26625                                           ! 4017 endasm
26626                                           !BCC_ENDASM
26627                                           !BCC_EOS
26628                                           ! 4018       if (status != 0) {
26629                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
26630 7A3F           8A46         FC            mov	al,-4[bp]
26631 7A42           84C0                       test	al,al
26632 7A44           74           11            je  	.5A1
26633                       00007A46            .5A2:
26634                                           ! 4019         AX = ((AX & 0x00ff) | ((0xb1) << 8));
26635                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26636 7A46           8A46         18            mov	al,$18[bp]
26637                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
26638 7A49           30E4                       xor	ah,ah
26639 7A4B           0D                   B100  or	ax,#-$4F00
26640                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26641 7A4E           8946         18            mov	$18[bp],ax
26642                                           !BCC_EOS
26643                                           ! 4020         goto int13_fail_noah;
26644 7A51           83C4                   0C  add	sp,#..FFE8-..FFEA
26645 7A54           E9         0623            br 	.FFE8
26646                                           !BCC_EOS
26647                                           ! 4021       }
26648                                           ! 4022       goto int13_success;
26649                       00007A57            .5A1:
26650 7A57           83C4                   0C  add	sp,#..FFE9-..FFEA
26651 7A5A           E9         063F            br 	.FFE9
26652                                           !BCC_EOS
26653                                           ! 4023       break;
26654 7A5D           E9         060C            br 	.56C
26655                                           !BCC_EOS
26656                                           ! 4024     case 0x48:
26657                                           ! 4025       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
26658                       00007A60            .5A3:
26659                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
26660 7A60           8B46         0C            mov	ax,$C[bp]
26661                                           ! Debug: list unsigned int = ax+0 (used reg = )
26662 7A63           50                         push	ax
26663                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26664 7A64           FF76         06            push	6[bp]
26665                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26666 7A67           E8         8B9D            call	_read_word
26667 7A6A           83C4                   04  add	sp,*4
26668                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
26669 7A6D           8946         E0            mov	-$20[bp],ax
26670                                           !BCC_EOS
26671                                           ! 4026       if(size < 0x1a)
26672                                           ! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
26673 7A70           8B46         E0            mov	ax,-$20[bp]
26674 7A73           3D                   001A  cmp	ax,*$1A
26675 7A76           73           06            jae 	.5A4
26676                       00007A78            .5A5:
26677                                           ! 4027         goto int13_fail;
26678 7A78           83C4                   0C  add	sp,#..FFEB-..FFEA
26679 7A7B           E9         05F1            br 	.FFEB
26680                                           !BCC_EOS
26681                                           ! 4028       if(size >= 0x1a) {
26682                       00007A7E            .5A4:
26683                                           ! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
26684 7A7E           8B46         E0            mov	ax,-$20[bp]
26685 7A81           3D                   001A  cmp	ax,*$1A
26686 7A84         0F82         00CC            blo 	.5A6
26687                       00007A88            .5A7:
26688                                           ! 4029         Bit16u cylinders, heads, spt, blksize;
26689                                           !BCC_EOS
26690                                           ! 4030         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
26691                                           ! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
26692 7A88           8A46         FD            mov	al,-3[bp]
26693 7A8B           30E4                       xor	ah,ah
26694 7A8D           B9                   001E  mov	cx,*$1E
26695 7A90           F7E9                       imul	cx
26696 7A92           89C3                       mov	bx,ax
26697                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
26698                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
26699 7A94           81C3                 0148  add	bx,#$148
26700 7A98           53                         push	bx
26701                                           ! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
26702 7A99           FF76         FE            push	-2[bp]
26703                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26704 7A9C           E8         8B68            call	_read_word
26705 7A9F           83C4                   04  add	sp,*4
26706                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
26707 7AA2           8946         D8            mov	-$28[bp],ax
26708                                           !BCC_EOS
26709                                           ! 4031         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
26710                                           ! Debug: list int = const $1A (used reg = )
26711 7AA5           B8                   001A  mov	ax,*$1A
26712 7AA8           50                         push	ax
26713                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
26714 7AA9           8B46         0C            mov	ax,$C[bp]
26715                                           ! Debug: list unsigned int = ax+0 (used reg = )
26716 7AAC           50                         push	ax
26717                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26718 7AAD           FF76         06            push	6[bp]
26719                                           ! Debug: func () void = write_word+0 (used reg = )
26720 7AB0           E8         8B7F            call	_write_word
26721 7AB3           83C4                   06  add	sp,*6
26722                                           !BCC_EOS
26723                                           ! 4032         write_word
26724                                           ! 4032 (DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
26725                                           ! Debug: list int = const $74 (used reg = )
26726 7AB6           B8                   0074  mov	ax,*$74
26727 7AB9           50                         push	ax
26728                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
26729 7ABA           8B46         0C            mov	ax,$C[bp]
26730                                           ! Debug: list unsigned int = ax+2 (used reg = )
26731 7ABD           40                         inc	ax
26732 7ABE           40                         inc	ax
26733 7ABF           50                         push	ax
26734                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26735 7AC0           FF76         06            push	6[bp]
26736                                           ! Debug: func () void = write_word+0 (used reg = )
26737 7AC3           E8         8B6C            call	_write_word
26738 7AC6           83C4                   06  add	sp,*6
26739                                           !BCC_EOS
26740                                           ! 4033         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
26741                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26742 7AC9           B8                   FFFF  mov	ax,#$FFFF
26743 7ACC           BB                   FFFF  mov	bx,#$FFFF
26744 7ACF           53                         push	bx
26745 7AD0           50                         push	ax
26746                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
26747 7AD1           8B46         0C            mov	ax,$C[bp]
26748                                           ! Debug: list unsigned int = ax+4 (used reg = )
26749 7AD4           05                   0004  add	ax,*4
26750 7AD7           50                         push	ax
26751                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26752 7AD8           FF76         06            push	6[bp]
26753                                           ! Debug: func () void = write_dword+0 (used reg = )
26754 7ADB           E8         85BD            call	_write_dword
26755 7ADE           83C4                   08  add	sp,*8
26756                                           !BCC_EOS
26757                                           ! 4034         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
26758                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26759 7AE1           B8                   FFFF  mov	ax,#$FFFF
26760 7AE4           BB                   FFFF  mov	bx,#$FFFF
26761 7AE7           53                         push	bx
26762 7AE8           50                         push	ax
26763                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
26764 7AE9           8B46         0C            mov	ax,$C[bp]
26765                                           ! Debug: list unsigned int = ax+8 (used reg = )
26766 7AEC           05                   0008  add	ax,*8
26767 7AEF           50                         push	ax
26768                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26769 7AF0           FF76         06            push	6[bp]
26770                                           ! Debug: func () void = write_dword+0 (used reg = )
26771 7AF3           E8         85A5            call	_write_dword
26772 7AF6           83C4                   08  add	sp,*8
26773                                           !BCC_EOS
26774                                           ! 4035         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
26775                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26776 7AF9           B8                   FFFF  mov	ax,#$FFFF
26777 7AFC           BB                   FFFF  mov	bx,#$FFFF
26778 7AFF           53                         push	bx
26779 7B00           50                         push	ax
26780                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
26781 7B01           8B46         0C            mov	ax,$C[bp]
26782                                           ! Debug: list unsigned int = ax+$C (used reg = )
26783 7B04           05                   000C  add	ax,*$C
26784 7B07           50                         push	ax
26785                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26786 7B08           FF76         06            push	6[bp]
26787                                           ! Debug: func () void = write_dword+0 (used reg = )
26788 7B0B           E8         858D            call	_write_dword
26789 7B0E           83C4                   08  add	sp,*8
26790                                           !BCC_EOS
26791                                           ! 4036         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
26792                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26793 7B11           B8                   FFFF  mov	ax,#$FFFF
26794 7B14           BB                   FFFF  mov	bx,#$FFFF
26795 7B17           53                         push	bx
26796 7B18           50                         push	ax
26797                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
26798 7B19           8B46         0C            mov	ax,$C[bp]
26799                                           ! Debug: list unsigned int = ax+$10 (used reg = )
26800 7B1C           05                   0010  add	ax,*$10
26801 7B1F           50                         push	ax
26802                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26803 7B20           FF76         06            push	6[bp]
26804                                           ! Debug: func () void = write_dword+0 (used reg = )
26805 7B23           E8         8575            call	_write_dword
26806 7B26           83C4                   08  add	sp,*8
26807                                           !BCC_EOS
26808                                           ! 4037         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
26809                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26810 7B29           B8                   FFFF  mov	ax,#$FFFF
26811 7B2C           BB                   FFFF  mov	bx,#$FFFF
26812 7B2F           53                         push	bx
26813 7B30           50                         push	ax
26814                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
26815 7B31           8B46         0C            mov	ax,$C[bp]
26816                                           ! Debug: list unsigned int = ax+$14 (used reg = )
26817 7B34           05                   0014  add	ax,*$14
26818 7B37           50                         push	ax
26819                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26820 7B38           FF76         06            push	6[bp]
26821                                           ! Debug: func () void = write_dword+0 (used reg = )
26822 7B3B           E8         855D            call	_write_dword
26823 7B3E           83C4                   08  add	sp,*8
26824                                           !BCC_EOS
26825                                           ! 4038         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
26826                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
26827 7B41           FF76         D8            push	-$28[bp]
26828                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
26829 7B44           8B46         0C            mov	ax,$C[bp]
26830                                           ! Debug: list unsigned int = ax+$18 (used reg = )
26831 7B47           05                   0018  add	ax,*$18
26832 7B4A           50                         push	ax
26833                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26834 7B4B           FF76         06            push	6[bp]
26835                                           ! Debug: func () void = write_word+0 (used reg = )
26836 7B4E           E8         8AE1            call	_write_word
26837 7B51           83C4                   06  add	sp,*6
26838                                           !BCC_EOS
26839                                           ! 4039         }
26840                                           ! 4040       if(size >= 0x1e) {
26841                       00007B54            .5A6:
26842                                           ! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
26843 7B54           8B46         E0            mov	ax,-$20[bp]
26844 7B57           3D                   001E  cmp	ax,*$1E
26845 7B5A         0F82         01F9            blo 	.5A8
26846                       00007B5E            .5A9:
26847                                           ! 4041         Bit8u channel, dev, irq, mode, checksum, i;
26848                                           !BCC_EOS
26849                                           ! 4042         Bit16u iobase1, iobase2, options;
26850                                           !BCC_EOS
26851                                           ! 4043         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
26852                                           ! Debug: list int = const $1E (used reg = )
26853 7B5E           B8                   001E  mov	ax,*$1E
26854 7B61           50                         push	ax
26855                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
26856 7B62           8B46         0C            mov	ax,$C[bp]
26857                                           ! Debug: list unsigned int = ax+0 (used reg = )
26858 7B65           50                         push	ax
26859                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26860 7B66           FF76         06            push	6[bp]
26861                                           ! Debug: func () void = write_word+0 (used reg = )
26862 7B69           E8         8AC6            call	_write_word
26863 7B6C           83C4                   06  add	sp,*6
26864                                           !BCC_EOS
26865                                           ! 4044         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
26866                                           ! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
26867 7B6F           FF76         FE            push	-2[bp]
26868                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
26869 7B72           8B46         0C            mov	ax,$C[bp]
26870                                           ! Debug: list unsigned int = ax+$1C (used reg = )
26871 7B75           05                   001C  add	ax,*$1C
26872 7B78           50                         push	ax
26873                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26874 7B79           FF76         06            push	6[bp]
26875                                           ! Debug: func () void = write_word+0 (used reg = )
26876 7B7C           E8         8AB3            call	_write_word
26877 7B7F           83C4                   06  add	sp,*6
26878                                           !BCC_EOS
26879                                           ! 4045         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
26880                                           ! Debug: list * struct  = const $244 (used reg = )
26881 7B82           B8                   0244  mov	ax,#$244
26882 7B85           50                         push	ax
26883                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
26884 7B86           8B46         0C            mov	ax,$C[bp]
26885                                           ! Debug: list unsigned int = ax+$1A (used reg = )
26886 7B89           05                   001A  add	ax,*$1A
26887 7B8C           50                         push	ax
26888                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26889 7B8D           FF76         06            push	6[bp]
26890                                           ! Debug: func () void = write_word+0 (used reg = )
26891 7B90           E8         8A9F            call	_write_word
26892 7B93           83C4                   06  add	sp,*6
26893                                           !BCC_EOS
26894                                           ! 4046         channel = device / 2;
26895                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
26896 7B96           8A46         FD            mov	al,-3[bp]
26897 7B99           30E4                       xor	ah,ah
26898 7B9B           D1E8                       shr	ax,*1
26899                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
26900 7B9D           8846         DF            mov	-$21[bp],al
26901                                           !BCC_EOS
26902                                           ! 4047         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
26903                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
26904 7BA0           8A46         DF            mov	al,-$21[bp]
26905 7BA3           30E4                       xor	ah,ah
26906 7BA5           B1                     03  mov	cl,*3
26907 7BA7           D3E0                       shl	ax,cl
26908 7BA9           89C3                       mov	bx,ax
26909                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
26910                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
26911 7BAB           81C3                 0124  add	bx,#$124
26912 7BAF           53                         push	bx
26913                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
26914 7BB0           FF76         FE            push	-2[bp]
26915                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26916 7BB3           E8         8A51            call	_read_word
26917 7BB6           83C4                   04  add	sp,*4
26918                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
26919 7BB9           8946         D8            mov	-$28[bp],ax
26920                                           !BCC_EOS
26921                                           ! 4048         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
26922                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
26923 7BBC           8A46         DF            mov	al,-$21[bp]
26924 7BBF           30E4                       xor	ah,ah
26925 7BC1           B1                     03  mov	cl,*3
26926 7BC3           D3E0                       shl	ax,cl
26927 7BC5           89C3                       mov	bx,ax
26928                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
26929                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
26930 7BC7           81C3                 0126  add	bx,#$126
26931 7BCB           53                         push	bx
26932                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
26933 7BCC           FF76         FE            push	-2[bp]
26934                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26935 7BCF           E8         8A35            call	_read_word
26936 7BD2           83C4                   04  add	sp,*4
26937                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
26938 7BD5           8946         D6            mov	-$2A[bp],ax
26939                                           !BCC_EOS
26940                                           ! 4049         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
26941                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
26942 7BD8           8A46         DF            mov	al,-$21[bp]
26943 7BDB           30E4                       xor	ah,ah
26944 7BDD           B1                     03  mov	cl,*3
26945 7BDF           D3E0                       shl	ax,cl
26946 7BE1           89C3                       mov	bx,ax
26947                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
26948                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
26949 7BE3           81C3                 0128  add	bx,#$128
26950 7BE7           53                         push	bx
26951                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
26952 7BE8           FF76         FE            push	-2[bp]
26953                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26954 7BEB           E8         8A06            call	_read_byte
26955 7BEE           83C4                   04  add	sp,*4
26956                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
26957 7BF1           8846         DD            mov	-$23[bp],al
26958                                           !BCC_EOS
26959                                           ! 4050         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
26960                                           ! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
26961 7BF4           8A46         FD            mov	al,-3[bp]
26962 7BF7           30E4                       xor	ah,ah
26963 7BF9           B9                   001E  mov	cx,*$1E
26964 7BFC           F7E9                       imul	cx
26965 7BFE           89C3                       mov	bx,ax
26966                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
26967                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
26968 7C00           81C3                 0146  add	bx,#$146
26969 7C04           53                         push	bx
26970                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
26971 7C05           FF76         FE            push	-2[bp]
26972                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26973 7C08           E8         89E9            call	_read_byte
26974 7C0B           83C4                   04  add	sp,*4
26975                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
26976 7C0E           8846         DC            mov	-$24[bp],al
26977                                           !BCC_EOS
26978                                           ! 4051         options = (1<<4);
26979                                           ! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
26980 7C11           B8                   0010  mov	ax,*$10
26981 7C14           8946         D4            mov	-$2C[bp],ax
26982                                           !BCC_EOS
26983                                           ! 4052         options |= (1<<5);
26984                                           ! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
26985 7C17           8B46         D4            mov	ax,-$2C[bp]
26986 7C1A           0C                     20  or	al,*$20
26987 7C1C           8946         D4            mov	-$2C[bp],ax
26988                                           !BCC_EOS
26989                                           ! 4053         options |= (1<<6);
26990                                           ! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
26991 7C1F           8B46         D4            mov	ax,-$2C[bp]
26992 7C22           0C                     40  or	al,*$40
26993 7C24           8946         D4            mov	-$2C[bp],ax
26994                                           !BCC_EOS
26995                                           ! 4054         options |= (mode==0x01?1:0<<7);
26996                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
26997 7C27           8A46         DC            mov	al,-$24[bp]
26998 7C2A           3C                     01  cmp	al,*1
26999 7C2C           75           04            jne 	.5AA
27000                       00007C2E            .5AB:
27001 7C2E           B0                     01  mov	al,*1
27002 7C30           EB           02            jmp .5AC
27003                       00007C32            .5AA:
27004 7C32           30C0                       xor	al,al
27005                       00007C34            .5AC:
27006                                           ! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
27007 7C34           30E4                       xor	ah,ah
27008 7C36           0B46         D4            or	ax,-$2C[bp]
27009 7C39           8946         D4            mov	-$2C[bp],ax
27010                                           !BCC_EOS
27011                                           ! 4055         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
27012                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27013 7C3C           FF76         D8            push	-$28[bp]
27014                                           ! Debug: list * unsigned short = const $244 (used reg = )
27015 7C3F           B8                   0244  mov	ax,#$244
27016 7C42           50                         push	ax
27017                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27018 7C43           FF76         FE            push	-2[bp]
27019                                           ! Debug: func () void = write_word+0 (used reg = )
27020 7C46           E8         89E9            call	_write_word
27021 7C49           83C4                   06  add	sp,*6
27022                                           !BCC_EOS
27023                                           ! 4056         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
27024                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27025 7C4C           8B46         D6            mov	ax,-$2A[bp]
27026                                           ! Debug: list unsigned int = ax+6 (used reg = )
27027 7C4F           05                   0006  add	ax,*6
27028 7C52           50                         push	ax
27029                                           ! Debug: list * unsigned short = const $246 (used reg = )
27030 7C53           B8                   0246  mov	ax,#$246
27031 7C56           50                         push	ax
27032                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27033 7C57           FF76         FE            push	-2[bp]
27034                                           ! Debug: func () void = write_word+0 (used reg = )
27035 7C5A           E8         89D5            call	_write_word
27036 7C5D           83C4                   06  add	sp,*6
27037                                           !BCC_EOS
27038                                           ! 4057         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
27039                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27040 7C60           8A46         FD            mov	al,-3[bp]
27041 7C63           30E4                       xor	ah,ah
27042 7C65           24                     01  and	al,*1
27043                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
27044                                           ! Debug: expression subtree swapping
27045 7C67           0C                     0E  or	al,*$E
27046                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
27047 7C69           30E4                       xor	ah,ah
27048 7C6B           B1                     04  mov	cl,*4
27049 7C6D           D3E0                       shl	ax,cl
27050                                           ! Debug: list unsigned int = ax+0 (used reg = )
27051 7C6F           50                         push	ax
27052                                           ! Debug: list * unsigned char = const $248 (used reg = )
27053 7C70           B8                   0248  mov	ax,#$248
27054 7C73           50                         push	ax
27055                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27056 7C74           FF76         FE            push	-2[bp]
27057                                           ! Debug: func () void = write_byte+0 (used reg = )
27058 7C77           E8         89A0            call	_write_byte
27059 7C7A           83C4                   06  add	sp,*6
27060                                           !BCC_EOS
27061                                           ! 4058         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
27062                                           ! Debug: list int = const $CB (used reg = )
27063 7C7D           B8                   00CB  mov	ax,#$CB
27064 7C80           50                         push	ax
27065                                           ! Debug: list * unsigned char = const $249 (used reg = )
27066 7C81           B8                   0249  mov	ax,#$249
27067 7C84           50                         push	ax
27068                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27069 7C85           FF76         FE            push	-2[bp]
27070                                           ! Debug: func () void = write_byte+0 (used reg = )
27071 7C88           E8         898F            call	_write_byte
27072 7C8B           83C4                   06  add	sp,*6
27073                                           !BCC_EOS
27074                                           ! 4059         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
27075                                           ! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
27076 7C8E           8A46         DD            mov	al,-$23[bp]
27077 7C91           30E4                       xor	ah,ah
27078 7C93           50                         push	ax
27079                                           ! Debug: list * unsigned char = const $24A (used reg = )
27080 7C94           B8                   024A  mov	ax,#$24A
27081 7C97           50                         push	ax
27082                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27083 7C98           FF76         FE            push	-2[bp]
27084                                           ! Debug: func () void = write_byte+0 (used reg = )
27085 7C9B           E8         897C            call	_write_byte
27086 7C9E           83C4                   06  add	sp,*6
27087                                           !BCC_EOS
27088                                           ! 4060         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
27089                                           ! Debug: list int = const 1 (used reg = )
27090 7CA1           B8                   0001  mov	ax,*1
27091 7CA4           50                         push	ax
27092                                           ! Debug: list * unsigned char = const $24B (used reg = )
27093 7CA5           B8                   024B  mov	ax,#$24B
27094 7CA8           50                         push	ax
27095                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27096 7CA9           FF76         FE            push	-2[bp]
27097                                           ! Debug: func () void = write_byte+0 (used reg = )
27098 7CAC           E8         896B            call	_write_byte
27099 7CAF           83C4                   06  add	sp,*6
27100                                           !BCC_EOS
27101                                           ! 4061         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
27102                                           ! Debug: list int = const 0 (used reg = )
27103 7CB2           31C0                       xor	ax,ax
27104 7CB4           50                         push	ax
27105                                           ! Debug: list * unsigned char = const $24C (used reg = )
27106 7CB5           B8                   024C  mov	ax,#$24C
27107 7CB8           50                         push	ax
27108                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27109 7CB9           FF76         FE            push	-2[bp]
27110                                           ! Debug: func () void = write_byte+0 (used reg = )
27111 7CBC           E8         895B            call	_write_byte
27112 7CBF           83C4                   06  add	sp,*6
27113                                           !BCC_EOS
27114                                           ! 4062         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
27115                                           ! Debug: list int = const 0 (used reg = )
27116 7CC2           31C0                       xor	ax,ax
27117 7CC4           50                         push	ax
27118                                           ! Debug: list * unsigned char = const $24D (used reg = )
27119 7CC5           B8                   024D  mov	ax,#$24D
27120 7CC8           50                         push	ax
27121                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27122 7CC9           FF76         FE            push	-2[bp]
27123                                           ! Debug: func () void = write_byte+0 (used reg = )
27124 7CCC           E8         894B            call	_write_byte
27125 7CCF           83C4                   06  add	sp,*6
27126                                           !BCC_EOS
27127                                           ! 4063         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, option
27128                                           ! 4063 s);
27129                                           ! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
27130 7CD2           FF76         D4            push	-$2C[bp]
27131                                           ! Debug: list * unsigned short = const $24E (used reg = )
27132 7CD5           B8                   024E  mov	ax,#$24E
27133 7CD8           50                         push	ax
27134                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27135 7CD9           FF76         FE            push	-2[bp]
27136                                           ! Debug: func () void = write_word+0 (used reg = )
27137 7CDC           E8         8953            call	_write_word
27138 7CDF           83C4                   06  add	sp,*6
27139                                           !BCC_EOS
27140                                           ! 4064         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
27141                                           ! Debug: list int = const 0 (used reg = )
27142 7CE2           31C0                       xor	ax,ax
27143 7CE4           50                         push	ax
27144                                           ! Debug: list * unsigned short = const $250 (used reg = )
27145 7CE5           B8                   0250  mov	ax,#$250
27146 7CE8           50                         push	ax
27147                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27148 7CE9           FF76         FE            push	-2[bp]
27149                                           ! Debug: func () void = write_word+0 (used reg = )
27150 7CEC           E8         8943            call	_write_word
27151 7CEF           83C4                   06  add	sp,*6
27152                                           !BCC_EOS
27153                                           ! 4065         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
27154                                           ! Debug: list int = const $11 (used reg = )
27155 7CF2           B8                   0011  mov	ax,*$11
27156 7CF5           50                         push	ax
27157                                           ! Debug: list * unsigned char = const $252 (used reg = )
27158 7CF6           B8                   0252  mov	ax,#$252
27159 7CF9           50                         push	ax
27160                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27161 7CFA           FF76         FE            push	-2[bp]
27162                                           ! Debug: func () void = write_byte+0 (used reg = )
27163 7CFD           E8         891A            call	_write_byte
27164 7D00           83C4                   06  add	sp,*6
27165                                           !BCC_EOS
27166                                           ! 4066         checksum=0;
27167                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27168 7D03           30C0                       xor	al,al
27169 7D05           8846         DB            mov	-$25[bp],al
27170                                           !BCC_EOS
27171                                           ! 4067         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
27172                                           ! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
27173 7D08           30C0                       xor	al,al
27174 7D0A           8846         DA            mov	-$26[bp],al
27175                                           !BCC_EOS
27176                                           !BCC_EOS
27177 7D0D           EB           24            jmp .5AF
27178                       00007D0F            .5B0:
27179                                           ! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
27180 7D0F           8A46         DA            mov	al,-$26[bp]
27181 7D12           30E4                       xor	ah,ah
27182                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
27183 7D14           05                   0244  add	ax,#$244
27184 7D17           50                         push	ax
27185                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27186 7D18           FF76         FE            push	-2[bp]
27187                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27188 7D1B           E8         88D6            call	_read_byte
27189 7D1E           83C4                   04  add	sp,*4
27190                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27191 7D21           30E4                       xor	ah,ah
27192 7D23           0246         DB            add	al,-$25[bp]
27193 7D26           80D4                   00  adc	ah,*0
27194 7D29           8846         DB            mov	-$25[bp],al
27195                                           !BCC_EOS
27196                                           ! 4068         checksum = ~checksum;
27197                       00007D2C            .5AE:
27198                                           ! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
27199 7D2C           8A46         DA            mov	al,-$26[bp]
27200 7D2F           40                         inc	ax
27201 7D30           8846         DA            mov	-$26[bp],al
27202                       00007D33            .5AF:
27203                                           ! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
27204 7D33           8A46         DA            mov	al,-$26[bp]
27205 7D36           3C                     0F  cmp	al,*$F
27206 7D38           72           D5            jb 	.5B0
27207                       00007D3A            .5B1:
27208                       00007D3A            .5AD:
27209                                           ! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
27210 7D3A           8A46         DB            mov	al,-$25[bp]
27211 7D3D           30E4                       xor	ah,ah
27212 7D3F           F7D0                       not	ax
27213                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27214 7D41           8846         DB            mov	-$25[bp],al
27215                                           !BCC_EOS
27216                                           ! 4069         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
27217                                           ! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
27218 7D44           8A46         DB            mov	al,-$25[bp]
27219 7D47           30E4                       xor	ah,ah
27220 7D49           50                         push	ax
27221                                           ! Debug: list * unsigned char = const $253 (used reg = )
27222 7D4A           B8                   0253  mov	ax,#$253
27223 7D4D           50                         push	ax
27224                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27225 7D4E           FF76         FE            push	-2[bp]
27226                                           ! Debug: func () void = write_byte+0 (used reg = )
27227 7D51           E8         88C6            call	_write_byte
27228 7D54           83C4                   06  add	sp,*6
27229                                           !BCC_EOS
27230                                           ! 4070         }
27231                                           ! 4071       if(size >= 0x42) {
27232                       00007D57            .5A8:
27233                                           ! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
27234 7D57           8B46         E0            mov	ax,-$20[bp]
27235 7D5A           3D                   0042  cmp	ax,*$42
27236 7D5D         0F82         023B            blo 	.5B2
27237                       00007D61            .5B3:
27238                                           ! 4072         Bit8u channel, iface, checksum, i;
27239                                           !BCC_EOS
27240                                           ! 4073         Bit16u iobase1;
27241                                           !BCC_EOS
27242                                           ! 4074         channel = device / 2;
27243                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
27244 7D61           8A46         FD            mov	al,-3[bp]
27245 7D64           30E4                       xor	ah,ah
27246 7D66           D1E8                       shr	ax,*1
27247                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
27248 7D68           8846         DF            mov	-$21[bp],al
27249                                           !BCC_EOS
27250                                           ! 4075         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
27251                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
27252 7D6B           8A46         DF            mov	al,-$21[bp]
27253 7D6E           30E4                       xor	ah,ah
27254 7D70           B1                     03  mov	cl,*3
27255 7D72           D3E0                       shl	ax,cl
27256 7D74           89C3                       mov	bx,ax
27257                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
27258                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
27259 7D76           81C3                 0122  add	bx,#$122
27260 7D7A           53                         push	bx
27261                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
27262 7D7B           FF76         FE            push	-2[bp]
27263                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27264 7D7E           E8         8873            call	_read_byte
27265 7D81           83C4                   04  add	sp,*4
27266                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
27267 7D84           8846         DE            mov	-$22[bp],al
27268                                           !BCC_EOS
27269                                           ! 4076         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27270                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
27271 7D87           8A46         DF            mov	al,-$21[bp]
27272 7D8A           30E4                       xor	ah,ah
27273 7D8C           B1                     03  mov	cl,*3
27274 7D8E           D3E0                       shl	ax,cl
27275 7D90           89C3                       mov	bx,ax
27276                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27277                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27278 7D92           81C3                 0124  add	bx,#$124
27279 7D96           53                         push	bx
27280                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
27281 7D97           FF76         FE            push	-2[bp]
27282                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27283 7D9A           E8         886A            call	_read_word
27284 7D9D           83C4                   04  add	sp,*4
27285                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
27286 7DA0           8946         DA            mov	-$26[bp],ax
27287                                           !BCC_EOS
27288                                           ! 4077         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
27289                                           ! Debug: list int = const $42 (used reg = )
27290 7DA3           B8                   0042  mov	ax,*$42
27291 7DA6           50                         push	ax
27292                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
27293 7DA7           8B46         0C            mov	ax,$C[bp]
27294                                           ! Debug: list unsigned int = ax+0 (used reg = )
27295 7DAA           50                         push	ax
27296                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27297 7DAB           FF76         06            push	6[bp]
27298                                           ! Debug: func () void = write_word+0 (used reg = )
27299 7DAE           E8         8881            call	_write_word
27300 7DB1           83C4                   06  add	sp,*6
27301                                           !BCC_EOS
27302                                           ! 4078         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
27303                                           ! Debug: list unsigned int = const $BEDD (used reg = )
27304 7DB4           B8                   BEDD  mov	ax,#$BEDD
27305 7DB7           50                         push	ax
27306                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
27307 7DB8           8B46         0C            mov	ax,$C[bp]
27308                                           ! Debug: list unsigned int = ax+$1E (used reg = )
27309 7DBB           05                   001E  add	ax,*$1E
27310 7DBE           50                         push	ax
27311                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27312 7DBF           FF76         06            push	6[bp]
27313                                           ! Debug: func () void = write_word+0 (used reg = )
27314 7DC2           E8         886D            call	_write_word
27315 7DC5           83C4                   06  add	sp,*6
27316                                           !BCC_EOS
27317                                           ! 4079         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
27318                                           ! Debug: list int = const $24 (used reg = )
27319 7DC8           B8                   0024  mov	ax,*$24
27320 7DCB           50                         push	ax
27321                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
27322 7DCC           8B46         0C            mov	ax,$C[bp]
27323                                           ! Debug: list unsigned int = ax+$20 (used reg = )
27324 7DCF           05                   0020  add	ax,*$20
27325 7DD2           50                         push	ax
27326                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27327 7DD3           FF76         06            push	6[bp]
27328                                           ! Debug: func () void = write_byte+0 (used reg = )
27329 7DD6           E8         8841            call	_write_byte
27330 7DD9           83C4                   06  add	sp,*6
27331                                           !BCC_EOS
27332                                           ! 4080         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
27333                                           ! Debug: list int = const 0 (used reg = )
27334 7DDC           31C0                       xor	ax,ax
27335 7DDE           50                         push	ax
27336                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
27337 7DDF           8B46         0C            mov	ax,$C[bp]
27338                                           ! Debug: list unsigned int = ax+$21 (used reg = )
27339 7DE2           05                   0021  add	ax,*$21
27340 7DE5           50                         push	ax
27341                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27342 7DE6           FF76         06            push	6[bp]
27343                                           ! Debug: func () void = write_byte+0 (used reg = )
27344 7DE9           E8         882E            call	_write_byte
27345 7DEC           83C4                   06  add	sp,*6
27346                                           !BCC_EOS
27347                                           ! 4081         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
27348                                           ! Debug: list int = const 0 (used reg = )
27349 7DEF           31C0                       xor	ax,ax
27350 7DF1           50                         push	ax
27351                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
27352 7DF2           8B46         0C            mov	ax,$C[bp]
27353                                           ! Debug: list unsigned int = ax+$22 (used reg = )
27354 7DF5           05                   0022  add	ax,*$22
27355 7DF8           50                         push	ax
27356                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27357 7DF9           FF76         06            push	6[bp]
27358                                           ! Debug: func () void = write_word+0 (used reg = )
27359 7DFC           E8         8833            call	_write_word
27360 7DFF           83C4                   06  add	sp,*6
27361                                           !BCC_EOS
27362                                           ! 4082         if (iface==0x00) {
27363                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
27364 7E02           8A46         DE            mov	al,-$22[bp]
27365 7E05           84C0                       test	al,al
27366 7E07           75           51            jne 	.5B4
27367                       00007E09            .5B5:
27368                                           ! 4083           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
27369                                           ! Debug: list int = const $49 (used reg = )
27370 7E09           B8                   0049  mov	ax,*$49
27371 7E0C           50                         push	ax
27372                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
27373 7E0D           8B46         0C            mov	ax,$C[bp]
27374                                           ! Debug: list unsigned int = ax+$24 (used reg = )
27375 7E10           05                   0024  add	ax,*$24
27376 7E13           50                         push	ax
27377                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27378 7E14           FF76         06            push	6[bp]
27379                                           ! Debug: func () void = write_byte+0 (used reg = )
27380 7E17           E8         8800            call	_write_byte
27381 7E1A           83C4                   06  add	sp,*6
27382                                           !BCC_EOS
27383                                           ! 4084           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
27384                                           ! Debug: list int = const $53 (used reg = )
27385 7E1D           B8                   0053  mov	ax,*$53
27386 7E20           50                         push	ax
27387                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
27388 7E21           8B46         0C            mov	ax,$C[bp]
27389                                           ! Debug: list unsigned int = ax+$25 (used reg = )
27390 7E24           05                   0025  add	ax,*$25
27391 7E27           50                         push	ax
27392                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27393 7E28           FF76         06            push	6[bp]
27394                                           ! Debug: func () void = write_byte+0 (used reg = )
27395 7E2B           E8         87EC            call	_write_byte
27396 7E2E           83C4                   06  add	sp,*6
27397                                           !BCC_EOS
27398                                           ! 4085           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
27399                                           ! Debug: list int = const $41 (used reg = )
27400 7E31           B8                   0041  mov	ax,*$41
27401 7E34           50                         push	ax
27402                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
27403 7E35           8B46         0C            mov	ax,$C[bp]
27404                                           ! Debug: list unsigned int = ax+$26 (used reg = )
27405 7E38           05                   0026  add	ax,*$26
27406 7E3B           50                         push	ax
27407                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27408 7E3C           FF76         06            push	6[bp]
27409                                           ! Debug: func () void = write_byte+0 (used reg = )
27410 7E3F           E8         87D8            call	_write_byte
27411 7E42           83C4                   06  add	sp,*6
27412                                           !BCC_EOS
27413                                           ! 4086           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
27414                                           ! Debug: list int = const 0 (used reg = )
27415 7E45           31C0                       xor	ax,ax
27416 7E47           50                         push	ax
27417                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
27418 7E48           8B46         0C            mov	ax,$C[bp]
27419                                           ! Debug: list unsigned int = ax+$27 (used reg = )
27420 7E4B           05                   0027  add	ax,*$27
27421 7E4E           50                         push	ax
27422                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27423 7E4F           FF76         06            push	6[bp]
27424                                           ! Debug: func () void = write_byte+0 (used reg = )
27425 7E52           E8         87C5            call	_write_byte
27426 7E55           83C4                   06  add	sp,*6
27427                                           !BCC_EOS
27428                                           ! 4087           }
27429                                           ! 4088         else {
27430 7E58           EB           00            jmp .5B6
27431                       00007E5A            .5B4:
27432                                           ! 4089           }
27433                                           ! 4090         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
27434                       00007E5A            .5B6:
27435                                           ! Debug: list int = const $41 (used reg = )
27436 7E5A           B8                   0041  mov	ax,*$41
27437 7E5D           50                         push	ax
27438                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
27439 7E5E           8B46         0C            mov	ax,$C[bp]
27440                                           ! Debug: list unsigned int = ax+$28 (used reg = )
27441 7E61           05                   0028  add	ax,*$28
27442 7E64           50                         push	ax
27443                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27444 7E65           FF76         06            push	6[bp]
27445                                           ! Debug: func () void = write_byte+0 (used reg = )
27446 7E68           E8         87AF            call	_write_byte
27447 7E6B           83C4                   06  add	sp,*6
27448                                           !BCC_EOS
27449                                           ! 4091         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
27450                                           ! Debug: list int = const $54 (used reg = )
27451 7E6E           B8                   0054  mov	ax,*$54
27452 7E71           50                         push	ax
27453                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
27454 7E72           8B46         0C            mov	ax,$C[bp]
27455                                           ! Debug: list unsigned int = ax+$29 (used reg = )
27456 7E75           05                   0029  add	ax,*$29
27457 7E78           50                         push	ax
27458                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27459 7E79           FF76         06            push	6[bp]
27460                                           ! Debug: func () void = write_byte+0 (used reg = )
27461 7E7C           E8         879B            call	_write_byte
27462 7E7F           83C4                   06  add	sp,*6
27463                                           !BCC_EOS
27464                                           ! 4092         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
27465                                           ! Debug: list int = const $41 (used reg = )
27466 7E82           B8                   0041  mov	ax,*$41
27467 7E85           50                         push	ax
27468                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
27469 7E86           8B46         0C            mov	ax,$C[bp]
27470                                           ! Debug: list unsigned int = ax+$2A (used reg = )
27471 7E89           05                   002A  add	ax,*$2A
27472 7E8C           50                         push	ax
27473                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27474 7E8D           FF76         06            push	6[bp]
27475                                           ! Debug: func () void = write_byte+0 (used reg = )
27476 7E90           E8         8787            call	_write_byte
27477 7E93           83C4                   06  add	sp,*6
27478                                           !BCC_EOS
27479                                           ! 4093         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
27480                                           ! Debug: list int = const 0 (used reg = )
27481 7E96           31C0                       xor	ax,ax
27482 7E98           50                         push	ax
27483                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
27484 7E99           8B46         0C            mov	ax,$C[bp]
27485                                           ! Debug: list unsigned int = ax+$2B (used reg = )
27486 7E9C           05                   002B  add	ax,*$2B
27487 7E9F           50                         push	ax
27488                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27489 7EA0           FF76         06            push	6[bp]
27490                                           ! Debug: func () void = write_byte+0 (used reg = )
27491 7EA3           E8         8774            call	_write_byte
27492 7EA6           83C4                   06  add	sp,*6
27493                                           !BCC_EOS
27494                                           ! 4094         if (iface==0x00) {
27495                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
27496 7EA9           8A46         DE            mov	al,-$22[bp]
27497 7EAC           84C0                       test	al,al
27498 7EAE           75           3E            jne 	.5B7
27499                       00007EB0            .5B8:
27500                                           ! 4095           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
27501                                           ! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
27502 7EB0           FF76         DA            push	-$26[bp]
27503                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
27504 7EB3           8B46         0C            mov	ax,$C[bp]
27505                                           ! Debug: list unsigned int = ax+$30 (used reg = )
27506 7EB6           05                   0030  add	ax,*$30
27507 7EB9           50                         push	ax
27508                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27509 7EBA           FF76         06            push	6[bp]
27510                                           ! Debug: func () void = write_word+0 (used reg = )
27511 7EBD           E8         8772            call	_write_word
27512 7EC0           83C4                   06  add	sp,*6
27513                                           !BCC_EOS
27514                                           ! 4096           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
27515                                           ! Debug: list int = const 0 (used reg = )
27516 7EC3           31C0                       xor	ax,ax
27517 7EC5           50                         push	ax
27518                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
27519 7EC6           8B46         0C            mov	ax,$C[bp]
27520                                           ! Debug: list unsigned int = ax+$32 (used reg = )
27521 7EC9           05                   0032  add	ax,*$32
27522 7ECC           50                         push	ax
27523                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27524 7ECD           FF76         06            push	6[bp]
27525                                           ! Debug: func () void = write_word+0 (used reg = )
27526 7ED0           E8         875F            call	_write_word
27527 7ED3           83C4                   06  add	sp,*6
27528                                           !BCC_EOS
27529                                           ! 4097           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
27530                                           ! Debug: list long = const 0 (used reg = )
27531 7ED6           31C0                       xor	ax,ax
27532 7ED8           31DB                       xor	bx,bx
27533 7EDA           53                         push	bx
27534 7EDB           50                         push	ax
27535                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
27536 7EDC           8B46         0C            mov	ax,$C[bp]
27537                                           ! Debug: list unsigned int = ax+$34 (used reg = )
27538 7EDF           05                   0034  add	ax,*$34
27539 7EE2           50                         push	ax
27540                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27541 7EE3           FF76         06            push	6[bp]
27542                                           ! Debug: func () void = write_dword+0 (used reg = )
27543 7EE6           E8         81B2            call	_write_dword
27544 7EE9           83C4                   08  add	sp,*8
27545                                           !BCC_EOS
27546                                           ! 4098           }
27547                                           ! 4099         else {
27548 7EEC           EB           00            jmp .5B9
27549                       00007EEE            .5B7:
27550                                           ! 4100           }
27551                                           ! 4101         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
27552                       00007EEE            .5B9:
27553                                           ! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
27554 7EEE           8A46         FD            mov	al,-3[bp]
27555 7EF1           30E4                       xor	ah,ah
27556 7EF3           24                     01  and	al,*1
27557                                           ! Debug: list unsigned char = al+0 (used reg = )
27558 7EF5           30E4                       xor	ah,ah
27559 7EF7           50                         push	ax
27560                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
27561 7EF8           8B46         0C            mov	ax,$C[bp]
27562                                           ! Debug: list unsigned int = ax+$38 (used reg = )
27563 7EFB           05                   0038  add	ax,*$38
27564 7EFE           50                         push	ax
27565                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27566 7EFF           FF76         06            push	6[bp]
27567                                           ! Debug: func () void = write_byte+0 (used reg = )
27568 7F02           E8         8715            call	_write_byte
27569 7F05           83C4                   06  add	sp,*6
27570                                           !BCC_EOS
27571                                           ! 4102         write_byte(DS,
27572                                           ! 4102  SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
27573                                           ! Debug: list int = const 0 (used reg = )
27574 7F08           31C0                       xor	ax,ax
27575 7F0A           50                         push	ax
27576                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
27577 7F0B           8B46         0C            mov	ax,$C[bp]
27578                                           ! Debug: list unsigned int = ax+$39 (used reg = )
27579 7F0E           05                   0039  add	ax,*$39
27580 7F11           50                         push	ax
27581                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27582 7F12           FF76         06            push	6[bp]
27583                                           ! Debug: func () void = write_byte+0 (used reg = )
27584 7F15           E8         8702            call	_write_byte
27585 7F18           83C4                   06  add	sp,*6
27586                                           !BCC_EOS
27587                                           ! 4103         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
27588                                           ! Debug: list int = const 0 (used reg = )
27589 7F1B           31C0                       xor	ax,ax
27590 7F1D           50                         push	ax
27591                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
27592 7F1E           8B46         0C            mov	ax,$C[bp]
27593                                           ! Debug: list unsigned int = ax+$3A (used reg = )
27594 7F21           05                   003A  add	ax,*$3A
27595 7F24           50                         push	ax
27596                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27597 7F25           FF76         06            push	6[bp]
27598                                           ! Debug: func () void = write_word+0 (used reg = )
27599 7F28           E8         8707            call	_write_word
27600 7F2B           83C4                   06  add	sp,*6
27601                                           !BCC_EOS
27602                                           ! 4104         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
27603                                           ! Debug: list long = const 0 (used reg = )
27604 7F2E           31C0                       xor	ax,ax
27605 7F30           31DB                       xor	bx,bx
27606 7F32           53                         push	bx
27607 7F33           50                         push	ax
27608                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
27609 7F34           8B46         0C            mov	ax,$C[bp]
27610                                           ! Debug: list unsigned int = ax+$3C (used reg = )
27611 7F37           05                   003C  add	ax,*$3C
27612 7F3A           50                         push	ax
27613                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27614 7F3B           FF76         06            push	6[bp]
27615                                           ! Debug: func () void = write_dword+0 (used reg = )
27616 7F3E           E8         815A            call	_write_dword
27617 7F41           83C4                   08  add	sp,*8
27618                                           !BCC_EOS
27619                                           ! 4105         checksum=0;
27620                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
27621 7F44           30C0                       xor	al,al
27622 7F46           8846         DD            mov	-$23[bp],al
27623                                           !BCC_EOS
27624                                           ! 4106         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
27625                                           ! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
27626 7F49           B0                     1E  mov	al,*$1E
27627 7F4B           8846         DC            mov	-$24[bp],al
27628                                           !BCC_EOS
27629                                           !BCC_EOS
27630 7F4E           EB           25            jmp .5BC
27631                       00007F50            .5BD:
27632                                           ! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
27633 7F50           8B46         0C            mov	ax,$C[bp]
27634 7F53           0246         DC            add	al,-$24[bp]
27635 7F56           80D4                   00  adc	ah,*0
27636                                           ! Debug: list unsigned int = ax+0 (used reg = )
27637 7F59           50                         push	ax
27638                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
27639 7F5A           FF76         06            push	6[bp]
27640                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27641 7F5D           E8         8694            call	_read_byte
27642 7F60           83C4                   04  add	sp,*4
27643                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
27644 7F63           30E4                       xor	ah,ah
27645 7F65           0246         DD            add	al,-$23[bp]
27646 7F68           80D4                   00  adc	ah,*0
27647 7F6B           8846         DD            mov	-$23[bp],al
27648                                           !BCC_EOS
27649                                           ! 4107         checksum = ~checksum;
27650                       00007F6E            .5BB:
27651                                           ! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
27652 7F6E           8A46         DC            mov	al,-$24[bp]
27653 7F71           40                         inc	ax
27654 7F72           8846         DC            mov	-$24[bp],al
27655                       00007F75            .5BC:
27656                                           ! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
27657 7F75           8A46         DC            mov	al,-$24[bp]
27658 7F78           3C                     40  cmp	al,*$40
27659 7F7A           72           D4            jb 	.5BD
27660                       00007F7C            .5BE:
27661                       00007F7C            .5BA:
27662                                           ! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
27663 7F7C           8A46         DD            mov	al,-$23[bp]
27664 7F7F           30E4                       xor	ah,ah
27665 7F81           F7D0                       not	ax
27666                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
27667 7F83           8846         DD            mov	-$23[bp],al
27668                                           !BCC_EOS
27669                                           ! 4108         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
27670                                           ! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
27671 7F86           8A46         DD            mov	al,-$23[bp]
27672 7F89           30E4                       xor	ah,ah
27673 7F8B           50                         push	ax
27674                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
27675 7F8C           8B46         0C            mov	ax,$C[bp]
27676                                           ! Debug: list unsigned int = ax+$41 (used reg = )
27677 7F8F           05                   0041  add	ax,*$41
27678 7F92           50                         push	ax
27679                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27680 7F93           FF76         06            push	6[bp]
27681                                           ! Debug: func () void = write_byte+0 (used reg = )
27682 7F96           E8         8681            call	_write_byte
27683 7F99           83C4                   06  add	sp,*6
27684                                           !BCC_EOS
27685                                           ! 4109         }
27686                                           ! 4110       goto int13_success;
27687                       00007F9C            .5B2:
27688 7F9C           83C4                   0C  add	sp,#..FFE9-..FFEA
27689 7F9F           E9         00FA            br 	.FFE9
27690                                           !BCC_EOS
27691                                           ! 4111       break;
27692 7FA2           E9         00C7            br 	.56C
27693                                           !BCC_EOS
27694                                           ! 4112     case 0x49:
27695                                           ! 4113       AX = ((AX & 0x00ff) | ((06) << 8));
27696                       00007FA5            .5BF:
27697                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27698 7FA5           8A46         18            mov	al,$18[bp]
27699                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
27700 7FA8           30E4                       xor	ah,ah
27701 7FAA           0D                   0600  or	ax,#$600
27702                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27703 7FAD           8946         18            mov	$18[bp],ax
27704                                           !BCC_EOS
27705                                           ! 4114       goto int13_fail_nostatus;
27706 7FB0           83C4                   0C  add	sp,#..FFE7-..FFEA
27707 7FB3           E9         00DA            br 	.FFE7
27708                                           !BCC_EOS
27709                                           ! 4115       break;
27710 7FB6           E9         00B3            br 	.56C
27711                                           !BCC_EOS
27712                                           ! 4116     case 0x4e:
27713                                           ! 4117       switch (( AX & 0x00ff )) {
27714                       00007FB9            .5C0:
27715                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27716 7FB9           8A46         18            mov	al,$18[bp]
27717 7FBC           EB           10            jmp .5C3
27718                                           ! 4118         case 0x01:
27719                                           ! 4119         case 0x03:
27720                       00007FBE            .5C4:
27721                                           ! 4120         case 0x04:
27722                       00007FBE            .5C5:
27723                                           ! 4121         case 0x06:
27724                       00007FBE            .5C6:
27725                                           ! 4122           goto int13_success;
27726                       00007FBE            .5C7:
27727 7FBE           83C4                   0C  add	sp,#..FFE9-..FFEA
27728 7FC1           E9         00D8            br 	.FFE9
27729                                           !BCC_EOS
27730                                           ! 4123           break;
27731 7FC4           EB           1A            jmp .5C1
27732                                           !BCC_EOS
27733                                           ! 4124         default :
27734                                           ! 4125           goto int13_fail;
27735                       00007FC6            .5C8:
27736 7FC6           83C4                   0C  add	sp,#..FFEB-..FFEA
27737 7FC9           E9         00A3            br 	.FFEB
27738                                           !BCC_EOS
27739                                           ! 4126         }
27740                                           ! 4127       break;
27741 7FCC           EB           12            jmp .5C1
27742                       00007FCE            .5C3:
27743 7FCE           2C                     01  sub	al,*1
27744 7FD0           74           EC            je 	.5C4
27745 7FD2           2C                     02  sub	al,*2
27746 7FD4           74           E8            je 	.5C5
27747 7FD6           2C                     01  sub	al,*1
27748 7FD8           74           E4            je 	.5C6
27749 7FDA           2C                     02  sub	al,*2
27750 7FDC           74           E0            je 	.5C7
27751 7FDE           EB           E6            jmp	.5C8
27752                       00007FE0            .5C1:
27753 7FE0           E9         0089            br 	.56C
27754                                           !BCC_EOS
27755                                           ! 4128     case 0x02:
27756                                           ! 4129     case 0x04:
27757                       00007FE3            .5C9:
27758                                           ! 4130     case 0x08:
27759                       00007FE3            .5CA:
27760                                           ! 4131     case 0x0a:
27761                       00007FE3            .5CB:
27762                                           ! 4132     case 0x0b:
27763                       00007FE3            .5CC:
27764                                           ! 4133     case 0x18:
27765                       00007FE3            .5CD:
27766                                           ! 4134     case 0x50:
27767                       00007FE3            .5CE:
27768                                           ! 4135     default:
27769                       00007FE3            .5CF:
27770                                           ! 4136       ;
27771                       00007FE3            .5D0:
27772                                           !BCC_EOS
27773                                           ! 4137       goto int13_fail;
27774 7FE3           83C4                   0C  add	sp,#..FFEB-..FFEA
27775 7FE6           E9         0086            br 	.FFEB
27776                                           !BCC_EOS
27777                                           ! 4138       break;
27778 7FE9           E9         0080            br 	.56C
27779                                           !BCC_EOS
27780                                           ! 4139     }
27781                                           ! 4140 int13_fail:
27782 7FEC           EB           7E            jmp .56C
27783                       00007FEE            .56E:
27784 7FEE           83C4                   F4  add	sp,*-$C
27785 7FF1           2D                   0000  sub	ax,*0
27786 7FF4           7C           ED            jl 	.5D0
27787 7FF6           3D                   0018  cmp	ax,*$18
27788 7FF9           77           3B            ja  	.5D1
27789 7FFB           D1E0                       shl	ax,*1
27790 7FFD           89C3                       mov	bx,ax
27791 7FFF           2E                         seg	cs
27792 8000           FFA7       8004            br	.5D2[bx]
27793                       00008004            .5D2:
27794 8004                      766E            .word	.56F
27795 8006                      768B            .word	.57A
27796 8008                      7FE3            .word	.5C9
27797 800A                      7677            .word	.577
27798 800C                      7FE3            .word	.5CA
27799 800E                      7677            .word	.578
27800 8010                      7FE3            .word	.5D0
27801 8012                      7FE3            .word	.5D0
27802 8014                      7FE3            .word	.5CB
27803 8016                      766E            .word	.570
27804 8018                      7FE3            .word	.5CC
27805 801A                      7FE3            .word	.5CD
27806 801C                      766E            .word	.571
27807 801E                      766E            .word	.572
27808 8020                      7FE3            .word	.5D0
27809 8022                      7FE3            .word	.5D0
27810 8024                      766E            .word	.573
27811 8026                      766E            .word	.574
27812 8028                      7FE3            .word	.5D0
27813 802A                      7FE3            .word	.5D0
27814 802C                      766E            .word	.575
27815 802E                      76DC            .word	.57E
27816 8030                      766E            .word	.576
27817 8032                      7FE3            .word	.5D0
27818 8034                      7FE3            .word	.5CE
27819                       00008036            .5D1:
27820 8036           2D                   0041  sub	ax,*$41
27821 8039           72           A8            jb 	.5D0
27822 803B           3D                   000F  cmp	ax,*$F
27823 803E           77           29            ja  	.5D3
27824 8040           D1E0                       shl	ax,*1
27825 8042           89C3                       mov	bx,ax
27826 8044           2E                         seg	cs
27827 8045           FFA7       8049            br	.5D4[bx]
27828                       00008049            .5D4:
27829 8049                      76F0            .word	.57F
27830 804B                      7710            .word	.580
27831 804D                      7677            .word	.579
27832 804F                      7710            .word	.581
27833 8051                      78D9            .word	.58B
27834 8053                      79F7            .word	.59E
27835 8055                      7710            .word	.582
27836 8057                      7A60            .word	.5A3
27837 8059                      7FA5            .word	.5BF
27838 805B                      7FE3            .word	.5D0
27839 805D                      7FE3            .word	.5D0
27840 805F                      7FE3            .word	.5D0
27841 8061                      7FE3            .word	.5D0
27842 8063                      7FB9            .word	.5C0
27843 8065                      7FE3            .word	.5D0
27844 8067                      7FE3            .word	.5CF
27845                       00008069            .5D3:
27846 8069           E9         FF77            br 	.5D0
27847                       0000806C            .56C:
27848                       FFFFFFD2            ..FFEA	=	-$2E
27849 806C           83C4                   0C  add	sp,*$C
27850                       0000806F            .FFEB:
27851                       FFFFFFDE            ..FFEB	=	-$22
27852                                           ! 4141     AX = ((AX & 0x00ff) | ((0x01) << 8));
27853                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27854 806F           8A46         18            mov	al,$18[bp]
27855                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
27856 8072           30E4                       xor	ah,ah
27857 8074           0D                   0100  or	ax,#$100
27858                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27859 8077           8946         18            mov	$18[bp],ax
27860                                           !BCC_EOS
27861                                           ! 4142 int13_fail_noah:
27862                       0000807A            .FFE8:
27863                       FFFFFFDE            ..FFE8	=	-$22
27864                                           ! 4143     write_byte(0x0040, 0x0074, ( AX >> 8 ));
27865                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
27866 807A           8B46         18            mov	ax,$18[bp]
27867 807D           88E0                       mov	al,ah
27868 807F           30E4                       xor	ah,ah
27869                                           ! Debug: list unsigned int = ax+0 (used reg = )
27870 8081           50                         push	ax
27871                                           ! Debug: list int = const $74 (used reg = )
27872 8082           B8                   0074  mov	ax,*$74
27873 8085           50                         push	ax
27874                                           ! Debug: list int = const $40 (used reg = )
27875 8086           B8                   0040  mov	ax,*$40
27876 8089           50                         push	ax
27877                                           ! Debug: func () void = write_byte+0 (used reg = )
27878 808A           E8         858D            call	_write_byte
27879 808D           83C4                   06  add	sp,*6
27880                                           !BCC_EOS
27881                                           ! 4144 int13_fail_nostatus:
27882                       00008090            .FFE7:
27883                       FFFFFFDE            ..FFE7	=	-$22
27884                                           ! 4145     FLAGS |= 0x0001;
27885                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
27886 8090           8B46         1E            mov	ax,$1E[bp]
27887 8093           0C                     01  or	al,*1
27888 8095           8946         1E            mov	$1E[bp],ax
27889                                           !BCC_EOS
27890                                           ! 4146     return;
27891 8098           89EC                       mov	sp,bp
27892 809A           5D                         pop	bp
27893 809B           C3                         ret
27894                                           !BCC_EOS
27895                                           ! 4147 int13_success:
27896                       0000809C            .FFE9:
27897                       FFFFFFDE            ..FFE9	=	-$22
27898                                           ! 4148     AX = ((AX & 0x00ff) | ((0x00) << 8));
27899                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27900 809C           8A46         18            mov	al,$18[bp]
27901                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
27902 809F           0C                     00  or	al,*0
27903                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
27904 80A1           30E4                       xor	ah,ah
27905 80A3           8946         18            mov	$18[bp],ax
27906                                           !BCC_EOS
27907                                           ! 4149 int13_success_noah:
27908                       000080A6            .FFE6:
27909                       FFFFFFDE            ..FFE6	=	-$22
27910                                           ! 4150     write_byte(0x0040, 0x0074, 0x00);
27911                                           ! Debug: list int = const 0 (used reg = )
27912 80A6           31C0                       xor	ax,ax
27913 80A8           50                         push	ax
27914                                           ! Debug: list int = const $74 (used reg = )
27915 80A9           B8                   0074  mov	ax,*$74
27916 80AC           50                         push	ax
27917                                           ! Debug: list int = const $40 (used reg = )
27918 80AD           B8                   0040  mov	ax,*$40
27919 80B0           50                         push	ax
27920                                           ! Debug: func () void = write_byte+0 (used reg = )
27921 80B1           E8         8566            call	_write_byte
27922 80B4           83C4                   06  add	sp,*6
27923                                           !BCC_EOS
27924                                           ! 4151     FLAGS &= 0xfffe;
27925                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
27926 80B7           8B46         1E            mov	ax,$1E[bp]
27927 80BA           24                     FE  and	al,#$FE
27928 80BC           8946         1E            mov	$1E[bp],ax
27929                                           !BCC_EOS
27930                                           ! 4152     return;
27931 80BF           89EC                       mov	sp,bp
27932 80C1           5D                         pop	bp
27933 80C2           C3                         ret
27934                                           !BCC_EOS
27935                                           ! 4153 }
27936                                           ! 4154   void
27937                                           ! Register BX used in function int13_cdrom
27938                                           ! 4155 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
27939                                           ! 4156   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
27940                                           export	_int13_eltorito
27941                       000080C3            _int13_eltorito:
27942                                           !BCC_EOS
27943                                           ! 4157 {
27944                                           ! 4158   Bit16u ebda_seg=read_word(0x0040,0x000E);
27945 80C3           55                         push	bp
27946 80C4           89E5                       mov	bp,sp
27947 80C6           4C                         dec	sp
27948 80C7           4C                         dec	sp
27949                                           ! Debug: list int = const $E (used reg = )
27950 80C8           B8                   000E  mov	ax,*$E
27951 80CB           50                         push	ax
27952                                           ! Debug: list int = const $40 (used reg = )
27953 80CC           B8                   0040  mov	ax,*$40
27954 80CF           50                         push	ax
27955                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27956 80D0           E8         8534            call	_read_word
27957 80D3           83C4                   04  add	sp,*4
27958                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
27959 80D6           8946         FE            mov	-2[bp],ax
27960                                           !BCC_EOS
27961                                           ! 4159   ;
27962                                           !BCC_EOS
27963                                           ! 4160   switch (( AX >> 8 )) {
27964                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
27965 80D9           8B46         16            mov	ax,$16[bp]
27966 80DC           88E0                       mov	al,ah
27967 80DE           30E4                       xor	ah,ah
27968 80E0           E9         01A8            br 	.5D7
27969                                           ! 4161     case 0x4a:
27970                                           ! 4162     case 0x4c:
27971                       000080E3            .5D8:
27972                                           ! 4163     case 0x4d:
27973                       000080E3            .5D9:
27974                                           ! 4164       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
27975                       000080E3            .5DA:
27976                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
27977 80E3           FF76         16            push	$16[bp]
27978                                           ! Debug: list * char = .5DB+0 (used reg = )
27979 80E6           BB                   D123  mov	bx,#.5DB
27980 80E9           53                         push	bx
27981                                           ! Debug: list int = const 7 (used reg = )
27982 80EA           B8                   0007  mov	ax,*7
27983 80ED           50                         push	ax
27984                                           ! Debug: func () void = bios_printf+0 (used reg = )
27985 80EE           E8         892A            call	_bios_printf
27986 80F1           83C4                   06  add	sp,*6
27987                                           !BCC_EOS
27988                                           ! 4165       goto int13_fail;
27989 80F4           83C4                   00  add	sp,#..FFE4-..FFE5
27990 80F7           E9         01AF            br 	.FFE4
27991                                           !BCC_EOS
27992                                           ! 4166       break;
27993 80FA           E9         01AC            br 	.5D5
27994                                           !BCC_EOS
27995                                           ! 4167     case 0x4b:
27996                                           ! 4168       write_byte(DS,SI+0x00,0x13);
27997                       000080FD            .5DC:
27998                                           ! Debug: list int = const $13 (used reg = )
27999 80FD           B8                   0013  mov	ax,*$13
28000 8100           50                         push	ax
28001                                           ! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
28002 8101           8B46         0A            mov	ax,$A[bp]
28003                                           ! Debug: list unsigned int = ax+0 (used reg = )
28004 8104           50                         push	ax
28005                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28006 8105           FF76         04            push	4[bp]
28007                                           ! Debug: func () void = write_byte+0 (used reg = )
28008 8108           E8         850F            call	_write_byte
28009 810B           83C4                   06  add	sp,*6
28010                                           !BCC_EOS
28011                                           ! 4169       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
28012                                           ! Debug: list * unsigned char = const $25B (used reg = )
28013 810E           B8                   025B  mov	ax,#$25B
28014 8111           50                         push	ax
28015                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28016 8112           FF76         FE            push	-2[bp]
28017                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28018 8115           E8         84DC            call	_read_byte
28019 8118           83C4                   04  add	sp,*4
28020                                           ! Debug: list unsigned char = al+0 (used reg = )
28021 811B           30E4                       xor	ah,ah
28022 811D           50                         push	ax
28023                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
28024 811E           8B46         0A            mov	ax,$A[bp]
28025                                           ! Debug: list unsigned int = ax+1 (used reg = )
28026 8121           40                         inc	ax
28027 8122           50                         push	ax
28028                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28029 8123           FF76         04            push	4[bp]
28030                                           ! Debug: func () void = write_byte+0 (used reg = )
28031 8126           E8         84F1            call	_write_byte
28032 8129           83C4                   06  add	sp,*6
28033                                           !BCC_EOS
28034                                           ! 4170       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
28035                                           ! Debug: list * unsigned char = const $25C (used reg = )
28036 812C           B8                   025C  mov	ax,#$25C
28037 812F           50                         push	ax
28038                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28039 8130           FF76         FE            push	-2[bp]
28040                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28041 8133           E8         84BE            call	_read_byte
28042 8136           83C4                   04  add	sp,*4
28043                                           ! Debug: list unsigned char = al+0 (used reg = )
28044 8139           30E4                       xor	ah,ah
28045 813B           50                         push	ax
28046                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
28047 813C           8B46         0A            mov	ax,$A[bp]
28048                                           ! Debug: list unsigned int = ax+2 (used reg = )
28049 813F           40                         inc	ax
28050 8140           40                         inc	ax
28051 8141           50                         push	ax
28052                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28053 8142           FF76         04            push	4[bp]
28054                                           ! Debug: func () void = write_byte+0 (used reg = )
28055 8145           E8         84D2            call	_write_byte
28056 8148           83C4                   06  add	sp,*6
28057                                           !BCC_EOS
28058                                           ! 4171       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
28059                                           ! Debug: list * unsigned char = const $25D (used reg = )
28060 814B           B8                   025D  mov	ax,#$25D
28061 814E           50                         push	ax
28062                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28063 814F           FF76         FE            push	-2[bp]
28064                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28065 8152           E8         849F            call	_read_byte
28066 8155           83C4                   04  add	sp,*4
28067                                           ! Debug: list unsigned char = al+0 (used reg = )
28068 8158           30E4                       xor	ah,ah
28069 815A           50                         push	ax
28070                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
28071 815B           8B46         0A            mov	ax,$A[bp]
28072                                           ! Debug: list unsigned int = ax+3 (used reg = )
28073 815E           05                   0003  add	ax,*3
28074 8161           50                         push	ax
28075                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28076 8162           FF76         04            push	4[bp]
28077                                           ! Debug: func () void = write_byte+0 (used reg = )
28078 8165           E8         84B2            call	_write_byte
28079 8168           83C4                   06  add	sp,*6
28080                                           !BCC_EOS
28081                                           ! 4172       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
28082                                           ! Debug: list * unsigned long = const $260 (used reg = )
28083 816B           B8                   0260  mov	ax,#$260
28084 816E           50                         push	ax
28085                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28086 816F           FF76         FE            push	-2[bp]
28087                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
28088 8172           E8         7F0E            call	_read_dword
28089 8175           89D3                       mov	bx,dx
28090 8177           83C4                   04  add	sp,*4
28091                                           ! Debug: list unsigned long = bx+0 (used reg = )
28092 817A           53                         push	bx
28093 817B           50                         push	ax
28094                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
28095 817C           8B46         0A            mov	ax,$A[bp]
28096                                           ! Debug: list unsigned int = ax+4 (used reg = )
28097 817F           05                   0004  add	ax,*4
28098 8182           50                         push	ax
28099                                           ! Debug: list unsigned short DS = [S+$A+2] (used reg = )
28100 8183           FF76         04            push	4[bp]
28101                                           ! Debug: func () void = write_dword+0 (used reg = )
28102 8186           E8         7F12            call	_write_dword
28103 8189           83C4                   08  add	sp,*8
28104                                           !BCC_EOS
28105                                           ! 4173     
28106                                           ! 4173   write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
28107                                           ! Debug: list * unsigned short = const $25E (used reg = )
28108 818C           B8                   025E  mov	ax,#$25E
28109 818F           50                         push	ax
28110                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28111 8190           FF76         FE            push	-2[bp]
28112                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28113 8193           E8         8471            call	_read_word
28114 8196           83C4                   04  add	sp,*4
28115                                           ! Debug: list unsigned short = ax+0 (used reg = )
28116 8199           50                         push	ax
28117                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
28118 819A           8B46         0A            mov	ax,$A[bp]
28119                                           ! Debug: list unsigned int = ax+8 (used reg = )
28120 819D           05                   0008  add	ax,*8
28121 81A0           50                         push	ax
28122                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28123 81A1           FF76         04            push	4[bp]
28124                                           ! Debug: func () void = write_word+0 (used reg = )
28125 81A4           E8         848B            call	_write_word
28126 81A7           83C4                   06  add	sp,*6
28127                                           !BCC_EOS
28128                                           ! 4174       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
28129                                           ! Debug: list * unsigned short = const $264 (used reg = )
28130 81AA           B8                   0264  mov	ax,#$264
28131 81AD           50                         push	ax
28132                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28133 81AE           FF76         FE            push	-2[bp]
28134                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28135 81B1           E8         8453            call	_read_word
28136 81B4           83C4                   04  add	sp,*4
28137                                           ! Debug: list unsigned short = ax+0 (used reg = )
28138 81B7           50                         push	ax
28139                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
28140 81B8           8B46         0A            mov	ax,$A[bp]
28141                                           ! Debug: list unsigned int = ax+$A (used reg = )
28142 81BB           05                   000A  add	ax,*$A
28143 81BE           50                         push	ax
28144                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28145 81BF           FF76         04            push	4[bp]
28146                                           ! Debug: func () void = write_word+0 (used reg = )
28147 81C2           E8         846D            call	_write_word
28148 81C5           83C4                   06  add	sp,*6
28149                                           !BCC_EOS
28150                                           ! 4175       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
28151                                           ! Debug: list * unsigned short = const $266 (used reg = )
28152 81C8           B8                   0266  mov	ax,#$266
28153 81CB           50                         push	ax
28154                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28155 81CC           FF76         FE            push	-2[bp]
28156                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28157 81CF           E8         8435            call	_read_word
28158 81D2           83C4                   04  add	sp,*4
28159                                           ! Debug: list unsigned short = ax+0 (used reg = )
28160 81D5           50                         push	ax
28161                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
28162 81D6           8B46         0A            mov	ax,$A[bp]
28163                                           ! Debug: list unsigned int = ax+$C (used reg = )
28164 81D9           05                   000C  add	ax,*$C
28165 81DC           50                         push	ax
28166                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28167 81DD           FF76         04            push	4[bp]
28168                                           ! Debug: func () void = write_word+0 (used reg = )
28169 81E0           E8         844F            call	_write_word
28170 81E3           83C4                   06  add	sp,*6
28171                                           !BCC_EOS
28172                                           ! 4176       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
28173                                           ! Debug: list * unsigned short = const $268 (used reg = )
28174 81E6           B8                   0268  mov	ax,#$268
28175 81E9           50                         push	ax
28176                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28177 81EA           FF76         FE            push	-2[bp]
28178                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28179 81ED           E8         8417            call	_read_word
28180 81F0           83C4                   04  add	sp,*4
28181                                           ! Debug: list unsigned short = ax+0 (used reg = )
28182 81F3           50                         push	ax
28183                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
28184 81F4           8B46         0A            mov	ax,$A[bp]
28185                                           ! Debug: list unsigned int = ax+$E (used reg = )
28186 81F7           05                   000E  add	ax,*$E
28187 81FA           50                         push	ax
28188                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28189 81FB           FF76         04            push	4[bp]
28190                                           ! Debug: func () void = write_word+0 (used reg = )
28191 81FE           E8         8431            call	_write_word
28192 8201           83C4                   06  add	sp,*6
28193                                           !BCC_EOS
28194                                           ! 4177       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
28195                                           ! Debug: list * unsigned short = const $26C (used reg = )
28196 8204           B8                   026C  mov	ax,#$26C
28197 8207           50                         push	ax
28198                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28199 8208           FF76         FE            push	-2[bp]
28200                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28201 820B           E8         83E6            call	_read_byte
28202 820E           83C4                   04  add	sp,*4
28203                                           ! Debug: list unsigned char = al+0 (used reg = )
28204 8211           30E4                       xor	ah,ah
28205 8213           50                         push	ax
28206                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
28207 8214           8B46         0A            mov	ax,$A[bp]
28208                                           ! Debug: list unsigned int = ax+$10 (used reg = )
28209 8217           05                   0010  add	ax,*$10
28210 821A           50                         push	ax
28211                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28212 821B           FF76         04            push	4[bp]
28213                                           ! Debug: func () void = write_byte+0 (used reg = )
28214 821E           E8         83F9            call	_write_byte
28215 8221           83C4                   06  add	sp,*6
28216                                           !BCC_EOS
28217                                           ! 4178       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
28218                                           ! Debug: list * unsigned short = const $26E (used reg = )
28219 8224           B8                   026E  mov	ax,#$26E
28220 8227           50                         push	ax
28221                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28222 8228           FF76         FE            push	-2[bp]
28223                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28224 822B           E8         83C6            call	_read_byte
28225 822E           83C4                   04  add	sp,*4
28226                                           ! Debug: list unsigned char = al+0 (used reg = )
28227 8231           30E4                       xor	ah,ah
28228 8233           50                         push	ax
28229                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
28230 8234           8B46         0A            mov	ax,$A[bp]
28231                                           ! Debug: list unsigned int = ax+$11 (used reg = )
28232 8237           05                   0011  add	ax,*$11
28233 823A           50                         push	ax
28234                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28235 823B           FF76         04            push	4[bp]
28236                                           ! Debug: func () void = write_byte+0 (used reg = )
28237 823E           E8         83D9            call	_write_byte
28238 8241           83C4                   06  add	sp,*6
28239                                           !BCC_EOS
28240                                           ! 4179       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
28241                                           ! Debug: list * unsigned short = const $26A (used reg = )
28242 8244           B8                   026A  mov	ax,#$26A
28243 8247           50                         push	ax
28244                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28245 8248           FF76         FE            push	-2[bp]
28246                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28247 824B           E8         83A6            call	_read_byte
28248 824E           83C4                   04  add	sp,*4
28249                                           ! Debug: list unsigned char = al+0 (used reg = )
28250 8251           30E4                       xor	ah,ah
28251 8253           50                         push	ax
28252                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
28253 8254           8B46         0A            mov	ax,$A[bp]
28254                                           ! Debug: list unsigned int = ax+$12 (used reg = )
28255 8257           05                   0012  add	ax,*$12
28256 825A           50                         push	ax
28257                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28258 825B           FF76         04            push	4[bp]
28259                                           ! Debug: func () void = write_byte+0 (used reg = )
28260 825E           E8         83B9            call	_write_byte
28261 8261           83C4                   06  add	sp,*6
28262                                           !BCC_EOS
28263                                           ! 4180       if(( AX & 0x00ff ) == 0x00) {
28264                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28265 8264           8A46         16            mov	al,$16[bp]
28266                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
28267 8267           84C0                       test	al,al
28268 8269           75           10            jne 	.5DD
28269                       0000826B            .5DE:
28270                                           ! 4181         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
28271                                           ! Debug: list int = const 0 (used reg = )
28272 826B           31C0                       xor	ax,ax
28273 826D           50                         push	ax
28274                                           ! Debug: list * unsigned char = const $25A (used reg = )
28275 826E           B8                   025A  mov	ax,#$25A
28276 8271           50                         push	ax
28277                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
28278 8272           FF76         FE            push	-2[bp]
28279                                           ! Debug: func () void = write_byte+0 (used reg = )
28280 8275           E8         83A2            call	_write_byte
28281 8278           83C4                   06  add	sp,*6
28282                                           !BCC_EOS
28283                                           ! 4182         }
28284                                           ! 4183       goto int13_success;
28285                       0000827B            .5DD:
28286 827B           83C4                   00  add	sp,#..FFE3-..FFE5
28287 827E           EB           56            jmp .FFE3
28288                                           !BCC_EOS
28289                                           ! 4184       break;
28290 8280           EB           27            jmp .5D5
28291                                           !BCC_EOS
28292                                           ! 4185     default:
28293                                           ! 4186       ;
28294                       00008282            .5DF:
28295                                           !BCC_EOS
28296                                           ! 4187       goto int13_fail;
28297 8282           83C4                   00  add	sp,#..FFE4-..FFE5
28298 8285           EB           22            jmp .FFE4
28299                                           !BCC_EOS
28300                                           ! 4188       break;
28301 8287           EB           20            jmp .5D5
28302                                           !BCC_EOS
28303                                           ! 4189     }
28304                                           ! 4190 int13_fail:
28305 8289           EB           1E            jmp .5D5
28306                       0000828B            .5D7:
28307 828B           2D                   004A  sub	ax,*$4A
28308 828E         0F84         FE51            beq 	.5D8
28309 8292           2D                   0001  sub	ax,*1
28310 8295         0F84         FE64            beq 	.5DC
28311 8299           2D                   0001  sub	ax,*1
28312 829C         0F84         FE43            beq 	.5D9
28313 82A0           2D                   0001  sub	ax,*1
28314 82A3         0F84         FE3C            beq 	.5DA
28315 82A7           EB           D9            jmp	.5DF
28316                       000082A9            .5D5:
28317                       FFFFFFFC            ..FFE5	=	-4
28318                       000082A9            .FFE4:
28319                       FFFFFFFC            ..FFE4	=	-4
28320                                           ! 4191     AX = ((AX & 0x00ff) | ((0x01) << 8));
28321                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28322 82A9           8A46         16            mov	al,$16[bp]
28323                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28324 82AC           30E4                       xor	ah,ah
28325 82AE           0D                   0100  or	ax,#$100
28326                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
28327 82B1           8946         16            mov	$16[bp],ax
28328                                           !BCC_EOS
28329                                           ! 4192     write_byte(0x0040, 0x0074, ( AX >> 8 ));
28330                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28331 82B4           8B46         16            mov	ax,$16[bp]
28332 82B7           88E0                       mov	al,ah
28333 82B9           30E4                       xor	ah,ah
28334                                           ! Debug: list unsigned int = ax+0 (used reg = )
28335 82BB           50                         push	ax
28336                                           ! Debug: list int = const $74 (used reg = )
28337 82BC           B8                   0074  mov	ax,*$74
28338 82BF           50                         push	ax
28339                                           ! Debug: list int = const $40 (used reg = )
28340 82C0           B8                   0040  mov	ax,*$40
28341 82C3           50                         push	ax
28342                                           ! Debug: func () void = write_byte+0 (used reg = )
28343 82C4           E8         8353            call	_write_byte
28344 82C7           83C4                   06  add	sp,*6
28345                                           !BCC_EOS
28346                                           ! 4193     FLAGS |= 0x0001;
28347                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
28348 82CA           8B46         1C            mov	ax,$1C[bp]
28349 82CD           0C                     01  or	al,*1
28350 82CF           8946         1C            mov	$1C[bp],ax
28351                                           !BCC_EOS
28352                                           ! 4194     return;
28353 82D2           89EC                       mov	sp,bp
28354 82D4           5D                         pop	bp
28355 82D5           C3                         ret
28356                                           !BCC_EOS
28357                                           ! 4195 int13_success:
28358                       000082D6            .FFE3:
28359                       FFFFFFFC            ..FFE3	=	-4
28360                                           ! 4196     AX = ((AX & 0x00ff) | ((0x00) << 8));
28361                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28362 82D6           8A46         16            mov	al,$16[bp]
28363                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28364 82D9           0C                     00  or	al,*0
28365                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
28366 82DB           30E4                       xor	ah,ah
28367 82DD           8946         16            mov	$16[bp],ax
28368                                           !BCC_EOS
28369                                           ! 4197     write_byte(0x0040, 0x0074, 0x00);
28370                                           ! Debug: list int = const 0 (used reg = )
28371 82E0           31C0                       xor	ax,ax
28372 82E2           50                         push	ax
28373                                           ! Debug: list int = const $74 (used reg = )
28374 82E3           B8                   0074  mov	ax,*$74
28375 82E6           50                         push	ax
28376                                           ! Debug: list int = const $40 (used reg = )
28377 82E7           B8                   0040  mov	ax,*$40
28378 82EA           50                         push	ax
28379                                           ! Debug: func () void = write_byte+0 (used reg = )
28380 82EB           E8         832C            call	_write_byte
28381 82EE           83C4                   06  add	sp,*6
28382                                           !BCC_EOS
28383                                           ! 4198     FLAGS &= 0xfffe;
28384                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
28385 82F1           8B46         1C            mov	ax,$1C[bp]
28386 82F4           24                     FE  and	al,#$FE
28387 82F6           8946         1C            mov	$1C[bp],ax
28388                                           !BCC_EOS
28389                                           ! 4199     return;
28390 82F9           89EC                       mov	sp,bp
28391 82FB           5D                         pop	bp
28392 82FC           C3                         ret
28393                                           !BCC_EOS
28394                                           ! 4200 }
28395                                           ! 4201   void
28396                                           ! Register BX used in function int13_eltorito
28397                                           ! 4202 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28398                                           ! 4203   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28399                                           export	_int13_cdemu
28400                       000082FD            _int13_cdemu:
28401                                           !BCC_EOS
28402                                           ! 4204 {
28403                                           ! 4205   Bit16u ebda_seg=read_word(0x0040,0x000E);
28404 82FD           55                         push	bp
28405 82FE           89E5                       mov	bp,sp
28406 8300           4C                         dec	sp
28407 8301           4C                         dec	sp
28408                                           ! Debug: list int = const $E (used reg = )
28409 8302           B8                   000E  mov	ax,*$E
28410 8305           50                         push	ax
28411                                           ! Debug: list int = const $40 (used reg = )
28412 8306           B8                   0040  mov	ax,*$40
28413 8309           50                         push	ax
28414                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28415 830A           E8         82FA            call	_read_word
28416 830D           83C4                   04  add	sp,*4
28417                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28418 8310           8946         FE            mov	-2[bp],ax
28419                                           !BCC_EOS
28420                                           ! 4206   Bit8u device, status;
28421                                           !BCC_EOS
28422                                           ! 4207   Bit16u vheads, vspt, vcylinders;
28423                                           !BCC_EOS
28424                                           ! 4208   Bit16u head, sector, cylinder, nbsectors;
28425                                           !BCC_EOS
28426                                           ! 4209   Bit32u vlba, ilba, slba, elba;
28427                                           !BCC_EOS
28428                                           ! 4210   Bit16u before, segment, offset;
28429                                           !BCC_EOS
28430                                           ! 4211   Bit8u atacmd[12];
28431                                           !BCC_EOS
28432                                           ! 4212   ;
28433 8313           83C4                   CE  add	sp,*-$32
28434                                           !BCC_EOS
28435                                           ! 4213   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
28436                                           ! Debug: list * unsigned char = const $25D (used reg = )
28437 8316           B8                   025D  mov	ax,#$25D
28438 8319           50                         push	ax
28439                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28440 831A           FF76         FE            push	-2[bp]
28441                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28442 831D           E8         82D4            call	_read_byte
28443 8320           83C4                   04  add	sp,*4
28444                                           ! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
28445 8323           30E4                       xor	ah,ah
28446 8325           D1E0                       shl	ax,*1
28447                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
28448 8327           8846         FD            mov	-3[bp],al
28449                                           !BCC_EOS
28450                                           ! 4214   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
28451                                           ! Debug: list * unsigned short = const $25E (used reg = )
28452 832A           B8                   025E  mov	ax,#$25E
28453 832D           50                         push	ax
28454                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28455 832E           FF76         FE            push	-2[bp]
28456                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28457 8331           E8         82C0            call	_read_byte
28458 8334           83C4                   04  add	sp,*4
28459                                           ! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
28460 8337           30E4                       xor	ah,ah
28461 8339           0246         FD            add	al,-3[bp]
28462 833C           80D4                   00  adc	ah,*0
28463 833F           8846         FD            mov	-3[bp],al
28464                                           !BCC_EOS
28465                                           ! 4215   write_byte(0x0040, 0x0074, 0x00);
28466                                           ! Debug: list int = const 0 (used reg = )
28467 8342           31C0                       xor	ax,ax
28468 8344           50                         push	ax
28469                                           ! Debug: list int = const $74 (used reg = )
28470 8345           B8                   0074  mov	ax,*$74
28471 8348           50                         push	ax
28472                                           ! Debug: list int = const $40 (used reg = )
28473 8349           B8                   0040  mov	ax,*$40
28474 834C           50                         push	ax
28475                                           ! Debug: func () void = write_byte+0 (used reg = )
28476 834D           E8         82CA            call	_write_byte
28477 8350           83C4                   06  add	sp,*6
28478                                           !BCC_EOS
28479                                           ! 4216   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
28480                                           ! 4217    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
28481                                           ! Debug: list * unsigned char = const $25A (used reg = )
28482 8353           B8                   025A  mov	ax,#$25A
28483 8356           50                         push	ax
28484                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28485 8357           FF76         FE            push	-2[bp]
28486                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28487 835A           E8         8297            call	_read_byte
28488 835D           83C4                   04  add	sp,*4
28489                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
28490 8360           84C0                       test	al,al
28491 8362           74           19            je  	.5E1
28492                       00008364            .5E2:
28493                                           ! Debug: expression subtree swapping
28494                                           ! Debug: list * unsigned char = const $25C (used reg = )
28495 8364           B8                   025C  mov	ax,#$25C
28496 8367           50                         push	ax
28497                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28498 8368           FF76         FE            push	-2[bp]
28499                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28500 836B           E8         8286            call	_read_byte
28501 836E           83C4                   04  add	sp,*4
28502 8371           50                         push	ax
28503                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
28504 8372           8A46         12            mov	al,$12[bp]
28505                                           ! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
28506 8375           3A46         CA            cmp	al,-$36[bp]
28507 8378           8D66         CC            lea	sp,-$34[bp]
28508 837B           74           06            je  	.5E0
28509                       0000837D            .5E1:
28510                                           ! 4218     ;
28511                                           !BCC_EOS
28512                                           ! 4219     goto int13_fail;
28513 837D           83C4                   00  add	sp,#..FFE2+$36
28514 8380           E9         0531            br 	.FFE2
28515                                           !BCC_EOS
28516                                           ! 4220     }
28517                                           ! 4221   switch (( AX >> 8 )) {
28518                       00008383            .5E0:
28519                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
28520 8383           8B46         16            mov	ax,$16[bp]
28521 8386           88E0                       mov	al,ah
28522 8388           30E4                       xor	ah,ah
28523 838A           E9         04AC            br 	.5E5
28524                                           ! 4222     case 0x00:
28525                                           ! 4223     case 0x09:
28526                       0000838D            .5E6:
28527                                           ! 4224     case 0x0c:
28528                       0000838D            .5E7:
28529                                           ! 4225     case 0x0d:
28530                       0000838D            .5E8:
28531                                           ! 4226     case 0x10:
28532                       0000838D            .5E9:
28533                                           ! 4227     case 0x11:
28534                       0000838D            .5EA:
28535                                           ! 4228     case 0x14:
28536                       0000838D            .5EB:
28537                                           ! 4229     case 0x16:
28538                       0000838D            .5EC:
28539                                           ! 4230       goto int13_suc
28540                       0000838D            .5ED:
28541                                           ! 4230 cess;
28542 838D           83C4                   00  add	sp,#..FFE0-..FFE1
28543 8390           E9         054E            br 	.FFE0
28544                                           !BCC_EOS
28545                                           ! 4231       break;
28546 8393           E9         051E            br 	.5E3
28547                                           !BCC_EOS
28548                                           ! 4232     case 0x03:
28549                                           ! 4233     case 0x05:
28550                       00008396            .5EE:
28551                                           ! 4234       AX = ((AX & 0x00ff) | ((0x03) << 8));
28552                       00008396            .5EF:
28553                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
28554 8396           8A46         16            mov	al,$16[bp]
28555                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
28556 8399           30E4                       xor	ah,ah
28557 839B           0D                   0300  or	ax,#$300
28558                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
28559 839E           8946         16            mov	$16[bp],ax
28560                                           !BCC_EOS
28561                                           ! 4235       goto int13_fail_noah;
28562 83A1           83C4                   00  add	sp,#..FFDF-..FFE1
28563 83A4           E9         0518            br 	.FFDF
28564                                           !BCC_EOS
28565                                           ! 4236       break;
28566 83A7           E9         050A            br 	.5E3
28567                                           !BCC_EOS
28568                                           ! 4237     case 0x01:
28569                                           ! 4238       status=read_byte(0x0040, 0x0074);
28570                       000083AA            .5F0:
28571                                           ! Debug: list int = const $74 (used reg = )
28572 83AA           B8                   0074  mov	ax,*$74
28573 83AD           50                         push	ax
28574                                           ! Debug: list int = const $40 (used reg = )
28575 83AE           B8                   0040  mov	ax,*$40
28576 83B1           50                         push	ax
28577                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28578 83B2           E8         823F            call	_read_byte
28579 83B5           83C4                   04  add	sp,*4
28580                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
28581 83B8           8846         FC            mov	-4[bp],al
28582                                           !BCC_EOS
28583                                           ! 4239       AX = ((AX & 0x00ff) | ((status) << 8));
28584                                           ! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
28585 83BB           8A46         FC            mov	al,-4[bp]
28586 83BE           30E4                       xor	ah,ah
28587 83C0           88C4                       mov	ah,al
28588 83C2           30C0                       xor	al,al
28589 83C4           50                         push	ax
28590                                           ! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
28591 83C5           8A46         16            mov	al,$16[bp]
28592                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
28593 83C8           30E4                       xor	ah,ah
28594 83CA           0B46         CA            or	ax,0+..FFE1[bp]
28595 83CD           44                         inc	sp
28596 83CE           44                         inc	sp
28597                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
28598 83CF           8946         16            mov	$16[bp],ax
28599                                           !BCC_EOS
28600                                           ! 4240       write_byte(0x0040, 0x0074, 0);
28601                                           ! Debug: list int = const 0 (used reg = )
28602 83D2           31C0                       xor	ax,ax
28603 83D4           50                         push	ax
28604                                           ! Debug: list int = const $74 (used reg = )
28605 83D5           B8                   0074  mov	ax,*$74
28606 83D8           50                         push	ax
28607                                           ! Debug: list int = const $40 (used reg = )
28608 83D9           B8                   0040  mov	ax,*$40
28609 83DC           50                         push	ax
28610                                           ! Debug: func () void = write_byte+0 (used reg = )
28611 83DD           E8         823A            call	_write_byte
28612 83E0           83C4                   06  add	sp,*6
28613                                           !BCC_EOS
28614                                           ! 4241       if (status) goto int13_fail_nostatus;
28615 83E3           8A46         FC            mov	al,-4[bp]
28616 83E6           84C0                       test	al,al
28617 83E8           74           08            je  	.5F1
28618                       000083EA            .5F2:
28619 83EA           83C4                   00  add	sp,#..FFDE-..FFE1
28620 83ED           E9         04E5            br 	.FFDE
28621                                           !BCC_EOS
28622                                           ! 4242       else goto int13_success_noah;
28623 83F0           EB           06            jmp .5F3
28624                       000083F2            .5F1:
28625 83F2           83C4                   00  add	sp,#..FFDD-..FFE1
28626 83F5           E9         04F3            br 	.FFDD
28627                                           !BCC_EOS
28628                                           ! 4243       break;
28629                       000083F8            .5F3:
28630 83F8           E9         04B9            br 	.5E3
28631                                           !BCC_EOS
28632                                           ! 4244     case 0x02:
28633                                           ! 4245     case 0x04:
28634                       000083FB            .5F4:
28635                                           ! 4246       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
28636                       000083FB            .5F5:
28637                                           ! Debug: list * unsigned short = const $26E (used reg = )
28638 83FB           B8                   026E  mov	ax,#$26E
28639 83FE           50                         push	ax
28640                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28641 83FF           FF76         FE            push	-2[bp]
28642                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28643 8402           E8         8202            call	_read_word
28644 8405           83C4                   04  add	sp,*4
28645                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
28646 8408           8946         F8            mov	-8[bp],ax
28647                                           !BCC_EOS
28648                                           ! 4247       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
28649                                           ! Debug: list * unsigned short = const $26C (used reg = )
28650 840B           B8                   026C  mov	ax,#$26C
28651 840E           50                         push	ax
28652                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28653 840F           FF76         FE            push	-2[bp]
28654                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28655 8412           E8         81F2            call	_read_word
28656 8415           83C4                   04  add	sp,*4
28657                                           ! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
28658 8418           8946         F6            mov	-$A[bp],ax
28659                                           !BCC_EOS
28660                                           ! 4248       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
28661                                           ! Debug: list * unsigned short = const $26A (used reg = )
28662 841B           B8                   026A  mov	ax,#$26A
28663 841E           50                         push	ax
28664                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28665 841F           FF76         FE            push	-2[bp]
28666                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28667 8422           E8         81E2            call	_read_word
28668 8425           83C4                   04  add	sp,*4
28669                                           ! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
28670 8428           8946         FA            mov	-6[bp],ax
28671                                           !BCC_EOS
28672                                           ! 4249       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
28673                                           ! Debug: list * unsigned long = const $260 (used reg = )
28674 842B           B8                   0260  mov	ax,#$260
28675 842E           50                         push	ax
28676                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28677 842F           FF76         FE            push	-2[bp]
28678                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
28679 8432           E8         7C4E            call	_read_dword
28680 8435           89D3                       mov	bx,dx
28681 8437           83C4                   04  add	sp,*4
28682                                           ! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
28683 843A           8946         E6            mov	-$1A[bp],ax
28684 843D           895E         E8            mov	-$18[bp],bx
28685                                           !BCC_EOS
28686                                           ! 4250       sector = ( CX & 0x00ff ) & 0x003f;
28687                                           ! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
28688 8440           8A46         14            mov	al,$14[bp]
28689                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
28690 8443           24                     3F  and	al,*$3F
28691                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
28692 8445           30E4                       xor	ah,ah
28693 8447           8946         F2            mov	-$E[bp],ax
28694                                           !BCC_EOS
28695                                           ! 4251       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
28696                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
28697 844A           8B46         14            mov	ax,$14[bp]
28698 844D           88E0                       mov	al,ah
28699 844F           30E4                       xor	ah,ah
28700 8451           50                         push	ax
28701                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
28702 8452           8A46         14            mov	al,$14[bp]
28703                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
28704 8455           24                     C0  and	al,#$C0
28705                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
28706 8457           30E4                       xor	ah,ah
28707 8459           D1E0                       shl	ax,*1
28708 845B           D1E0                       shl	ax,*1
28709                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
28710 845D           0B46         CA            or	ax,0+..FFE1[bp]
28711 8460           44                         inc	sp
28712 8461           44                         inc	sp
28713                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
28714 8462           8946         F0            mov	-$10[bp],ax
28715                                           !BCC_EOS
28716                                           ! 4252       head = ( DX >> 8 );
28717                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
28718 8465           8B46         12            mov	ax,$12[bp]
28719 8468           88E0                       mov	al,ah
28720 846A           30E4                       xor	ah,ah
28721                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
28722 846C           8946         F4            mov	-$C[bp],ax
28723                                           !BCC_EOS
28724                                           ! 4253       nbsectors = ( AX & 0x00ff );
28725                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
28726 846F           8A46         16            mov	al,$16[bp]
28727                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
28728 8472           30E4                       xor	ah,ah
28729 8474           8946         EE            mov	-$12[bp],ax
28730                                           !BCC_EOS
28731                                           ! 4254       segment = ES;
28732                                           ! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
28733 8477           8B46         06            mov	ax,6[bp]
28734 847A           8946         DA            mov	-$26[bp],ax
28735                                           !BCC_EOS
28736                                           ! 4255       offset = BX;
28737                                           ! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
28738 847D           8B46         10            mov	ax,$10[bp]
28739 8480           8946         D8            mov	-$28[bp],ax
28740                                           !BCC_EOS
28741                                           ! 4256       if(nbsectors==0) goto int13_success;
28742                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
28743 8483           8B46         EE            mov	ax,-$12[bp]
28744 8486           85C0                       test	ax,ax
28745 8488           75           06            jne 	.5F6
28746                       0000848A            .5F7:
28747 848A           83C4                   00  add	sp,#..FFE0-..FFE1
28748 848D           E9         0451            br 	.FFE0
28749                                           !BCC_EOS
28750                                           ! 4257       if ((sector > vspt)
28751                       00008490            .5F6:
28752                                           ! 4258        || (cylinder >= vcylinders)
28753                                           ! 4259        || (head >= vheads)) {
28754                                           ! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
28755 8490           8B46         F2            mov	ax,-$E[bp]
28756 8493           3B46         F8            cmp	ax,-8[bp]
28757 8496           77           10            ja  	.5F9
28758                       00008498            .5FB:
28759                                           ! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
28760 8498           8B46         F0            mov	ax,-$10[bp]
28761 849B           3B46         F6            cmp	ax,-$A[bp]
28762 849E           73           08            jae 	.5F9
28763                       000084A0            .5FA:
28764                                           ! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
28765 84A0           8B46         F4            mov	ax,-$C[bp]
28766 84A3           3B46         FA            cmp	ax,-6[bp]
28767 84A6           72           06            jb  	.5F8
28768                       000084A8            .5F9:
28769                                           ! 4260         goto int13_fail;
28770 84A8           83C4                   00  add	sp,#..FFE2-..FFE1
28771 84AB           E9         0406            br 	.FFE2
28772                                           !BCC_EOS
28773                                           ! 4261         }
28774                                           ! 4262       if (( AX >> 8 ) == 0x04) goto int13_success;
28775                       000084AE            .5F8:
28776                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
28777 84AE           8B46         16            mov	ax,$16[bp]
28778 84B1           88E0                       mov	al,ah
28779 84B3           30E4                       xor	ah,ah
28780                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
28781 84B5           3D                   0004  cmp	ax,*4
28782 84B8           75           06            jne 	.5FC
28783                       000084BA            .5FD:
28784 84BA           83C4                   00  add	sp,#..FFE0-..FFE1
28785 84BD           E9         0421            br 	.FFE0
28786                                           !BCC_EOS
28787                                           ! 4263       segment = ES+(BX / 16);
28788                       000084C0            .5FC:
28789                                           ! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
28790 84C0           8B46         10            mov	ax,$10[bp]
28791 84C3           B1                     04  mov	cl,*4
28792 84C5           D3E8                       shr	ax,cl
28793                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
28794                                           ! Debug: expression subtree swapping
28795 84C7           0346         06            add	ax,6[bp]
28796                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
28797 84CA           8946         DA            mov	-$26[bp],ax
28798                                           !BCC_EOS
28799                                           ! 4264       offset = BX % 16;
28800                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
28801 84CD           8B46         10            mov	ax,$10[bp]
28802 84D0           24                     0F  and	al,*$F
28803                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
28804 84D2           30E4                       xor	ah,ah
28805 84D4           8946         D8            mov	-$28[bp],ax
28806                                           !BCC_EOS
28807                                           ! 4265       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
28808                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
28809 84D7           8B46         F2            mov	ax,-$E[bp]
28810                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
28811 84DA           48                         dec	ax
28812 84DB           31DB                       xor	bx,bx
28813 84DD           53                         push	bx
28814 84DE           50                         push	ax
28815                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
28816 84DF           8B46         F8            mov	ax,-8[bp]
28817 84E2           31DB                       xor	bx,bx
28818 84E4           53                         push	bx
28819 84E5           50                         push	ax
28820                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
28821 84E6           8B46         F4            mov	ax,-$C[bp]
28822 84E9           31DB                       xor	bx,bx
28823 84EB           53                         push	bx
28824 84EC           50                         push	ax
28825                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
28826 84ED           8B46         FA            mov	ax,-6[bp]
28827 84F0           31DB                       xor	bx,bx
28828 84F2           53                         push	bx
28829 84F3           50                         push	ax
28830                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
28831 84F4           8B46         F0            mov	ax,-$10[bp]
28832 84F7           31DB                       xor	bx,bx
28833                                           ! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
28834 84F9           8D7E         BC            lea	di,-$E+..FFE1[bp]
28835 84FC           E8         7BEA            call	lmulul
28836 84FF           83C4                   04  add	sp,*4
28837                                           ! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
28838 8502           8D7E         C0            lea	di,-$A+..FFE1[bp]
28839 8505           E8         7BBB            call	laddul
28840 8508           83C4                   04  add	sp,*4
28841                                           ! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
28842 850B           8D7E         C4            lea	di,-6+..FFE1[bp]
28843 850E           E8         7BD8            call	lmulul
28844 8511           83C4                   04  add	sp,*4
28845                                           ! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
28846 8514           8D7E         C8            lea	di,-2+..FFE1[bp]
28847 8517           E8         7BA9            call	laddul
28848 851A           83C4                   04  add	sp,*4
28849                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
28850 851D           8946         EA            mov	-$16[bp],ax
28851 8520           895E         EC            mov	-$14[bp],bx
28852                                           !BCC_EOS
28853                                           ! 4266       AX = ((AX & 0xff00) | (nbsectors));
28854                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
28855 8523           8B46         16            mov	ax,$16[bp]
28856 8526           30C0                       xor	al,al
28857                                           ! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
28858 8528           0B46         EE            or	ax,-$12[bp]
28859                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
28860 852B           8946         16            mov	$16[bp],ax
28861                                           !BCC_EOS
28862                                           ! 4267       slba = (Bit32u)vlba/4;
28863                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
28864 852E           B8                   0004  mov	ax,*4
28865 8531           31DB                       xor	bx,bx
28866 8533           53                         push	bx
28867 8534           50                         push	ax
28868 8535           8B46         EA            mov	ax,-$16[bp]
28869 8538           8B5E         EC            mov	bx,-$14[bp]
28870 853B           8D7E         C8            lea	di,-2+..FFE1[bp]
28871 853E           E8         7C2D            call	ldivul
28872 8541           83C4                   04  add	sp,*4
28873                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
28874 8544           8946         E2            mov	-$1E[bp],ax
28875 8547           895E         E4            mov	-$1C[bp],bx
28876                                           !BCC_EOS
28877                                           ! 4268       before= (Bit16u)vlba%4;
28878                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
28879 854A           8B46         EA            mov	ax,-$16[bp]
28880 854D           24                     03  and	al,*3
28881                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
28882 854F           30E4                       xor	ah,ah
28883 8551           8946         DC            mov	-$24[bp],ax
28884                                           !BCC_EOS
28885                                           ! 4269       elba = (Bit32u)(vlba+nbsectors-1)/4;
28886                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
28887 8554           8B46         EE            mov	ax,-$12[bp]
28888 8557           31DB                       xor	bx,bx
28889                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
28890                                           ! Debug: expression subtree swapping
28891 8559           8D7E         EA            lea	di,-$16[bp]
28892 855C           E8         7B64            call	laddul
28893                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
28894 855F           53                         push	bx
28895 8560           50                         push	ax
28896 8561           B8                   0001  mov	ax,*1
28897 8564           31DB                       xor	bx,bx
28898 8566           53                         push	bx
28899 8567           50                         push	ax
28900 8568           8B46         C8            mov	ax,-2+..FFE1[bp]
28901 856B           8B5E         CA            mov	bx,0+..FFE1[bp]
28902 856E           8D7E         C4            lea	di,-6+..FFE1[bp]
28903 8571           E8         7B6D            call	lsubul
28904 8574           83C4                   08  add	sp,*8
28905                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
28906                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
28907 8577           53                         push	bx
28908 8578           50                         push	ax
28909 8579           B8                   0004  mov	ax,*4
28910 857C           31DB                       xor	bx,bx
28911 857E           53                         push	bx
28912 857F           50                         push	ax
28913 8580           8B46         C8            mov	ax,-2+..FFE1[bp]
28914 8583           8B5E         CA            mov	bx,0+..FFE1[bp]
28915 8586           8D7E         C4            lea	di,-6+..FFE1[bp]
28916 8589           E8         7BE2            call	ldivul
28917 858C           83C4                   08  add	sp,*8
28918                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
28919 858F           8946         DE            mov	-$22[bp],ax
28920 8592           895E         E0            mov	-$20[bp],bx
28921                                           !BCC_EOS
28922                                           ! 4270       memsetb(get_SS(),atacmd,0,12);
28923                                           ! Debug: list int = const $C (used reg = )
28924 8595           B8                   000C  mov	ax,*$C
28925 8598           50                         push	ax
28926                                           ! Debug: list int = const 0 (used reg = )
28927 8599           31C0                       xor	ax,ax
28928 859B           50                         push	ax
28929                                           ! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
28930 859C           8D5E         CC            lea	bx,-$34[bp]
28931 859F           53                         push	bx
28932                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
28933 85A0           E8         80AA            call	_get_SS
28934                                           ! Debug: list unsigned short = ax+0 (used reg = )
28935 85A3           50                         push	ax
28936                                           ! Debug: func () void = memsetb+0 (used reg = )
28937 85A4           E8         7A59            call	_memsetb
28938 85A7           83C4                   08  add	sp,*8
28939                                           !BCC_EOS
28940                                           ! 4271       atacmd[0]=0x28;
28941                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
28942 85AA           B0                     28  mov	al,*$28
28943 85AC           8846         CC            mov	-$34[bp],al
28944                                           !BCC_EOS
28945                                           ! 4272       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
28946                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
28947 85AF           8B46         DE            mov	ax,-$22[bp]
28948 85B2           8B5E         E0            mov	bx,-$20[bp]
28949 85B5           8D7E         E2            lea	di,-$1E[bp]
28950 85B8           E8         7B26            call	lsubul
28951                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
28952 85BB           53                         push	bx
28953 85BC           50                         push	ax
28954 85BD           B8                   0001  mov	ax,*1
28955 85C0           31DB                       xor	bx,bx
28956 85C2           53                         push	bx
28957 85C3           50                         push	ax
28958 85C4           8B46         C8            mov	ax,-2+..FFE1[bp]
28959 85C7           8B5E         CA            mov	bx,0+..FFE1[bp]
28960 85CA           8D7E         C4            lea	di,-6+..FFE1[bp]
28961 85CD           E8         7AF3            call	laddul
28962 85D0           83C4                   08  add	sp,*8
28963                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
28964                                           ! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
28965 85D3           30C0                       xor	al,al
28966                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
28967 85D5           88E0                       mov	al,ah
28968 85D7           30E4                       xor	ah,ah
28969                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
28970 85D9           8846         D3            mov	-$2D[bp],al
28971                                           !BCC_EOS
28972                                           ! 4273       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
28973                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
28974 85DC           8B46         DE            mov	ax,-$22[bp]
28975 85DF           8B5E         E0            mov	bx,-$20[bp]
28976 85E2           8D7E         E2            lea	di,-$1E[bp]
28977 85E5           E8         7AF9            call	lsubul
28978                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
28979 85E8           53                         push	bx
28980 85E9           50                         push	ax
28981 85EA           B8                   0001  mov	ax,*1
28982 85ED           31DB                       xor	bx,bx
28983 85EF           53                         push	bx
28984 85F0           50                         push	ax
28985 85F1           8B46         C8            mov	ax,-2+..FFE1[bp]
28986 85F4           8B5E         CA            mov	bx,0+..FFE1[bp]
28987 85F7           8D7E         C4            lea	di,-6+..FFE1[bp]
28988 85FA           E8         7AC6            call	laddul
28989 85FD           83C4                   08  add	sp,*8
28990                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
28991                                           ! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
28992                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
28993 8600           8846         D4            mov	-$2C[bp],al
28994                                           !BCC_EOS
28995                                           ! 4274       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
28996                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
28997 8603           8B46         E6            mov	ax,-$1A[bp]
28998 8606           8B5E         E8            mov	bx,-$18[bp]
28999 8609           8D7E         E2            lea	di,-$1E[bp]
29000 860C           E8         7AB4            call	laddul
29001                                           ! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
29002 860F           53                         push	bx
29003 8610           50                         push	ax
29004 8611           31C0                       xor	ax,ax
29005 8613           BB                   FF00  mov	bx,#$FF00
29006 8616           53                         push	bx
29007 8617           50                         push	ax
29008 8618           8B46         C8            mov	ax,-2+..FFE1[bp]
29009 861B           8B5E         CA            mov	bx,0+..FFE1[bp]
29010 861E           8D7E         C4            lea	di,-6+..FFE1[bp]
29011 8621           E8         7A97            call	landul
29012 8624           83C4                   08  add	sp,*8
29013                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
29014 8627           93                         xchg	bx,ax
29015 8628           88E0                       mov	al,ah
29016 862A           30E4                       xor	ah,ah
29017 862C           31DB                       xor	bx,bx
29018                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
29019 862E           8846         CE            mov	-$32[bp],al
29020                                           !BCC_EOS
29021                                           ! 4275       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
29022                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29023 8631           8B46         E6            mov	ax,-$1A[bp]
29024 8634           8B5E         E8            mov	bx,-$18[bp]
29025 8637           8D7E         E2            lea	di,-$1E[bp]
29026 863A           E8         7A86            call	laddul
29027                                           ! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
29028 863D           53                         push	bx
29029 863E           50                         push	ax
29030 863F           31C0                       xor	ax,ax
29031 8641           BB                   00FF  mov	bx,#$FF
29032 8644           53                         push	bx
29033 8645           50                         push	ax
29034 8646           8B46         C8            mov	ax,-2+..FFE1[bp]
29035 8649           8B5E         CA            mov	bx,0+..FFE1[bp]
29036 864C           8D7E         C4            lea	di,-6+..FFE1[bp]
29037 864F           E8         7A69            call	landul
29038 8652           83C4                   08  add	sp,*8
29039                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
29040 8655           93                         xchg	bx,ax
29041 8656           31DB                       xor	bx,bx
29042                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
29043 8658           8846         CF            mov	-$31[bp],al
29044                                           !BCC_EOS
29045                                           ! 4276       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
29046                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29047 865B           8B46         E6            mov	ax,-$1A[bp]
29048 865E           8B5E         E8            mov	bx,-$18[bp]
29049 8661           8D7E         E2            lea	di,-$1E[bp]
29050 8664           E8         7A5C            call	laddul
29051                                           ! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
29052 8667           53                         push	bx
29053 8668           50                         push	ax
29054 8669           B8                   FF00  mov	ax,#$FF00
29055 866C           31DB                       xor	bx,bx
29056 866E           53                         push	bx
29057 866F           50                         push	ax
29058 8670           8B46         C8            mov	ax,-2+..FFE1[bp]
29059 8673           8B5E         CA            mov	bx,0+..FFE1[bp]
29060 8676           8D7E         C4            lea	di,-6+..FFE1[bp]
29061 8679           E8         7A3F            call	landul
29062 867C           83C4                   08  add	sp,*8
29063                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
29064 867F           88E0                       mov	al,ah
29065 8681           88DC                       mov	ah,bl
29066 8683           88FB                       mov	bl,bh
29067 8685           28FF                       sub	bh,bh
29068                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
29069 8687           8846         D0            mov	-$30[bp],al
29070                                           !BCC_EOS
29071                                           ! 4277       atacmd[5]=(ilba+slba & 0x000000ff);
29072                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29073 868A           8B46         E6            mov	ax,-$1A[bp]
29074 868D           8B5E         E8            mov	bx,-$18[bp]
29075 8690           8D7E         E2            lea	di,-$1E[bp]
29076 8693           E8         7A2D            call	laddul
29077                                           ! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
29078 8696           53                         push	bx
29079 8697           50                         push	ax
29080 8698           B8                   00FF  mov	ax,#$FF
29081 869B           31DB                       xor	bx,bx
29082 869D           53                         push	bx
29083 869E           50                         push	ax
29084 869F           8B46         C8            mov	ax,-2+..FFE1[bp]
29085 86A2           8B5E         CA            mov	bx,0+..FFE1[bp]
29086 86A5           8D7E         C4            lea	di,-6+..FFE1[bp]
29087 86A8           E8         7A10            call	landul
29088 86AB           83C4                   08  add	sp,*8
29089                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
29090 86AE           8846         D1            mov	-$2F[bp],al
29091                                           !BCC_EOS
29092                                           ! 4278       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
29093                                           ! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
29094 86B1           FF76         D8            push	-$28[bp]
29095                                           ! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
29096 86B4           FF76         DA            push	-$26[bp]
29097                                           ! Debug: list int = const 1 (used reg = )
29098 86B7           B8                   0001  mov	ax,*1
29099 86BA           50                         push	ax
29100                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
29101 86BB           8B46         EE            mov	ax,-$12[bp]
29102 86BE           31DB                       xor	bx,bx
29103                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
29104 86C0           53                         push	bx
29105 86C1           50                         push	ax
29106 86C2           B8                   0200  mov	ax,#$200
29107 86C5           31DB                       xor	bx,bx
29108 86C7           53                         push	bx
29109 86C8           50                         push	ax
29110 86C9           8B46         C2            mov	ax,-8+..FFE1[bp]
29111 86CC           8B5E         C4            mov	bx,-6+..FFE1[bp]
29112 86CF           8D7E         BE            lea	di,-$C+..FFE1[bp]
29113 86D2           E8         7A14            call	lmulul
29114 86D5           83C4                   08  add	sp,*8
29115                                           ! Debug: list unsigned long = bx+0 (used reg = )
29116 86D8           53                         push	bx
29117 86D9           50                         push	ax
29118                                           ! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
29119 86DA           8B46         DC            mov	ax,-$24[bp]
29120 86DD           B9                   0200  mov	cx,#$200
29121 86E0           F7E9                       imul	cx
29122                                           ! Debug: list unsigned int = ax+0 (used reg = )
29123 86E2           50                         push	ax
29124                                           ! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
29125 86E3           8D5E         CC            lea	bx,-$34[bp]
29126 86E6           53                         push	bx
29127                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29128 86E7           E8         7F63            call	_get_SS
29129                                           ! Debug: list unsigned short = ax+0 (used reg = )
29130 86EA           50                         push	ax
29131                                           ! Debug: list int = const $C (used reg = )
29132 86EB           B8                   000C  mov	ax,*$C
29133 86EE           50                         push	ax
29134                                           ! Debug: list unsigned char device = [S+$48-5] (used reg = )
29135 86EF           8A46         FD            mov	al,-3[bp]
29136 86F2           30E4                       xor	ah,ah
29137 86F4           50                         push	ax
29138                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
29139 86F5           E8         ADE3            call	_ata_cmd_packet
29140 86F8           83C4                   14  add	sp,*$14
29141                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
29142 86FB           8846         FC            mov	-4[bp],al
29143                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29144 86FE           84C0                       test	al,al
29145 8700           74           1B            je  	.5FE
29146                       00008702            .5FF:
29147                                           ! 4279         ;
29148                                           !BCC_EOS
29149                                           ! 4280         AX = ((AX & 0x00ff) | ((0x02) << 8));
29150                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29151 8702           8A46         16            mov	al,$16[bp]
29152                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
29153 8705           30E4                       xor	ah,ah
29154 8707           0D                   0200  or	ax,#$200
29155                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29156 870A           8946         16            mov	$16[bp],ax
29157                                           !BCC_EOS
29158                                           ! 4281         AX = ((AX & 0xff00) | (0));
29159                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29160 870D           8B46         16            mov	ax,$16[bp]
29161 8710           30C0                       xor	al,al
29162                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29163 8712           0C                     00  or	al,*0
29164                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29165 8714           8946         16            mov	$16[bp],ax
29166                                           !BCC_EOS
29167                                           ! 4282         goto int13_fail_noah;
29168 8717           83C4                   00  add	sp,#..FFDF-..FFE1
29169 871A           E9         01A2            br 	.FFDF
29170                                           !BCC_EOS
29171                                           ! 4283         }
29172                                           ! 4284       goto int13_succes
29173                       0000871D            .5FE:
29174                                           ! 4284 s;
29175 871D           83C4                   00  add	sp,#..FFE0-..FFE1
29176 8720           E9         01BE            br 	.FFE0
29177                                           !BCC_EOS
29178                                           ! 4285       break;
29179 8723           E9         018E            br 	.5E3
29180                                           !BCC_EOS
29181                                           ! 4286     case 0x08:
29182                                           ! 4287       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
29183                       00008726            .600:
29184                                           ! Debug: list * unsigned short = const $26E (used reg = )
29185 8726           B8                   026E  mov	ax,#$26E
29186 8729           50                         push	ax
29187                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29188 872A           FF76         FE            push	-2[bp]
29189                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29190 872D           E8         7ED7            call	_read_word
29191 8730           83C4                   04  add	sp,*4
29192                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
29193 8733           8946         F8            mov	-8[bp],ax
29194                                           !BCC_EOS
29195                                           ! 4288       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
29196                                           ! Debug: list * unsigned short = const $26C (used reg = )
29197 8736           B8                   026C  mov	ax,#$26C
29198 8739           50                         push	ax
29199                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29200 873A           FF76         FE            push	-2[bp]
29201                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29202 873D           E8         7EC7            call	_read_word
29203 8740           83C4                   04  add	sp,*4
29204                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
29205                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
29206 8743           48                         dec	ax
29207 8744           8946         F6            mov	-$A[bp],ax
29208                                           !BCC_EOS
29209                                           ! 4289       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
29210                                           ! Debug: list * unsigned short = const $26A (used reg = )
29211 8747           B8                   026A  mov	ax,#$26A
29212 874A           50                         push	ax
29213                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29214 874B           FF76         FE            push	-2[bp]
29215                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29216 874E           E8         7EB6            call	_read_word
29217 8751           83C4                   04  add	sp,*4
29218                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
29219                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
29220 8754           48                         dec	ax
29221 8755           8946         FA            mov	-6[bp],ax
29222                                           !BCC_EOS
29223                                           ! 4290       AX = ((AX & 0xff00) | (0x00));
29224                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29225 8758           8B46         16            mov	ax,$16[bp]
29226 875B           30C0                       xor	al,al
29227                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29228 875D           0C                     00  or	al,*0
29229                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29230 875F           8946         16            mov	$16[bp],ax
29231                                           !BCC_EOS
29232                                           ! 4291       BX = ((BX & 0xff00) | (0x00));
29233                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29234 8762           8B46         10            mov	ax,$10[bp]
29235 8765           30C0                       xor	al,al
29236                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29237 8767           0C                     00  or	al,*0
29238                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29239 8769           8946         10            mov	$10[bp],ax
29240                                           !BCC_EOS
29241                                           ! 4292       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
29242                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
29243 876C           8A46         F6            mov	al,-$A[bp]
29244                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
29245 876F           30E4                       xor	ah,ah
29246 8771           88C4                       mov	ah,al
29247 8773           30C0                       xor	al,al
29248 8775           50                         push	ax
29249                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
29250 8776           8A46         14            mov	al,$14[bp]
29251                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29252 8779           30E4                       xor	ah,ah
29253 877B           0B46         CA            or	ax,0+..FFE1[bp]
29254 877E           44                         inc	sp
29255 877F           44                         inc	sp
29256                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
29257 8780           8946         14            mov	$14[bp],ax
29258                                           !BCC_EOS
29259                                           ! 4293       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
29260                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
29261 8783           8A46         F8            mov	al,-8[bp]
29262 8786           24                     3F  and	al,*$3F
29263 8788           50                         push	ax
29264                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
29265 8789           8B46         F6            mov	ax,-$A[bp]
29266 878C           D1E8                       shr	ax,*1
29267 878E           D1E8                       shr	ax,*1
29268                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
29269 8790           24                     C0  and	al,#$C0
29270                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29271 8792           0A46         CA            or	al,0+..FFE1[bp]
29272 8795           44                         inc	sp
29273 8796           44                         inc	sp
29274 8797           50                         push	ax
29275                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
29276 8798           8B46         14            mov	ax,$14[bp]
29277 879B           30C0                       xor	al,al
29278                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
29279 879D           0A46         CA            or	al,0+..FFE1[bp]
29280 87A0           44                         inc	sp
29281 87A1           44                         inc	sp
29282                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
29283 87A2           8946         14            mov	$14[bp],ax
29284                                           !BCC_EOS
29285                                           ! 4294       DX = ((DX & 0x00ff) | ((vheads) << 8));
29286                                           ! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
29287 87A5           8B46         FA            mov	ax,-6[bp]
29288 87A8           88C4                       mov	ah,al
29289 87AA           30C0                       xor	al,al
29290 87AC           50                         push	ax
29291                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
29292 87AD           8A46         12            mov	al,$12[bp]
29293                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29294 87B0           30E4                       xor	ah,ah
29295 87B2           0B46         CA            or	ax,0+..FFE1[bp]
29296 87B5           44                         inc	sp
29297 87B6           44                         inc	sp
29298                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
29299 87B7           8946         12            mov	$12[bp],ax
29300                                           !BCC_EOS
29301                                           ! 4295       DX = ((DX & 0xff00) | (0x02));
29302                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
29303 87BA           8B46         12            mov	ax,$12[bp]
29304 87BD           30C0                       xor	al,al
29305                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
29306 87BF           0C                     02  or	al,*2
29307                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
29308 87C1           8946         12            mov	$12[bp],ax
29309                                           !BCC_EOS
29310                                           ! 4296       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
29311                                           ! Debug: list * unsigned char = const $25B (used reg = )
29312 87C4           B8                   025B  mov	ax,#$25B
29313 87C7           50                         push	ax
29314                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29315 87C8           FF76         FE            push	-2[bp]
29316                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29317 87CB           E8         7E26            call	_read_byte
29318 87CE           83C4                   04  add	sp,*4
29319 87D1           EB           26            jmp .603
29320                                           ! 4297         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
29321                       000087D3            .604:
29322                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29323 87D3           8B46         10            mov	ax,$10[bp]
29324 87D6           30C0                       xor	al,al
29325                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
29326 87D8           0C                     02  or	al,*2
29327                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29328 87DA           8946         10            mov	$10[bp],ax
29329                                           !BCC_EOS
29330 87DD           EB           26            jmp .601
29331                                           !BCC_EOS
29332                                           ! 4298         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
29333                       000087DF            .605:
29334                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29335 87DF           8B46         10            mov	ax,$10[bp]
29336 87E2           30C0                       xor	al,al
29337                                           ! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
29338 87E4           0C                     04  or	al,*4
29339                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29340 87E6           8946         10            mov	$10[bp],ax
29341                                           !BCC_EOS
29342 87E9           EB           1A            jmp .601
29343                                           !BCC_EOS
29344                                           ! 4299         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
29345                       000087EB            .606:
29346                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29347 87EB           8B46         10            mov	ax,$10[bp]
29348 87EE           30C0                       xor	al,al
29349                                           ! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
29350 87F0           0C                     06  or	al,*6
29351                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29352 87F2           8946         10            mov	$10[bp],ax
29353                                           !BCC_EOS
29354 87F5           EB           0E            jmp .601
29355                                           !BCC_EOS
29356                                           ! 4300         }
29357                                           ! 4301 #asm
29358 87F7           EB           0C            jmp .601
29359                       000087F9            .603:
29360 87F9           2C                     01  sub	al,*1
29361 87FB           74           D6            je 	.604
29362 87FD           2C                     01  sub	al,*1
29363 87FF           74           DE            je 	.605
29364 8801           2C                     01  sub	al,*1
29365 8803           74           E6            je 	.606
29366                       00008805            .601:
29367                                           !BCC_EOS
29368                                           !BCC_ASM
29369                       00000040            _int13_cdemu.BP	set	$40
29370                       0000000C            .int13_cdemu.BP	set	$C
29371                       0000004E            _int13_cdemu.CS	set	$4E
29372                       0000001A            .int13_cdemu.CS	set	$1A
29373                       00000022            _int13_cdemu.nbsectors	set	$22
29374                       FFFFFFEE            .int13_cdemu.nbsectors	set	-$12
29375                       00000048            _int13_cdemu.CX	set	$48
29376                       00000014            .int13_cdemu.CX	set	$14
29377                       00000012            _int13_cdemu.elba	set	$12
29378                       FFFFFFDE            .int13_cdemu.elba	set	-$22
29379                       0000000E            _int13_cdemu.segment	set	$E
29380                       FFFFFFDA            .int13_cdemu.segment	set	-$26
29381                       0000003C            _int13_cdemu.DI	set	$3C
29382                       00000008            .int13_cdemu.DI	set	8
29383                       00000050            _int13_cdemu.FLAGS	set	$50
29384                       0000001C            .int13_cdemu.FLAGS	set	$1C
29385                       0000002A            _int13_cdemu.vcylinders	set	$2A
29386                       FFFFFFF6            .int13_cdemu.vcylinders	set	-$A
29387                       00000026            _int13_cdemu.sector	set	$26
29388                       FFFFFFF2            .int13_cdemu.sector	set	-$E
29389                       00000038            _int13_cdemu.DS	set	$38
29390                       00000004            .int13_cdemu.DS	set	4
29391                       00000028            _int13_cdemu.head	set	$28
29392                       FFFFFFF4            .int13_cdemu.head	set	-$C
29393                       00000024            _int13_cdemu.cylinder	set	$24
29394                       FFFFFFF0            .int13_cdemu.cylinder	set	-$10
29395                       00000046            _int13_cdemu.DX	set	$46
29396                       00000012            .int13_cdemu.DX	set	$12
29397                       00000031            _int13_cdemu.device	set	$31
29398                       FFFFFFFD            .int13_cdemu.device	set	-3
29399                       0000003A            _int13_cdemu.ES	set	$3A
29400                       00000006            .int13_cdemu.ES	set	6
29401                       0000002C            _int13_cdemu.vspt	set	$2C
29402                       FFFFFFF8            .int13_cdemu.vspt	set	-8
29403                       0000001E            _int13_cdemu.vlba	set	$1E
29404                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
29405                       00000032            _int13_cdemu.ebda_seg	set	$32
29406                       FFFFFFFE            .int13_cdemu.ebda_seg	set	-2
29407                       0000003E            _int13_cdemu.SI	set	$3E
29408                       0000000A            .int13_cdemu.SI	set	$A
29409                       0000004C            _int13_cdemu.IP	set	$4C
29410                       00000018            .int13_cdemu.IP	set	$18
29411                       00000030            _int13_cdemu.status	set	$30
29412                       FFFFFFFC            .int13_cdemu.status	set	-4
29413                       00000000            _int13_cdemu.atacmd	set	0
29414                       FFFFFFCC            .int13_cdemu.atacmd	set	-$34
29415                       0000004A            _int13_cdemu.AX	set	$4A
29416                       00000016            .int13_cdemu.AX	set	$16
29417                       0000001A            _int13_cdemu.ilba	set	$1A
29418                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
29419                       00000010            _int13_cdemu.before	set	$10
29420                       FFFFFFDC            .int13_cdemu.before	set	-$24
29421                       0000000C            _int13_cdemu.offset	set	$C
29422                       FFFFFFD8            .int13_cdemu.offset	set	-$28
29423                       00000016            _int13_cdemu.slba	set	$16
29424                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
29425                       00000042            _int13_cdemu.SP	set	$42
29426                       0000000E            .int13_cdemu.SP	set	$E
29427                       0000002E            _int13_cdemu.vheads	set	$2E
29428                       FFFFFFFA            .int13_cdemu.vheads	set	-6
29429                       00000044            _int13_cdemu.BX	set	$44
29430                       00000010            .int13_cdemu.BX	set	$10
29431 8805           55                               push bp
29432 8806           89E5                             mov bp, sp
29433 8808           B8                   EFDE        mov ax, #diskette_param_table2
29434 880B           8946         3E                  mov _int13_cdemu.DI+2[bp], ax
29435 880E           8C4E         3C                  mov _int13_cdemu.ES+2[bp], cs
29436 8811           5D                               pop bp
29437                                           ! 4308 endasm
29438                                           !BCC_ENDASM
29439                                           !BCC_EOS
29440                                           ! 4309       goto int13_success;
29441 8812           83C4                   00  add	sp,#..FFE0-..FFE1
29442 8815           E9         00C9            br 	.FFE0
29443                                           !BCC_EOS
29444                                           ! 4310       break;
29445 8818           E9         0099            br 	.5E3
29446                                           !BCC_EOS
29447                                           ! 4311     case 0x15:
29448                                           ! 4312       AX = ((AX & 0x00ff) | ((0x03) << 8));
29449                       0000881B            .607:
29450                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29451 881B           8A46         16            mov	al,$16[bp]
29452                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
29453 881E           30E4                       xor	ah,ah
29454 8820           0D                   0300  or	ax,#$300
29455                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29456 8823           8946         16            mov	$16[bp],ax
29457                                           !BCC_EOS
29458                                           ! 4313       goto int13_success_noah;
29459 8826           83C4                   00  add	sp,#..FFDD-..FFE1
29460 8829           E9         00BF            br 	.FFDD
29461                                           !BCC_EOS
29462                                           ! 4314       break;
29463 882C           E9         0085            br 	.5E3
29464                                           !BCC_EOS
29465                                           ! 4315     case 0x0a:
29466                                           ! 4316     case 0x0b:
29467                       0000882F            .608:
29468                                           ! 4317     case 0x18:
29469                       0000882F            .609:
29470                                           ! 4318     case 0x41:
29471                       0000882F            .60A:
29472                                           ! 4319     case 0x42:
29473                       0000882F            .60B:
29474                                           ! 4320     case 0x43:
29475                       0000882F            .60C:
29476                                           ! 4321     case 0x44:
29477                       0000882F            .60D:
29478                                           ! 4322     case 0x45:
29479                       0000882F            .60E:
29480                                           ! 4323     case 0x46:
29481                       0000882F            .60F:
29482                                           ! 4324     case 0x47:
29483                       0000882F            .610:
29484                                           ! 4325     case 0x48:
29485                       0000882F            .611:
29486                                           ! 4326     case 0x49:
29487                       0000882F            .612:
29488                                           ! 4327     case 0x4e:
29489                       0000882F            .613:
29490                                           ! 4328     case 0x50:
29491                       0000882F            .614:
29492                                           ! 4329     default:
29493                       0000882F            .615:
29494                                           ! 4330       ;
29495                       0000882F            .616:
29496                                           !BCC_EOS
29497                                           ! 4331       goto int13_fail;
29498 882F           83C4                   00  add	sp,#..FFE2-..FFE1
29499 8832           E9         007F            jmp .FFE2
29500                                           !BCC_EOS
29501                                           ! 4332       break;
29502 8835           EB           7D            jmp .5E3
29503                                           !BCC_EOS
29504                                           ! 4333     }
29505                                           ! 4334 int13_fail:
29506 8837           EB           7B            jmp .5E3
29507                       00008839            .5E5:
29508 8839           2D                   0000  sub	ax,*0
29509 883C           7C           F1            jl 	.616
29510 883E           3D                   0018  cmp	ax,*$18
29511 8841           77           3B            ja  	.617
29512 8843           D1E0                       shl	ax,*1
29513 8845           89C3                       mov	bx,ax
29514 8847           2E                         seg	cs
29515 8848           FFA7       884C            br	.618[bx]
29516                       0000884C            .618:
29517 884C                      838D            .word	.5E6
29518 884E                      83AA            .word	.5F0
29519 8850                      83FB            .word	.5F4
29520 8852                      8396            .word	.5EE
29521 8854                      83FB            .word	.5F5
29522 8856                      8396            .word	.5EF
29523 8858                      882F            .word	.616
29524 885A                      882F            .word	.616
29525 885C                      8726            .word	.600
29526 885E                      838D            .word	.5E7
29527 8860                      882F            .word	.608
29528 8862                      882F            .word	.609
29529 8864                      838D            .word	.5E8
29530 8866                      838D            .word	.5E9
29531 8868                      882F            .word	.616
29532 886A                      882F            .word	.616
29533 886C                      838D            .word	.5EA
29534 886E                      838D            .word	.5EB
29535 8870                      882F            .word	.616
29536 8872                      882F            .word	.616
29537 8874                      838D            .word	.5EC
29538 8876                      881B            .word	.607
29539 8878                      838D            .word	.5ED
29540 887A                      882F            .word	.616
29541 887C                      882F            .word	.60A
29542                       0000887E            .617:
29543 887E           2D                   0041  sub	ax,*$41
29544 8881           72           AC            jb 	.616
29545 8883           3D                   000F  cmp	ax,*$F
29546 8886           77           29            ja  	.619
29547 8888           D1E0                       shl	ax,*1
29548 888A           89C3                       mov	bx,ax
29549 888C           2E                         seg	cs
29550 888D           FFA7       8891            br	.61A[bx]
29551                       00008891            .61A:
29552 8891                      882F            .word	.60B
29553 8893                      882F            .word	.60C
29554 8895                      882F            .word	.60D
29555 8897                      882F            .word	.60E
29556 8899                      882F            .word	.60F
29557 889B                      882F            .word	.610
29558 889D                      882F            .word	.611
29559 889F                      882F            .word	.612
29560 88A1                      882F            .word	.613
29561 88A3                      882F            .word	.616
29562 88A5                      882F            .word	.616
29563 88A7                      882F            .word	.616
29564 88A9                      882F            .word	.616
29565 88AB                      882F            .word	.614
29566 88AD                      882F            .word	.616
29567 88AF                      882F            .word	.615
29568                       000088B1            .619:
29569 88B1           E9         FF7B            br 	.616
29570                       000088B4            .5E3:
29571                       FFFFFFCA            ..FFE1	=	-$36
29572                       000088B4            .FFE2:
29573                       FFFFFFCA            ..FFE2	=	-$36
29574                                           ! 4335     AX = ((AX & 0x00ff) | ((0x01) << 8));
29575                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29576 88B4           8A46         16            mov	al,$16[bp]
29577                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
29578 88B7           30E4                       xor	ah,ah
29579 88B9           0D                   0100  or	ax,#$100
29580                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29581 88BC           8946         16            mov	$16[bp],ax
29582                                           !BCC_EOS
29583                                           ! 4336 int13_fail_noah:
29584                       000088BF            .FFDF:
29585                       FFFFFFCA            ..FFDF	=	-$36
29586                                           ! 4337     write_byte(0x0040, 0x0074, ( AX >> 8 ));
29587                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29588 88BF           8B46         16            mov	ax,$16[bp]
29589 88C2           88E0                       mov	al,ah
29590 88C4           30E4                       xor	ah,ah
29591                                           ! Debug: list unsigned int = ax+0 (used reg = )
29592 88C6           50                         push	ax
29593                                           ! Debug: list int = const $74 (used reg = )
29594 88C7           B8                   0074  mov	ax,*$74
29595 88CA           50                         push	ax
29596                                           ! Debug: list int = const $40 (used reg = )
29597 88CB           B8                   0040  mov	ax,*$40
29598 88CE           50                         push	ax
29599                                           ! Debug: func () void = write_byte+0 (used reg = )
29600 88CF           E8         7D48            call	_write_byte
29601 88D2           83C4                   06  add	sp,*6
29602                                           !BCC_EOS
29603                                           ! 4338 int13_fail_nostatus:
29604                       000088D5            .FFDE:
29605                       FFFFFFCA            ..FFDE	=	-$36
29606                                           ! 4339     FLAGS |= 0x0001;
29607                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
29608 88D5           8B46         1C            mov	ax,$1C[bp]
29609 88D8           0C                     01  or	al,*1
29610 88DA           8946         1C            mov	$1C[bp],ax
29611                                           !BCC_EOS
29612                                           ! 4340     return;
29613 88DD           89EC                       mov	sp,bp
29614 88DF           5D                         pop	bp
29615 88E0           C3                         ret
29616                                           !BCC_EOS
29617                                           ! 4341 int13_success:
29618                       000088E1            .FFE0:
29619                       FFFFFFCA            ..FFE0	=	-$36
29620                                           ! 4342     AX = ((AX & 0x00ff) | ((0x00) << 8));
29621                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29622 88E1           8A46         16            mov	al,$16[bp]
29623                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
29624 88E4           0C                     00  or	al,*0
29625                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
29626 88E6           30E4                       xor	ah,ah
29627 88E8           8946         16            mov	$16[bp],ax
29628                                           !BCC_EOS
29629                                           ! 4343 int13_success_noah:
29630                       000088EB            .FFDD:
29631                       FFFFFFCA            ..FFDD	=	-$36
29632                                           ! 4344     write_byte(0x0040, 0x0074, 0x00);
29633                                           ! Debug: list int = const 0 (used reg = )
29634 88EB           31C0                       xor	ax,ax
29635 88ED           50                         push	ax
29636                                           ! Debug: list int = const $74 (used reg = )
29637 88EE           B8                   0074  mov	ax,*$74
29638 88F1           50                         push	ax
29639                                           ! Debug: list int = const $40 (used reg = )
29640 88F2           B8                   0040  mov	ax,*$40
29641 88F5           50                         push	ax
29642                                           ! Debug: func () void = write_byte+0 (used reg = )
29643 88F6           E8         7D21            call	_write_byte
29644 88F9           83C4                   06  add	sp,*6
29645                                           !BCC_EOS
29646                                           ! 4345     FLAGS &= 0xfffe;
29647                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
29648 88FC           8B46         1C            mov	ax,$1C[bp]
29649 88FF           24                     FE  and	al,#$FE
29650 8901           8946         1C            mov	$1C[bp],ax
29651                                           !BCC_EOS
29652                                           ! 4346     return;
29653 8904           89EC                       mov	sp,bp
29654 8906           5D                         pop	bp
29655 8907           C3                         ret
29656                                           !BCC_EOS
29657                                           ! 4347 }
29658                                           ! 4348 void floppy_reset_controller()
29659                                           ! Register BX used in function int13_cdemu
29660                                           ! 4349 {
29661                                           export	_floppy_reset_controller
29662                       00008908            _floppy_reset_controller:
29663                                           ! 4350   Bit8u val8;
29664                                           !BCC_EOS
29665                                           ! 4351   val8 = inb(0x03f2);
29666 8908           55                         push	bp
29667 8909           89E5                       mov	bp,sp
29668 890B           4C                         dec	sp
29669 890C           4C                         dec	sp
29670                                           ! Debug: list int = const $3F2 (used reg = )
29671 890D           B8                   03F2  mov	ax,#$3F2
29672 8910           50                         push	ax
29673                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29674 8911           E8         7C2A            call	_inb
29675 8914           44                         inc	sp
29676 8915           44                         inc	sp
29677                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
29678 8916           8846         FF            mov	-1[bp],al
29679                                           !BCC_EOS
29680                                           ! 4352   outb(0x03f2, val8 & ~0x04);
29681                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
29682 8919           8A46         FF            mov	al,-1[bp]
29683 891C           24                     FB  and	al,#$FB
29684                                           ! Debug: list unsigned char = al+0 (used reg = )
29685 891E           30E4                       xor	ah,ah
29686 8920           50                         push	ax
29687                                           ! Debug: list int = const $3F2 (used reg = )
29688 8921           B8                   03F2  mov	ax,#$3F2
29689 8924           50                         push	ax
29690                                           ! Debug: func () void = outb+0 (used reg = )
29691 8925           E8         7C2C            call	_outb
29692 8928           83C4                   04  add	sp,*4
29693                                           !BCC_EOS
29694                                           ! 4353   outb(0x03f2, val8 | 0x04);
29695                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
29696 892B           8A46         FF            mov	al,-1[bp]
29697 892E           0C                     04  or	al,*4
29698                                           ! Debug: list unsigned char = al+0 (used reg = )
29699 8930           30E4                       xor	ah,ah
29700 8932           50                         push	ax
29701                                           ! Debug: list int = const $3F2 (used reg = )
29702 8933           B8                   03F2  mov	ax,#$3F2
29703 8936           50                         push	ax
29704                                           ! Debug: func () void = outb+0 (used reg = )
29705 8937           E8         7C1A            call	_outb
29706 893A           83C4                   04  add	sp,*4
29707                                           !BCC_EOS
29708                                           ! 4354   do {
29709                       0000893D            .61D:
29710                                           ! 4355     val8 = inb(0x3f4);
29711                                           ! Debug: list int = const $3F4 (used reg = )
29712 893D           B8                   03F4  mov	ax,#$3F4
29713 8940           50                         push	ax
29714                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29715 8941           E8         7BFA            call	_inb
29716 8944           44                         inc	sp
29717 8945           44                         inc	sp
29718                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
29719 8946           8846         FF            mov	-1[bp],al
29720                                           !BCC_EOS
29721                                           ! 4356   } while ( (val8 & 0xc0) != 0x80 );
29722                       00008949            .61C:
29723                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
29724 8949           8A46         FF            mov	al,-1[bp]
29725 894C           24                     C0  and	al,#$C0
29726                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
29727 894E           3C                     80  cmp	al,#$80
29728 8950           75           EB            jne	.61D
29729                       00008952            .61E:
29730                                           !BCC_EOS
29731                                           ! 4357 }
29732                       00008952            .61B:
29733 8952           89EC                       mov	sp,bp
29734 8954           5D                         pop	bp
29735 8955           C3                         ret
29736                                           ! 4358 void floppy_prepare_controller(drive)
29737                                           ! 4359   Bit16u drive;
29738                                           export	_floppy_prepare_controller
29739                       00008956            _floppy_prepare_controller:
29740                                           !BCC_EOS
29741                                           ! 4360 {
29742                                           ! 4361   Bit8u val8, dor, prev_reset;
29743                                           !BCC_EOS
29744                                           ! 4362   val8 = read_byte(0x0040, 0x003e);
29745 8956           55                         push	bp
29746 8957           89E5                       mov	bp,sp
29747 8959           83C4                   FC  add	sp,*-4
29748                                           ! Debug: list int = const $3E (used reg = )
29749 895C           B8                   003E  mov	ax,*$3E
29750 895F           50                         push	ax
29751                                           ! Debug: list int = const $40 (used reg = )
29752 8960           B8                   0040  mov	ax,*$40
29753 8963           50                         push	ax
29754                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29755 8964           E8         7C8D            call	_read_byte
29756 8967           83C4                   04  add	sp,*4
29757                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
29758 896A           8846         FF            mov	-1[bp],al
29759                                           !BCC_EOS
29760                                           ! 4363   val8 &= 0x7
29761                                           ! 4363 f;
29762                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
29763 896D           8A46         FF            mov	al,-1[bp]
29764 8970           24                     7F  and	al,*$7F
29765 8972           8846         FF            mov	-1[bp],al
29766                                           !BCC_EOS
29767                                           ! 4364   write_byte(0x0040, 0x003e, val8);
29768                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
29769 8975           8A46         FF            mov	al,-1[bp]
29770 8978           30E4                       xor	ah,ah
29771 897A           50                         push	ax
29772                                           ! Debug: list int = const $3E (used reg = )
29773 897B           B8                   003E  mov	ax,*$3E
29774 897E           50                         push	ax
29775                                           ! Debug: list int = const $40 (used reg = )
29776 897F           B8                   0040  mov	ax,*$40
29777 8982           50                         push	ax
29778                                           ! Debug: func () void = write_byte+0 (used reg = )
29779 8983           E8         7C94            call	_write_byte
29780 8986           83C4                   06  add	sp,*6
29781                                           !BCC_EOS
29782                                           ! 4365   prev_reset = inb(0x03f2) & 0x04;
29783                                           ! Debug: list int = const $3F2 (used reg = )
29784 8989           B8                   03F2  mov	ax,#$3F2
29785 898C           50                         push	ax
29786                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29787 898D           E8         7BAE            call	_inb
29788 8990           44                         inc	sp
29789 8991           44                         inc	sp
29790                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
29791 8992           24                     04  and	al,*4
29792                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
29793 8994           8846         FD            mov	-3[bp],al
29794                                           !BCC_EOS
29795                                           ! 4366   if (drive)
29796 8997           8B46         04            mov	ax,4[bp]
29797 899A           85C0                       test	ax,ax
29798 899C           74           07            je  	.61F
29799                       0000899E            .620:
29800                                           ! 4367     dor = 0x20;
29801                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
29802 899E           B0                     20  mov	al,*$20
29803 89A0           8846         FE            mov	-2[bp],al
29804                                           !BCC_EOS
29805                                           ! 4368   else
29806                                           ! 4369     dor = 0x10;
29807 89A3           EB           05            jmp .621
29808                       000089A5            .61F:
29809                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
29810 89A5           B0                     10  mov	al,*$10
29811 89A7           8846         FE            mov	-2[bp],al
29812                                           !BCC_EOS
29813                                           ! 4370   dor |= 0x0c;
29814                       000089AA            .621:
29815                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
29816 89AA           8A46         FE            mov	al,-2[bp]
29817 89AD           0C                     0C  or	al,*$C
29818 89AF           8846         FE            mov	-2[bp],al
29819                                           !BCC_EOS
29820                                           ! 4371   dor |= drive;
29821                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
29822 89B2           8B46         04            mov	ax,4[bp]
29823 89B5           0A46         FE            or	al,-2[bp]
29824 89B8           8846         FE            mov	-2[bp],al
29825                                           !BCC_EOS
29826                                           ! 4372   outb(0x03f2, dor);
29827                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
29828 89BB           8A46         FE            mov	al,-2[bp]
29829 89BE           30E4                       xor	ah,ah
29830 89C0           50                         push	ax
29831                                           ! Debug: list int = const $3F2 (used reg = )
29832 89C1           B8                   03F2  mov	ax,#$3F2
29833 89C4           50                         push	ax
29834                                           ! Debug: func () void = outb+0 (used reg = )
29835 89C5           E8         7B8C            call	_outb
29836 89C8           83C4                   04  add	sp,*4
29837                                           !BCC_EOS
29838                                           ! 4373   write_byte(0x40,0x40, 37);
29839                                           ! Debug: list int = const $25 (used reg = )
29840 89CB           B8                   0025  mov	ax,*$25
29841 89CE           50                         push	ax
29842                                           ! Debug: list int = const $40 (used reg = )
29843 89CF           B8                   0040  mov	ax,*$40
29844 89D2           50                         push	ax
29845                                           ! Debug: list int = const $40 (used reg = )
29846 89D3           B8                   0040  mov	ax,*$40
29847 89D6           50                         push	ax
29848                                           ! Debug: func () void = write_byte+0 (used reg = )
29849 89D7           E8         7C40            call	_write_byte
29850 89DA           83C4                   06  add	sp,*6
29851                                           !BCC_EOS
29852                                           ! 4374   do {
29853                       000089DD            .624:
29854                                           ! 4375     val8 = inb(0x3f4);
29855                                           ! Debug: list int = const $3F4 (used reg = )
29856 89DD           B8                   03F4  mov	ax,#$3F4
29857 89E0           50                         push	ax
29858                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29859 89E1           E8         7B5A            call	_inb
29860 89E4           44                         inc	sp
29861 89E5           44                         inc	sp
29862                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
29863 89E6           8846         FF            mov	-1[bp],al
29864                                           !BCC_EOS
29865                                           ! 4376   } while ( (val8 & 0xc0) != 0x80 );
29866                       000089E9            .623:
29867                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
29868 89E9           8A46         FF            mov	al,-1[bp]
29869 89EC           24                     C0  and	al,#$C0
29870                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
29871 89EE           3C                     80  cmp	al,#$80
29872 89F0           75           EB            jne	.624
29873                       000089F2            .625:
29874                                           !BCC_EOS
29875                                           ! 4377   if (prev_reset == 0) {
29876                       000089F2            .622:
29877                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
29878 89F2           8A46         FD            mov	al,-3[bp]
29879 89F5           84C0                       test	al,al
29880 89F7           75           38            jne 	.626
29881                       000089F9            .627:
29882                                           ! 4378 #asm
29883                                           !BCC_EOS
29884                                           !BCC_ASM
29885                       00000002            _floppy_prepare_controller.dor	set	2
29886                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
29887                       00000001            _floppy_prepare_controller.prev_reset	set	1
29888                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
29889                       00000003            _floppy_prepare_controller.val8	set	3
29890                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
29891                       00000008            _floppy_prepare_controller.drive	set	8
29892                       00000004            .floppy_prepare_controller.drive	set	4
29893 89F9           FB                             sti
29894                                           ! 4380 endasm
29895                                           !BCC_ENDASM
29896                                           !BCC_EOS
29897                                           ! 4381     do {
29898                       000089FA            .62A:
29899                                           ! 4382       val8 = read_byte(0x0040, 0x003e);
29900                                           ! Debug: list int = const $3E (used reg = )
29901 89FA           B8                   003E  mov	ax,*$3E
29902 89FD           50                         push	ax
29903                                           ! Debug: list int = const $40 (used reg = )
29904 89FE           B8                   0040  mov	ax,*$40
29905 8A01           50                         push	ax
29906                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29907 8A02           E8         7BEF            call	_read_byte
29908 8A05           83C4                   04  add	sp,*4
29909                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
29910 8A08           8846         FF            mov	-1[bp],al
29911                                           !BCC_EOS
29912                                           ! 4383     } while ( (val8 & 0x80) == 0 );
29913                       00008A0B            .629:
29914                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
29915 8A0B           8A46         FF            mov	al,-1[bp]
29916 8A0E           24                     80  and	al,#$80
29917                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
29918 8A10           84C0                       test	al,al
29919 8A12           74           E6            je 	.62A
29920                       00008A14            .62B:
29921                                           !BCC_EOS
29922                                           ! 4384     val8 &= 0x7f;
29923                       00008A14            .628:
29924                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
29925 8A14           8A46         FF            mov	al,-1[bp]
29926 8A17           24                     7F  and	al,*$7F
29927 8A19           8846         FF            mov	-1[bp],al
29928                                           !BCC_EOS
29929                                           ! 4385 #asm
29930                                           !BCC_EOS
29931                                           !BCC_ASM
29932                       00000002            _floppy_prepare_controller.dor	set	2
29933                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
29934                       00000001            _floppy_prepare_controller.prev_reset	set	1
29935                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
29936                       00000003            _floppy_prepare_controller.val8	set	3
29937                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
29938                       00000008            _floppy_prepare_controller.drive	set	8
29939                       00000004            .floppy_prepare_controller.drive	set	4
29940 8A1C           FA                             cli
29941                                           ! 4387 endasm
29942                                           !BCC_ENDASM
29943                                           !BCC_EOS
29944                                           ! 4388     write_byte(0x0040, 0x003e, val8);
29945                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
29946 8A1D           8A46         FF            mov	al,-1[bp]
29947 8A20           30E4                       xor	ah,ah
29948 8A22           50                         push	ax
29949                                           ! Debug: list int = const $3E (used reg = )
29950 8A23           B8                   003E  mov	ax,*$3E
29951 8A26           50                         push	ax
29952                                           ! Debug: list int = const $40 (used reg = )
29953 8A27           B8                   0040  mov	ax,*$40
29954 8A2A           50                         push	ax
29955                                           ! Debug: func () void = write_byte+0 (used reg = )
29956 8A2B           E8         7BEC            call	_write_byte
29957 8A2E           83C4                   06  add	sp,*6
29958                                           !BCC_EOS
29959                                           ! 4389   }
29960                                           ! 4390 }
29961                       00008A31            .626:
29962 8A31           89EC                       mov	sp,bp
29963 8A33           5D                         pop	bp
29964 8A34           C3                         ret
29965                                           ! 4391   bx_bool
29966                                           ! 4392 floppy_media_known(drive)
29967                                           ! 4393   Bit16u drive;
29968                                           export	_floppy_media_known
29969                       00008A35            _floppy_media_known:
29970                                           !BCC_EOS
29971                                           ! 4394 {
29972                                           ! 4395   Bit8u val8;
29973                                           !BCC_EOS
29974                                           ! 4396   Bit16u media_state_offset;
29975                                           !BCC_EOS
29976                                           ! 4397   val8 = read_byte(0x0040, 0x003e);
29977 8A35           55                         push	bp
29978 8A36           89E5                       mov	bp,sp
29979 8A38           83C4                   FC  add	sp,*-4
29980                                           ! Debug: list int = const $3E (used reg = )
29981 8A3B           B8                   003E  mov	ax,*$3E
29982 8A3E           50                         push	ax
29983                                           ! Debug: list int = const $40 (used reg = )
29984 8A3F           B8                   0040  mov	ax,*$40
29985 8A42           50                         push	ax
29986                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29987 8A43           E8         7BAE            call	_read_byte
29988 8A46           83C4                   04  add	sp,*4
29989                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
29990 8A49           8846         FF            mov	-1[bp],al
29991                                           !BCC_EOS
29992                                           ! 4398   if (drive)
29993 8A4C           8B46         04            mov	ax,4[bp]
29994 8A4F           85C0                       test	ax,ax
29995 8A51           74           0A            je  	.62C
29996                       00008A53            .62D:
29997                                           ! 4399     val8 >>= 1;
29998                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
29999 8A53           8A46         FF            mov	al,-1[bp]
30000 8A56           30E4                       xor	ah,ah
30001 8A58           D1E8                       shr	ax,*1
30002 8A5A           8846         FF            mov	-1[bp],al
30003                                           !BCC_EOS
30004                                           ! 4400   val8 &= 0x01;
30005                       00008A5D            .62C:
30006                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30007 8A5D           8A46         FF            mov	al,-1[bp]
30008 8A60           24                     01  and	al,*1
30009 8A62           8846         FF            mov	-1[bp],al
30010                                           !BCC_EOS
30011                                           ! 4401   if (val8 == 0)
30012                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30013 8A65           8A46         FF            mov	al,-1[bp]
30014 8A68           84C0                       test	al,al
30015 8A6A           75           06            jne 	.62E
30016                       00008A6C            .62F:
30017                                           ! 4402     return(0);
30018 8A6C           31C0                       xor	ax,ax
30019 8A6E           89EC                       mov	sp,bp
30020 8A70           5D                         pop	bp
30021 8A71           C3                         ret
30022                                           !BCC_EOS
30023                                           ! 4403   media_state_offset = 0x0090;
30024                       00008A72            .62E:
30025                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
30026 8A72           B8                   0090  mov	ax,#$90
30027 8A75           8946         FC            mov	-4[bp],ax
30028                                           !BCC_EOS
30029                                           ! 4404   if (drive)
30030 8A78           8B46         04            mov	ax,4[bp]
30031 8A7B           85C0                       test	ax,ax
30032 8A7D           74           07            je  	.630
30033                       00008A7F            .631:
30034                                           ! 4405     media_state_offset += 1;
30035                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
30036 8A7F           8B46         FC            mov	ax,-4[bp]
30037 8A82           40                         inc	ax
30038 8A83           8946         FC            mov	-4[bp],ax
30039                                           !BCC_EOS
30040                                           ! 4406   val8 = read_byte(0x0040, media_state_offset);
30041                       00008A86            .630:
30042                                           ! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
30043 8A86           FF76         FC            push	-4[bp]
30044                                           ! Debug: list int = const $40 (used reg = )
30045 8A89           B8                   0040  mov	ax,*$40
30046 8A8C           50                         push	ax
30047                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30048 8A8D           E8         7B64            call	_read_byte
30049 8A90           83C4                   04  add	sp,*4
30050                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30051 8A93           8846         FF            mov	-1[bp],al
30052                                           !BCC_EOS
30053                                           ! 4407   val8 = (val8 >> 4) & 0x01;
30054                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
30055 8A96           8A46         FF            mov	al,-1[bp]
30056 8A99           30E4                       xor	ah,ah
30057 8A9B           B1                     04  mov	cl,*4
30058 8A9D           D3E8                       shr	ax,cl
30059                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30060 8A9F           24                     01  and	al,*1
30061                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30062 8AA1           8846         FF            mov	-1[bp],al
30063                                           !BCC_EOS
30064                                           ! 4408   if (val8 == 0)
30065                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30066 8AA4           8A46         FF            mov	al,-1[bp]
30067 8AA7           84C0                       test	al,al
30068 8AA9           75           06            jne 	.632
30069                       00008AAB            .633:
30070                                           ! 4409     return(0);
30071 8AAB           31C0                       xor	ax,ax
30072 8AAD           89EC                       mov	sp,bp
30073 8AAF           5D                         pop	bp
30074 8AB0           C3                         ret
30075                                           !BCC_EOS
30076                                           ! 4410   return(1);
30077                       00008AB1            .632:
30078 8AB1           B8                   0001  mov	ax,*1
30079 8AB4           89EC                       mov	sp,bp
30080 8AB6           5D                         pop	bp
30081 8AB7           C3                         ret
30082                                           !BCC_EOS
30083                                           ! 4411 }
30084                                           ! 4412   bx_bool
30085                                           ! 4413 floppy_media_sense(drive)
30086                                           ! 4414   Bit16u drive;
30087                                           export	_floppy_media_sense
30088                       00008AB8            _floppy_media_sense:
30089                                           !BCC_EOS
30090                                           ! 4415 {
30091                                           ! 4416   bx_bool retval;
30092                                           !BCC_EOS
30093                                           ! 4417   Bit16u media_state_offset;
30094                                           !BCC_EOS
30095                                           ! 4418   Bit8u drive_type, config_data, media_state;
30096                                           !BCC_EOS
30097                                           ! 4419   if (floppy_drive_recal(drive) == 0) {
30098 8AB8           55                         push	bp
30099 8AB9           89E5                       mov	bp,sp
30100 8ABB           83C4                   F8  add	sp,*-8
30101                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
30102 8ABE           FF76         04            push	4[bp]
30103                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
30104 8AC1           E8         0153            call	_floppy_drive_recal
30105 8AC4           44                         inc	sp
30106 8AC5           44                         inc	sp
30107                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30108 8AC6           85C0                       test	ax,ax
30109 8AC8           75           06            jne 	.634
30110                       00008ACA            .635:
30111                                           ! 4420     return(0);
30112 8ACA           31C0                       xor	ax,ax
30113 8ACC           89EC                       mov	sp,bp
30114 8ACE           5D                         pop	bp
30115 8ACF           C3                         ret
30116                                           !BCC_EOS
30117                                           ! 4421     }
30118                                           ! 4422   drive_type = inb_cmos(0x10);
30119                       00008AD0            .634:
30120                                           ! Debug: list int = const $10 (used reg = )
30121 8AD0           B8                   0010  mov	ax,*$10
30122 8AD3           50                         push	ax
30123                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30124 8AD4           E8         7AAC            call	_inb_cmos
30125 8AD7           44                         inc	sp
30126 8AD8           44                         inc	sp
30127                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
30128 8AD9           8846         FB            mov	-5[bp],al
30129                                           !BCC_EOS
30130                                           ! 4423   if (drive == 0)
30131                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
30132 8ADC           8B46         04            mov	ax,4[bp]
30133 8ADF           85C0                       test	ax,ax
30134 8AE1           75           0E            jne 	.636
30135                       00008AE3            .637:
30136                                           ! 4424     drive_type >>= 4;
30137                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
30138 8AE3           8A46         FB            mov	al,-5[bp]
30139 8AE6           30E4                       xor	ah,ah
30140 8AE8           B1                     04  mov	cl,*4
30141 8AEA           D3E8                       shr	ax,cl
30142 8AEC           8846         FB            mov	-5[bp],al
30143                                           !BCC_EOS
30144                                           ! 4425   else
30145                                           ! 4426     drive_type &= 0x0f;
30146 8AEF           EB           08            jmp .638
30147                       00008AF1            .636:
30148                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
30149 8AF1           8A46         FB            mov	al,-5[bp]
30150 8AF4           24                     0F  and	al,*$F
30151 8AF6           8846         FB            mov	-5[bp],al
30152                                           !BCC_EOS
30153                                           ! 4427   if ( drive_type == 1 ) {
30154                       00008AF9            .638:
30155                                           ! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
30156 8AF9           8A46         FB            mov	al,-5[bp]
30157 8AFC           3C                     01  cmp	al,*1
30158 8AFE           75           13            jne 	.639
30159                       00008B00            .63A:
30160                                           ! 4428     config_data = 0x00;
30161                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30162 8B00           30C0                       xor	al,al
30163 8B02           8846         FA            mov	-6[bp],al
30164                                           !BCC_EOS
30165                                           ! 4429     media_state = 0x25;
30166                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
30167 8B05           B0                     25  mov	al,*$25
30168 8B07           8846         F9            mov	-7[bp],al
30169                                           !BCC_EOS
30170                                           ! 4430     retval = 1;
30171                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30172 8B0A           B8                   0001  mov	ax,*1
30173 8B0D           8946         FE            mov	-2[bp],ax
30174                                           !BCC_EOS
30175                                           ! 4431     }
30176                                           ! 4432   else if ( drive_type == 2 ) {
30177 8B10           E9         00C1            br 	.63B
30178                       00008B13            .639:
30179                                           ! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
30180 8B13           8A46         FB            mov	al,-5[bp]
30181 8B16           3C                     02  cmp	al,*2
30182 8B18           75           13            jne 	.63C
30183                       00008B1A            .63D:
30184                                           ! 4433     config_data = 0x00;
30185                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30186 8B1A           30C0                       xor	al,al
30187 8B1C           8846         FA            mov	-6[bp],al
30188                                           !BCC_EOS
30189                                           ! 4434     media_state = 0x25;
30190                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
30191 8B1F           B0                     25  mov	al,*$25
30192 8B21           8846         F9            mov	-7[bp],al
30193                                           !BCC_EOS
30194                                           ! 4435     retval = 1;
30195                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30196 8B24           B8                   0001  mov	ax,*1
30197 8B27           8946         FE            mov	-2[bp],ax
30198                                           !BCC_EOS
30199                                           ! 4436     }
30200                                           ! 4437   else if ( drive_type == 3 ) {
30201 8B2A           E9         00A7            br 	.63E
30202                       00008B2D            .63C:
30203                                           ! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
30204 8B2D           8A46         FB            mov	al,-5[bp]
30205 8B30           3C                     03  cmp	al,*3
30206 8B32           75           13            jne 	.63F
30207                       00008B34            .640:
30208                                           ! 4438     config_data = 0x00;
30209                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30210 8B34           30C0                       xor	al,al
30211 8B36           8846         FA            mov	-6[bp],al
30212                                           !BCC_EOS
30213                                           ! 4439     media_state = 0x17;
30214                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
30215 8B39           B0                     17  mov	al,*$17
30216 8B3B           8846         F9            mov	-7[bp],al
30217                                           !BCC_EOS
30218                                           ! 4440     retval = 1;
30219                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30220 8B3E           B8                   0001  mov	ax,*1
30221 8B41           8946         FE            mov	-2[bp],ax
30222                                           !BCC_EOS
30223                                           ! 4441     }
30224                                           ! 4442   else if ( drive_type == 4 ) {
30225 8B44           E9         008D            br 	.641
30226                       00008B47            .63F:
30227                                           ! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
30228 8B47           8A46         FB            mov	al,-5[bp]
30229 8B4A           3C                     04  cmp	al,*4
30230 8B4C           75           13            jne 	.642
30231                       00008B4E            .643:
30232                                           ! 4443     config_data = 0x00;
30233                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30234 8B4E           30C0                       xor	al,al
30235 8B50           8846         FA            mov	-6[bp],al
30236                                           !BCC_EOS
30237                                           ! 4444     media_state = 0x17;
30238                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
30239 8B53           B0                     17  mov	al,*$17
30240 8B55           8846         F9            mov	-7[bp],al
30241                                           !BCC_EOS
30242                                           ! 4445     retval = 1;
30243                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30244 8B58           B8                   0001  mov	ax,*1
30245 8B5B           8946         FE            mov	-2[bp],ax
30246                                           !BCC_EOS
30247                                           ! 4446     }
30248                                           ! 4447   else if ( drive_type == 5 ) {
30249 8B5E           E9         0073            br 	.644
30250                       00008B61            .642:
30251                                           ! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
30252 8B61           8A46         FB            mov	al,-5[bp]
30253 8B64           3C                     05  cmp	al,*5
30254 8B66           75           12            jne 	.645
30255                       00008B68            .646:
30256                                           ! 4448     config_data = 0xCC;
30257                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
30258 8B68           B0                     CC  mov	al,#$CC
30259 8B6A           8846         FA            mov	-6[bp],al
30260                                           !BCC_EOS
30261                                           ! 4449     media_state = 0xD7;
30262                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
30263 8B6D           B0                     D7  mov	al,#$D7
30264 8B6F           8846         F9            mov	-7[bp],al
30265                                           !BCC_EOS
30266                                           ! 4450     retval = 1;
30267                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30268 8B72           B8                   0001  mov	ax,*1
30269 8B75           8946         FE            mov	-2[bp],ax
30270                                           !BCC_EOS
30271                                           ! 4451     }
30272                                           ! 4452   else if ( drive_type == 6 ) {
30273 8B78           EB           5A            jmp .647
30274                       00008B7A            .645:
30275                                           ! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
30276 8B7A           8A46         FB            mov	al,-5[bp]
30277 8B7D           3C                     06  cmp	al,*6
30278 8B7F           75           12            jne 	.648
30279                       00008B81            .649:
30280                                           ! 4453     config_data = 0x00;
30281                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30282 8B81           30C0                       xor	al,al
30283 8B83           8846         FA            mov	-6[bp],al
30284                                           !BCC_EOS
30285                                           ! 4454     media_state = 0x27;
30286                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30287 8B86           B0                     27  mov	al,*$27
30288 8B88           8846         F9            mov	-7[bp],al
30289                                           !BCC_EOS
30290                                           ! 4455     retval = 1;
30291                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30292 8B8B           B8                   0001  mov	ax,*1
30293 8B8E           8946         FE            mov	-2[bp],ax
30294                                           !BCC_EOS
30295                                           ! 4456     }
30296                                           ! 4457   else if ( drive_type == 7 ) {
30297 8B91           EB           41            jmp .64A
30298                       00008B93            .648:
30299                                           ! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
30300 8B93           8A46         FB            mov	al,-5[bp]
30301 8B96           3C                     07  cmp	al,*7
30302 8B98           75           12            jne 	.64B
30303                       00008B9A            .64C:
30304                                           ! 4458     config_data = 0x00;
30305                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30306 8B9A           30C0                       xor	al,al
30307 8B9C           8846         FA            mov	-6[bp],al
30308                                           !BCC_EOS
30309                                           ! 4459     media_state = 0x27;
30310                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30311 8B9F           B0                     27  mov	al,*$27
30312 8BA1           8846         F9            mov	-7[bp],al
30313                                           !BCC_EOS
30314                                           ! 4460     retval = 1;
30315                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30316 8BA4           B8                   0001  mov	ax,*1
30317 8BA7           8946         FE            mov	-2[bp],ax
30318                                           !BCC_EOS
30319                                           ! 4461     }
30320                                           ! 4462   else if ( drive_type == 8 ) {
30321 8BAA           EB           28            jmp .64D
30322                       00008BAC            .64B:
30323                                           ! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
30324 8BAC           8A46         FB            mov	al,-5[bp]
30325 8BAF           3C                     08  cmp	al,*8
30326 8BB1           75           12            jne 	.64E
30327                       00008BB3            .64F:
30328                                           ! 4463     config_data = 0x00;
30329                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30330 8BB3           30C0                       xor	al,al
30331 8BB5           8846         FA            mov	-6[bp],al
30332                                           !BCC_EOS
30333                                           ! 4464     media_state = 0x27;
30334                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30335 8BB8           B0                     27  mov	al,*$27
30336 8BBA           8846         F9            mov	-7[bp],al
30337                                           !BCC_EOS
30338                                           ! 4465     retval = 1;
30339                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30340 8BBD           B8                   0001  mov	ax,*1
30341 8BC0           8946         FE            mov	-2[bp],ax
30342                                           !BCC_EOS
30343                                           ! 4466     }
30344                                           ! 4467   else {
30345 8BC3           EB           0F            jmp .650
30346                       00008BC5            .64E:
30347                                           ! 4468     config_data = 0x00;
30348                                           ! 4468 
30349                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30350 8BC5           30C0                       xor	al,al
30351 8BC7           8846         FA            mov	-6[bp],al
30352                                           !BCC_EOS
30353                                           ! 4469     media_state = 0x00;
30354                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
30355 8BCA           30C0                       xor	al,al
30356 8BCC           8846         F9            mov	-7[bp],al
30357                                           !BCC_EOS
30358                                           ! 4470     retval = 0;
30359                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
30360 8BCF           31C0                       xor	ax,ax
30361 8BD1           8946         FE            mov	-2[bp],ax
30362                                           !BCC_EOS
30363                                           ! 4471     }
30364                                           ! 4472   if (drive == 0)
30365                       00008BD4            .650:
30366                       00008BD4            .64D:
30367                       00008BD4            .64A:
30368                       00008BD4            .647:
30369                       00008BD4            .644:
30370                       00008BD4            .641:
30371                       00008BD4            .63E:
30372                       00008BD4            .63B:
30373                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
30374 8BD4           8B46         04            mov	ax,4[bp]
30375 8BD7           85C0                       test	ax,ax
30376 8BD9           75           08            jne 	.651
30377                       00008BDB            .652:
30378                                           ! 4473     media_state_offset = 0x90;
30379                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
30380 8BDB           B8                   0090  mov	ax,#$90
30381 8BDE           8946         FC            mov	-4[bp],ax
30382                                           !BCC_EOS
30383                                           ! 4474   else
30384                                           ! 4475     media_state_offset = 0x91;
30385 8BE1           EB           06            jmp .653
30386                       00008BE3            .651:
30387                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
30388 8BE3           B8                   0091  mov	ax,#$91
30389 8BE6           8946         FC            mov	-4[bp],ax
30390                                           !BCC_EOS
30391                                           ! 4476   write_byte(0x0040, 0x008B, config_data);
30392                       00008BE9            .653:
30393                                           ! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
30394 8BE9           8A46         FA            mov	al,-6[bp]
30395 8BEC           30E4                       xor	ah,ah
30396 8BEE           50                         push	ax
30397                                           ! Debug: list int = const $8B (used reg = )
30398 8BEF           B8                   008B  mov	ax,#$8B
30399 8BF2           50                         push	ax
30400                                           ! Debug: list int = const $40 (used reg = )
30401 8BF3           B8                   0040  mov	ax,*$40
30402 8BF6           50                         push	ax
30403                                           ! Debug: func () void = write_byte+0 (used reg = )
30404 8BF7           E8         7A20            call	_write_byte
30405 8BFA           83C4                   06  add	sp,*6
30406                                           !BCC_EOS
30407                                           ! 4477   write_byte(0x0040, media_state_offset, media_state);
30408                                           ! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
30409 8BFD           8A46         F9            mov	al,-7[bp]
30410 8C00           30E4                       xor	ah,ah
30411 8C02           50                         push	ax
30412                                           ! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
30413 8C03           FF76         FC            push	-4[bp]
30414                                           ! Debug: list int = const $40 (used reg = )
30415 8C06           B8                   0040  mov	ax,*$40
30416 8C09           50                         push	ax
30417                                           ! Debug: func () void = write_byte+0 (used reg = )
30418 8C0A           E8         7A0D            call	_write_byte
30419 8C0D           83C4                   06  add	sp,*6
30420                                           !BCC_EOS
30421                                           ! 4478   return(retval);
30422 8C10           8B46         FE            mov	ax,-2[bp]
30423 8C13           89EC                       mov	sp,bp
30424 8C15           5D                         pop	bp
30425 8C16           C3                         ret
30426                                           !BCC_EOS
30427                                           ! 4479 }
30428                                           ! 4480   bx_bool
30429                                           ! 4481 floppy_drive_recal(drive)
30430                                           ! 4482   Bit16u drive;
30431                                           export	_floppy_drive_recal
30432                       00008C17            _floppy_drive_recal:
30433                                           !BCC_EOS
30434                                           ! 4483 {
30435                                           ! 4484   Bit8u val8;
30436                                           !BCC_EOS
30437                                           ! 4485   Bit16u curr_cyl_offset;
30438                                           !BCC_EOS
30439                                           ! 4486   floppy_prepare_controller(drive);
30440 8C17           55                         push	bp
30441 8C18           89E5                       mov	bp,sp
30442 8C1A           83C4                   FC  add	sp,*-4
30443                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
30444 8C1D           FF76         04            push	4[bp]
30445                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
30446 8C20           E8         FD33            call	_floppy_prepare_controller
30447 8C23           44                         inc	sp
30448 8C24           44                         inc	sp
30449                                           !BCC_EOS
30450                                           ! 4487   outb(0x03f5, 0x07);
30451                                           ! Debug: list int = const 7 (used reg = )
30452 8C25           B8                   0007  mov	ax,*7
30453 8C28           50                         push	ax
30454                                           ! Debug: list int = const $3F5 (used reg = )
30455 8C29           B8                   03F5  mov	ax,#$3F5
30456 8C2C           50                         push	ax
30457                                           ! Debug: func () void = outb+0 (used reg = )
30458 8C2D           E8         7924            call	_outb
30459 8C30           83C4                   04  add	sp,*4
30460                                           !BCC_EOS
30461                                           ! 4488   outb(0x03f5, drive);
30462                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
30463 8C33           FF76         04            push	4[bp]
30464                                           ! Debug: list int = const $3F5 (used reg = )
30465 8C36           B8                   03F5  mov	ax,#$3F5
30466 8C39           50                         push	ax
30467                                           ! Debug: func () void = outb+0 (used reg = )
30468 8C3A           E8         7917            call	_outb
30469 8C3D           83C4                   04  add	sp,*4
30470                                           !BCC_EOS
30471                                           ! 4489 #asm
30472                                           !BCC_EOS
30473                                           !BCC_ASM
30474                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
30475                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
30476                       00000003            _floppy_drive_recal.val8	set	3
30477                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
30478                       00000008            _floppy_drive_recal.drive	set	8
30479                       00000004            .floppy_drive_recal.drive	set	4
30480 8C40           FB                           sti
30481                                           ! 4491 endasm
30482                                           !BCC_ENDASM
30483                                           !BCC_EOS
30484                                           ! 4492   do {
30485                       00008C41            .656:
30486                                           ! 4493     val8 = (read_byte(0x0040, 0x003e) & 0x80);
30487                                           ! Debug: list int = const $3E (used reg = )
30488 8C41           B8                   003E  mov	ax,*$3E
30489 8C44           50                         push	ax
30490                                           ! Debug: list int = const $40 (used reg = )
30491 8C45           B8                   0040  mov	ax,*$40
30492 8C48           50                         push	ax
30493                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30494 8C49           E8         79A8            call	_read_byte
30495 8C4C           83C4                   04  add	sp,*4
30496                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
30497 8C4F           24                     80  and	al,#$80
30498                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30499 8C51           8846         FF            mov	-1[bp],al
30500                                           !BCC_EOS
30501                                           ! 4494   } while ( val8 == 0 );
30502                       00008C54            .655:
30503                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30504 8C54           8A46         FF            mov	al,-1[bp]
30505 8C57           84C0                       test	al,al
30506 8C59           74           E6            je 	.656
30507                       00008C5B            .657:
30508                                           !BCC_EOS
30509                                           ! 4495   val8 = 0;
30510                       00008C5B            .654:
30511                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30512 8C5B           30C0                       xor	al,al
30513 8C5D           8846         FF            mov	-1[bp],al
30514                                           !BCC_EOS
30515                                           ! 4496 #asm
30516                                           !BCC_EOS
30517                                           !BCC_ASM
30518                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
30519                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
30520                       00000003            _floppy_drive_recal.val8	set	3
30521                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
30522                       00000008            _floppy_drive_recal.drive	set	8
30523                       00000004            .floppy_drive_recal.drive	set	4
30524 8C60           FA                           cli
30525                                           ! 4498 endasm
30526                                           !BCC_ENDASM
30527                                           !BCC_EOS
30528                                           ! 4499   val8 = read_byte(0x0040, 0x003e);
30529                                           ! Debug: list int = const $3E (used reg = )
30530 8C61           B8                   003E  mov	ax,*$3E
30531 8C64           50                         push	ax
30532                                           ! Debug: list int = const $40 (used reg = )
30533 8C65           B8                   0040  mov	ax,*$40
30534 8C68           50                         push	ax
30535                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30536 8C69           E8         7988            call	_read_byte
30537 8C6C           83C4                   04  add	sp,*4
30538                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30539 8C6F           8846         FF            mov	-1[bp],al
30540                                           !BCC_EOS
30541                                           ! 4500   val8 &= 0x7f;
30542                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30543 8C72           8A46         FF            mov	al,-1[bp]
30544 8C75           24                     7F  and	al,*$7F
30545 8C77           8846         FF            mov	-1[bp],al
30546                                           !BCC_EOS
30547                                           ! 4501   if (drive) {
30548 8C7A           8B46         04            mov	ax,4[bp]
30549 8C7D           85C0                       test	ax,ax
30550 8C7F           74           10            je  	.658
30551                       00008C81            .659:
30552                                           ! 4502     val8 |= 0x02;
30553                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
30554 8C81           8A46         FF            mov	al,-1[bp]
30555 8C84           0C                     02  or	al,*2
30556 8C86           8846         FF            mov	-1[bp],al
30557                                           !BCC_EOS
30558                                           ! 4503     curr_cyl_offset = 0x0095;
30559                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
30560 8C89           B8                   0095  mov	ax,#$95
30561 8C8C           8946         FC            mov	-4[bp],ax
30562                                           !BCC_EOS
30563                                           ! 4504   } else {
30564 8C8F           EB           0E            jmp .65A
30565                       00008C91            .658:
30566                                           ! 4505     val8 |= 0x01;
30567                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30568 8C91           8A46         FF            mov	al,-1[bp]
30569 8C94           0C                     01  or	al,*1
30570 8C96           8846         FF            mov	-1[bp],al
30571                                           !BCC_EOS
30572                                           ! 4506     curr_cyl_offset = 0x0094;
30573                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
30574 8C99           B8                   0094  mov	ax,#$94
30575 8C9C           8946         FC            mov	-4[bp],ax
30576                                           !BCC_EOS
30577                                           ! 4507   }
30578                                           ! 4508   write_byte(0x0040, 0x003e, val8);
30579                       00008C9F            .65A:
30580                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30581 8C9F           8A46         FF            mov	al,-1[bp]
30582 8CA2           30E4                       xor	ah,ah
30583 8CA4           50                         push	ax
30584                                           ! Debug: list int = const $3E (used reg = )
30585 8CA5           B8                   003E  mov	ax,*$3E
30586 8CA8           50                         push	ax
30587                                           ! Debug: list int = const $40 (used reg = )
30588 8CA9           B8                   0040  mov	ax,*$40
30589 8CAC           50                         push	ax
30590                                           ! Debug: func () void = write_byte+0 (used reg = )
30591 8CAD           E8         796A            call	_write_byte
30592 8CB0           83C4                   06  add	sp,*6
30593                                           !BCC_EOS
30594                                           ! 4509   write_byte(0x0040, curr_cyl_offset, 0);
30595                                           ! Debug: list int = const 0 (used reg = )
30596 8CB3           31C0                       xor	ax,ax
30597 8CB5           50                         push	ax
30598                                           ! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
30599 8CB6           FF76         FC            push	-4[bp]
30600                                           ! Debug: list int = const $40 (used reg = )
30601 8CB9           B8                   0040  mov	ax,*$40
30602 8CBC           50                         push	ax
30603                                           ! Debug: func () void = write_byte+0 (used reg = )
30604 8CBD           E8         795A            call	_write_byte
30605 8CC0           83C4                   06  add	sp,*6
30606                                           !BCC_EOS
30607                                           ! 4510   return(1);
30608 8CC3           B8                   0001  mov	ax,*1
30609 8CC6           89EC                       mov	sp,bp
30610 8CC8           5D                         pop	bp
30611 8CC9           C3                         ret
30612                                           !BCC_EOS
30613                                           ! 4511 }
30614                                           ! 4512   bx_bool
30615                                           ! 4513 floppy_drive_exists(drive)
30616                                           ! 4514   Bit16u drive;
30617                                           export	_floppy_drive_exists
30618                       00008CCA            _floppy_drive_exists:
30619                                           !BCC_EOS
30620                                           ! 4515 {
30621                                           ! 4516   Bit8u drive_type;
30622                                           !BCC_EOS
30623                                           ! 4517   drive_type = inb_cmos(0x10);
30624 8CCA           55                         push	bp
30625 8CCB           89E5                       mov	bp,sp
30626 8CCD           4C                         dec	sp
30627 8CCE           4C                         dec	sp
30628                                           ! Debug: list int = const $10 (used reg = )
30629 8CCF           B8                   0010  mov	ax,*$10
30630 8CD2           50                         push	ax
30631                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30632 8CD3           E8         78AD            call	_inb_cmos
30633 8CD6           44                         inc	sp
30634 8CD7           44                         inc	sp
30635                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
30636 8CD8           8846         FF            mov	-1[bp],al
30637                                           !BCC_EOS
30638                                           ! 4518   if (drive == 0)
30639                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
30640 8CDB           8B46         04            mov	ax,4[bp]
30641 8CDE           85C0                       test	ax,ax
30642 8CE0           75           0E            jne 	.65B
30643                       00008CE2            .65C:
30644                                           ! 4519     drive_type >>= 4;
30645                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
30646 8CE2           8A46         FF            mov	al,-1[bp]
30647 8CE5           30E4                       xor	ah,ah
30648 8CE7           B1                     04  mov	cl,*4
30649 8CE9           D3E8                       shr	ax,cl
30650 8CEB           8846         FF            mov	-1[bp],al
30651                                           !BCC_EOS
30652                                           ! 4520   else
30653                                           ! 4521     drive_type &= 0x0f;
30654 8CEE           EB           08            jmp .65D
30655                       00008CF0            .65B:
30656                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
30657 8CF0           8A46         FF            mov	al,-1[bp]
30658 8CF3           24                     0F  and	al,*$F
30659 8CF5           8846         FF            mov	-1[bp],al
30660                                           !BCC_EOS
30661                                           ! 4522   if ( drive_type == 0 )
30662                       00008CF8            .65D:
30663                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
30664 8CF8           8A46         FF            mov	al,-1[bp]
30665 8CFB           84C0                       test	al,al
30666 8CFD           75           08            jne 	.65E
30667                       00008CFF            .65F:
30668                                           ! 4523     return(0);
30669 8CFF           31C0                       xor	ax,ax
30670 8D01           89EC                       mov	sp,bp
30671 8D03           5D                         pop	bp
30672 8D04           C3                         ret
30673                                           !BCC_EOS
30674                                           ! 4524   else
30675                                           ! 4525     return(1);
30676 8D05           EB           07            jmp .660
30677                       00008D07            .65E:
30678 8D07           B8                   0001  mov	ax,*1
30679 8D0A           89EC                       mov	sp,bp
30680 8D0C           5D                         pop	bp
30681 8D0D           C3                         ret
30682                                           !BCC_EOS
30683                                           ! 4526 }
30684                       00008D0E            .660:
30685 8D0E           89EC                       mov	sp,bp
30686 8D10           5D                         pop	bp
30687 8D11           C3                         ret
30688                                           ! 4527   void
30689                                           ! 4528 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
30690                                           ! 4529   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
30691                                           export	_int13_diskette_function
30692                       00008D12            _int13_diskette_function:
30693                                           !BCC_EOS
30694                                           ! 4530 {
30695                                           ! 4531   Bit8u drive, num_sectors, track, sector, head, status;
30696                                           !BCC_EOS
30697                                           ! 4532   Bit16u base_address, base_count, base_es;
30698                                           !BCC_EOS
30699                                           ! 4533   Bit8u page, mode_register, val8, dor;
30700                                           !BCC_EOS
30701                                           ! 4534   Bit8u return_status[7];
30702                                           !BCC_EOS
30703                                           ! 4535   Bit8u drive_type, num_floppies, ah;
30704                                           !BCC_EOS
30705                                           ! 4536   Bit16u es, last_addr;
30706                                           !BCC_EOS
30707                                           ! 4537   ;
30708 8D12           55                         push	bp
30709 8D13           89E5                       mov	bp,sp
30710 8D15           83C4                   E2  add	sp,*-$1E
30711                                           !BCC_EOS
30712                                           ! 4538   ah = ( AX >> 8 );
30713                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
30714 8D18           8B46         16            mov	ax,$16[bp]
30715 8D1B           88E0                       mov	al,ah
30716 8D1D           30E4                       xor	ah,ah
30717                                           ! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
30718 8D1F           8846         E6            mov	-$1A[bp],al
30719                                           !BCC_EOS
30720                                           ! 4539   switch ( ah ) {
30721 8D22           8A46         E6            mov	al,-$1A[bp]
30722 8D25           E9         109F            br 	.663
30723                                           ! 4540     case 0x00:
30724                                           ! 4541 ;
30725                       00008D28            .664:
30726                                           !BCC_EOS
30727                                           ! 4542       drive = ( ELDX & 0x00ff );
30728                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
30729 8D28           8A46         0E            mov	al,$E[bp]
30730                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
30731 8D2B           8846         FF            mov	-1[bp],al
30732                                           !BCC_EOS
30733                                           ! 4543       if (drive > 1) {
30734                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
30735 8D2E           8A46         FF            mov	al,-1[bp]
30736 8D31           3C                     01  cmp	al,*1
30737 8D33           76           20            jbe 	.665
30738                       00008D35            .666:
30739                                           ! 4544         AX = ((AX & 0x00ff) | ((1) << 8));
30740                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30741 8D35           8A46         16            mov	al,$16[bp]
30742                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
30743 8D38           30E4                       xor	ah,ah
30744 8D3A           0D                   0100  or	ax,#$100
30745                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30746 8D3D           8946         16            mov	$16[bp],ax
30747                                           !BCC_EOS
30748                                           ! 4545         set_diskette_ret_status(1);
30749                                           ! Debug: list int = const 1 (used reg = )
30750 8D40           B8                   0001  mov	ax,*1
30751 8D43           50                         push	ax
30752                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30753 8D44           E8         10C3            call	_set_diskette_ret_status
30754 8D47           44                         inc	sp
30755 8D48           44                         inc	sp
30756                                           !BCC_EOS
30757                                           ! 4546         FLAGS |= 0x0001;
30758                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30759 8D49           8B46         1C            mov	ax,$1C[bp]
30760 8D4C           0C                     01  or	al,*1
30761 8D4E           8946         1C            mov	$1C[bp],ax
30762                                           !BCC_EOS
30763                                           ! 4547         return;
30764 8D51           89EC                       mov	sp,bp
30765 8D53           5D                         pop	bp
30766 8D54           C3                         ret
30767                                           !BCC_EOS
30768                                           ! 4548       }
30769                                           ! 4549       drive_type = inb_cmos(0x10);
30770                       00008D55            .665:
30771                                           ! Debug: list int = const $10 (used reg = )
30772 8D55           B8                   0010  mov	ax,*$10
30773 8D58           50                         push	ax
30774                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30775 8D59           E8         7827            call	_inb_cmos
30776 8D5C           44                         inc	sp
30777 8D5D           44                         inc	sp
30778                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30779 8D5E           8846         E8            mov	-$18[bp],al
30780                                           !BCC_EOS
30781                                           ! 4550       if (drive == 0)
30782                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
30783 8D61           8A46         FF            mov	al,-1[bp]
30784 8D64           84C0                       test	al,al
30785 8D66           75           0E            jne 	.667
30786                       00008D68            .668:
30787                                           ! 4551         drive_type >>= 4;
30788                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30789 8D68           8A46         E8            mov	al,-$18[bp]
30790 8D6B           30E4                       xor	ah,ah
30791 8D6D           B1                     04  mov	cl,*4
30792 8D6F           D3E8                       shr	ax,cl
30793 8D71           8846         E8            mov	-$18[bp],al
30794                                           !BCC_EOS
30795                                           ! 4552       else
30796                                           ! 4553         drive_type &= 0x0f;
30797 8D74           EB           08            jmp .669
30798                       00008D76            .667:
30799                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
30800 8D76           8A46         E8            mov	al,-$18[bp]
30801 8D79           24                     0F  and	al,*$F
30802 8D7B           8846         E8            mov	-$18[bp],al
30803                                           !BCC_EOS
30804                                           ! 4554       if (drive_type == 0) {
30805                       00008D7E            .669:
30806                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30807 8D7E           8A46         E8            mov	al,-$18[bp]
30808 8D81           84C0                       test	al,al
30809 8D83           75           20            jne 	.66A
30810                       00008D85            .66B:
30811                                           ! 4555         AX = ((AX & 0x00ff) | ((0x80) << 8));
30812                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30813 8D85           8A46         16            mov	al,$16[bp]
30814                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
30815 8D88           30E4                       xor	ah,ah
30816 8D8A           0D                   8000  or	ax,#-$8000
30817                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30818 8D8D           8946         16            mov	$16[bp],ax
30819                                           !BCC_EOS
30820                                           ! 4556         set_diskette_ret_status(0x80);
30821                                           ! Debug: list int = const $80 (used reg = )
30822 8D90           B8                   0080  mov	ax,#$80
30823 8D93           50                         push	ax
30824                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30825 8D94           E8         1073            call	_set_diskette_ret_status
30826 8D97           44                         inc	sp
30827 8D98           44                         inc	sp
30828                                           !BCC_EOS
30829                                           ! 4557         FLAGS |= 0x0001;
30830                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30831 8D99           8B46         1C            mov	ax,$1C[bp]
30832 8D9C           0C                     01  or	al,*1
30833 8D9E           8946         1C            mov	$1C[bp],ax
30834                                           !BCC_EOS
30835                                           ! 4558         return;
30836 8DA1           89EC                       mov	sp,bp
30837 8DA3           5D                         pop	bp
30838 8DA4           C3                         ret
30839                                           !BCC_EOS
30840                                           ! 4559       }
30841                                           ! 4560       AX = ((AX & 0x00ff) | ((0) << 8));
30842                       00008DA5            .66A:
30843                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30844 8DA5           8A46         16            mov	al,$16[bp]
30845                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
30846 8DA8           0C                     00  or	al,*0
30847                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
30848 8DAA           30E4                       xor	ah,ah
30849 8DAC           8946         16            mov	$16[bp],ax
30850                                           !BCC_EOS
30851                                           ! 4561       set_diskette_ret_sta
30852                                           ! 4561 tus(0);
30853                                           ! Debug: list int = const 0 (used reg = )
30854 8DAF           31C0                       xor	ax,ax
30855 8DB1           50                         push	ax
30856                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30857 8DB2           E8         1055            call	_set_diskette_ret_status
30858 8DB5           44                         inc	sp
30859 8DB6           44                         inc	sp
30860                                           !BCC_EOS
30861                                           ! 4562       FLAGS &= 0xfffe;
30862                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30863 8DB7           8B46         1C            mov	ax,$1C[bp]
30864 8DBA           24                     FE  and	al,#$FE
30865 8DBC           8946         1C            mov	$1C[bp],ax
30866                                           !BCC_EOS
30867                                           ! 4563       set_diskette_current_cyl(drive, 0);
30868                                           ! Debug: list int = const 0 (used reg = )
30869 8DBF           31C0                       xor	ax,ax
30870 8DC1           50                         push	ax
30871                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
30872 8DC2           8A46         FF            mov	al,-1[bp]
30873 8DC5           30E4                       xor	ah,ah
30874 8DC7           50                         push	ax
30875                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
30876 8DC8           E8         1057            call	_set_diskette_current_cyl
30877 8DCB           83C4                   04  add	sp,*4
30878                                           !BCC_EOS
30879                                           ! 4564       return;
30880 8DCE           89EC                       mov	sp,bp
30881 8DD0           5D                         pop	bp
30882 8DD1           C3                         ret
30883                                           !BCC_EOS
30884                                           ! 4565     case 0x01:
30885                                           ! 4566       FLAGS &= 0xfffe;
30886                       00008DD2            .66C:
30887                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30888 8DD2           8B46         1C            mov	ax,$1C[bp]
30889 8DD5           24                     FE  and	al,#$FE
30890 8DD7           8946         1C            mov	$1C[bp],ax
30891                                           !BCC_EOS
30892                                           ! 4567       val8 = read_byte(0x0000, 0x0441);
30893                                           ! Debug: list int = const $441 (used reg = )
30894 8DDA           B8                   0441  mov	ax,#$441
30895 8DDD           50                         push	ax
30896                                           ! Debug: list int = const 0 (used reg = )
30897 8DDE           31C0                       xor	ax,ax
30898 8DE0           50                         push	ax
30899                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30900 8DE1           E8         7810            call	_read_byte
30901 8DE4           83C4                   04  add	sp,*4
30902                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
30903 8DE7           8846         F1            mov	-$F[bp],al
30904                                           !BCC_EOS
30905                                           ! 4568       AX = ((AX & 0x00ff) | ((val8) << 8));
30906                                           ! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
30907 8DEA           8A46         F1            mov	al,-$F[bp]
30908 8DED           30E4                       xor	ah,ah
30909 8DEF           88C4                       mov	ah,al
30910 8DF1           30C0                       xor	al,al
30911 8DF3           50                         push	ax
30912                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
30913 8DF4           8A46         16            mov	al,$16[bp]
30914                                           ! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
30915 8DF7           30E4                       xor	ah,ah
30916 8DF9           0B46         E0            or	ax,0+..FFDC[bp]
30917 8DFC           44                         inc	sp
30918 8DFD           44                         inc	sp
30919                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30920 8DFE           8946         16            mov	$16[bp],ax
30921                                           !BCC_EOS
30922                                           ! 4569       if (val8) {
30923 8E01           8A46         F1            mov	al,-$F[bp]
30924 8E04           84C0                       test	al,al
30925 8E06           74           08            je  	.66D
30926                       00008E08            .66E:
30927                                           ! 4570         FLAGS |= 0x0001;
30928                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30929 8E08           8B46         1C            mov	ax,$1C[bp]
30930 8E0B           0C                     01  or	al,*1
30931 8E0D           8946         1C            mov	$1C[bp],ax
30932                                           !BCC_EOS
30933                                           ! 4571       }
30934                                           ! 4572       return;
30935                       00008E10            .66D:
30936 8E10           89EC                       mov	sp,bp
30937 8E12           5D                         pop	bp
30938 8E13           C3                         ret
30939                                           !BCC_EOS
30940                                           ! 4573     case 0x02:
30941                                           ! 4574     case 0x03:
30942                       00008E14            .66F:
30943                                           ! 4575     case 0x04:
30944                       00008E14            .670:
30945                                           ! 4576       num_sectors = ( AX & 0x00ff );
30946                       00008E14            .671:
30947                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30948 8E14           8A46         16            mov	al,$16[bp]
30949                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
30950 8E17           8846         FE            mov	-2[bp],al
30951                                           !BCC_EOS
30952                                           ! 4577       track = ( CX >> 8 );
30953                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
30954 8E1A           8B46         14            mov	ax,$14[bp]
30955 8E1D           88E0                       mov	al,ah
30956 8E1F           30E4                       xor	ah,ah
30957                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
30958 8E21           8846         FD            mov	-3[bp],al
30959                                           !BCC_EOS
30960                                           ! 4578       sector = ( CX & 0x00ff );
30961                                           ! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
30962 8E24           8A46         14            mov	al,$14[bp]
30963                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
30964 8E27           8846         FC            mov	-4[bp],al
30965                                           !BCC_EOS
30966                                           ! 4579       head = ( DX >> 8 );
30967                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
30968 8E2A           8B46         12            mov	ax,$12[bp]
30969 8E2D           88E0                       mov	al,ah
30970 8E2F           30E4                       xor	ah,ah
30971                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
30972 8E31           8846         FB            mov	-5[bp],al
30973                                           !BCC_EOS
30974                                           ! 4580       drive = ( ELDX & 0x00ff );
30975                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
30976 8E34           8A46         0E            mov	al,$E[bp]
30977                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
30978 8E37           8846         FF            mov	-1[bp],al
30979                                           !BCC_EOS
30980                                           ! 4581       if ((drive > 1) || (head > 1) || (sector == 0) ||
30981                                           ! 4582           (num_sectors == 0) || (num_sectors > 72)) {
30982                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
30983 8E3A           8A46         FF            mov	al,-1[bp]
30984 8E3D           3C                     01  cmp	al,*1
30985 8E3F           77           1C            ja  	.673
30986                       00008E41            .677:
30987                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
30988 8E41           8A46         FB            mov	al,-5[bp]
30989 8E44           3C                     01  cmp	al,*1
30990 8E46           77           15            ja  	.673
30991                       00008E48            .676:
30992                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
30993 8E48           8A46         FC            mov	al,-4[bp]
30994 8E4B           84C0                       test	al,al
30995 8E4D           74           0E            je  	.673
30996                       00008E4F            .675:
30997                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
30998 8E4F           8A46         FE            mov	al,-2[bp]
30999 8E52           84C0                       test	al,al
31000 8E54           74           07            je  	.673
31001                       00008E56            .674:
31002                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
31003 8E56           8A46         FE            mov	al,-2[bp]
31004 8E59           3C                     48  cmp	al,*$48
31005 8E5B           76           2A            jbe 	.672
31006                       00008E5D            .673:
31007                                           ! 4583         ;
31008                                           !BCC_EOS
31009                                           ! 4584         AX = ((AX & 0x00ff) | ((1) << 8));
31010                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31011 8E5D           8A46         16            mov	al,$16[bp]
31012                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31013 8E60           30E4                       xor	ah,ah
31014 8E62           0D                   0100  or	ax,#$100
31015                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31016 8E65           8946         16            mov	$16[bp],ax
31017                                           !BCC_EOS
31018                                           ! 4585         set_diskette_ret_status(1);
31019                                           ! Debug: list int = const 1 (used reg = )
31020 8E68           B8                   0001  mov	ax,*1
31021 8E6B           50                         push	ax
31022                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31023 8E6C           E8         0F9B            call	_set_diskette_ret_status
31024 8E6F           44                         inc	sp
31025 8E70           44                         inc	sp
31026                                           !BCC_EOS
31027                                           ! 4586         AX = ((AX & 0xff00) | (0));
31028                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31029 8E71           8B46         16            mov	ax,$16[bp]
31030 8E74           30C0                       xor	al,al
31031                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31032 8E76           0C                     00  or	al,*0
31033                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31034 8E78           8946         16            mov	$16[bp],ax
31035                                           !BCC_EOS
31036                                           ! 4587         FLAGS |= 0x0001;
31037                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31038 8E7B           8B46         1C            mov	ax,$1C[bp]
31039 8E7E           0C                     01  or	al,*1
31040 8E80           8946         1C            mov	$1C[bp],ax
31041                                           !BCC_EOS
31042                                           ! 4588         return;
31043 8E83           89EC                       mov	sp,bp
31044 8E85           5D                         pop	bp
31045 8E86           C3                         ret
31046                                           !BCC_EOS
31047                                           ! 4589       }
31048                                           ! 4590       if (floppy_drive_exists(drive) == 0) {
31049                       00008E87            .672:
31050                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31051 8E87           8A46         FF            mov	al,-1[bp]
31052 8E8A           30E4                       xor	ah,ah
31053 8E8C           50                         push	ax
31054                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
31055 8E8D           E8         FE3A            call	_floppy_drive_exists
31056 8E90           44                         inc	sp
31057 8E91           44                         inc	sp
31058                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31059 8E92           85C0                       test	ax,ax
31060 8E94           75           2A            jne 	.678
31061                       00008E96            .679:
31062                                           ! 4591         AX = ((AX & 0x00ff) | ((0x80) << 8));
31063                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31064 8E96           8A46         16            mov	al,$16[bp]
31065                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31066 8E99           30E4                       xor	ah,ah
31067 8E9B           0D                   8000  or	ax,#-$8000
31068                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31069 8E9E           8946         16            mov	$16[bp],ax
31070                                           !BCC_EOS
31071                                           ! 4592         set_diskette_ret_status(0x80);
31072                                           ! Debug: list int = const $80 (used reg = )
31073 8EA1           B8                   0080  mov	ax,#$80
31074 8EA4           50                         push	ax
31075                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31076 8EA5           E8         0F62            call	_set_diskette_ret_status
31077 8EA8           44                         inc	sp
31078 8EA9           44                         inc	sp
31079                                           !BCC_EOS
31080                                           ! 4593         AX = ((AX & 0xff00) | (0));
31081                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31082 8EAA           8B46         16            mov	ax,$16[bp]
31083 8EAD           30C0                       xor	al,al
31084                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31085 8EAF           0C                     00  or	al,*0
31086                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31087 8EB1           8946         16            mov	$16[bp],ax
31088                                           !BCC_EOS
31089                                           ! 4594         FLAGS |= 0x0001;
31090                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31091 8EB4           8B46         1C            mov	ax,$1C[bp]
31092 8EB7           0C                     01  or	al,*1
31093 8EB9           8946         1C            mov	$1C[bp],ax
31094                                           !BCC_EOS
31095                                           ! 4595         return;
31096 8EBC           89EC                       mov	sp,bp
31097 8EBE           5D                         pop	bp
31098 8EBF           C3                         ret
31099                                           !BCC_EOS
31100                                           ! 4596       }
31101                                           ! 4597       if (floppy_media_known(drive) == 0) {
31102                       00008EC0            .678:
31103                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31104 8EC0           8A46         FF            mov	al,-1[bp]
31105 8EC3           30E4                       xor	ah,ah
31106 8EC5           50                         push	ax
31107                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
31108 8EC6           E8         FB6C            call	_floppy_media_known
31109 8EC9           44                         inc	sp
31110 8ECA           44                         inc	sp
31111                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31112 8ECB           85C0                       test	ax,ax
31113 8ECD           75           39            jne 	.67A
31114                       00008ECF            .67B:
31115                                           ! 4598         if (floppy_media_sense(drive) == 0) {
31116                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31117 8ECF           8A46         FF            mov	al,-1[bp]
31118 8ED2           30E4                       xor	ah,ah
31119 8ED4           50                         push	ax
31120                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
31121 8ED5           E8         FBE0            call	_floppy_media_sense
31122 8ED8           44                         inc	sp
31123 8ED9           44                         inc	sp
31124                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31125 8EDA           85C0                       test	ax,ax
31126 8EDC           75           2A            jne 	.67C
31127                       00008EDE            .67D:
31128                                           ! 4599           AX = ((AX & 0x00ff) | ((0x0C) << 8));
31129                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31130 8EDE           8A46         16            mov	al,$16[bp]
31131                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
31132 8EE1           30E4                       xor	ah,ah
31133 8EE3           0D                   0C00  or	ax,#$C00
31134                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31135 8EE6           8946         16            mov	$16[bp],ax
31136                                           !BCC_EOS
31137                                           ! 4600           set_diskette_ret_status(0x0C);
31138                                           ! Debug: list int = const $C (used reg = )
31139 8EE9           B8                   000C  mov	ax,*$C
31140 8EEC           50                         push	ax
31141                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31142 8EED           E8         0F1A            call	_set_diskette_ret_status
31143 8EF0           44                         inc	sp
31144 8EF1           44                         inc	sp
31145                                           !BCC_EOS
31146                                           ! 4601           AX = ((AX & 0xff00) | (0));
31147                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31148 8EF2           8B46         16            mov	ax,$16[bp]
31149 8EF5           30C0                       xor	al,al
31150                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31151 8EF7           0C                     00  or	al,*0
31152                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31153 8EF9           8946         16            mov	$16[bp],ax
31154                                           !BCC_EOS
31155                                           ! 4602           FLAGS |= 0x0001;
31156                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31157 8EFC           8B46         1C            mov	ax,$1C[bp]
31158 8EFF           0C                     01  or	al,*1
31159 8F01           8946         1C            mov	$1C[bp],ax
31160                                           !BCC_EOS
31161                                           ! 4603           return;
31162 8F04           89EC                       mov	sp,bp
31163 8F06           5D                         pop	bp
31164 8F07           C3                         ret
31165                                           !BCC_EOS
31166                                           ! 4604         }
31167                                           ! 4605       }
31168                       00008F08            .67C:
31169                                           ! 4606       if (ah == 0x02) {
31170                       00008F08            .67A:
31171                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
31172 8F08           8A46         E6            mov	al,-$1A[bp]
31173 8F0B           3C                     02  cmp	al,*2
31174 8F0D         0F85         03B4            bne 	.67E
31175                       00008F11            .67F:
31176                                           ! 4607         page = (ES >> 12);
31177                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
31178 8F11           8B46         06            mov	ax,6[bp]
31179 8F14           88E0                       mov	al,ah
31180 8F16           30E4                       xor	ah,ah
31181 8F18           B1                     04  mov	cl,*4
31182 8F1A           D3E8                       shr	ax,cl
31183                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
31184 8F1C           8846         F3            mov	-$D[bp],al
31185                                           !BCC_EOS
31186                                           ! 4608         base_es = (ES << 4);
31187                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
31188 8F1F           8B46         06            mov	ax,6[bp]
31189 8F22           B1                     04  mov	cl,*4
31190 8F24           D3E0                       shl	ax,cl
31191                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
31192 8F26           8946         F4            mov	-$C[bp],ax
31193                                           !BCC_EOS
31194                                           ! 4609         base_address = base_es + BX;
31195                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
31196 8F29           8B46         F4            mov	ax,-$C[bp]
31197 8F2C           0346         10            add	ax,$10[bp]
31198                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
31199 8F2F           8946         F8            mov	-8[bp],ax
31200                                           !BCC_EOS
31201                                           ! 4610         if ( base_address < base_es ) {
31202                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
31203 8F32           8B46         F8            mov	ax,-8[bp]
31204 8F35           3B46         F4            cmp	ax,-$C[bp]
31205 8F38           73           07            jae 	.680
31206                       00008F3A            .681:
31207                                           ! 4611           page++;
31208                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
31209 8F3A           8A46         F3            mov	al,-$D[bp]
31210 8F3D           40                         inc	ax
31211 8F3E           8846         F3            mov	-$D[bp],al
31212                                           !BCC_EOS
31213                                           ! 4612         }
31214                                           ! 4613         base_count = (num_sectors * 512) - 1;
31215                       00008F41            .680:
31216                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
31217 8F41           8A46         FE            mov	al,-2[bp]
31218 8F44           30E4                       xor	ah,ah
31219 8F46           B9                   0200  mov	cx,#$200
31220 8F49           F7E9                       imul	cx
31221                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
31222                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
31223 8F4B           48                         dec	ax
31224 8F4C           8946         F6            mov	-$A[bp],ax
31225                                           !BCC_EOS
31226                                           ! 4614         last_addr = base_address + base_count;
31227                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
31228 8F4F           8B46         F8            mov	ax,-8[bp]
31229 8F52           0346         F6            add	ax,-$A[bp]
31230                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
31231 8F55           8946         E2            mov	-$1E[bp],ax
31232                                           !BCC_EOS
31233                                           ! 4615         if (last_addr < base_address) {
31234                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
31235 8F58           8B46         E2            mov	ax,-$1E[bp]
31236 8F5B           3B46         F8            cmp	ax,-8[bp]
31237 8F5E           73           2A            jae 	.682
31238                       00008F60            .683:
31239                                           ! 4616           AX = ((AX & 0x00ff) | ((0x09) << 8));
31240                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31241 8F60           8A46         16            mov	al,$16[bp]
31242                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
31243 8F63           30E4                       xor	ah,ah
31244 8F65           0D                   0900  or	ax,#$900
31245                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31246 8F68           8946         16            mov	$16[bp],ax
31247                                           !BCC_EOS
31248                                           ! 4617           set_diskette_ret_status(0x09);
31249                                           ! Debug: list int = const 9 (used reg = )
31250 8F6B           B8                   0009  mov	ax,*9
31251 8F6E           50                         push	ax
31252                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31253 8F6F           E8         0E98            call	_set_diskette_ret_status
31254 8F72           44                         inc	sp
31255 8F73           44                         inc	sp
31256                                           !BCC_EOS
31257                                           ! 4618           AX = ((AX & 0xff00) | (0));
31258                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31259 8F74           8B46         16            mov	ax,$16[bp]
31260 8F77           30C0                       xor	al,al
31261                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31262 8F79           0C                     00  or	al,*0
31263                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31264 8F7B           8946         16            mov	$16[bp],ax
31265                                           !BCC_EOS
31266                                           ! 4619           FLAGS |= 0x0001;
31267                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31268 8F7E           8B46         1C            mov	ax,$1C[bp]
31269 8F81           0C                     01  or	al,*1
31270 8F83           8946         1C            mov	$1C[bp],ax
31271                                           !BCC_EOS
31272                                           ! 4620           return;
31273 8F86           89EC                       mov	sp,bp
31274 8F88           5D                         pop	bp
31275 8F89           C3                         ret
31276                                           !BCC_EOS
31277                                           ! 4621         }
31278                                           ! 4622         ;
31279                       00008F8A            .682:
31280                                           !BCC_EOS
31281                                           ! 4623         outb(0x000a, 0x06);
31282                                           ! Debug: list int = const 6 (used reg = )
31283 8F8A           B8                   0006  mov	ax,*6
31284 8F8D           50                         push	ax
31285                                           ! Debug: list int = const $A (used reg = )
31286 8F8E           B8                   000A  mov	ax,*$A
31287 8F91           50                         push	ax
31288                                           ! Debug: func () void = outb+0 (used reg = )
31289 8F92           E8         75BF            call	_outb
31290 8F95           83C4                   04  add	sp,*4
31291                                           !BCC_EOS
31292                                           ! 4624   ;
31293                                           !BCC_EOS
31294                                           ! 4625         outb(0x000c, 0x00);
31295                                           ! Debug: list int = const 0 (used reg = )
31296 8F98           31C0                       xor	ax,ax
31297 8F9A           50                         push	ax
31298                                           ! Debug: list int = const $C (used reg = )
31299 8F9B           B8                   000C  mov	ax,*$C
31300 8F9E           50                         push	ax
31301                                           ! Debug: func () void = outb+0 (used reg = )
31302 8F9F           E8         75B2            call	_outb
31303 8FA2           83C4                   04  add	sp,*4
31304                                           !BCC_EOS
31305                                           ! 4626         outb(0x0004, base_address);
31306                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
31307 8FA5           FF76         F8            push	-8[bp]
31308                                           ! Debug: list int = const 4 (used reg = )
31309 8FA8           B8                   0004  mov	ax,*4
31310 8FAB           50                         push	ax
31311                                           ! Debug: func () void = outb+0 (used reg = )
31312 8FAC           E8         75A5            call	_outb
31313 8FAF           83C4                   04  add	sp,*4
31314                                           !BCC_EOS
31315                                           ! 4627         outb(0x0004, base_address>>8);
31316                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
31317 8FB2           8B46         F8            mov	ax,-8[bp]
31318 8FB5           88E0                       mov	al,ah
31319 8FB7           30E4                       xor	ah,ah
31320                                           ! Debug: list unsigned int = ax+0 (used reg = )
31321 8FB9           50                         push	ax
31322                                           ! Debug: list int = const 4 (used reg = )
31323 8FBA           B8                   0004  mov	ax,*4
31324 8FBD           50                         push	ax
31325                                           ! Debug: func () void = outb+0 (used reg = )
31326 8FBE           E8         7593            call	_outb
31327 8FC1           83C4                   04  add	sp,*4
31328                                           !BCC_EOS
31329                                           ! 4628   ;
31330                                           !BCC_EOS
31331                                           ! 4629         outb(0x000c, 0x00);
31332                                           ! Debug: list int = const 0 (used reg = )
31333 8FC4           31C0                       xor	ax,ax
31334 8FC6           50                         push	ax
31335                                           ! Debug: list int = const $C (used reg = )
31336 8FC7           B8                   000C  mov	ax,*$C
31337 8FCA           50                         push	ax
31338                                           ! Debug: func () void = outb+0 (used reg = )
31339 8FCB           E8         7586            call	_outb
31340 8FCE           83C4                   04  add	sp,*4
31341                                           !BCC_EOS
31342                                           ! 4630         outb(0x0005, base_count);
31343                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
31344 8FD1           FF76         F6            push	-$A[bp]
31345                                           ! Debug: list int = const 5 (used reg = )
31346 8FD4           B8                   0005  mov	ax,*5
31347 8FD7           50                         push	ax
31348                                           ! Debug: func () void = outb+0 (used reg = )
31349 8FD8           E8         7579            call	_outb
31350 8FDB           83C4                   04  add	sp,*4
31351                                           !BCC_EOS
31352                                           ! 4631         outb(0x0005, base_count>>8);
31353                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
31354 8FDE           8B46         F6            mov	ax,-$A[bp]
31355 8FE1           88E0                       mov	al,ah
31356 8FE3           30E4                       xor	ah,ah
31357                                           ! Debug: list unsigned int = ax+0 (used reg = )
31358 8FE5           50                         push	ax
31359                                           ! Debug: list int = const 5 (used reg = )
31360 8FE6           B8                   0005  mov	ax,*5
31361 8FE9           50                         push	ax
31362                                           ! Debug: func () void = outb+0 (used reg = )
31363 8FEA           E8         7567            call	_outb
31364 8FED           83C4                   04  add	sp,*4
31365                                           !BCC_EOS
31366                                           ! 4632         mode_register = 0x46;
31367                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
31368 8FF0           B0                     46  mov	al,*$46
31369 8FF2           8846         F2            mov	-$E[bp],al
31370                                           !BCC_EOS
31371                                           ! 4633   ;
31372                                           !BCC_EOS
31373                                           ! 4634         outb(
31374                                           ! 4634 0x000b, mode_register);
31375                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
31376 8FF5           8A46         F2            mov	al,-$E[bp]
31377 8FF8           30E4                       xor	ah,ah
31378 8FFA           50                         push	ax
31379                                           ! Debug: list int = const $B (used reg = )
31380 8FFB           B8                   000B  mov	ax,*$B
31381 8FFE           50                         push	ax
31382                                           ! Debug: func () void = outb+0 (used reg = )
31383 8FFF           E8         7552            call	_outb
31384 9002           83C4                   04  add	sp,*4
31385                                           !BCC_EOS
31386                                           ! 4635   ;
31387                                           !BCC_EOS
31388                                           ! 4636         outb(0x0081, page);
31389                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
31390 9005           8A46         F3            mov	al,-$D[bp]
31391 9008           30E4                       xor	ah,ah
31392 900A           50                         push	ax
31393                                           ! Debug: list int = const $81 (used reg = )
31394 900B           B8                   0081  mov	ax,#$81
31395 900E           50                         push	ax
31396                                           ! Debug: func () void = outb+0 (used reg = )
31397 900F           E8         7542            call	_outb
31398 9012           83C4                   04  add	sp,*4
31399                                           !BCC_EOS
31400                                           ! 4637   ;
31401                                           !BCC_EOS
31402                                           ! 4638         outb(0x000a, 0x02);
31403                                           ! Debug: list int = const 2 (used reg = )
31404 9015           B8                   0002  mov	ax,*2
31405 9018           50                         push	ax
31406                                           ! Debug: list int = const $A (used reg = )
31407 9019           B8                   000A  mov	ax,*$A
31408 901C           50                         push	ax
31409                                           ! Debug: func () void = outb+0 (used reg = )
31410 901D           E8         7534            call	_outb
31411 9020           83C4                   04  add	sp,*4
31412                                           !BCC_EOS
31413                                           ! 4639         ;
31414                                           !BCC_EOS
31415                                           ! 4640         outb(0x000a, 0x02);
31416                                           ! Debug: list int = const 2 (used reg = )
31417 9023           B8                   0002  mov	ax,*2
31418 9026           50                         push	ax
31419                                           ! Debug: list int = const $A (used reg = )
31420 9027           B8                   000A  mov	ax,*$A
31421 902A           50                         push	ax
31422                                           ! Debug: func () void = outb+0 (used reg = )
31423 902B           E8         7526            call	_outb
31424 902E           83C4                   04  add	sp,*4
31425                                           !BCC_EOS
31426                                           ! 4641         floppy_prepare_controller(drive);
31427                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31428 9031           8A46         FF            mov	al,-1[bp]
31429 9034           30E4                       xor	ah,ah
31430 9036           50                         push	ax
31431                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
31432 9037           E8         F91C            call	_floppy_prepare_controller
31433 903A           44                         inc	sp
31434 903B           44                         inc	sp
31435                                           !BCC_EOS
31436                                           ! 4642         outb(0x03f5, 0xe6);
31437                                           ! Debug: list int = const $E6 (used reg = )
31438 903C           B8                   00E6  mov	ax,#$E6
31439 903F           50                         push	ax
31440                                           ! Debug: list int = const $3F5 (used reg = )
31441 9040           B8                   03F5  mov	ax,#$3F5
31442 9043           50                         push	ax
31443                                           ! Debug: func () void = outb+0 (used reg = )
31444 9044           E8         750D            call	_outb
31445 9047           83C4                   04  add	sp,*4
31446                                           !BCC_EOS
31447                                           ! 4643         outb(0x03f5, (head << 2) | drive);
31448                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
31449 904A           8A46         FB            mov	al,-5[bp]
31450 904D           30E4                       xor	ah,ah
31451 904F           D1E0                       shl	ax,*1
31452 9051           D1E0                       shl	ax,*1
31453                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
31454 9053           0A46         FF            or	al,-1[bp]
31455                                           ! Debug: list unsigned int = ax+0 (used reg = )
31456 9056           50                         push	ax
31457                                           ! Debug: list int = const $3F5 (used reg = )
31458 9057           B8                   03F5  mov	ax,#$3F5
31459 905A           50                         push	ax
31460                                           ! Debug: func () void = outb+0 (used reg = )
31461 905B           E8         74F6            call	_outb
31462 905E           83C4                   04  add	sp,*4
31463                                           !BCC_EOS
31464                                           ! 4644         outb(0x03f5, track);
31465                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
31466 9061           8A46         FD            mov	al,-3[bp]
31467 9064           30E4                       xor	ah,ah
31468 9066           50                         push	ax
31469                                           ! Debug: list int = const $3F5 (used reg = )
31470 9067           B8                   03F5  mov	ax,#$3F5
31471 906A           50                         push	ax
31472                                           ! Debug: func () void = outb+0 (used reg = )
31473 906B           E8         74E6            call	_outb
31474 906E           83C4                   04  add	sp,*4
31475                                           !BCC_EOS
31476                                           ! 4645         outb(0x03f5, head);
31477                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
31478 9071           8A46         FB            mov	al,-5[bp]
31479 9074           30E4                       xor	ah,ah
31480 9076           50                         push	ax
31481                                           ! Debug: list int = const $3F5 (used reg = )
31482 9077           B8                   03F5  mov	ax,#$3F5
31483 907A           50                         push	ax
31484                                           ! Debug: func () void = outb+0 (used reg = )
31485 907B           E8         74D6            call	_outb
31486 907E           83C4                   04  add	sp,*4
31487                                           !BCC_EOS
31488                                           ! 4646         outb(0x03f5, sector);
31489                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
31490 9081           8A46         FC            mov	al,-4[bp]
31491 9084           30E4                       xor	ah,ah
31492 9086           50                         push	ax
31493                                           ! Debug: list int = const $3F5 (used reg = )
31494 9087           B8                   03F5  mov	ax,#$3F5
31495 908A           50                         push	ax
31496                                           ! Debug: func () void = outb+0 (used reg = )
31497 908B           E8         74C6            call	_outb
31498 908E           83C4                   04  add	sp,*4
31499                                           !BCC_EOS
31500                                           ! 4647         outb(0x03f5, 2);
31501                                           ! Debug: list int = const 2 (used reg = )
31502 9091           B8                   0002  mov	ax,*2
31503 9094           50                         push	ax
31504                                           ! Debug: list int = const $3F5 (used reg = )
31505 9095           B8                   03F5  mov	ax,#$3F5
31506 9098           50                         push	ax
31507                                           ! Debug: func () void = outb+0 (used reg = )
31508 9099           E8         74B8            call	_outb
31509 909C           83C4                   04  add	sp,*4
31510                                           !BCC_EOS
31511                                           ! 4648         outb(0x03f5, sector + num_sectors - 1);
31512                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
31513 909F           8A46         FC            mov	al,-4[bp]
31514 90A2           30E4                       xor	ah,ah
31515 90A4           0246         FE            add	al,-2[bp]
31516 90A7           80D4                   00  adc	ah,*0
31517                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
31518                                           ! Debug: list unsigned int = ax-1 (used reg = )
31519 90AA           48                         dec	ax
31520 90AB           50                         push	ax
31521                                           ! Debug: list int = const $3F5 (used reg = )
31522 90AC           B8                   03F5  mov	ax,#$3F5
31523 90AF           50                         push	ax
31524                                           ! Debug: func () void = outb+0 (used reg = )
31525 90B0           E8         74A1            call	_outb
31526 90B3           83C4                   04  add	sp,*4
31527                                           !BCC_EOS
31528                                           ! 4649         outb(0x03f5, 0);
31529                                           ! Debug: list int = const 0 (used reg = )
31530 90B6           31C0                       xor	ax,ax
31531 90B8           50                         push	ax
31532                                           ! Debug: list int = const $3F5 (used reg = )
31533 90B9           B8                   03F5  mov	ax,#$3F5
31534 90BC           50                         push	ax
31535                                           ! Debug: func () void = outb+0 (used reg = )
31536 90BD           E8         7494            call	_outb
31537 90C0           83C4                   04  add	sp,*4
31538                                           !BCC_EOS
31539                                           ! 4650         outb(0x03f5, 0xff);
31540                                           ! Debug: list int = const $FF (used reg = )
31541 90C3           B8                   00FF  mov	ax,#$FF
31542 90C6           50                         push	ax
31543                                           ! Debug: list int = const $3F5 (used reg = )
31544 90C7           B8                   03F5  mov	ax,#$3F5
31545 90CA           50                         push	ax
31546                                           ! Debug: func () void = outb+0 (used reg = )
31547 90CB           E8         7486            call	_outb
31548 90CE           83C4                   04  add	sp,*4
31549                                           !BCC_EOS
31550                                           ! 4651 #asm
31551                                           !BCC_EOS
31552                                           !BCC_ASM
31553                       0000002A            _int13_diskette_function.BP	set	$2A
31554                       0000000C            .int13_diskette_function.BP	set	$C
31555                       00000038            _int13_diskette_function.CS	set	$38
31556                       0000001A            .int13_diskette_function.CS	set	$1A
31557                       00000032            _int13_diskette_function.CX	set	$32
31558                       00000014            .int13_diskette_function.CX	set	$14
31559                       00000016            _int13_diskette_function.base_address	set	$16
31560                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
31561                       00000026            _int13_diskette_function.DI	set	$26
31562                       00000008            .int13_diskette_function.DI	set	8
31563                       0000003A            _int13_diskette_function.FLAGS	set	$3A
31564                       0000001C            .int13_diskette_function.FLAGS	set	$1C
31565                       00000014            _int13_diskette_function.base_count	set	$14
31566                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
31567                       0000001A            _int13_diskette_function.sector	set	$1A
31568                       FFFFFFFC            .int13_diskette_function.sector	set	-4
31569                       00000022            _int13_diskette_function.DS	set	$22
31570                       00000004            .int13_diskette_function.DS	set	4
31571                       00000019            _int13_diskette_function.head	set	$19
31572                       FFFFFFFB            .int13_diskette_function.head	set	-5
31573                       0000002C            _int13_diskette_function.ELDX	set	$2C
31574                       0000000E            .int13_diskette_function.ELDX	set	$E
31575                       0000000E            _int13_diskette_function.dor	set	$E
31576                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
31577                       00000030            _int13_diskette_function.DX	set	$30
31578                       00000012            .int13_diskette_function.DX	set	$12
31579                       00000007            _int13_diskette_function.return_status	set	7
31580                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
31581                       00000002            _int13_diskette_function.es	set	2
31582                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
31583                       00000010            _int13_diskette_function.mode_register	set	$10
31584                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
31585                       00000024            _int13_diskette_function.ES	set	$24
31586                       00000006            .int13_diskette_function.ES	set	6
31587                       00000012            _int13_diskette_function.base_es	set	$12
31588                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
31589                       0000001B            _int13_diskette_function.track	set	$1B
31590                       FFFFFFFD            .int13_diskette_function.track	set	-3
31591                       00000028            _int13_diskette_function.SI	set	$28
31592                       0000000A            .int13_diskette_function.SI	set	$A
31593                       00000006            _int13_diskette_function.drive_type	set	6
31594                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
31595                       0000001C            _int13_diskette_function.num_sectors	set	$1C
31596                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
31597                       00000036            _int13_diskette_function.IP	set	$36
31598                       00000018            .int13_diskette_function.IP	set	$18
31599                       00000018            _int13_diskette_function.status	set	$18
31600                       FFFFFFFA            .int13_diskette_function.status	set	-6
31601                       00000034            _int13_diskette_function.AX	set	$34
31602                       00000016            .int13_diskette_function.AX	set	$16
31603                       0000000F            _int13_diskette_function.val8	set	$F
31604                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
31605                       00000000            _int13_diskette_function.last_addr	set	0
31606                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
31607                       00000011            _int13_diskette_function.page	set	$11
31608                       FFFFFFF3            .int13_diskette_function.page	set	-$D
31609                       00000004            _int13_diskette_function.ah	set	4
31610                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
31611                       0000001D            _int13_diskette_function.drive	set	$1D
31612                       FFFFFFFF            .int13_diskette_function.drive	set	-1
31613                       00000005            _int13_diskette_function.num_floppies	set	5
31614                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
31615                       0000002E            _int13_diskette_function.BX	set	$2E
31616                       00000010            .int13_diskette_function.BX	set	$10
31617 90D1           FB                                 sti
31618                                           ! 4653 endasm
31619                                           !BCC_ENDASM
31620                                           !BCC_EOS
31621                                           ! 4654         do {
31622                       000090D2            .686:
31623                                           ! 4655           val8 = read_byte(0x0040, 0x0040);
31624                                           ! Debug: list int = const $40 (used reg = )
31625 90D2           B8                   0040  mov	ax,*$40
31626 90D5           50                         push	ax
31627                                           ! Debug: list int = const $40 (used reg = )
31628 90D6           B8                   0040  mov	ax,*$40
31629 90D9           50                         push	ax
31630                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31631 90DA           E8         7517            call	_read_byte
31632 90DD           83C4                   04  add	sp,*4
31633                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31634 90E0           8846         F1            mov	-$F[bp],al
31635                                           !BCC_EOS
31636                                           ! 4656           if (val8 == 0) {
31637                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31638 90E3           8A46         F1            mov	al,-$F[bp]
31639 90E6           84C0                       test	al,al
31640 90E8           75           2D            jne 	.687
31641                       000090EA            .688:
31642                                           ! 4657             floppy_reset_controller();
31643                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
31644 90EA           E8         F81B            call	_floppy_reset_controller
31645                                           !BCC_EOS
31646                                           ! 4658             AX = ((AX & 0x00ff) | ((0x80) << 8));
31647                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31648 90ED           8A46         16            mov	al,$16[bp]
31649                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31650 90F0           30E4                       xor	ah,ah
31651 90F2           0D                   8000  or	ax,#-$8000
31652                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31653 90F5           8946         16            mov	$16[bp],ax
31654                                           !BCC_EOS
31655                                           ! 4659             set_diskette_ret_status(0x80);
31656                                           ! Debug: list int = const $80 (used reg = )
31657 90F8           B8                   0080  mov	ax,#$80
31658 90FB           50                         push	ax
31659                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31660 90FC           E8         0D0B            call	_set_diskette_ret_status
31661 90FF           44                         inc	sp
31662 9100           44                         inc	sp
31663                                           !BCC_EOS
31664                                           ! 4660             AX = ((AX & 0xff00) | (0));
31665                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31666 9101           8B46         16            mov	ax,$16[bp]
31667 9104           30C0                       xor	al,al
31668                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31669 9106           0C                     00  or	al,*0
31670                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31671 9108           8946         16            mov	$16[bp],ax
31672                                           !BCC_EOS
31673                                           ! 4661             FLAGS |= 0x0001;
31674                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31675 910B           8B46         1C            mov	ax,$1C[bp]
31676 910E           0C                     01  or	al,*1
31677 9110           8946         1C            mov	$1C[bp],ax
31678                                           !BCC_EOS
31679                                           ! 4662             return;
31680 9113           89EC                       mov	sp,bp
31681 9115           5D                         pop	bp
31682 9116           C3                         ret
31683                                           !BCC_EOS
31684                                           ! 4663           }
31685                                           ! 4664           val8 = (read_byte(0x0040, 0x003e) & 0x80);
31686                       00009117            .687:
31687                                           ! Debug: list int = const $3E (used reg = )
31688 9117           B8                   003E  mov	ax,*$3E
31689 911A           50                         push	ax
31690                                           ! Debug: list int = const $40 (used reg = )
31691 911B           B8                   0040  mov	ax,*$40
31692 911E           50                         push	ax
31693                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31694 911F           E8         74D2            call	_read_byte
31695 9122           83C4                   04  add	sp,*4
31696                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
31697 9125           24                     80  and	al,#$80
31698                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31699 9127           8846         F1            mov	-$F[bp],al
31700                                           !BCC_EOS
31701                                           ! 4665         } while ( val8 == 0 );
31702                       0000912A            .685:
31703                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31704 912A           8A46         F1            mov	al,-$F[bp]
31705 912D           84C0                       test	al,al
31706 912F           74           A1            je 	.686
31707                       00009131            .689:
31708                                           !BCC_EOS
31709                                           ! 4666         val8 = 0;
31710                       00009131            .684:
31711                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31712 9131           30C0                       xor	al,al
31713 9133           8846         F1            mov	-$F[bp],al
31714                                           !BCC_EOS
31715                                           ! 4667 #asm
31716                                           !BCC_EOS
31717                                           !BCC_ASM
31718                       0000002A            _int13_diskette_function.BP	set	$2A
31719                       0000000C            .int13_diskette_function.BP	set	$C
31720                       00000038            _int13_diskette_function.CS	set	$38
31721                       0000001A            .int13_diskette_function.CS	set	$1A
31722                       00000032            _int13_diskette_function.CX	set	$32
31723                       00000014            .int13_diskette_function.CX	set	$14
31724                       00000016            _int13_diskette_function.base_address	set	$16
31725                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
31726                       00000026            _int13_diskette_function.DI	set	$26
31727                       00000008            .int13_diskette_function.DI	set	8
31728                       0000003A            _int13_diskette_function.FLAGS	set	$3A
31729                       0000001C            .int13_diskette_function.FLAGS	set	$1C
31730                       00000014            _int13_diskette_function.base_count	set	$14
31731                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
31732                       0000001A            _int13_diskette_function.sector	set	$1A
31733                       FFFFFFFC            .int13_diskette_function.sector	set	-4
31734                       00000022            _int13_diskette_function.DS	set	$22
31735                       00000004            .int13_diskette_function.DS	set	4
31736                       00000019            _int13_diskette_function.head	set	$19
31737                       FFFFFFFB            .int13_diskette_function.head	set	-5
31738                       0000002C            _int13_diskette_function.ELDX	set	$2C
31739                       0000000E            .int13_diskette_function.ELDX	set	$E
31740                       0000000E            _int13_diskette_function.dor	set	$E
31741                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
31742                       00000030            _int13_diskette_function.DX	set	$30
31743                       00000012            .int13_diskette_function.DX	set	$12
31744                       00000007            _int13_diskette_function.return_status	set	7
31745                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
31746                       00000002            _int13_diskette_function.es	set	2
31747                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
31748                       00000010            _int13_diskette_function.mode_register	set	$10
31749                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
31750                       00000024            _int13_diskette_function.ES	set	$24
31751                       00000006            .int13_diskette_function.ES	set	6
31752                       00000012            _int13_diskette_function.base_es	set	$12
31753                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
31754                       0000001B            _int13_diskette_function.track	set	$1B
31755                       FFFFFFFD            .int13_diskette_function.track	set	-3
31756                       00000028            _int13_diskette_function.SI	set	$28
31757                       0000000A            .int13_diskette_function.SI	set	$A
31758                       00000006            _int13_diskette_function.drive_type	set	6
31759                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
31760                       0000001C            _int13_diskette_function.num_sectors	set	$1C
31761                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
31762                       00000036            _int13_diskette_function.IP	set	$36
31763                       00000018            .int13_diskette_function.IP	set	$18
31764                       00000018            _int13_diskette_function.status	set	$18
31765                       FFFFFFFA            .int13_diskette_function.status	set	-6
31766                       00000034            _int13_diskette_function.AX	set	$34
31767                       00000016            .int13_diskette_function.AX	set	$16
31768                       0000000F            _int13_diskette_function.val8	set	$F
31769                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
31770                       00000000            _int13_diskette_function.last_addr	set	0
31771                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
31772                       00000011            _int13_diskette_function.page	set	$11
31773                       FFFFFFF3            .int13_diskette_function.page	set	-$D
31774                       00000004            _int13_diskette_function.ah	set	4
31775                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
31776                       0000001D            _int13_diskette_function.drive	set	$1D
31777                       FFFFFFFF            .int13_diskette_function.drive	set	-1
31778                       00000005            _int13_diskette_function.num_floppies	set	5
31779                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
31780                       0000002E            _int13_diskette_function.BX	set	$2E
31781                       00000010            .int13_diskette_function.BX	set	$10
31782 9136           FA                                 cli
31783                                           ! 4669 endasm
31784                                           !BCC_ENDASM
31785                                           !BCC_EOS
31786                                           ! 4670         val8 = read_byte(0x0040, 0x003e);
31787                                           ! Debug: list int = const $3E (used reg = )
31788 9137           B8                   003E  mov	ax,*$3E
31789 913A           50                         push	ax
31790                                           ! Debug: list int = const $40 (used reg = )
31791 913B           B8                   0040  mov	ax,*$40
31792 913E           50                         push	ax
31793                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31794 913F           E8         74B2            call	_read_byte
31795 9142           83C4                   04  add	sp,*4
31796                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31797 9145           8846         F1            mov	-$F[bp],al
31798                                           !BCC_EOS
31799                                           ! 4671         val8 &= 0x7f;
31800                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
31801 9148           8A46         F1            mov	al,-$F[bp]
31802 914B           24                     7F  and	al,*$7F
31803 914D           8846         F1            mov	-$F[bp],al
31804                                           !BCC_EOS
31805                                           ! 4672         write_byte(0x0040, 0x003e, val8);
31806                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
31807 9150           8A46         F1            mov	al,-$F[bp]
31808 9153           30E4                       xor	ah,ah
31809 9155           50                         push	ax
31810                                           ! Debug: list int = const $3E (used reg = )
31811 9156           B8                   003E  mov	ax,*$3E
31812 9159           50                         push	ax
31813                                           ! Debug: list int = const $40 (used reg = )
31814 915A           B8                   0040  mov	ax,*$40
31815 915D           50                         push	ax
31816                                           ! Debug: func () void = write_byte+0 (used reg = )
31817 915E           E8         74B9            call	_write_byte
31818 9161           83C4                   06  add	sp,*6
31819                                           !BCC_EOS
31820                                           ! 4673         val8 = inb(0x3f4);
31821                                           ! Debug: list int = const $3F4 (used reg = )
31822 9164           B8                   03F4  mov	ax,#$3F4
31823 9167           50                         push	ax
31824                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31825 9168           E8         73D3            call	_inb
31826 916B           44                         inc	sp
31827 916C           44                         inc	sp
31828                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31829 916D           8846         F1            mov	-$F[bp],al
31830                                           !BCC_EOS
31831                                           ! 4674         if ( (val8 & 0xc0) != 0xc0 )
31832                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
31833 9170           8A46         F1            mov	al,-$F[bp]
31834 9173           24                     C0  and	al,#$C0
31835                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
31836 9175           3C                     C0  cmp	al,#$C0
31837 9177           74           0E            je  	.68A
31838                       00009179            .68B:
31839                                           ! 4675           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
31840                                           ! Debug: list * char = .68C+0 (used reg = )
31841 9179           BB                   D103  mov	bx,#.68C
31842 917C           53                         push	bx
31843                                           ! Debug: list int = const 7 (used reg = )
31844 917D           B8                   0007  mov	ax,*7
31845 9180           50                         push	ax
31846                                           ! Debug: func () void = bios_printf+0 (used reg = )
31847 9181           E8         7897            call	_bios_printf
31848 9184           83C4                   04  add	sp,*4
31849                                           !BCC_EOS
31850                                           ! 4676         return_status[0] = inb(0x3f5);
31851                       00009187            .68A:
31852                                           ! Debug: list int = const $3F5 (used reg = )
31853 9187           B8                   03F5  mov	ax,#$3F5
31854 918A           50                         push	ax
31855                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31856 918B           E8         73B0            call	_inb
31857 918E           44                         inc	sp
31858 918F           44                         inc	sp
31859                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
31860 9190           8846         E9            mov	-$17[bp],al
31861                                           !BCC_EOS
31862                                           ! 4677         return_status[1] = inb(0x3f5);
31863                                           ! Debug: list int = const $3F5 (used reg = )
31864 9193           B8                   03F5  mov	ax,#$3F5
31865 9196           50                         push	ax
31866                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31867 9197           E8         73A4            call	_inb
31868 919A           44                         inc	sp
31869 919B           44                         inc	sp
31870                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
31871 919C           8846         EA            mov	-$16[bp],al
31872                                           !BCC_EOS
31873                                           ! 4678         return_status[2] = inb(0x3f5);
31874                                           ! Debug: list int = const $3F5 (used reg = )
31875 919F           B8                   03F5  mov	ax,#$3F5
31876 91A2           50                         push	ax
31877                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31878 91A3           E8         7398            call	_inb
31879 91A6           44                         inc	sp
31880 91A7           44                         inc	sp
31881                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
31882 91A8           8846         EB            mov	-$15[bp],al
31883                                           !BCC_EOS
31884                                           ! 4679         return_status[3] = inb(0x3f5);
31885                                           ! Debug: list int = const $3F5 (used reg = )
31886 91AB           B8                   03F5  mov	ax,#$3F5
31887 91AE           50                         push	ax
31888                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31889 91AF           E8         738C            call	_inb
31890 91B2           44                         inc	sp
31891 91B3           44                         inc	sp
31892                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
31893 91B4           8846         EC            mov	-$14[bp],al
31894                                           !BCC_EOS
31895                                           ! 4680         return_status[4] = inb(0x3f5);
31896                                           ! Debug: list int = const $3F5 (used reg = )
31897 91B7           B8                   03F5  mov	ax,#$3F5
31898 91BA           50                         push	ax
31899                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31900 91BB           E8         7380            call	_inb
31901 91BE           44                         inc	sp
31902 91BF           44                         inc	sp
31903                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
31904 91C0           8846         ED            mov	-$13[bp],al
31905                                           !BCC_EOS
31906                                           ! 4681         return_status[5] = inb(0x3f5);
31907                                           ! Debug: list int = const $3F5 (used reg = )
31908 91C3           B8                   03F5  mov	ax,#$3F5
31909 91C6           50                         push	ax
31910                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31911 91C7           E8         7374            call	_inb
31912 91CA           44                         inc	sp
31913 91CB           44                         inc	sp
31914                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
31915 91CC           8846         EE            mov	-$12[bp],al
31916                                           !BCC_EOS
31917                                           ! 4682         return_status[6] = inb(0x3f5);
31918                                           ! Debug: list int = const $3F5 (used reg = )
31919 91CF           B8                   03F5  mov	ax,#$3F5
31920 91D2           50                         push	ax
31921                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31922 91D3           E8         7368            call	_inb
31923 91D6           44                         inc	sp
31924 91D7           44                         inc	sp
31925                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
31926 91D8           8846         EF            mov	-$11[bp],al
31927                                           !BCC_EOS
31928                                           ! 4683         write_byte(0x0040, 0x0042, return_status[0]);
31929                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
31930 91DB           8A46         E9            mov	al,-$17[bp]
31931 91DE           30E4                       xor	ah,ah
31932 91E0           50                         push	ax
31933                                           ! Debug: list int = const $42 (used reg = )
31934 91E1           B8                   0042  mov	ax,*$42
31935 91E4           50                         push	ax
31936                                           ! Debug: list int = const $40 (used reg = )
31937 91E5           B8                   0040  mov	ax,*$40
31938 91E8           50                         push	ax
31939                                           ! Debug: func () void = write_byte+0 (used reg = )
31940 91E9           E8         742E            call	_write_byte
31941 91EC           83C4                   06  add	sp,*6
31942                                           !BCC_EOS
31943                                           ! 4684         write_byte(0x0040, 0x0043, return_status[1]);
31944                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
31945 91EF           8A46         EA            mov	al,-$16[bp]
31946 91F2           30E4                       xor	ah,ah
31947 91F4           50                         push	ax
31948                                           ! Debug: list int = const $43 (used reg = )
31949 91F5           B8                   0043  mov	ax,*$43
31950 91F8           50                         push	ax
31951                                           ! Debug: list int = const $40 (used reg = )
31952 91F9           B8                   0040  mov	ax,*$40
31953 91FC           50                         push	ax
31954                                           ! Debug: func () void = write_byte+0 (used reg = )
31955 91FD           E8         741A            call	_write_byte
31956 9200           83C4                   06  add	sp,*6
31957                                           !BCC_EOS
31958                                           ! 4685         write_byte(0x0040, 0x0044, return_status[2]);
31959                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
31960 9203           8A46         EB            mov	al,-$15[bp]
31961 9206           30E4                       xor	ah,ah
31962 9208           50                         push	ax
31963                                           ! Debug: list int = const $44 (used reg = )
31964 9209           B8                   0044  mov	ax,*$44
31965 920C           50                         push	ax
31966                                           ! Debug: list int = const $40 (used reg = )
31967 920D           B8                   0040  mov	ax,*$40
31968 9210           50                         push	ax
31969                                           ! Debug: func () void = write_byte+0 (used reg = )
31970 9211           E8         7406            call	_write_byte
31971 9214           83C4                   06  add	sp,*6
31972                                           !BCC_EOS
31973                                           ! 4686         write_byte(0x0040, 0x0045, return_status[3]);
31974                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
31975 9217           8A46         EC            mov	al,-$14[bp]
31976 921A           30E4                       xor	ah,ah
31977 921C           50                         push	ax
31978                                           ! Debug: list int = const $45 (used reg = )
31979 921D           B8                   0045  mov	ax,*$45
31980 9220           50                         push	ax
31981                                           ! Debug: list int = const $40 (used reg = )
31982 9221           B8                   0040  mov	ax,*$40
31983 9224           50                         push	ax
31984                                           ! Debug: func () void = write_byte+0 (used reg = )
31985 9225           E8         73F2            call	_write_byte
31986 9228           83C4                   06  add	sp,*6
31987                                           !BCC_EOS
31988                                           ! 4687         write_byte(0x0040, 0x0046, return_status[4]);
31989                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
31990 922B           8A46         ED            mov	al,-$13[bp]
31991 922E           30E4                       xor	ah,ah
31992 9230           50                         push	ax
31993                                           ! Debug: list int = const $46 (used reg = )
31994 9231           B8                   0046  mov	ax,*$46
31995 9234           50                         push	ax
31996                                           ! Debug: list int = const $40 (used reg = )
31997 9235           B8                   0040  mov	ax,*$40
31998 9238           50                         push	ax
31999                                           ! Debug: func () void = write_byte+0 (used reg = )
32000 9239           E8         73DE            call	_write_byte
32001 923C           83C4                   06  add	sp,*6
32002                                           !BCC_EOS
32003                                           ! 4688         write_byte(0x0040, 0x0047, return_status[5]);
32004                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
32005 923F           8A46         EE            mov	al,-$12[bp]
32006 9242           30E4                       xor	ah,ah
32007 9244           50                         push	ax
32008                                           ! Debug: list int = const $47 (used reg = )
32009 9245           B8                   0047  mov	ax,*$47
32010 9248           50                         push	ax
32011                                           ! Debug: list int = const $40 (used reg = )
32012 9249           B8                   0040  mov	ax,*$40
32013 924C           50                         push	ax
32014                                           ! Debug: func () void = write_byte+0 (used reg = )
32015 924D           E8         73CA            call	_write_byte
32016 9250           83C4                   06  add	sp,*6
32017                                           !BCC_EOS
32018                                           ! 4689         write_byte(0x0040, 0x0048, return_status[6]);
32019                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
32020 9253           8A46         EF            mov	al,-$11[bp]
32021 9256           30E4                       xor	ah,ah
32022 9258           50                         push	ax
32023                                           ! Debug: list int = const $48 (used reg = )
32024 9259           B8                   0048  mov	ax,*$48
32025 925C           50                         push	ax
32026                                           ! Debug: list int = const $40 (used reg = )
32027 925D           B8                   0040  mov	ax,*$40
32028 9260           50                         push	ax
32029                                           ! Debug: func () void = write_byte+0 (used reg = )
32030 9261           E8         73B6            call	_write_byte
32031 9264           83C4                   06  add	sp,*6
32032                                           !BCC_EOS
32033                                           ! 4690         if ( (return_status[0] & 0xc0) != 0 ) {
32034                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
32035 9267           8A46         E9            mov	al,-$17[bp]
32036 926A           24                     C0  and	al,#$C0
32037                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32038 926C           84C0                       test	al,al
32039 926E           74           2A            je  	.68D
32040                       00009270            .68E:
32041                                           ! 4691           AX = ((AX & 0x00ff) | ((0x20) << 8));
32042                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32043 9270           8A46         16            mov	al,$16[bp]
32044                                           ! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
32045 9273           30E4                       xor	ah,ah
32046 9275           0D                   2000  or	ax,#$2000
32047                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32048 9278           8946         16            mov	$16[bp],ax
32049                                           !BCC_EOS
32050                                           ! 4692           set_diskette_ret_status(0x20);
32051                                           ! Debug: list int = const $20 (used reg = )
32052 927B           B8                   0020  mov	ax,*$20
32053 927E           50                         push	ax
32054                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32055 927F           E8         0B88            call	_set_diskette_ret_status
32056 9282           44                         inc	sp
32057 9283           44                         inc	sp
32058                                           !BCC_EOS
32059                                           ! 4693           AX = ((AX & 0xff00) | (0));
32060                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32061 9284           8B46         16            mov	ax,$16[bp]
32062 9287           30C0                       xor	al,al
32063                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32064 9289           0C                     00  or	al,*0
32065                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32066 928B           8946         16            mov	$16[bp],ax
32067                                           !BCC_EOS
32068                                           ! 4694           FLAGS |= 0x0001;
32069                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32070 928E           8B46         1C            mov	ax,$1C[bp]
32071 9291           0C                     01  or	al,*1
32072 9293           8946         1C            mov	$1C[bp],ax
32073                                           !BCC_EOS
32074                                           ! 4695           return;
32075 9296           89EC                       mov	sp,bp
32076 9298           5D                         pop	bp
32077 9299           C3                         ret
32078                                           !BCC_EOS
32079                                           ! 4696         }
32080                                           ! 4697     
32081                                           ! 4697     set_diskette_current_cyl(drive, track);
32082                       0000929A            .68D:
32083                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32084 929A           8A46         FD            mov	al,-3[bp]
32085 929D           30E4                       xor	ah,ah
32086 929F           50                         push	ax
32087                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
32088 92A0           8A46         FF            mov	al,-1[bp]
32089 92A3           30E4                       xor	ah,ah
32090 92A5           50                         push	ax
32091                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
32092 92A6           E8         0B79            call	_set_diskette_current_cyl
32093 92A9           83C4                   04  add	sp,*4
32094                                           !BCC_EOS
32095                                           ! 4698         AX = ((AX & 0x00ff) | ((0x00) << 8));
32096                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32097 92AC           8A46         16            mov	al,$16[bp]
32098                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32099 92AF           0C                     00  or	al,*0
32100                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
32101 92B1           30E4                       xor	ah,ah
32102 92B3           8946         16            mov	$16[bp],ax
32103                                           !BCC_EOS
32104                                           ! 4699         FLAGS &= 0xfffe;
32105                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32106 92B6           8B46         1C            mov	ax,$1C[bp]
32107 92B9           24                     FE  and	al,#$FE
32108 92BB           8946         1C            mov	$1C[bp],ax
32109                                           !BCC_EOS
32110                                           ! 4700         return;
32111 92BE           89EC                       mov	sp,bp
32112 92C0           5D                         pop	bp
32113 92C1           C3                         ret
32114                                           !BCC_EOS
32115                                           ! 4701       } else if (ah == 0x03) {
32116 92C2           E9         03D7            br 	.68F
32117                       000092C5            .67E:
32118                                           ! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
32119 92C5           8A46         E6            mov	al,-$1A[bp]
32120 92C8           3C                     03  cmp	al,*3
32121 92CA         0F85         03A6            bne 	.690
32122                       000092CE            .691:
32123                                           ! 4702         page = (ES >> 12);
32124                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
32125 92CE           8B46         06            mov	ax,6[bp]
32126 92D1           88E0                       mov	al,ah
32127 92D3           30E4                       xor	ah,ah
32128 92D5           B1                     04  mov	cl,*4
32129 92D7           D3E8                       shr	ax,cl
32130                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
32131 92D9           8846         F3            mov	-$D[bp],al
32132                                           !BCC_EOS
32133                                           ! 4703         base_es = (ES << 4);
32134                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
32135 92DC           8B46         06            mov	ax,6[bp]
32136 92DF           B1                     04  mov	cl,*4
32137 92E1           D3E0                       shl	ax,cl
32138                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
32139 92E3           8946         F4            mov	-$C[bp],ax
32140                                           !BCC_EOS
32141                                           ! 4704         base_address = base_es + BX;
32142                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
32143 92E6           8B46         F4            mov	ax,-$C[bp]
32144 92E9           0346         10            add	ax,$10[bp]
32145                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
32146 92EC           8946         F8            mov	-8[bp],ax
32147                                           !BCC_EOS
32148                                           ! 4705         if ( base_address < base_es ) {
32149                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
32150 92EF           8B46         F8            mov	ax,-8[bp]
32151 92F2           3B46         F4            cmp	ax,-$C[bp]
32152 92F5           73           07            jae 	.692
32153                       000092F7            .693:
32154                                           ! 4706           page++;
32155                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
32156 92F7           8A46         F3            mov	al,-$D[bp]
32157 92FA           40                         inc	ax
32158 92FB           8846         F3            mov	-$D[bp],al
32159                                           !BCC_EOS
32160                                           ! 4707         }
32161                                           ! 4708         base_count = (num_sectors * 512) - 1;
32162                       000092FE            .692:
32163                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
32164 92FE           8A46         FE            mov	al,-2[bp]
32165 9301           30E4                       xor	ah,ah
32166 9303           B9                   0200  mov	cx,#$200
32167 9306           F7E9                       imul	cx
32168                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32169                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
32170 9308           48                         dec	ax
32171 9309           8946         F6            mov	-$A[bp],ax
32172                                           !BCC_EOS
32173                                           ! 4709         last_addr = base_address + base_count;
32174                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
32175 930C           8B46         F8            mov	ax,-8[bp]
32176 930F           0346         F6            add	ax,-$A[bp]
32177                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
32178 9312           8946         E2            mov	-$1E[bp],ax
32179                                           !BCC_EOS
32180                                           ! 4710         if (last_addr < base_address) {
32181                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
32182 9315           8B46         E2            mov	ax,-$1E[bp]
32183 9318           3B46         F8            cmp	ax,-8[bp]
32184 931B           73           2A            jae 	.694
32185                       0000931D            .695:
32186                                           ! 4711           AX = ((AX & 0x00ff) | ((0x09) << 8));
32187                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32188 931D           8A46         16            mov	al,$16[bp]
32189                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
32190 9320           30E4                       xor	ah,ah
32191 9322           0D                   0900  or	ax,#$900
32192                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32193 9325           8946         16            mov	$16[bp],ax
32194                                           !BCC_EOS
32195                                           ! 4712           set_diskette_ret_status(0x09);
32196                                           ! Debug: list int = const 9 (used reg = )
32197 9328           B8                   0009  mov	ax,*9
32198 932B           50                         push	ax
32199                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32200 932C           E8         0ADB            call	_set_diskette_ret_status
32201 932F           44                         inc	sp
32202 9330           44                         inc	sp
32203                                           !BCC_EOS
32204                                           ! 4713           AX = ((AX & 0xff00) | (0));
32205                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32206 9331           8B46         16            mov	ax,$16[bp]
32207 9334           30C0                       xor	al,al
32208                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32209 9336           0C                     00  or	al,*0
32210                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32211 9338           8946         16            mov	$16[bp],ax
32212                                           !BCC_EOS
32213                                           ! 4714           FLAGS |= 0x0001;
32214                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32215 933B           8B46         1C            mov	ax,$1C[bp]
32216 933E           0C                     01  or	al,*1
32217 9340           8946         1C            mov	$1C[bp],ax
32218                                           !BCC_EOS
32219                                           ! 4715           return;
32220 9343           89EC                       mov	sp,bp
32221 9345           5D                         pop	bp
32222 9346           C3                         ret
32223                                           !BCC_EOS
32224                                           ! 4716         }
32225                                           ! 4717         ;
32226                       00009347            .694:
32227                                           !BCC_EOS
32228                                           ! 4718         outb(0x000a, 0x06);
32229                                           ! Debug: list int = const 6 (used reg = )
32230 9347           B8                   0006  mov	ax,*6
32231 934A           50                         push	ax
32232                                           ! Debug: list int = const $A (used reg = )
32233 934B           B8                   000A  mov	ax,*$A
32234 934E           50                         push	ax
32235                                           ! Debug: func () void = outb+0 (used reg = )
32236 934F           E8         7202            call	_outb
32237 9352           83C4                   04  add	sp,*4
32238                                           !BCC_EOS
32239                                           ! 4719         outb(0x000c, 0x00);
32240                                           ! Debug: list int = const 0 (used reg = )
32241 9355           31C0                       xor	ax,ax
32242 9357           50                         push	ax
32243                                           ! Debug: list int = const $C (used reg = )
32244 9358           B8                   000C  mov	ax,*$C
32245 935B           50                         push	ax
32246                                           ! Debug: func () void = outb+0 (used reg = )
32247 935C           E8         71F5            call	_outb
32248 935F           83C4                   04  add	sp,*4
32249                                           !BCC_EOS
32250                                           ! 4720         outb(0x0004, base_address);
32251                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
32252 9362           FF76         F8            push	-8[bp]
32253                                           ! Debug: list int = const 4 (used reg = )
32254 9365           B8                   0004  mov	ax,*4
32255 9368           50                         push	ax
32256                                           ! Debug: func () void = outb+0 (used reg = )
32257 9369           E8         71E8            call	_outb
32258 936C           83C4                   04  add	sp,*4
32259                                           !BCC_EOS
32260                                           ! 4721         outb(0x0004, base_address>>8);
32261                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
32262 936F           8B46         F8            mov	ax,-8[bp]
32263 9372           88E0                       mov	al,ah
32264 9374           30E4                       xor	ah,ah
32265                                           ! Debug: list unsigned int = ax+0 (used reg = )
32266 9376           50                         push	ax
32267                                           ! Debug: list int = const 4 (used reg = )
32268 9377           B8                   0004  mov	ax,*4
32269 937A           50                         push	ax
32270                                           ! Debug: func () void = outb+0 (used reg = )
32271 937B           E8         71D6            call	_outb
32272 937E           83C4                   04  add	sp,*4
32273                                           !BCC_EOS
32274                                           ! 4722         outb(0x000c, 0x00);
32275                                           ! Debug: list int = const 0 (used reg = )
32276 9381           31C0                       xor	ax,ax
32277 9383           50                         push	ax
32278                                           ! Debug: list int = const $C (used reg = )
32279 9384           B8                   000C  mov	ax,*$C
32280 9387           50                         push	ax
32281                                           ! Debug: func () void = outb+0 (used reg = )
32282 9388           E8         71C9            call	_outb
32283 938B           83C4                   04  add	sp,*4
32284                                           !BCC_EOS
32285                                           ! 4723         outb(0x0005, base_count);
32286                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
32287 938E           FF76         F6            push	-$A[bp]
32288                                           ! Debug: list int = const 5 (used reg = )
32289 9391           B8                   0005  mov	ax,*5
32290 9394           50                         push	ax
32291                                           ! Debug: func () void = outb+0 (used reg = )
32292 9395           E8         71BC            call	_outb
32293 9398           83C4                   04  add	sp,*4
32294                                           !BCC_EOS
32295                                           ! 4724         outb(0x0005, base_count>>8);
32296                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
32297 939B           8B46         F6            mov	ax,-$A[bp]
32298 939E           88E0                       mov	al,ah
32299 93A0           30E4                       xor	ah,ah
32300                                           ! Debug: list unsigned int = ax+0 (used reg = )
32301 93A2           50                         push	ax
32302                                           ! Debug: list int = const 5 (used reg = )
32303 93A3           B8                   0005  mov	ax,*5
32304 93A6           50                         push	ax
32305                                           ! Debug: func () void = outb+0 (used reg = )
32306 93A7           E8         71AA            call	_outb
32307 93AA           83C4                   04  add	sp,*4
32308                                           !BCC_EOS
32309                                           ! 4725         mode_register = 0x4a;
32310                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
32311 93AD           B0                     4A  mov	al,*$4A
32312 93AF           8846         F2            mov	-$E[bp],al
32313                                           !BCC_EOS
32314                                           ! 4726         outb(0x000b, mode_register);
32315                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
32316 93B2           8A46         F2            mov	al,-$E[bp]
32317 93B5           30E4                       xor	ah,ah
32318 93B7           50                         push	ax
32319                                           ! Debug: list int = const $B (used reg = )
32320 93B8           B8                   000B  mov	ax,*$B
32321 93BB           50                         push	ax
32322                                           ! Debug: func () void = outb+0 (used reg = )
32323 93BC           E8         7195            call	_outb
32324 93BF           83C4                   04  add	sp,*4
32325                                           !BCC_EOS
32326                                           ! 4727         outb(0x0081, page);
32327                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
32328 93C2           8A46         F3            mov	al,-$D[bp]
32329 93C5           30E4                       xor	ah,ah
32330 93C7           50                         push	ax
32331                                           ! Debug: list int = const $81 (used reg = )
32332 93C8           B8                   0081  mov	ax,#$81
32333 93CB           50                         push	ax
32334                                           ! Debug: func () void = outb+0 (used reg = )
32335 93CC           E8         7185            call	_outb
32336 93CF           83C4                   04  add	sp,*4
32337                                           !BCC_EOS
32338                                           ! 4728         ;
32339                                           !BCC_EOS
32340                                           ! 4729         outb(0x000a, 0x02);
32341                                           ! Debug: list int = const 2 (used reg = )
32342 93D2           B8                   0002  mov	ax,*2
32343 93D5           50                         push	ax
32344                                           ! Debug: list int = const $A (used reg = )
32345 93D6           B8                   000A  mov	ax,*$A
32346 93D9           50                         push	ax
32347                                           ! Debug: func () void = outb+0 (used reg = )
32348 93DA           E8         7177            call	_outb
32349 93DD           83C4                   04  add	sp,*4
32350                                           !BCC_EOS
32351                                           ! 4730         floppy_prepare_controller(drive);
32352                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32353 93E0           8A46         FF            mov	al,-1[bp]
32354 93E3           30E4                       xor	ah,ah
32355 93E5           50                         push	ax
32356                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
32357 93E6           E8         F56D            call	_floppy_prepare_controller
32358 93E9           44                         inc	sp
32359 93EA           44                         inc	sp
32360                                           !BCC_EOS
32361                                           ! 4731         outb(0x03f5, 0xc5);
32362                                           ! Debug: list int = const $C5 (used reg = )
32363 93EB           B8                   00C5  mov	ax,#$C5
32364 93EE           50                         push	ax
32365                                           ! Debug: list int = const $3F5 (used reg = )
32366 93EF           B8                   03F5  mov	ax,#$3F5
32367 93F2           50                         push	ax
32368                                           ! Debug: func () void = outb+0 (used reg = )
32369 93F3           E8         715E            call	_outb
32370 93F6           83C4                   04  add	sp,*4
32371                                           !BCC_EOS
32372                                           ! 4732         outb(0x03f5, (head << 2) | drive);
32373                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
32374 93F9           8A46         FB            mov	al,-5[bp]
32375 93FC           30E4                       xor	ah,ah
32376 93FE           D1E0                       shl	ax,*1
32377 9400           D1E0                       shl	ax,*1
32378                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
32379 9402           0A46         FF            or	al,-1[bp]
32380                                           ! Debug: list unsigned int = ax+0 (used reg = )
32381 9405           50                         push	ax
32382                                           ! Debug: list int = const $3F5 (used reg = )
32383 9406           B8                   03F5  mov	ax,#$3F5
32384 9409           50                         push	ax
32385                                           ! Debug: func () void = outb+0 (used reg = )
32386 940A           E8         7147            call	_outb
32387 940D           83C4                   04  add	sp,*4
32388                                           !BCC_EOS
32389                                           ! 4733         outb(0x03f5, track);
32390                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32391 9410           8A46         FD            mov	al,-3[bp]
32392 9413           30E4                       xor	ah,ah
32393 9415           50                         push	ax
32394                                           ! Debug: list int = const $3F5 (used reg = )
32395 9416           B8                   03F5  mov	ax,#$3F5
32396 9419           50                         push	ax
32397                                           ! Debug: func () void = outb+0 (used reg = )
32398 941A           E8         7137            call	_outb
32399 941D           83C4                   04  add	sp,*4
32400                                           !BCC_EOS
32401                                           ! 4734         outb(0x03f5, head);
32402                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
32403 9420           8A46         FB            mov	al,-5[bp]
32404 9423           30E4                       xor	ah,ah
32405 9425           50                         push	ax
32406                                           ! Debug: list int = const $3F5 (used reg = )
32407 9426           B8                   03F5  mov	ax,#$3F5
32408 9429           50                         push	ax
32409                                           ! Debug: func () void = outb+0 (used reg = )
32410 942A           E8         7127            call	_outb
32411 942D           83C4                   04  add	sp,*4
32412                                           !BCC_EOS
32413                                           ! 4735         outb(0x03f5, sector);
32414                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
32415 9430           8A46         FC            mov	al,-4[bp]
32416 9433           30E4                       xor	ah,ah
32417 9435           50                         push	ax
32418                                           ! Debug: list int = const $3F5 (used reg = )
32419 9436           B8                   03F5  mov	ax,#$3F5
32420 9439           50                         push	ax
32421                                           ! Debug: func () void = outb+0 (used reg = )
32422 943A           E8         7117            call	_outb
32423 943D           83C4                   04  add	sp,*4
32424                                           !BCC_EOS
32425                                           ! 4736         outb(0x03f5, 2);
32426                                           ! Debug: list int = const 2 (used reg = )
32427 9440           B8                   0002  mov	ax,*2
32428 9443           50                         push	ax
32429                                           ! Debug: list int = const $3F5 (used reg = )
32430 9444           B8                   03F5  mov	ax,#$3F5
32431 9447           50                         push	ax
32432                                           ! Debug: func () void = outb+0 (used reg = )
32433 9448           E8         7109            call	_outb
32434 944B           83C4                   04  add	sp,*4
32435                                           !BCC_EOS
32436                                           ! 4737         outb(0x03f5, sector + num_sectors - 1);
32437                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
32438 944E           8A46         FC            mov	al,-4[bp]
32439 9451           30E4                       xor	ah,ah
32440 9453           0246         FE            add	al,-2[bp]
32441 9456           80D4                   00  adc	ah,*0
32442                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32443                                           ! Debug: list unsigned int = ax-1 (used reg = )
32444 9459           48                         dec	ax
32445 945A           50                         push	ax
32446                                           ! Debug: list int = const $3F5 (used reg = )
32447 945B           B8                   03F5  mov	ax,#$3F5
32448 945E           50                         push	ax
32449                                           ! Debug: func () void = outb+0 (used reg = )
32450 945F           E8         70F2            call	_outb
32451 9462           83C4                   04  add	sp,*4
32452                                           !BCC_EOS
32453                                           ! 4738         outb(0x03f5, 0);
32454                                           ! Debug: list int = const 0 (used reg = )
32455 9465           31C0                       xor	ax,ax
32456 9467           50                         push	ax
32457                                           ! Debug: list int = const $3F5 (used reg = )
32458 9468           B8                   03F5  mov	ax,#$3F5
32459 946B           50                         push	ax
32460                                           ! Debug: func () void = outb+0 (used reg = )
32461 946C           E8         70E5            call	_outb
32462 946F           83C4                   04  add	sp,*4
32463                                           !BCC_EOS
32464                                           ! 4739         outb(0x03f5, 0xff);
32465                                           ! Debug: list int = const $FF (used reg = )
32466 9472           B8                   00FF  mov	ax,#$FF
32467 9475           50                         push	ax
32468                                           ! Debug: list int = const $3F5 (used reg = )
32469 9476           B8                   03F5  mov	ax,#$3F5
32470 9479           50                         push	ax
32471                                           ! Debug: func () void = outb+0 (used reg = )
32472 947A           E8         70D7            call	_outb
32473 947D           83C4                   04  add	sp,*4
32474                                           !BCC_EOS
32475                                           ! 4740 #asm
32476                                           !BCC_EOS
32477                                           !BCC_ASM
32478                       0000002A            _int13_diskette_function.BP	set	$2A
32479                       0000000C            .int13_diskette_function.BP	set	$C
32480                       00000038            _int13_diskette_function.CS	set	$38
32481                       0000001A            .int13_diskette_function.CS	set	$1A
32482                       00000032            _int13_diskette_function.CX	set	$32
32483                       00000014            .int13_diskette_function.CX	set	$14
32484                       00000016            _int13_diskette_function.base_address	set	$16
32485                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32486                       00000026            _int13_diskette_function.DI	set	$26
32487                       00000008            .int13_diskette_function.DI	set	8
32488                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32489                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32490                       00000014            _int13_diskette_function.base_count	set	$14
32491                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32492                       0000001A            _int13_diskette_function.sector	set	$1A
32493                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32494                       00000022            _int13_diskette_function.DS	set	$22
32495                       00000004            .int13_diskette_function.DS	set	4
32496                       00000019            _int13_diskette_function.head	set	$19
32497                       FFFFFFFB            .int13_diskette_function.head	set	-5
32498                       0000002C            _int13_diskette_function.ELDX	set	$2C
32499                       0000000E            .int13_diskette_function.ELDX	set	$E
32500                       0000000E            _int13_diskette_function.dor	set	$E
32501                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32502                       00000030            _int13_diskette_function.DX	set	$30
32503                       00000012            .int13_diskette_function.DX	set	$12
32504                       00000007            _int13_diskette_function.return_status	set	7
32505                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32506                       00000002            _int13_diskette_function.es	set	2
32507                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32508                       00000010            _int13_diskette_function.mode_register	set	$10
32509                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32510                       00000024            _int13_diskette_function.ES	set	$24
32511                       00000006            .int13_diskette_function.ES	set	6
32512                       00000012            _int13_diskette_function.base_es	set	$12
32513                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32514                       0000001B            _int13_diskette_function.track	set	$1B
32515                       FFFFFFFD            .int13_diskette_function.track	set	-3
32516                       00000028            _int13_diskette_function.SI	set	$28
32517                       0000000A            .int13_diskette_function.SI	set	$A
32518                       00000006            _int13_diskette_function.drive_type	set	6
32519                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32520                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32521                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32522                       00000036            _int13_diskette_function.IP	set	$36
32523                       00000018            .int13_diskette_function.IP	set	$18
32524                       00000018            _int13_diskette_function.status	set	$18
32525                       FFFFFFFA            .int13_diskette_function.status	set	-6
32526                       00000034            _int13_diskette_function.AX	set	$34
32527                       00000016            .int13_diskette_function.AX	set	$16
32528                       0000000F            _int13_diskette_function.val8	set	$F
32529                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32530                       00000000            _int13_diskette_function.last_addr	set	0
32531                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32532                       00000011            _int13_diskette_function.page	set	$11
32533                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32534                       00000004            _int13_diskette_function.ah	set	4
32535                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32536                       0000001D            _int13_diskette_function.drive	set	$1D
32537                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32538                       00000005            _int13_diskette_function.num_floppies	set	5
32539                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32540                       0000002E            _int13_diskette_function.BX	set	$2E
32541                       00000010            .int13_diskette_function.BX	set	$10
32542 9480           FB                                 sti
32543                                           ! 4742 endasm
32544                                           !BCC_ENDASM
32545                                           !BCC_EOS
32546                                           ! 4743         do {
32547                       00009481            .698:
32548                                           ! 4744           val8 = read_byte(0x0040, 0x0040);
32549                                           ! Debug: list int = const $40 (used reg = )
32550 9481           B8                   0040  mov	ax,*$40
32551 9484           50                         push	ax
32552                                           ! Debug: list int = const $40 (used reg = )
32553 9485           B8                   0040  mov	ax,*$40
32554 9488           50                         push	ax
32555                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32556 9489           E8         7168            call	_read_byte
32557 948C           83C4                   04  add	sp,*4
32558                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32559 948F           8846         F1            mov	-$F[bp],al
32560                                           !BCC_EOS
32561                                           ! 4745           if (val8 == 0) {
32562                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32563 9492           8A46         F1            mov	al,-$F[bp]
32564 9495           84C0                       test	al,al
32565 9497           75           2D            jne 	.699
32566                       00009499            .69A:
32567                                           ! 4746             floppy_reset_controller();
32568                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
32569 9499           E8         F46C            call	_floppy_reset_controller
32570                                           !BCC_EOS
32571                                           ! 4747             AX = ((AX & 0x00ff) | ((0x80) << 8));
32572                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32573 949C           8A46         16            mov	al,$16[bp]
32574                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32575 949F           30E4                       xor	ah,ah
32576 94A1           0D                   8000  or	ax,#-$8000
32577                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32578 94A4           8946         16            mov	$16[bp],ax
32579                                           !BCC_EOS
32580                                           ! 4748             set_diskette_ret_status(0x80);
32581                                           ! Debug: list int = const $80 (used reg = )
32582 94A7           B8                   0080  mov	ax,#$80
32583 94AA           50                         push	ax
32584                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32585 94AB           E8         095C            call	_set_diskette_ret_status
32586 94AE           44                         inc	sp
32587 94AF           44                         inc	sp
32588                                           !BCC_EOS
32589                                           ! 4749             AX = ((AX & 0xff00) | (0));
32590                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32591 94B0           8B46         16            mov	ax,$16[bp]
32592 94B3           30C0                       xor	al,al
32593                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32594 94B5           0C                     00  or	al,*0
32595                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32596 94B7           8946         16            mov	$16[bp],ax
32597                                           !BCC_EOS
32598                                           ! 4750             FLAGS |= 0x0001;
32599                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32600 94BA           8B46         1C            mov	ax,$1C[bp]
32601 94BD           0C                     01  or	al,*1
32602 94BF           8946         1C            mov	$1C[bp],ax
32603                                           !BCC_EOS
32604                                           ! 4751             return;
32605 94C2           89EC                       mov	sp,bp
32606 94C4           5D                         pop	bp
32607 94C5           C3                         ret
32608                                           !BCC_EOS
32609                                           ! 4752           }
32610                                           ! 4753           val8 = (read_byte(0x0040, 0x003e) & 0x80);
32611                       000094C6            .699:
32612                                           ! Debug: list int = const $3E (used reg = )
32613 94C6           B8                   003E  mov	ax,*$3E
32614 94C9           50                         push	ax
32615                                           ! Debug: list int = const $40 (used reg = )
32616 94CA           B8                   0040  mov	ax,*$40
32617 94CD           50                         push	ax
32618                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32619 94CE           E8         7123            call	_read_byte
32620 94D1           83C4                   04  add	sp,*4
32621                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32622 94D4           24                     80  and	al,#$80
32623                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32624 94D6           8846         F1            mov	-$F[bp],al
32625                                           !BCC_EOS
32626                                           ! 4754         } while ( val8 == 0 );
32627                       000094D9            .697:
32628                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32629 94D9           8A46         F1            mov	al,-$F[bp]
32630 94DC           84C0                       test	al,al
32631 94DE           74           A1            je 	.698
32632                       000094E0            .69B:
32633                                           !BCC_EOS
32634                                           ! 4755         val8 = 0;
32635                       000094E0            .696:
32636                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32637 94E0           30C0                       xor	al,al
32638 94E2           8846         F1            mov	-$F[bp],al
32639                                           !BCC_EOS
32640                                           ! 4756 #asm
32641                                           !BCC_EOS
32642                                           !BCC_ASM
32643                       0000002A            _int13_diskette_function.BP	set	$2A
32644                       0000000C            .int13_diskette_function.BP	set	$C
32645                       00000038            _int13_diskette_function.CS	set	$38
32646                       0000001A            .int13_diskette_function.CS	set	$1A
32647                       00000032            _int13_diskette_function.CX	set	$32
32648                       00000014            .int13_diskette_function.CX	set	$14
32649                       00000016            _int13_diskette_function.base_address	set	$16
32650                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32651                       00000026            _int13_diskette_function.DI	set	$26
32652                       00000008            .int13_diskette_function.DI	set	8
32653                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32654                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32655                       00000014            _int13_diskette_function.base_count	set	$14
32656                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32657                       0000001A            _int13_diskette_function.sector	set	$1A
32658                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32659                       00000022            _int13_diskette_function.DS	set	$22
32660                       00000004            .int13_diskette_function.DS	set	4
32661                       00000019            _int13_diskette_function.head	set	$19
32662                       FFFFFFFB            .int13_diskette_function.head	set	-5
32663                       0000002C            _int13_diskette_function.ELDX	set	$2C
32664                       0000000E            .int13_diskette_function.ELDX	set	$E
32665                       0000000E            _int13_diskette_function.dor	set	$E
32666                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32667                       00000030            _int13_diskette_function.DX	set	$30
32668                       00000012            .int13_diskette_function.DX	set	$12
32669                       00000007            _int13_diskette_function.return_status	set	7
32670                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32671                       00000002            _int13_diskette_function.es	set	2
32672                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32673                       00000010            _int13_diskette_function.mode_register	set	$10
32674                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32675                       00000024            _int13_diskette_function.ES	set	$24
32676                       00000006            .int13_diskette_function.ES	set	6
32677                       00000012            _int13_diskette_function.base_es	set	$12
32678                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32679                       0000001B            _int13_diskette_function.track	set	$1B
32680                       FFFFFFFD            .int13_diskette_function.track	set	-3
32681                       00000028            _int13_diskette_function.SI	set	$28
32682                       0000000A            .int13_diskette_function.SI	set	$A
32683                       00000006            _int13_diskette_function.drive_type	set	6
32684                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32685                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32686                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32687                       00000036            _int13_diskette_function.IP	set	$36
32688                       00000018            .int13_diskette_function.IP	set	$18
32689                       00000018            _int13_diskette_function.status	set	$18
32690                       FFFFFFFA            .int13_diskette_function.status	set	-6
32691                       00000034            _int13_diskette_function.AX	set	$34
32692                       00000016            .int13_diskette_function.AX	set	$16
32693                       0000000F            _int13_diskette_function.val8	set	$F
32694                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32695                       00000000            _int13_diskette_function.last_addr	set	0
32696                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32697                       00000011            _int13_diskette_function.page	set	$11
32698                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32699                       00000004            _int13_diskette_function.ah	set	4
32700                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32701                       0000001D            _int13_diskette_function.drive	set	$1D
32702                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32703                       00000005            _int13_diskette_function.num_floppies	set	5
32704                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32705                       0000002E            _int13_diskette_function.BX	set	$2E
32706                       00000010            .int13_diskette_function.BX	set	$10
32707 94E5           FA                                 cli
32708                                           ! 4758 endasm
32709                                           !BCC_ENDASM
32710                                           !BCC_EOS
32711                                           ! 4759         val8 = read_byte(0x0040, 0x003e);
32712                                           ! Debug: list int = const $3E (used reg = )
32713 94E6           B8                   003E  mov	ax,*$3E
32714 94E9           50                         push	ax
32715                                           ! Debug: list int = const $40 (used reg = )
32716 94EA           B8                   0040  mov	ax,*$40
32717 94ED           50                         push	ax
32718                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32719 94EE           E8         7103            call	_read_byte
32720 94F1           83C4                   04  add	sp,*4
32721                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32722 94F4           8846         F1            mov	-$F[bp],al
32723                                           !BCC_EOS
32724                                           ! 4760         val8 &= 0x7f;
32725                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
32726 94F7           8A46         F1            mov	al,-$F[bp]
32727 94FA           24                     7F  and	al,*$7F
32728 94FC           8846         F1            mov	-$F[bp],al
32729                                           !BCC_EOS
32730                                           ! 4761         write_byte(0x0040, 0x003e, val8);
32731                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
32732 94FF           8A46         F1            mov	al,-$F[bp]
32733 9502           30E4                       xor	ah,ah
32734 9504           50                         push	ax
32735                                           ! Debug: list int = const $3E (used reg = )
32736 9505           B8                   003E  mov	ax,*$3E
32737 9508           50                         push	ax
32738                                           ! Debug: list int = const $40 (used reg = )
32739 9509           B8                   0040  mov	ax,*$40
32740 950C           50                         push	ax
32741                                           ! Debug: func () void = write_byte+0 (used reg = )
32742 950D           E8         710A            call	_write_byte
32743 9510           83C4                   06  add	sp,*6
32744                                           !BCC_EOS
32745                                           ! 4762         val8 = inb(0x3f4);
32746                                           ! Debug: list int = const $3F4 (used reg = )
32747 9513           B8                   03F4  mov	ax,#$3F4
32748 9516           50                         push	ax
32749                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32750 9517           E8         7024            call	_inb
32751 951A           44                         inc	sp
32752 951B           44                         inc	sp
32753                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32754 951C           8846         F1            mov	-$F[bp],al
32755                                           !BCC_EOS
32756                                           ! 4763         if ( (val8 & 0xc0) != 0xc0 )
32757                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
32758 951F           8A46         F1            mov	al,-$F[bp]
32759 9522           24                     C0  and	al,#$C0
32760                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
32761 9524           3C                     C0  cmp	al,#$C0
32762 9526           74           0E            je  	.69C
32763                       00009528            .69D:
32764                                           ! 4764           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32765                                           ! Debug: list * char = .69E+0 (used reg = )
32766 9528           BB                   D0E3  mov	bx,#.69E
32767 952B           53                         push	bx
32768                                           ! Debug: list int = const 7 (used reg = )
32769 952C           B8                   0007  mov	ax,*7
32770 952F           50                         push	ax
32771                                           ! Debug: func () void = bios_printf+0 (used reg = )
32772 9530           E8         74E8            call	_bios_printf
32773 9533           83C4                   04  add	sp,*4
32774                                           !BCC_EOS
32775                                           ! 4765 
32776                                           ! 4765         return_status[0] = inb(0x3f5);
32777                       00009536            .69C:
32778                                           ! Debug: list int = const $3F5 (used reg = )
32779 9536           B8                   03F5  mov	ax,#$3F5
32780 9539           50                         push	ax
32781                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32782 953A           E8         7001            call	_inb
32783 953D           44                         inc	sp
32784 953E           44                         inc	sp
32785                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32786 953F           8846         E9            mov	-$17[bp],al
32787                                           !BCC_EOS
32788                                           ! 4766         return_status[1] = inb(0x3f5);
32789                                           ! Debug: list int = const $3F5 (used reg = )
32790 9542           B8                   03F5  mov	ax,#$3F5
32791 9545           50                         push	ax
32792                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32793 9546           E8         6FF5            call	_inb
32794 9549           44                         inc	sp
32795 954A           44                         inc	sp
32796                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32797 954B           8846         EA            mov	-$16[bp],al
32798                                           !BCC_EOS
32799                                           ! 4767         return_status[2] = inb(0x3f5);
32800                                           ! Debug: list int = const $3F5 (used reg = )
32801 954E           B8                   03F5  mov	ax,#$3F5
32802 9551           50                         push	ax
32803                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32804 9552           E8         6FE9            call	_inb
32805 9555           44                         inc	sp
32806 9556           44                         inc	sp
32807                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32808 9557           8846         EB            mov	-$15[bp],al
32809                                           !BCC_EOS
32810                                           ! 4768         return_status[3] = inb(0x3f5);
32811                                           ! Debug: list int = const $3F5 (used reg = )
32812 955A           B8                   03F5  mov	ax,#$3F5
32813 955D           50                         push	ax
32814                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32815 955E           E8         6FDD            call	_inb
32816 9561           44                         inc	sp
32817 9562           44                         inc	sp
32818                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32819 9563           8846         EC            mov	-$14[bp],al
32820                                           !BCC_EOS
32821                                           ! 4769         return_status[4] = inb(0x3f5);
32822                                           ! Debug: list int = const $3F5 (used reg = )
32823 9566           B8                   03F5  mov	ax,#$3F5
32824 9569           50                         push	ax
32825                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32826 956A           E8         6FD1            call	_inb
32827 956D           44                         inc	sp
32828 956E           44                         inc	sp
32829                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32830 956F           8846         ED            mov	-$13[bp],al
32831                                           !BCC_EOS
32832                                           ! 4770         return_status[5] = inb(0x3f5);
32833                                           ! Debug: list int = const $3F5 (used reg = )
32834 9572           B8                   03F5  mov	ax,#$3F5
32835 9575           50                         push	ax
32836                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32837 9576           E8         6FC5            call	_inb
32838 9579           44                         inc	sp
32839 957A           44                         inc	sp
32840                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
32841 957B           8846         EE            mov	-$12[bp],al
32842                                           !BCC_EOS
32843                                           ! 4771         return_status[6] = inb(0x3f5);
32844                                           ! Debug: list int = const $3F5 (used reg = )
32845 957E           B8                   03F5  mov	ax,#$3F5
32846 9581           50                         push	ax
32847                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32848 9582           E8         6FB9            call	_inb
32849 9585           44                         inc	sp
32850 9586           44                         inc	sp
32851                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
32852 9587           8846         EF            mov	-$11[bp],al
32853                                           !BCC_EOS
32854                                           ! 4772         write_byte(0x0040, 0x0042, return_status[0]);
32855                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
32856 958A           8A46         E9            mov	al,-$17[bp]
32857 958D           30E4                       xor	ah,ah
32858 958F           50                         push	ax
32859                                           ! Debug: list int = const $42 (used reg = )
32860 9590           B8                   0042  mov	ax,*$42
32861 9593           50                         push	ax
32862                                           ! Debug: list int = const $40 (used reg = )
32863 9594           B8                   0040  mov	ax,*$40
32864 9597           50                         push	ax
32865                                           ! Debug: func () void = write_byte+0 (used reg = )
32866 9598           E8         707F            call	_write_byte
32867 959B           83C4                   06  add	sp,*6
32868                                           !BCC_EOS
32869                                           ! 4773         write_byte(0x0040, 0x0043, return_status[1]);
32870                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
32871 959E           8A46         EA            mov	al,-$16[bp]
32872 95A1           30E4                       xor	ah,ah
32873 95A3           50                         push	ax
32874                                           ! Debug: list int = const $43 (used reg = )
32875 95A4           B8                   0043  mov	ax,*$43
32876 95A7           50                         push	ax
32877                                           ! Debug: list int = const $40 (used reg = )
32878 95A8           B8                   0040  mov	ax,*$40
32879 95AB           50                         push	ax
32880                                           ! Debug: func () void = write_byte+0 (used reg = )
32881 95AC           E8         706B            call	_write_byte
32882 95AF           83C4                   06  add	sp,*6
32883                                           !BCC_EOS
32884                                           ! 4774         write_byte(0x0040, 0x0044, return_status[2]);
32885                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
32886 95B2           8A46         EB            mov	al,-$15[bp]
32887 95B5           30E4                       xor	ah,ah
32888 95B7           50                         push	ax
32889                                           ! Debug: list int = const $44 (used reg = )
32890 95B8           B8                   0044  mov	ax,*$44
32891 95BB           50                         push	ax
32892                                           ! Debug: list int = const $40 (used reg = )
32893 95BC           B8                   0040  mov	ax,*$40
32894 95BF           50                         push	ax
32895                                           ! Debug: func () void = write_byte+0 (used reg = )
32896 95C0           E8         7057            call	_write_byte
32897 95C3           83C4                   06  add	sp,*6
32898                                           !BCC_EOS
32899                                           ! 4775         write_byte(0x0040, 0x0045, return_status[3]);
32900                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
32901 95C6           8A46         EC            mov	al,-$14[bp]
32902 95C9           30E4                       xor	ah,ah
32903 95CB           50                         push	ax
32904                                           ! Debug: list int = const $45 (used reg = )
32905 95CC           B8                   0045  mov	ax,*$45
32906 95CF           50                         push	ax
32907                                           ! Debug: list int = const $40 (used reg = )
32908 95D0           B8                   0040  mov	ax,*$40
32909 95D3           50                         push	ax
32910                                           ! Debug: func () void = write_byte+0 (used reg = )
32911 95D4           E8         7043            call	_write_byte
32912 95D7           83C4                   06  add	sp,*6
32913                                           !BCC_EOS
32914                                           ! 4776         write_byte(0x0040, 0x0046, return_status[4]);
32915                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
32916 95DA           8A46         ED            mov	al,-$13[bp]
32917 95DD           30E4                       xor	ah,ah
32918 95DF           50                         push	ax
32919                                           ! Debug: list int = const $46 (used reg = )
32920 95E0           B8                   0046  mov	ax,*$46
32921 95E3           50                         push	ax
32922                                           ! Debug: list int = const $40 (used reg = )
32923 95E4           B8                   0040  mov	ax,*$40
32924 95E7           50                         push	ax
32925                                           ! Debug: func () void = write_byte+0 (used reg = )
32926 95E8           E8         702F            call	_write_byte
32927 95EB           83C4                   06  add	sp,*6
32928                                           !BCC_EOS
32929                                           ! 4777         write_byte(0x0040, 0x0047, return_status[5]);
32930                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
32931 95EE           8A46         EE            mov	al,-$12[bp]
32932 95F1           30E4                       xor	ah,ah
32933 95F3           50                         push	ax
32934                                           ! Debug: list int = const $47 (used reg = )
32935 95F4           B8                   0047  mov	ax,*$47
32936 95F7           50                         push	ax
32937                                           ! Debug: list int = const $40 (used reg = )
32938 95F8           B8                   0040  mov	ax,*$40
32939 95FB           50                         push	ax
32940                                           ! Debug: func () void = write_byte+0 (used reg = )
32941 95FC           E8         701B            call	_write_byte
32942 95FF           83C4                   06  add	sp,*6
32943                                           !BCC_EOS
32944                                           ! 4778         write_byte(0x0040, 0x0048, return_status[6]);
32945                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
32946 9602           8A46         EF            mov	al,-$11[bp]
32947 9605           30E4                       xor	ah,ah
32948 9607           50                         push	ax
32949                                           ! Debug: list int = const $48 (used reg = )
32950 9608           B8                   0048  mov	ax,*$48
32951 960B           50                         push	ax
32952                                           ! Debug: list int = const $40 (used reg = )
32953 960C           B8                   0040  mov	ax,*$40
32954 960F           50                         push	ax
32955                                           ! Debug: func () void = write_byte+0 (used reg = )
32956 9610           E8         7007            call	_write_byte
32957 9613           83C4                   06  add	sp,*6
32958                                           !BCC_EOS
32959                                           ! 4779         if ( (return_status[0] & 0xc0) != 0 ) {
32960                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
32961 9616           8A46         E9            mov	al,-$17[bp]
32962 9619           24                     C0  and	al,#$C0
32963                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32964 961B           84C0                       test	al,al
32965 961D           74           2B            je  	.69F
32966                       0000961F            .6A0:
32967                                           ! 4780           if ( (return_status[1] & 0x02) != 0 ) {
32968                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
32969 961F           8A46         EA            mov	al,-$16[bp]
32970 9622           24                     02  and	al,*2
32971                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32972 9624           84C0                       test	al,al
32973 9626           74           14            je  	.6A1
32974                       00009628            .6A2:
32975                                           ! 4781             AX = 0x0300;
32976                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
32977 9628           B8                   0300  mov	ax,#$300
32978 962B           8946         16            mov	$16[bp],ax
32979                                           !BCC_EOS
32980                                           ! 4782             FLAGS |= 0x0001;
32981                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32982 962E           8B46         1C            mov	ax,$1C[bp]
32983 9631           0C                     01  or	al,*1
32984 9633           8946         1C            mov	$1C[bp],ax
32985                                           !BCC_EOS
32986                                           ! 4783             return;
32987 9636           89EC                       mov	sp,bp
32988 9638           5D                         pop	bp
32989 9639           C3                         ret
32990                                           !BCC_EOS
32991                                           ! 4784           } else {
32992 963A           EB           0E            jmp .6A3
32993                       0000963C            .6A1:
32994                                           ! 4785             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
32995                                           ! Debug: list * char = .6A4+0 (used reg = )
32996 963C           BB                   D0BE  mov	bx,#.6A4
32997 963F           53                         push	bx
32998                                           ! Debug: list int = const 7 (used reg = )
32999 9640           B8                   0007  mov	ax,*7
33000 9643           50                         push	ax
33001                                           ! Debug: func () void = bios_printf+0 (used reg = )
33002 9644           E8         73D4            call	_bios_printf
33003 9647           83C4                   04  add	sp,*4
33004                                           !BCC_EOS
33005                                           ! 4786           }
33006                                           ! 4787         }
33007                       0000964A            .6A3:
33008                                           ! 4788         set_diskette_current_cyl(drive, track);
33009                       0000964A            .69F:
33010                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33011 964A           8A46         FD            mov	al,-3[bp]
33012 964D           30E4                       xor	ah,ah
33013 964F           50                         push	ax
33014                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33015 9650           8A46         FF            mov	al,-1[bp]
33016 9653           30E4                       xor	ah,ah
33017 9655           50                         push	ax
33018                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33019 9656           E8         07C9            call	_set_diskette_current_cyl
33020 9659           83C4                   04  add	sp,*4
33021                                           !BCC_EOS
33022                                           ! 4789         AX = ((AX & 0x00ff) | ((0x00) << 8));
33023                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33024 965C           8A46         16            mov	al,$16[bp]
33025                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33026 965F           0C                     00  or	al,*0
33027                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33028 9661           30E4                       xor	ah,ah
33029 9663           8946         16            mov	$16[bp],ax
33030                                           !BCC_EOS
33031                                           ! 4790         FLAGS &= 0xfffe;
33032                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33033 9666           8B46         1C            mov	ax,$1C[bp]
33034 9669           24                     FE  and	al,#$FE
33035 966B           8946         1C            mov	$1C[bp],ax
33036                                           !BCC_EOS
33037                                           ! 4791         return;
33038 966E           89EC                       mov	sp,bp
33039 9670           5D                         pop	bp
33040 9671           C3                         ret
33041                                           !BCC_EOS
33042                                           ! 4792       } else {
33043 9672           EB           28            jmp .6A5
33044                       00009674            .690:
33045                                           ! 4793         set_diskette_current_cyl(drive, track);
33046                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33047 9674           8A46         FD            mov	al,-3[bp]
33048 9677           30E4                       xor	ah,ah
33049 9679           50                         push	ax
33050                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33051 967A           8A46         FF            mov	al,-1[bp]
33052 967D           30E4                       xor	ah,ah
33053 967F           50                         push	ax
33054                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33055 9680           E8         079F            call	_set_diskette_current_cyl
33056 9683           83C4                   04  add	sp,*4
33057                                           !BCC_EOS
33058                                           ! 4794         FLAGS &= 0xfffe;
33059                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33060 9686           8B46         1C            mov	ax,$1C[bp]
33061 9689           24                     FE  and	al,#$FE
33062 968B           8946         1C            mov	$1C[bp],ax
33063                                           !BCC_EOS
33064                                           ! 4795         AX = ((AX & 0x00ff) | ((0x00) << 8));
33065                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33066 968E           8A46         16            mov	al,$16[bp]
33067                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33068 9691           0C                     00  or	al,*0
33069                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33070 9693           30E4                       xor	ah,ah
33071 9695           8946         16            mov	$16[bp],ax
33072                                           !BCC_EOS
33073                                           ! 4796         return;
33074 9698           89EC                       mov	sp,bp
33075 969A           5D                         pop	bp
33076 969B           C3                         ret
33077                                           !BCC_EOS
33078                                           ! 4797       }
33079                                           ! 4798       break;
33080                       0000969C            .6A5:
33081                       0000969C            .68F:
33082 969C           E9         0767            br 	.661
33083                                           !BCC_EOS
33084                                           ! 4799     case 0x05:
33085                                           ! 4800 ;
33086                       0000969F            .6A6:
33087                                           !BCC_EOS
33088                                           ! 4801       num_sectors = ( AX & 0x00ff );
33089                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33090 969F           8A46         16            mov	al,$16[bp]
33091                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33092 96A2           8846         FE            mov	-2[bp],al
33093                                           !BCC_EOS
33094                                           ! 4802       track = ( CX >> 8 );
33095                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
33096 96A5           8B46         14            mov	ax,$14[bp]
33097 96A8           88E0                       mov	al,ah
33098 96AA           30E4                       xor	ah,ah
33099                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
33100 96AC           8846         FD            mov	-3[bp],al
33101                                           !BCC_EOS
33102                                           ! 4803       head = ( DX >> 8 );
33103                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
33104 96AF           8B46         12            mov	ax,$12[bp]
33105 96B2           88E0                       mov	al,ah
33106 96B4           30E4                       xor	ah,ah
33107                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
33108 96B6           8846         FB            mov	-5[bp],al
33109                                           !BCC_EOS
33110                                           ! 4804       drive = ( ELDX & 0x00ff );
33111                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
33112 96B9           8A46         0E            mov	al,$E[bp]
33113                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
33114 96BC           8846         FF            mov	-1[bp],al
33115                                           !BCC_EOS
33116                                           ! 4805       if ((drive > 1) || (head > 1) || (track > 79) ||
33117                                           ! 4806           (num_sectors == 0) || (num_sectors > 18)) {
33118                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
33119 96BF           8A46         FF            mov	al,-1[bp]
33120 96C2           3C                     01  cmp	al,*1
33121 96C4           77           1C            ja  	.6A8
33122                       000096C6            .6AC:
33123                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
33124 96C6           8A46         FB            mov	al,-5[bp]
33125 96C9           3C                     01  cmp	al,*1
33126 96CB           77           15            ja  	.6A8
33127                       000096CD            .6AB:
33128                                           ! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
33129 96CD           8A46         FD            mov	al,-3[bp]
33130 96D0           3C                     4F  cmp	al,*$4F
33131 96D2           77           0E            ja  	.6A8
33132                       000096D4            .6AA:
33133                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33134 96D4           8A46         FE            mov	al,-2[bp]
33135 96D7           84C0                       test	al,al
33136 96D9           74           07            je  	.6A8
33137                       000096DB            .6A9:
33138                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
33139 96DB           8A46         FE            mov	al,-2[bp]
33140 96DE           3C                     12  cmp	al,*$12
33141 96E0           76           1C            jbe 	.6A7
33142                       000096E2            .6A8:
33143                                           ! 4807         AX = ((AX & 0x00ff) | ((1) << 8));
33144                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33145 96E2           8A46         16            mov	al,$16[bp]
33146                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33147 96E5           30E4                       xor	ah,ah
33148 96E7           0D                   0100  or	ax,#$100
33149                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33150 96EA           8946         16            mov	$16[bp],ax
33151                                           !BCC_EOS
33152                                           ! 4808         set_diskette_ret_status(1);
33153                                           ! Debug: list int = const 1 (used reg = )
33154 96ED           B8                   0001  mov	ax,*1
33155 96F0           50                         push	ax
33156                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33157 96F1           E8         0716            call	_set_diskette_ret_status
33158 96F4           44                         inc	sp
33159 96F5           44                         inc	sp
33160                                           !BCC_EOS
33161                                           ! 4809         FLAGS |= 0x0001;
33162                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33163 96F6           8B46         1C            mov	ax,$1C[bp]
33164 96F9           0C                     01  or	al,*1
33165 96FB           8946         1C            mov	$1C[bp],ax
33166                                           !BCC_EOS
33167                                           ! 4810       }
33168                                           ! 4811       if (floppy_drive_exists(drive) == 0) {
33169                       000096FE            .6A7:
33170                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33171 96FE           8A46         FF            mov	al,-1[bp]
33172 9701           30E4                       xor	ah,ah
33173 9703           50                         push	ax
33174                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
33175 9704           E8         F5C3            call	_floppy_drive_exists
33176 9707           44                         inc	sp
33177 9708           44                         inc	sp
33178                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33179 9709           85C0                       test	ax,ax
33180 970B           75           20            jne 	.6AD
33181                       0000970D            .6AE:
33182                                           ! 4812         AX = ((AX & 0x00ff) | ((0x80) << 8));
33183                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33184 970D           8A46         16            mov	al,$16[bp]
33185                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33186 9710           30E4                       xor	ah,ah
33187 9712           0D                   8000  or	ax,#-$8000
33188                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33189 9715           8946         16            mov	$16[bp],ax
33190                                           !BCC_EOS
33191                                           ! 4813         set_diskette_ret_status(0x80);
33192                                           ! Debug: list int = const $80 (used reg = )
33193 9718           B8                   0080  mov	ax,#$80
33194 971B           50                         push	ax
33195                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33196 971C           E8         06EB            call	_set_diskette_ret_status
33197 971F           44                         inc	sp
33198 9720           44                         inc	sp
33199                                           !BCC_EOS
33200                                           ! 4814         FLAGS |= 0x0001;
33201                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33202 9721           8B46         1C            mov	ax,$1C[bp]
33203 9724           0C                     01  or	al,*1
33204 9726           8946         1C            mov	$1C[bp],ax
33205                                           !BCC_EOS
33206                                           ! 4815         return;
33207 9729           89EC                       mov	sp,bp
33208 972B           5D                         pop	bp
33209 972C           C3                         ret
33210                                           !BCC_EOS
33211                                           ! 4816       }
33212                                           ! 4817       if (floppy_media_known(drive) == 0) {
33213                       0000972D            .6AD:
33214                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33215 972D           8A46         FF            mov	al,-1[bp]
33216 9730           30E4                       xor	ah,ah
33217 9732           50                         push	ax
33218                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
33219 9733           E8         F2FF            call	_floppy_media_known
33220 9736           44                         inc	sp
33221 9737           44                         inc	sp
33222                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33223 9738           85C0                       test	ax,ax
33224 973A           75           39            jne 	.6AF
33225                       0000973C            .6B0:
33226                                           ! 4818         if (floppy_media_sense(drive) == 0) {
33227                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33228 973C           8A46         FF            mov	al,-1[bp]
33229 973F           30E4                       xor	ah,ah
33230 9741           50                         push	ax
33231                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
33232 9742           E8         F373            call	_floppy_media_sense
33233 9745           44                         inc	sp
33234 9746           44                         inc	sp
33235                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33236 9747           85C0                       test	ax,ax
33237 9749           75           2A            jne 	.6B1
33238                       0000974B            .6B2:
33239                                           ! 4819           AX = ((AX & 0x00ff) | ((0x0C) << 8));
33240                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33241 974B           8A46         16            mov	al,$16[bp]
33242                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
33243 974E           30E4                       xor	ah,ah
33244 9750           0D                   0C00  or	ax,#$C00
33245                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33246 9753           8946         16            mov	$16[bp],ax
33247                                           !BCC_EOS
33248                                           ! 4820           set_diskette_ret_status(0x0C);
33249                                           ! Debug: list int = const $C (used reg = )
33250 9756           B8                   000C  mov	ax,*$C
33251 9759           50                         push	ax
33252                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33253 975A           E8         06AD            call	_set_diskette_ret_status
33254 975D           44                         inc	sp
33255 975E           44                         inc	sp
33256                                           !BCC_EOS
33257                                           ! 4821           AX = ((AX & 0xff00) | (0));
33258                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33259 975F           8B46         16            mov	ax,$16[bp]
33260 9762           30C0                       xor	al,al
33261                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33262 9764           0C                     00  or	al,*0
33263                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33264 9766           8946         16            mov	$16[bp],ax
33265                                           !BCC_EOS
33266                                           ! 4822           FLAGS |= 0x0001;
33267                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33268 9769           8B46         1C            mov	ax,$1C[bp]
33269 976C           0C                     01  or	al,*1
33270 976E           8946         1C            mov	$1C[bp],ax
33271                                           !BCC_EOS
33272                                           ! 4823           retur
33273                                           ! 4823 n;
33274 9771           89EC                       mov	sp,bp
33275 9773           5D                         pop	bp
33276 9774           C3                         ret
33277                                           !BCC_EOS
33278                                           ! 4824         }
33279                                           ! 4825       }
33280                       00009775            .6B1:
33281                                           ! 4826       page = (ES >> 12);
33282                       00009775            .6AF:
33283                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
33284 9775           8B46         06            mov	ax,6[bp]
33285 9778           88E0                       mov	al,ah
33286 977A           30E4                       xor	ah,ah
33287 977C           B1                     04  mov	cl,*4
33288 977E           D3E8                       shr	ax,cl
33289                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
33290 9780           8846         F3            mov	-$D[bp],al
33291                                           !BCC_EOS
33292                                           ! 4827       base_es = (ES << 4);
33293                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
33294 9783           8B46         06            mov	ax,6[bp]
33295 9786           B1                     04  mov	cl,*4
33296 9788           D3E0                       shl	ax,cl
33297                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
33298 978A           8946         F4            mov	-$C[bp],ax
33299                                           !BCC_EOS
33300                                           ! 4828       base_address = base_es + BX;
33301                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
33302 978D           8B46         F4            mov	ax,-$C[bp]
33303 9790           0346         10            add	ax,$10[bp]
33304                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
33305 9793           8946         F8            mov	-8[bp],ax
33306                                           !BCC_EOS
33307                                           ! 4829       if ( base_address < base_es ) {
33308                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
33309 9796           8B46         F8            mov	ax,-8[bp]
33310 9799           3B46         F4            cmp	ax,-$C[bp]
33311 979C           73           07            jae 	.6B3
33312                       0000979E            .6B4:
33313                                           ! 4830         page++;
33314                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
33315 979E           8A46         F3            mov	al,-$D[bp]
33316 97A1           40                         inc	ax
33317 97A2           8846         F3            mov	-$D[bp],al
33318                                           !BCC_EOS
33319                                           ! 4831       }
33320                                           ! 4832       base_count = (num_sectors * 4) - 1;
33321                       000097A5            .6B3:
33322                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
33323 97A5           8A46         FE            mov	al,-2[bp]
33324 97A8           30E4                       xor	ah,ah
33325 97AA           D1E0                       shl	ax,*1
33326 97AC           D1E0                       shl	ax,*1
33327                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33328                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
33329 97AE           48                         dec	ax
33330 97AF           8946         F6            mov	-$A[bp],ax
33331                                           !BCC_EOS
33332                                           ! 4833       last_addr = base_address + base_count;
33333                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
33334 97B2           8B46         F8            mov	ax,-8[bp]
33335 97B5           0346         F6            add	ax,-$A[bp]
33336                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
33337 97B8           8946         E2            mov	-$1E[bp],ax
33338                                           !BCC_EOS
33339                                           ! 4834       if (last_addr < base_address) {
33340                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
33341 97BB           8B46         E2            mov	ax,-$1E[bp]
33342 97BE           3B46         F8            cmp	ax,-8[bp]
33343 97C1           73           2A            jae 	.6B5
33344                       000097C3            .6B6:
33345                                           ! 4835         AX = ((AX & 0x00ff) | ((0x09) << 8));
33346                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33347 97C3           8A46         16            mov	al,$16[bp]
33348                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
33349 97C6           30E4                       xor	ah,ah
33350 97C8           0D                   0900  or	ax,#$900
33351                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33352 97CB           8946         16            mov	$16[bp],ax
33353                                           !BCC_EOS
33354                                           ! 4836         set_diskette_ret_status(0x09);
33355                                           ! Debug: list int = const 9 (used reg = )
33356 97CE           B8                   0009  mov	ax,*9
33357 97D1           50                         push	ax
33358                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33359 97D2           E8         0635            call	_set_diskette_ret_status
33360 97D5           44                         inc	sp
33361 97D6           44                         inc	sp
33362                                           !BCC_EOS
33363                                           ! 4837         AX = ((AX & 0xff00) | (0));
33364                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33365 97D7           8B46         16            mov	ax,$16[bp]
33366 97DA           30C0                       xor	al,al
33367                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33368 97DC           0C                     00  or	al,*0
33369                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33370 97DE           8946         16            mov	$16[bp],ax
33371                                           !BCC_EOS
33372                                           ! 4838         FLAGS |= 0x0001;
33373                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33374 97E1           8B46         1C            mov	ax,$1C[bp]
33375 97E4           0C                     01  or	al,*1
33376 97E6           8946         1C            mov	$1C[bp],ax
33377                                           !BCC_EOS
33378                                           ! 4839         return;
33379 97E9           89EC                       mov	sp,bp
33380 97EB           5D                         pop	bp
33381 97EC           C3                         ret
33382                                           !BCC_EOS
33383                                           ! 4840       }
33384                                           ! 4841       outb(0x000a, 0x06);
33385                       000097ED            .6B5:
33386                                           ! Debug: list int = const 6 (used reg = )
33387 97ED           B8                   0006  mov	ax,*6
33388 97F0           50                         push	ax
33389                                           ! Debug: list int = const $A (used reg = )
33390 97F1           B8                   000A  mov	ax,*$A
33391 97F4           50                         push	ax
33392                                           ! Debug: func () void = outb+0 (used reg = )
33393 97F5           E8         6D5C            call	_outb
33394 97F8           83C4                   04  add	sp,*4
33395                                           !BCC_EOS
33396                                           ! 4842       outb(0x000c, 0x00);
33397                                           ! Debug: list int = const 0 (used reg = )
33398 97FB           31C0                       xor	ax,ax
33399 97FD           50                         push	ax
33400                                           ! Debug: list int = const $C (used reg = )
33401 97FE           B8                   000C  mov	ax,*$C
33402 9801           50                         push	ax
33403                                           ! Debug: func () void = outb+0 (used reg = )
33404 9802           E8         6D4F            call	_outb
33405 9805           83C4                   04  add	sp,*4
33406                                           !BCC_EOS
33407                                           ! 4843       outb(0x0004, base_address);
33408                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
33409 9808           FF76         F8            push	-8[bp]
33410                                           ! Debug: list int = const 4 (used reg = )
33411 980B           B8                   0004  mov	ax,*4
33412 980E           50                         push	ax
33413                                           ! Debug: func () void = outb+0 (used reg = )
33414 980F           E8         6D42            call	_outb
33415 9812           83C4                   04  add	sp,*4
33416                                           !BCC_EOS
33417                                           ! 4844       outb(0x0004, base_address>>8);
33418                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
33419 9815           8B46         F8            mov	ax,-8[bp]
33420 9818           88E0                       mov	al,ah
33421 981A           30E4                       xor	ah,ah
33422                                           ! Debug: list unsigned int = ax+0 (used reg = )
33423 981C           50                         push	ax
33424                                           ! Debug: list int = const 4 (used reg = )
33425 981D           B8                   0004  mov	ax,*4
33426 9820           50                         push	ax
33427                                           ! Debug: func () void = outb+0 (used reg = )
33428 9821           E8         6D30            call	_outb
33429 9824           83C4                   04  add	sp,*4
33430                                           !BCC_EOS
33431                                           ! 4845       outb(0x000c, 0x00);
33432                                           ! Debug: list int = const 0 (used reg = )
33433 9827           31C0                       xor	ax,ax
33434 9829           50                         push	ax
33435                                           ! Debug: list int = const $C (used reg = )
33436 982A           B8                   000C  mov	ax,*$C
33437 982D           50                         push	ax
33438                                           ! Debug: func () void = outb+0 (used reg = )
33439 982E           E8         6D23            call	_outb
33440 9831           83C4                   04  add	sp,*4
33441                                           !BCC_EOS
33442                                           ! 4846       outb(0x0005, base_count);
33443                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
33444 9834           FF76         F6            push	-$A[bp]
33445                                           ! Debug: list int = const 5 (used reg = )
33446 9837           B8                   0005  mov	ax,*5
33447 983A           50                         push	ax
33448                                           ! Debug: func () void = outb+0 (used reg = )
33449 983B           E8         6D16            call	_outb
33450 983E           83C4                   04  add	sp,*4
33451                                           !BCC_EOS
33452                                           ! 4847       outb(0x0005, base_count>>8);
33453                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
33454 9841           8B46         F6            mov	ax,-$A[bp]
33455 9844           88E0                       mov	al,ah
33456 9846           30E4                       xor	ah,ah
33457                                           ! Debug: list unsigned int = ax+0 (used reg = )
33458 9848           50                         push	ax
33459                                           ! Debug: list int = const 5 (used reg = )
33460 9849           B8                   0005  mov	ax,*5
33461 984C           50                         push	ax
33462                                           ! Debug: func () void = outb+0 (used reg = )
33463 984D           E8         6D04            call	_outb
33464 9850           83C4                   04  add	sp,*4
33465                                           !BCC_EOS
33466                                           ! 4848       mode_register = 0x4a;
33467                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
33468 9853           B0                     4A  mov	al,*$4A
33469 9855           8846         F2            mov	-$E[bp],al
33470                                           !BCC_EOS
33471                                           ! 4849       outb(0x000b, mode_register);
33472                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
33473 9858           8A46         F2            mov	al,-$E[bp]
33474 985B           30E4                       xor	ah,ah
33475 985D           50                         push	ax
33476                                           ! Debug: list int = const $B (used reg = )
33477 985E           B8                   000B  mov	ax,*$B
33478 9861           50                         push	ax
33479                                           ! Debug: func () void = outb+0 (used reg = )
33480 9862           E8         6CEF            call	_outb
33481 9865           83C4                   04  add	sp,*4
33482                                           !BCC_EOS
33483                                           ! 4850       outb(0x0081, page);
33484                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
33485 9868           8A46         F3            mov	al,-$D[bp]
33486 986B           30E4                       xor	ah,ah
33487 986D           50                         push	ax
33488                                           ! Debug: list int = const $81 (used reg = )
33489 986E           B8                   0081  mov	ax,#$81
33490 9871           50                         push	ax
33491                                           ! Debug: func () void = outb+0 (used reg = )
33492 9872           E8         6CDF            call	_outb
33493 9875           83C4                   04  add	sp,*4
33494                                           !BCC_EOS
33495                                           ! 4851       outb(0x000a, 0x02);
33496                                           ! Debug: list int = const 2 (used reg = )
33497 9878           B8                   0002  mov	ax,*2
33498 987B           50                         push	ax
33499                                           ! Debug: list int = const $A (used reg = )
33500 987C           B8                   000A  mov	ax,*$A
33501 987F           50                         push	ax
33502                                           ! Debug: func () void = outb+0 (used reg = )
33503 9880           E8         6CD1            call	_outb
33504 9883           83C4                   04  add	sp,*4
33505                                           !BCC_EOS
33506                                           ! 4852       floppy_prepare_controller(drive);
33507                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33508 9886           8A46         FF            mov	al,-1[bp]
33509 9889           30E4                       xor	ah,ah
33510 988B           50                         push	ax
33511                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
33512 988C           E8         F0C7            call	_floppy_prepare_controller
33513 988F           44                         inc	sp
33514 9890           44                         inc	sp
33515                                           !BCC_EOS
33516                                           ! 4853       outb(0x03f5, 0x4d);
33517                                           ! Debug: list int = const $4D (used reg = )
33518 9891           B8                   004D  mov	ax,*$4D
33519 9894           50                         push	ax
33520                                           ! Debug: list int = const $3F5 (used reg = )
33521 9895           B8                   03F5  mov	ax,#$3F5
33522 9898           50                         push	ax
33523                                           ! Debug: func () void = outb+0 (used reg = )
33524 9899           E8         6CB8            call	_outb
33525 989C           83C4                   04  add	sp,*4
33526                                           !BCC_EOS
33527                                           ! 4854       outb(0x03f5, (head << 2) | drive);
33528                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
33529 989F           8A46         FB            mov	al,-5[bp]
33530 98A2           30E4                       xor	ah,ah
33531 98A4           D1E0                       shl	ax,*1
33532 98A6           D1E0                       shl	ax,*1
33533                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
33534 98A8           0A46         FF            or	al,-1[bp]
33535                                           ! Debug: list unsigned int = ax+0 (used reg = )
33536 98AB           50                         push	ax
33537                                           ! Debug: list int = const $3F5 (used reg = )
33538 98AC           B8                   03F5  mov	ax,#$3F5
33539 98AF           50                         push	ax
33540                                           ! Debug: func () void = outb+0 (used reg = )
33541 98B0           E8         6CA1            call	_outb
33542 98B3           83C4                   04  add	sp,*4
33543                                           !BCC_EOS
33544                                           ! 4855       outb(0x03f5, 2);
33545                                           ! Debug: list int = const 2 (used reg = )
33546 98B6           B8                   0002  mov	ax,*2
33547 98B9           50                         push	ax
33548                                           ! Debug: list int = const $3F5 (used reg = )
33549 98BA           B8                   03F5  mov	ax,#$3F5
33550 98BD           50                         push	ax
33551                                           ! Debug: func () void = outb+0 (used reg = )
33552 98BE           E8         6C93            call	_outb
33553 98C1           83C4                   04  add	sp,*4
33554                                           !BCC_EOS
33555                                           ! 4856       outb(0x03f5, num_sectors);
33556                                           ! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
33557 98C4           8A46         FE            mov	al,-2[bp]
33558 98C7           30E4                       xor	ah,ah
33559 98C9           50                         push	ax
33560                                           ! Debug: list int = const $3F5 (used reg = )
33561 98CA           B8                   03F5  mov	ax,#$3F5
33562 98CD           50                         push	ax
33563                                           ! Debug: func () void = outb+0 (used reg = )
33564 98CE           E8         6C83            call	_outb
33565 98D1           83C4                   04  add	sp,*4
33566                                           !BCC_EOS
33567                                           ! 4857       outb(0x03f5, 0);
33568                                           ! Debug: list int = const 0 (used reg = )
33569 98D4           31C0                       xor	ax,ax
33570 98D6           50                         push	ax
33571                                           ! Debug: list int = const $3F5 (used reg = )
33572 98D7           B8                   03F5  mov	ax,#$3F5
33573 98DA           50                         push	ax
33574                                           ! Debug: func () void = outb+0 (used reg = )
33575 98DB           E8         6C76            call	_outb
33576 98DE           83C4                   04  add	sp,*4
33577                                           !BCC_EOS
33578                                           ! 4858       outb(0x03f5, 0xf6);
33579                                           ! Debug: list int = const $F6 (used reg = )
33580 98E1           B8                   00F6  mov	ax,#$F6
33581 98E4           50                         push	ax
33582                                           ! Debug: list int = const $3F5 (used reg = )
33583 98E5           B8                   03F5  mov	ax,#$3F5
33584 98E8           50                         push	ax
33585                                           ! Debug: func () void = outb+0 (used reg = )
33586 98E9           E8         6C68            call	_outb
33587 98EC           83C4                   04  add	sp,*4
33588                                           !BCC_EOS
33589                                           ! 4859 #asm
33590                                           !BCC_EOS
33591                                           !BCC_ASM
33592                       0000002A            _int13_diskette_function.BP	set	$2A
33593                       0000000C            .int13_diskette_function.BP	set	$C
33594                       00000038            _int13_diskette_function.CS	set	$38
33595                       0000001A            .int13_diskette_function.CS	set	$1A
33596                       00000032            _int13_diskette_function.CX	set	$32
33597                       00000014            .int13_diskette_function.CX	set	$14
33598                       00000016            _int13_diskette_function.base_address	set	$16
33599                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33600                       00000026            _int13_diskette_function.DI	set	$26
33601                       00000008            .int13_diskette_function.DI	set	8
33602                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33603                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33604                       00000014            _int13_diskette_function.base_count	set	$14
33605                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33606                       0000001A            _int13_diskette_function.sector	set	$1A
33607                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33608                       00000022            _int13_diskette_function.DS	set	$22
33609                       00000004            .int13_diskette_function.DS	set	4
33610                       00000019            _int13_diskette_function.head	set	$19
33611                       FFFFFFFB            .int13_diskette_function.head	set	-5
33612                       0000002C            _int13_diskette_function.ELDX	set	$2C
33613                       0000000E            .int13_diskette_function.ELDX	set	$E
33614                       0000000E            _int13_diskette_function.dor	set	$E
33615                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33616                       00000030            _int13_diskette_function.DX	set	$30
33617                       00000012            .int13_diskette_function.DX	set	$12
33618                       00000007            _int13_diskette_function.return_status	set	7
33619                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33620                       00000002            _int13_diskette_function.es	set	2
33621                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33622                       00000010            _int13_diskette_function.mode_register	set	$10
33623                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33624                       00000024            _int13_diskette_function.ES	set	$24
33625                       00000006            .int13_diskette_function.ES	set	6
33626                       00000012            _int13_diskette_function.base_es	set	$12
33627                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33628                       0000001B            _int13_diskette_function.track	set	$1B
33629                       FFFFFFFD            .int13_diskette_function.track	set	-3
33630                       00000028            _int13_diskette_function.SI	set	$28
33631                       0000000A            .int13_diskette_function.SI	set	$A
33632                       00000006            _int13_diskette_function.drive_type	set	6
33633                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33634                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33635                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33636                       00000036            _int13_diskette_function.IP	set	$36
33637                       00000018            .int13_diskette_function.IP	set	$18
33638                       00000018            _int13_diskette_function.status	set	$18
33639                       FFFFFFFA            .int13_diskette_function.status	set	-6
33640                       00000034            _int13_diskette_function.AX	set	$34
33641                       00000016            .int13_diskette_function.AX	set	$16
33642                       0000000F            _int13_diskette_function.val8	set	$F
33643                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33644                       00000000            _int13_diskette_function.last_addr	set	0
33645                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33646                       00000011            _int13_diskette_function.page	set	$11
33647                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33648                       00000004            _int13_diskette_function.ah	set	4
33649                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33650                       0000001D            _int13_diskette_function.drive	set	$1D
33651                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33652                       00000005            _int13_diskette_function.num_floppies	set	5
33653                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33654                       0000002E            _int13_diskette_function.BX	set	$2E
33655                       00000010            .int13_diskette_function.BX	set	$10
33656 98EF           FB                               sti
33657                                           ! 4861 endasm
33658                                           !BCC_ENDASM
33659                                           !BCC_EOS
33660                                           ! 4862       do {
33661                       000098F0            .6B9:
33662                                           ! 4863         val8 = read_byte(0x0040, 0x0040);
33663                                           ! Debug: list int = const $40 (used reg = )
33664 98F0           B8                   0040  mov	ax,*$40
33665 98F3           50                         push	ax
33666                                           ! Debug: list int = const $40 (used reg = )
33667 98F4           B8                   0040  mov	ax,*$40
33668 98F7           50                         push	ax
33669                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33670 98F8           E8         6CF9            call	_read_byte
33671 98FB           83C4                   04  add	sp,*4
33672                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33673 98FE           8846         F1            mov	-$F[bp],al
33674                                           !BCC_EOS
33675                                           ! 4864         if (val8 == 0) {
33676                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33677 9901           8A46         F1            mov	al,-$F[bp]
33678 9904           84C0                       test	al,al
33679 9906           75           23            jne 	.6BA
33680                       00009908            .6BB:
33681                                           ! 4865           floppy_reset_controller();
33682                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
33683 9908           E8         EFFD            call	_floppy_reset_controller
33684                                           !BCC_EOS
33685                                           ! 4866           AX = ((AX & 0x00ff) | ((0x80) << 8));
33686                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33687 990B           8A46         16            mov	al,$16[bp]
33688                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33689 990E           30E4                       xor	ah,ah
33690 9910           0D                   8000  or	ax,#-$8000
33691                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33692 9913           8946         16            mov	$16[bp],ax
33693                                           !BCC_EOS
33694                                           ! 4867           set_diskette_ret_status(0x80);
33695                                           ! Debug: list int = const $80 (used reg = )
33696 9916           B8                   0080  mov	ax,#$80
33697 9919           50                         push	ax
33698                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33699 991A           E8         04ED            call	_set_diskette_ret_status
33700 991D           44                         inc	sp
33701 991E           44                         inc	sp
33702                                           !BCC_EOS
33703                                           ! 4868           FLAGS |= 0x0001;
33704                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33705 991F           8B46         1C            mov	ax,$1C[bp]
33706 9922           0C                     01  or	al,*1
33707 9924           8946         1C            mov	$1C[bp],ax
33708                                           !BCC_EOS
33709                                           ! 4869           return;
33710 9927           89EC                       mov	sp,bp
33711 9929           5D                         pop	bp
33712 992A           C3                         ret
33713                                           !BCC_EOS
33714                                           ! 4870         }
33715                                           ! 4871         val8 = (read_byte(0x0040, 0x003e) & 0x80);
33716                       0000992B            .6BA:
33717                                           ! Debug: list int = const $3E (used reg = )
33718 992B           B8                   003E  mov	ax,*$3E
33719 992E           50                         push	ax
33720                                           ! Debug: list int = const $40 (used reg = )
33721 992F           B8                   0040  mov	ax,*$40
33722 9932           50                         push	ax
33723                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33724 9933           E8         6CBE            call	_read_byte
33725 9936           83C4                   04  add	sp,*4
33726                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
33727 9939           24                     80  and	al,#$80
33728                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33729 993B           8846         F1            mov	-$F[bp],al
33730                                           !BCC_EOS
33731                                           ! 4872       } while ( val8 == 0 );
33732                       0000993E            .6B8:
33733                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33734 993E           8A46         F1            mov	al,-$F[bp]
33735 9941           84C0                       test	al,al
33736 9943           74           AB            je 	.6B9
33737                       00009945            .6BC:
33738                                           !BCC_EOS
33739                                           ! 4873       val8 = 0;
33740                       00009945            .6B7:
33741                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33742 9945           30C0                       xor	al,al
33743 9947           8846         F1            mov	-$F[bp],al
33744                                           !BCC_EOS
33745                                           ! 4874 #asm
33746                                           !BCC_EOS
33747                                           !BCC_ASM
33748                       0000002A            _int13_diskette_function.BP	set	$2A
33749                       0000000C            .int13_diskette_function.BP	set	$C
33750                       00000038            _int13_diskette_function.CS	set	$38
33751                       0000001A            .int13_diskette_function.CS	set	$1A
33752                       00000032            _int13_diskette_function.CX	set	$32
33753                       00000014            .int13_diskette_function.CX	set	$14
33754                       00000016            _int13_diskette_function.base_address	set	$16
33755                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33756                       00000026            _int13_diskette_function.DI	set	$26
33757                       00000008            .int13_diskette_function.DI	set	8
33758                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33759                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33760                       00000014            _int13_diskette_function.base_count	set	$14
33761                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33762                       0000001A            _int13_diskette_function.sector	set	$1A
33763                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33764                       00000022            _int13_diskette_function.DS	set	$22
33765                       00000004            .int13_diskette_function.DS	set	4
33766                       00000019            _int13_diskette_function.head	set	$19
33767                       FFFFFFFB            .int13_diskette_function.head	set	-5
33768                       0000002C            _int13_diskette_function.ELDX	set	$2C
33769                       0000000E            .int13_diskette_function.ELDX	set	$E
33770                       0000000E            _int13_diskette_function.dor	set	$E
33771                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33772                       00000030            _int13_diskette_function.DX	set	$30
33773                       00000012            .int13_diskette_function.DX	set	$12
33774                       00000007            _int13_diskette_function.return_status	set	7
33775                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33776                       00000002            _int13_diskette_function.es	set	2
33777                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33778                       00000010            _int13_diskette_function.mode_register	set	$10
33779                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33780                       00000024            _int13_diskette_function.ES	set	$24
33781                       00000006            .int13_diskette_function.ES	set	6
33782                       00000012            _int13_diskette_function.base_es	set	$12
33783                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33784                       0000001B            _int13_diskette_function.track	set	$1B
33785                       FFFFFFFD            .int13_diskette_function.track	set	-3
33786                       00000028            _int13_diskette_function.SI	set	$28
33787                       0000000A            .int13_diskette_function.SI	set	$A
33788                       00000006            _int13_diskette_function.drive_type	set	6
33789                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33790                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33791                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33792                       00000036            _int13_diskette_function.IP	set	$36
33793                       00000018            .int13_diskette_function.IP	set	$18
33794                       00000018            _int13_diskette_function.status	set	$18
33795                       FFFFFFFA            .int13_diskette_function.status	set	-6
33796                       00000034            _int13_diskette_function.AX	set	$34
33797                       00000016            .int13_diskette_function.AX	set	$16
33798                       0000000F            _int13_diskette_function.val8	set	$F
33799                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33800                       00000000            _int13_diskette_function.last_addr	set	0
33801                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33802                       00000011            _int13_diskette_function.page	set	$11
33803                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33804                       00000004            _int13_diskette_function.ah	set	4
33805                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33806                       0000001D            _int13_diskette_function.drive	set	$1D
33807                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33808                       00000005            _int13_diskette_function.num_floppies	set	5
33809                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33810                       0000002E            _int13_diskette_function.BX	set	$2E
33811                       00000010            .int13_diskette_function.BX	set	$10
33812 994A           FA                               cli
33813                                           ! 4876 endasm
33814                                           !BCC_ENDASM
33815                                           !BCC_EOS
33816                                           ! 4877       val8 = read_byte(0x0040, 0x003e);
33817                                           ! Debug: list int = const $3E (used reg = )
33818 994B           B8                   003E  mov	ax,*$3E
33819 994E           50                         push	ax
33820                                           ! Debug: list int = const $40 (used reg = )
33821 994F           B8                   0040  mov	ax,*$40
33822 9952           50                         push	ax
33823                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33824 9953           E8         6C9E            call	_read_byte
33825 9956           83C4                   04  add	sp,*4
33826                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33827 9959           8846         F1            mov	-$F[bp],al
33828                                           !BCC_EOS
33829                                           ! 4878       val8 &= 0x7f;
33830                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
33831 995C           8A46         F1            mov	al,-$F[bp]
33832 995F           24                     7F  and	al,*$7F
33833 9961           8846         F1            mov	-$F[bp],al
33834                                           !BCC_EOS
33835                                           ! 4879       write_byte(0x0040, 0x003e, val8);
33836                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
33837 9964           8A46         F1            mov	al,-$F[bp]
33838 9967           30E4                       xor	ah,ah
33839 9969           50                         push	ax
33840                                           ! Debug: list int = const $3E (used reg = )
33841 996A           B8                   003E  mov	ax,*$3E
33842 996D           50                         push	ax
33843                                           ! Debug: list int = const $40 (used reg = )
33844 996E           B8                   0040  mov	ax,*$40
33845 9971           50                         push	ax
33846                                           ! Debug: func () void = write_byte+0 (used reg = )
33847 9972           E8         6CA5            call	_write_byte
33848 9975           83C4                   06  add	sp,*6
33849                                           !BCC_EOS
33850                                           ! 4880       val8 = inb(0x3f4);
33851                                           ! Debug: list int = const $3F4 (used reg = )
33852 9978           B8                   03F4  mov	ax,#$3F4
33853 997B           50                         push	ax
33854                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33855 997C           E8         6BBF            call	_inb
33856 997F           44                         inc	sp
33857 9980           44                         inc	sp
33858                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33859 9981           8846         F1            mov	-$F[bp],al
33860                                           !BCC_EOS
33861                                           ! 4881       if ( (val8 & 0xc0) != 0xc0 )
33862                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
33863 9984           8A46         F1            mov	al,-$F[bp]
33864 9987           24                     C0  and	al,#$C0
33865                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
33866 9989           3C                     C0  cmp	al,#$C0
33867 998B           74           0E            je  	.6BD
33868                       0000998D            .6BE:
33869                                           ! 4882         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
33870                                           ! Debug: list * char = .6BF+0 (used reg = )
33871 998D           BB                   D09E  mov	bx,#.6BF
33872 9990           53                         push	bx
33873                                           ! Debug: list int = const 7 (used reg = )
33874 9991           B8                   0007  mov	ax,*7
33875 9994           50                         push	ax
33876                                           ! Debug: func () void = bios_printf+0 (used reg = )
33877 9995           E8         7083            call	_bios_printf
33878 9998           83C4                   04  add	sp,*4
33879                                           !BCC_EOS
33880                                           ! 4883       return_status[0] = inb(0x3f5);
33881                       0000999B            .6BD:
33882                                           ! Debug: list int = const $3F5 (used reg = )
33883 999B           B8                   03F5  mov	ax,#$3F5
33884 999E           50                         push	ax
33885                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33886 999F           E8         6B9C            call	_inb
33887 99A2           44                         inc	sp
33888 99A3           44                         inc	sp
33889                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
33890 99A4           8846         E9            mov	-$17[bp],al
33891                                           !BCC_EOS
33892                                           ! 4884       return_status[1] = inb(0x3f5);
33893                                           ! Debug: list int = const $3F5 (used reg = )
33894 99A7           B8                   03F5  mov	ax,#$3F5
33895 99AA           50                         push	ax
33896                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33897 99AB           E8         6B90            call	_inb
33898 99AE           44                         inc	sp
33899 99AF           44                         inc	sp
33900                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
33901 99B0           8846         EA            mov	-$16[bp],al
33902                                           !BCC_EOS
33903                                           ! 4885       return_status[2] = inb(0x3f5);
33904                                           ! Debug: list int = const $3F5 (used reg = )
33905 99B3           B8                   03F5  mov	ax,#$3F5
33906 99B6           50                         push	ax
33907                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33908 99B7           E8         6B84            call	_inb
33909 99BA           44                         inc	sp
33910 99BB           44                         inc	sp
33911                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
33912 99BC           8846         EB            mov	-$15[bp],al
33913                                           !BCC_EOS
33914                                           ! 4886       return_status[3] = inb(0x3f5);
33915                                           ! Debug: list int = const $3F5 (used reg = )
33916 99BF           B8                   03F5  mov	ax,#$3F5
33917 99C2           50                         push	ax
33918                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33919 99C3           E8         6B78            call	_inb
33920 99C6           44                         inc	sp
33921 99C7           44                         inc	sp
33922                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
33923 99C8           8846         EC            mov	-$14[bp],al
33924                                           !BCC_EOS
33925                                           ! 4887       return_status[4] = inb(0x3f5);
33926                                           ! Debug: list int = const $3F5 (used reg = )
33927 99CB           B8                   03F5  mov	ax,#$3F5
33928 99CE           50                         push	ax
33929                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33930 99CF           E8         6B6C            call	_inb
33931 99D2           44                         inc	sp
33932 99D3           44                         inc	sp
33933                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
33934 99D4           8846         ED            mov	-$13[bp],al
33935                                           !BCC_EOS
33936                                           ! 4888       return_status[5] = inb(0x3f5);
33937                                           ! Debug: list int = const $3F5 (used reg = )
33938 99D7           B8                   03F5  mov	ax,#$3F5
33939 99DA           50                         push	ax
33940                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33941 99DB           E8         6B60            call	_inb
33942 99DE           44                         inc	sp
33943 99DF           44                         inc	sp
33944                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
33945 99E0           8846         EE            mov	-$12[bp],al
33946                                           !BCC_EOS
33947                                           ! 4889       return_status[6] = inb(0x3f5);
33948                                           ! Debug: list int = const $3F5 (used reg = )
33949 99E3           B8                   03F5  mov	ax,#$3F5
33950 99E6           50                         push	ax
33951                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33952 99E7           E8         6B54            call	_inb
33953 99EA           44                         inc	sp
33954 99EB           44                         inc	sp
33955                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
33956 99EC           8846         EF            mov	-$11[bp],al
33957                                           !BCC_EOS
33958                                           ! 4890       write_byte(0x0040, 0x0042, return_status[0]);
33959                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
33960 99EF           8A46         E9            mov	al,-$17[bp]
33961 99F2           30E4                       xor	ah,ah
33962 99F4           50                         push	ax
33963                                           ! Debug: list int = const $42 (used reg = )
33964 99F5           B8                   0042  mov	ax,*$42
33965 99F8           50                         push	ax
33966                                           ! Debug: list int = const $40 (used reg = )
33967 99F9           B8                   0040  mov	ax,*$40
33968 99FC           50                         push	ax
33969                                           ! Debug: func () void = write_byte+0 (used reg = )
33970 99FD           E8         6C1A            call	_write_byte
33971 9A00           83C4                   06  add	sp,*6
33972                                           !BCC_EOS
33973                                           ! 4891       write_byte(0x0040, 0x0043, return_status[1]);
33974                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
33975 9A03           8A46         EA            mov	al,-$16[bp]
33976 9A06           30E4                       xor	ah,ah
33977 9A08           50                         push	ax
33978                                           ! Debug: list int = const $43 (used reg = )
33979 9A09           B8                   0043  mov	ax,*$43
33980 9A0C           50                         push	ax
33981                                           ! Debug: list int = const $40 (used reg = )
33982 9A0D           B8                   0040  mov	ax,*$40
33983 9A10           50                         push	ax
33984                                           ! Debug: func () void = write_byte+0 (used reg = )
33985 9A11           E8         6C06            call	_write_byte
33986 9A14           83C4                   06  add	sp,*6
33987                                           !BCC_EOS
33988                                           ! 4892       write_byte(0x0040, 0x0044, return_status
33989                                           ! 4892 [2]);
33990                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
33991 9A17           8A46         EB            mov	al,-$15[bp]
33992 9A1A           30E4                       xor	ah,ah
33993 9A1C           50                         push	ax
33994                                           ! Debug: list int = const $44 (used reg = )
33995 9A1D           B8                   0044  mov	ax,*$44
33996 9A20           50                         push	ax
33997                                           ! Debug: list int = const $40 (used reg = )
33998 9A21           B8                   0040  mov	ax,*$40
33999 9A24           50                         push	ax
34000                                           ! Debug: func () void = write_byte+0 (used reg = )
34001 9A25           E8         6BF2            call	_write_byte
34002 9A28           83C4                   06  add	sp,*6
34003                                           !BCC_EOS
34004                                           ! 4893       write_byte(0x0040, 0x0045, return_status[3]);
34005                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
34006 9A2B           8A46         EC            mov	al,-$14[bp]
34007 9A2E           30E4                       xor	ah,ah
34008 9A30           50                         push	ax
34009                                           ! Debug: list int = const $45 (used reg = )
34010 9A31           B8                   0045  mov	ax,*$45
34011 9A34           50                         push	ax
34012                                           ! Debug: list int = const $40 (used reg = )
34013 9A35           B8                   0040  mov	ax,*$40
34014 9A38           50                         push	ax
34015                                           ! Debug: func () void = write_byte+0 (used reg = )
34016 9A39           E8         6BDE            call	_write_byte
34017 9A3C           83C4                   06  add	sp,*6
34018                                           !BCC_EOS
34019                                           ! 4894       write_byte(0x0040, 0x0046, return_status[4]);
34020                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
34021 9A3F           8A46         ED            mov	al,-$13[bp]
34022 9A42           30E4                       xor	ah,ah
34023 9A44           50                         push	ax
34024                                           ! Debug: list int = const $46 (used reg = )
34025 9A45           B8                   0046  mov	ax,*$46
34026 9A48           50                         push	ax
34027                                           ! Debug: list int = const $40 (used reg = )
34028 9A49           B8                   0040  mov	ax,*$40
34029 9A4C           50                         push	ax
34030                                           ! Debug: func () void = write_byte+0 (used reg = )
34031 9A4D           E8         6BCA            call	_write_byte
34032 9A50           83C4                   06  add	sp,*6
34033                                           !BCC_EOS
34034                                           ! 4895       write_byte(0x0040, 0x0047, return_status[5]);
34035                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
34036 9A53           8A46         EE            mov	al,-$12[bp]
34037 9A56           30E4                       xor	ah,ah
34038 9A58           50                         push	ax
34039                                           ! Debug: list int = const $47 (used reg = )
34040 9A59           B8                   0047  mov	ax,*$47
34041 9A5C           50                         push	ax
34042                                           ! Debug: list int = const $40 (used reg = )
34043 9A5D           B8                   0040  mov	ax,*$40
34044 9A60           50                         push	ax
34045                                           ! Debug: func () void = write_byte+0 (used reg = )
34046 9A61           E8         6BB6            call	_write_byte
34047 9A64           83C4                   06  add	sp,*6
34048                                           !BCC_EOS
34049                                           ! 4896       write_byte(0x0040, 0x0048, return_status[6]);
34050                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
34051 9A67           8A46         EF            mov	al,-$11[bp]
34052 9A6A           30E4                       xor	ah,ah
34053 9A6C           50                         push	ax
34054                                           ! Debug: list int = const $48 (used reg = )
34055 9A6D           B8                   0048  mov	ax,*$48
34056 9A70           50                         push	ax
34057                                           ! Debug: list int = const $40 (used reg = )
34058 9A71           B8                   0040  mov	ax,*$40
34059 9A74           50                         push	ax
34060                                           ! Debug: func () void = write_byte+0 (used reg = )
34061 9A75           E8         6BA2            call	_write_byte
34062 9A78           83C4                   06  add	sp,*6
34063                                           !BCC_EOS
34064                                           ! 4897       if ( (return_status[0] & 0xc0) != 0 ) {
34065                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
34066 9A7B           8A46         E9            mov	al,-$17[bp]
34067 9A7E           24                     C0  and	al,#$C0
34068                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34069 9A80           84C0                       test	al,al
34070 9A82           74           2B            je  	.6C0
34071                       00009A84            .6C1:
34072                                           ! 4898         if ( (return_status[1] & 0x02) != 0 ) {
34073                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
34074 9A84           8A46         EA            mov	al,-$16[bp]
34075 9A87           24                     02  and	al,*2
34076                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34077 9A89           84C0                       test	al,al
34078 9A8B           74           14            je  	.6C2
34079                       00009A8D            .6C3:
34080                                           ! 4899           AX = 0x0300;
34081                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
34082 9A8D           B8                   0300  mov	ax,#$300
34083 9A90           8946         16            mov	$16[bp],ax
34084                                           !BCC_EOS
34085                                           ! 4900           FLAGS |= 0x0001;
34086                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34087 9A93           8B46         1C            mov	ax,$1C[bp]
34088 9A96           0C                     01  or	al,*1
34089 9A98           8946         1C            mov	$1C[bp],ax
34090                                           !BCC_EOS
34091                                           ! 4901           return;
34092 9A9B           89EC                       mov	sp,bp
34093 9A9D           5D                         pop	bp
34094 9A9E           C3                         ret
34095                                           !BCC_EOS
34096                                           ! 4902         } else {
34097 9A9F           EB           0E            jmp .6C4
34098                       00009AA1            .6C2:
34099                                           ! 4903           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
34100                                           ! Debug: list * char = .6C5+0 (used reg = )
34101 9AA1           BB                   D078  mov	bx,#.6C5
34102 9AA4           53                         push	bx
34103                                           ! Debug: list int = const 7 (used reg = )
34104 9AA5           B8                   0007  mov	ax,*7
34105 9AA8           50                         push	ax
34106                                           ! Debug: func () void = bios_printf+0 (used reg = )
34107 9AA9           E8         6F6F            call	_bios_printf
34108 9AAC           83C4                   04  add	sp,*4
34109                                           !BCC_EOS
34110                                           ! 4904         }
34111                                           ! 4905       }
34112                       00009AAF            .6C4:
34113                                           ! 4906       AX = ((AX & 0x00ff) | ((0) << 8));
34114                       00009AAF            .6C0:
34115                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34116 9AAF           8A46         16            mov	al,$16[bp]
34117                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34118 9AB2           0C                     00  or	al,*0
34119                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34120 9AB4           30E4                       xor	ah,ah
34121 9AB6           8946         16            mov	$16[bp],ax
34122                                           !BCC_EOS
34123                                           ! 4907       set_diskette_ret_status(0);
34124                                           ! Debug: list int = const 0 (used reg = )
34125 9AB9           31C0                       xor	ax,ax
34126 9ABB           50                         push	ax
34127                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34128 9ABC           E8         034B            call	_set_diskette_ret_status
34129 9ABF           44                         inc	sp
34130 9AC0           44                         inc	sp
34131                                           !BCC_EOS
34132                                           ! 4908       set_diskette_current_cyl(drive, 0);
34133                                           ! Debug: list int = const 0 (used reg = )
34134 9AC1           31C0                       xor	ax,ax
34135 9AC3           50                         push	ax
34136                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34137 9AC4           8A46         FF            mov	al,-1[bp]
34138 9AC7           30E4                       xor	ah,ah
34139 9AC9           50                         push	ax
34140                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34141 9ACA           E8         0355            call	_set_diskette_current_cyl
34142 9ACD           83C4                   04  add	sp,*4
34143                                           !BCC_EOS
34144                                           ! 4909       FLAGS &= 0xfffe;
34145                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34146 9AD0           8B46         1C            mov	ax,$1C[bp]
34147 9AD3           24                     FE  and	al,#$FE
34148 9AD5           8946         1C            mov	$1C[bp],ax
34149                                           !BCC_EOS
34150                                           ! 4910       return;
34151 9AD8           89EC                       mov	sp,bp
34152 9ADA           5D                         pop	bp
34153 9ADB           C3                         ret
34154                                           !BCC_EOS
34155                                           ! 4911     case 0x08:
34156                                           ! 4912 ;
34157                       00009ADC            .6C6:
34158                                           !BCC_EOS
34159                                           ! 4913       drive = ( ELDX & 0x00ff );
34160                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34161 9ADC           8A46         0E            mov	al,$E[bp]
34162                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34163 9ADF           8846         FF            mov	-1[bp],al
34164                                           !BCC_EOS
34165                                           ! 4914       if (drive > 1) {
34166                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34167 9AE2           8A46         FF            mov	al,-1[bp]
34168 9AE5           3C                     01  cmp	al,*1
34169 9AE7           76           35            jbe 	.6C7
34170                       00009AE9            .6C8:
34171                                           ! 4915         AX = 0;
34172                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
34173 9AE9           31C0                       xor	ax,ax
34174 9AEB           8946         16            mov	$16[bp],ax
34175                                           !BCC_EOS
34176                                           ! 4916         BX = 0;
34177                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
34178 9AEE           31C0                       xor	ax,ax
34179 9AF0           8946         10            mov	$10[bp],ax
34180                                           !BCC_EOS
34181                                           ! 4917         CX = 0;
34182                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
34183 9AF3           31C0                       xor	ax,ax
34184 9AF5           8946         14            mov	$14[bp],ax
34185                                           !BCC_EOS
34186                                           ! 4918         DX = 0;
34187                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
34188 9AF8           31C0                       xor	ax,ax
34189 9AFA           8946         12            mov	$12[bp],ax
34190                                           !BCC_EOS
34191                                           ! 4919         ES = 0;
34192                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
34193 9AFD           31C0                       xor	ax,ax
34194 9AFF           8946         06            mov	6[bp],ax
34195                                           !BCC_EOS
34196                                           ! 4920         DI = 0;
34197                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
34198 9B02           31C0                       xor	ax,ax
34199 9B04           8946         08            mov	8[bp],ax
34200                                           !BCC_EOS
34201                                           ! 4921         DX = ((DX & 0xff00) | (num_floppies));
34202                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
34203 9B07           8B46         12            mov	ax,$12[bp]
34204 9B0A           30C0                       xor	al,al
34205                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
34206 9B0C           0A46         E7            or	al,-$19[bp]
34207                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34208 9B0F           8946         12            mov	$12[bp],ax
34209                                           !BCC_EOS
34210                                           ! 4922         FLAGS |= 0x0001;
34211                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34212 9B12           8B46         1C            mov	ax,$1C[bp]
34213 9B15           0C                     01  or	al,*1
34214 9B17           8946         1C            mov	$1C[bp],ax
34215                                           !BCC_EOS
34216                                           ! 4923         return;
34217 9B1A           89EC                       mov	sp,bp
34218 9B1C           5D                         pop	bp
34219 9B1D           C3                         ret
34220                                           !BCC_EOS
34221                                           ! 4924         }
34222                                           ! 4925       drive_type = inb_cmos(0x10);
34223                       00009B1E            .6C7:
34224                                           ! Debug: list int = const $10 (used reg = )
34225 9B1E           B8                   0010  mov	ax,*$10
34226 9B21           50                         push	ax
34227                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34228 9B22           E8         6A5E            call	_inb_cmos
34229 9B25           44                         inc	sp
34230 9B26           44                         inc	sp
34231                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34232 9B27           8846         E8            mov	-$18[bp],al
34233                                           !BCC_EOS
34234                                           ! 4926       num_floppies = 0;
34235                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
34236 9B2A           30C0                       xor	al,al
34237 9B2C           8846         E7            mov	-$19[bp],al
34238                                           !BCC_EOS
34239                                           ! 4927       if (drive_type & 0xf0)
34240                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34241 9B2F           8A46         E8            mov	al,-$18[bp]
34242 9B32           24                     F0  and	al,#$F0
34243 9B34           84C0                       test	al,al
34244 9B36           74           07            je  	.6C9
34245                       00009B38            .6CA:
34246                                           ! 4928         num_floppies++;
34247                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
34248 9B38           8A46         E7            mov	al,-$19[bp]
34249 9B3B           40                         inc	ax
34250 9B3C           8846         E7            mov	-$19[bp],al
34251                                           !BCC_EOS
34252                                           ! 4929       if (drive_type & 0x0f)
34253                       00009B3F            .6C9:
34254                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34255 9B3F           8A46         E8            mov	al,-$18[bp]
34256 9B42           24                     0F  and	al,*$F
34257 9B44           84C0                       test	al,al
34258 9B46           74           07            je  	.6CB
34259                       00009B48            .6CC:
34260                                           ! 4930         num_floppies++;
34261                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
34262 9B48           8A46         E7            mov	al,-$19[bp]
34263 9B4B           40                         inc	ax
34264 9B4C           8846         E7            mov	-$19[bp],al
34265                                           !BCC_EOS
34266                                           ! 4931       if (drive == 0)
34267                       00009B4F            .6CB:
34268                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
34269 9B4F           8A46         FF            mov	al,-1[bp]
34270 9B52           84C0                       test	al,al
34271 9B54           75           0E            jne 	.6CD
34272                       00009B56            .6CE:
34273                                           ! 4932         drive_type >>= 4;
34274                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34275 9B56           8A46         E8            mov	al,-$18[bp]
34276 9B59           30E4                       xor	ah,ah
34277 9B5B           B1                     04  mov	cl,*4
34278 9B5D           D3E8                       shr	ax,cl
34279 9B5F           8846         E8            mov	-$18[bp],al
34280                                           !BCC_EOS
34281                                           ! 4933       else
34282                                           ! 4934         drive_type &= 0x0f;
34283 9B62           EB           08            jmp .6CF
34284                       00009B64            .6CD:
34285                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34286 9B64           8A46         E8            mov	al,-$18[bp]
34287 9B67           24                     0F  and	al,*$F
34288 9B69           8846         E8            mov	-$18[bp],al
34289                                           !BCC_EOS
34290                                           ! 4935       BX = ((BX & 0x00ff) | ((0) << 8));
34291                       00009B6C            .6CF:
34292                                           ! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
34293 9B6C           8A46         10            mov	al,$10[bp]
34294                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34295 9B6F           0C                     00  or	al,*0
34296                                           ! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
34297 9B71           30E4                       xor	ah,ah
34298 9B73           8946         10            mov	$10[bp],ax
34299                                           !BCC_EOS
34300                                           ! 4936       BX = ((BX & 0xff00) | (drive_type));
34301                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
34302 9B76           8B46         10            mov	ax,$10[bp]
34303 9B79           30C0                       xor	al,al
34304                                           ! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
34305 9B7B           0A46         E8            or	al,-$18[bp]
34306                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
34307 9B7E           8946         10            mov	$10[bp],ax
34308                                           !BCC_EOS
34309                                           ! 4937       AX = ((AX & 0x00ff) | ((0) << 8));
34310                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34311 9B81           8A46         16            mov	al,$16[bp]
34312                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34313 9B84           0C                     00  or	al,*0
34314                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34315 9B86           30E4                       xor	ah,ah
34316 9B88           8946         16            mov	$16[bp],ax
34317                                           !BCC_EOS
34318                                           ! 4938       AX = ((AX & 0xff00) | (0));
34319                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34320 9B8B           8B46         16            mov	ax,$16[bp]
34321 9B8E           30C0                       xor	al,al
34322                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34323 9B90           0C                     00  or	al,*0
34324                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34325 9B92           8946         16            mov	$16[bp],ax
34326                                           !BCC_EOS
34327                                           ! 4939       DX = ((DX & 0xff00) | (num_floppies));
34328                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
34329 9B95           8B46         12            mov	ax,$12[bp]
34330 9B98           30C0                       xor	al,al
34331                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
34332 9B9A           0A46         E7            or	al,-$19[bp]
34333                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34334 9B9D           8946         12            mov	$12[bp],ax
34335                                           !BCC_EOS
34336                                           ! 4940       switch (drive_type) {
34337 9BA0           8A46         E8            mov	al,-$18[bp]
34338 9BA3           E9         00BC            br 	.6D2
34339                                           ! 4941         case 0:
34340                                           ! 4942           CX = 0;
34341                       00009BA6            .6D3:
34342                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
34343 9BA6           31C0                       xor	ax,ax
34344 9BA8           8946         14            mov	$14[bp],ax
34345                                           !BCC_EOS
34346                                           ! 4943           DX = ((DX & 0x00ff) | ((0) << 8));
34347                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34348 9BAB           8A46         12            mov	al,$12[bp]
34349                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34350 9BAE           0C                     00  or	al,*0
34351                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34352 9BB0           30E4                       xor	ah,ah
34353 9BB2           8946         12            mov	$12[bp],ax
34354                                           !BCC_EOS
34355                                           ! 4944           break;
34356 9BB5           E9         00D1            br 	.6D0
34357                                           !BCC_EOS
34358                                           ! 4945         case 1:
34359                                           ! 4946           CX = 0x2709;
34360                       00009BB8            .6D4:
34361                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
34362 9BB8           B8                   2709  mov	ax,#$2709
34363 9BBB           8946         14            mov	$14[bp],ax
34364                                           !BCC_EOS
34365                                           ! 4947           DX = ((DX & 0x00ff) | ((1) << 8));
34366                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34367 9BBE           8A46         12            mov	al,$12[bp]
34368                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34369 9BC1           30E4                       xor	ah,ah
34370 9BC3           0D                   0100  or	ax,#$100
34371                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34372 9BC6           8946         12            mov	$12[bp],ax
34373                                           !BCC_EOS
34374                                           ! 4948           break;
34375 9BC9           E9         00BD            br 	.6D0
34376                                           !BCC_EOS
34377                                           ! 4949         case 2:
34378                                           ! 4950           CX = 0x4f0f;
34379                       00009BCC            .6D5:
34380                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
34381 9BCC           B8                   4F0F  mov	ax,#$4F0F
34382 9BCF           8946         14            mov	$14[bp],ax
34383                                           !BCC_EOS
34384                                           ! 4951           DX = ((DX & 0x00ff) | ((1) << 8));
34385                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34386 9BD2           8A46         12            mov	al,$12[bp]
34387                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34388 9BD5           30E4                       xor	ah,ah
34389 9BD7           0D                   0100  or	ax,#$100
34390                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34391 9BDA           8946         12            mov	$12[bp],ax
34392                                           !BCC_EOS
34393                                           ! 4952           break;
34394 9BDD           E9         00A9            br 	.6D0
34395                                           !BCC_EOS
34396                                           ! 4953         case 3:
34397                                           ! 4954           CX = 0x4f09;
34398                       00009BE0            .6D6:
34399                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
34400 9BE0           B8                   4F09  mov	ax,#$4F09
34401 9BE3           8946         14            mov	$14[bp],ax
34402                                           !BCC_EOS
34403                                           ! 4955           DX = ((DX & 0x00ff) | ((1) << 8));
34404                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34405 9BE6           8A46         12            mov	al,$12[bp]
34406                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34407 9BE9           30E4                       xor	ah,ah
34408 9BEB           0D                   0100  or	ax,#$100
34409                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34410 9BEE           8946         12            mov	$12[bp],ax
34411                                           !BCC_EOS
34412                                           ! 4956           break;
34413 9BF1           E9         0095            br 	.6D0
34414                                           !BCC_EOS
34415                                           ! 4957         case 4:
34416                                           ! 4958           CX = 0x4f12;
34417                       00009BF4            .6D7:
34418                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
34419 9BF4           B8                   4F12  mov	ax,#$4F12
34420 9BF7           8946         14            mov	$14[bp],ax
34421                                           !BCC_EOS
34422                                           ! 4959           DX = ((DX & 0x00ff) | ((1) << 8));
34423                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34424 9BFA           8A46         12            mov	al,$12[bp]
34425                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34426 9BFD           30E4                       xor	ah,ah
34427 9BFF           0D                   0100  or	ax,#$100
34428                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34429 9C02           8946         12            mov	$12[bp],ax
34430                                           !BCC_EOS
34431                                           ! 4960           break;
34432 9C05           E9         0081            br 	.6D0
34433                                           !BCC_EOS
34434                                           ! 4961         case 5:
34435                                           ! 4962           CX = 0x4f24;
34436                       00009C08            .6D8:
34437                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
34438 9C08           B8                   4F24  mov	ax,#$4F24
34439 9C0B           8946         14            mov	$14[bp],ax
34440                                           !BCC_EOS
34441                                           ! 4963           DX = ((DX & 0x00ff) | ((1) << 8));
34442                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34443 9C0E           8A46         12            mov	al,$12[bp]
34444                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34445 9C11           30E4                       xor	ah,ah
34446 9C13           0D                   0100  or	ax,#$100
34447                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34448 9C16           8946         12            mov	$12[bp],ax
34449                                           !BCC_EOS
34450                                           ! 4964           break;
34451 9C19           EB           6E            jmp .6D0
34452                                           !BCC_EOS
34453                                           ! 4965         case 6:
34454                                           ! 4966           CX = 0x2708;
34455                       00009C1B            .6D9:
34456                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
34457 9C1B           B8                   2708  mov	ax,#$2708
34458 9C1E           8946         14            mov	$14[bp],ax
34459                                           !BCC_EOS
34460                                           ! 4967           DX =
34461                                           ! 4967  ((DX & 0x00ff) | ((0) << 8));
34462                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34463 9C21           8A46         12            mov	al,$12[bp]
34464                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34465 9C24           0C                     00  or	al,*0
34466                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34467 9C26           30E4                       xor	ah,ah
34468 9C28           8946         12            mov	$12[bp],ax
34469                                           !BCC_EOS
34470                                           ! 4968           break;
34471 9C2B           EB           5C            jmp .6D0
34472                                           !BCC_EOS
34473                                           ! 4969         case 7:
34474                                           ! 4970           CX = 0x2709;
34475                       00009C2D            .6DA:
34476                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
34477 9C2D           B8                   2709  mov	ax,#$2709
34478 9C30           8946         14            mov	$14[bp],ax
34479                                           !BCC_EOS
34480                                           ! 4971           DX = ((DX & 0x00ff) | ((0) << 8));
34481                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34482 9C33           8A46         12            mov	al,$12[bp]
34483                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34484 9C36           0C                     00  or	al,*0
34485                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34486 9C38           30E4                       xor	ah,ah
34487 9C3A           8946         12            mov	$12[bp],ax
34488                                           !BCC_EOS
34489                                           ! 4972           break;
34490 9C3D           EB           4A            jmp .6D0
34491                                           !BCC_EOS
34492                                           ! 4973         case 8:
34493                                           ! 4974           CX = 0x2708;
34494                       00009C3F            .6DB:
34495                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
34496 9C3F           B8                   2708  mov	ax,#$2708
34497 9C42           8946         14            mov	$14[bp],ax
34498                                           !BCC_EOS
34499                                           ! 4975           DX = ((DX & 0x00ff) | ((1) << 8));
34500                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34501 9C45           8A46         12            mov	al,$12[bp]
34502                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34503 9C48           30E4                       xor	ah,ah
34504 9C4A           0D                   0100  or	ax,#$100
34505                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34506 9C4D           8946         12            mov	$12[bp],ax
34507                                           !BCC_EOS
34508                                           ! 4976           break;
34509 9C50           EB           37            jmp .6D0
34510                                           !BCC_EOS
34511                                           ! 4977         default:
34512                                           ! 4978           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
34513                       00009C52            .6DC:
34514                                           ! Debug: list * char = .6DD+0 (used reg = )
34515 9C52           BB                   D058  mov	bx,#.6DD
34516 9C55           53                         push	bx
34517                                           ! Debug: list int = const 7 (used reg = )
34518 9C56           B8                   0007  mov	ax,*7
34519 9C59           50                         push	ax
34520                                           ! Debug: func () void = bios_printf+0 (used reg = )
34521 9C5A           E8         6DBE            call	_bios_printf
34522 9C5D           83C4                   04  add	sp,*4
34523                                           !BCC_EOS
34524                                           ! 4979         }
34525                                           ! 4980 #asm
34526 9C60           EB           27            jmp .6D0
34527                       00009C62            .6D2:
34528 9C62           2C                     00  sub	al,*0
34529 9C64           72           EC            jb 	.6DC
34530 9C66           3C                     08  cmp	al,*8
34531 9C68           77           1D            ja  	.6DE
34532 9C6A           30E4                       xor	ah,ah
34533 9C6C           D1E0                       shl	ax,*1
34534 9C6E           89C3                       mov	bx,ax
34535 9C70           2E                         seg	cs
34536 9C71           FFA7       9C75            br	.6DF[bx]
34537                       00009C75            .6DF:
34538 9C75                      9BA6            .word	.6D3
34539 9C77                      9BB8            .word	.6D4
34540 9C79                      9BCC            .word	.6D5
34541 9C7B                      9BE0            .word	.6D6
34542 9C7D                      9BF4            .word	.6D7
34543 9C7F                      9C08            .word	.6D8
34544 9C81                      9C1B            .word	.6D9
34545 9C83                      9C2D            .word	.6DA
34546 9C85                      9C3F            .word	.6DB
34547                       00009C87            .6DE:
34548 9C87           EB           C9            jmp	.6DC
34549                       00009C89            .6D0:
34550                                           !BCC_EOS
34551                                           !BCC_ASM
34552                       0000002A            _int13_diskette_function.BP	set	$2A
34553                       0000000C            .int13_diskette_function.BP	set	$C
34554                       00000038            _int13_diskette_function.CS	set	$38
34555                       0000001A            .int13_diskette_function.CS	set	$1A
34556                       00000032            _int13_diskette_function.CX	set	$32
34557                       00000014            .int13_diskette_function.CX	set	$14
34558                       00000016            _int13_diskette_function.base_address	set	$16
34559                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34560                       00000026            _int13_diskette_function.DI	set	$26
34561                       00000008            .int13_diskette_function.DI	set	8
34562                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34563                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34564                       00000014            _int13_diskette_function.base_count	set	$14
34565                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34566                       0000001A            _int13_diskette_function.sector	set	$1A
34567                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34568                       00000022            _int13_diskette_function.DS	set	$22
34569                       00000004            .int13_diskette_function.DS	set	4
34570                       00000019            _int13_diskette_function.head	set	$19
34571                       FFFFFFFB            .int13_diskette_function.head	set	-5
34572                       0000002C            _int13_diskette_function.ELDX	set	$2C
34573                       0000000E            .int13_diskette_function.ELDX	set	$E
34574                       0000000E            _int13_diskette_function.dor	set	$E
34575                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34576                       00000030            _int13_diskette_function.DX	set	$30
34577                       00000012            .int13_diskette_function.DX	set	$12
34578                       00000007            _int13_diskette_function.return_status	set	7
34579                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34580                       00000002            _int13_diskette_function.es	set	2
34581                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34582                       00000010            _int13_diskette_function.mode_register	set	$10
34583                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34584                       00000024            _int13_diskette_function.ES	set	$24
34585                       00000006            .int13_diskette_function.ES	set	6
34586                       00000012            _int13_diskette_function.base_es	set	$12
34587                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34588                       0000001B            _int13_diskette_function.track	set	$1B
34589                       FFFFFFFD            .int13_diskette_function.track	set	-3
34590                       00000028            _int13_diskette_function.SI	set	$28
34591                       0000000A            .int13_diskette_function.SI	set	$A
34592                       00000006            _int13_diskette_function.drive_type	set	6
34593                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34594                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34595                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34596                       00000036            _int13_diskette_function.IP	set	$36
34597                       00000018            .int13_diskette_function.IP	set	$18
34598                       00000018            _int13_diskette_function.status	set	$18
34599                       FFFFFFFA            .int13_diskette_function.status	set	-6
34600                       00000034            _int13_diskette_function.AX	set	$34
34601                       00000016            .int13_diskette_function.AX	set	$16
34602                       0000000F            _int13_diskette_function.val8	set	$F
34603                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34604                       00000000            _int13_diskette_function.last_addr	set	0
34605                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34606                       00000011            _int13_diskette_function.page	set	$11
34607                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34608                       00000004            _int13_diskette_function.ah	set	4
34609                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34610                       0000001D            _int13_diskette_function.drive	set	$1D
34611                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34612                       00000005            _int13_diskette_function.num_floppies	set	5
34613                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34614                       0000002E            _int13_diskette_function.BX	set	$2E
34615                       00000010            .int13_diskette_function.BX	set	$10
34616 9C89           55                               push bp
34617 9C8A           89E5                             mov bp, sp
34618 9C8C           B8                   EFDE        mov ax, #diskette_param_table2
34619 9C8F           8946         28                  mov _int13_diskette_function.DI+2[bp], ax
34620 9C92           8C4E         26                  mov _int13_diskette_function.ES+2[bp], cs
34621 9C95           5D                               pop bp
34622                                           ! 4987 endasm
34623                                           !BCC_ENDASM
34624                                           !BCC_EOS
34625                                           ! 4988       FLAGS &= 0xfffe;
34626                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34627 9C96           8B46         1C            mov	ax,$1C[bp]
34628 9C99           24                     FE  and	al,#$FE
34629 9C9B           8946         1C            mov	$1C[bp],ax
34630                                           !BCC_EOS
34631                                           ! 4989       return;
34632 9C9E           89EC                       mov	sp,bp
34633 9CA0           5D                         pop	bp
34634 9CA1           C3                         ret
34635                                           !BCC_EOS
34636                                           ! 4990     case 0x15:
34637                                           ! 4991 ;
34638                       00009CA2            .6E0:
34639                                           !BCC_EOS
34640                                           ! 4992       drive = ( ELDX & 0x00ff );
34641                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34642 9CA2           8A46         0E            mov	al,$E[bp]
34643                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34644 9CA5           8846         FF            mov	-1[bp],al
34645                                           !BCC_EOS
34646                                           ! 4993       if (drive > 1) {
34647                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34648 9CA8           8A46         FF            mov	al,-1[bp]
34649 9CAB           3C                     01  cmp	al,*1
34650 9CAD           76           16            jbe 	.6E1
34651                       00009CAF            .6E2:
34652                                           ! 4994         AX = ((AX & 0x00ff) | ((0) << 8));
34653                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34654 9CAF           8A46         16            mov	al,$16[bp]
34655                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34656 9CB2           0C                     00  or	al,*0
34657                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34658 9CB4           30E4                       xor	ah,ah
34659 9CB6           8946         16            mov	$16[bp],ax
34660                                           !BCC_EOS
34661                                           ! 4995         FLAGS |= 0x0001;
34662                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34663 9CB9           8B46         1C            mov	ax,$1C[bp]
34664 9CBC           0C                     01  or	al,*1
34665 9CBE           8946         1C            mov	$1C[bp],ax
34666                                           !BCC_EOS
34667                                           ! 4996         return;
34668 9CC1           89EC                       mov	sp,bp
34669 9CC3           5D                         pop	bp
34670 9CC4           C3                         ret
34671                                           !BCC_EOS
34672                                           ! 4997         }
34673                                           ! 4998       drive_type = inb_cmos(0x10);
34674                       00009CC5            .6E1:
34675                                           ! Debug: list int = const $10 (used reg = )
34676 9CC5           B8                   0010  mov	ax,*$10
34677 9CC8           50                         push	ax
34678                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34679 9CC9           E8         68B7            call	_inb_cmos
34680 9CCC           44                         inc	sp
34681 9CCD           44                         inc	sp
34682                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34683 9CCE           8846         E8            mov	-$18[bp],al
34684                                           !BCC_EOS
34685                                           ! 4999       if (drive == 0)
34686                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
34687 9CD1           8A46         FF            mov	al,-1[bp]
34688 9CD4           84C0                       test	al,al
34689 9CD6           75           0E            jne 	.6E3
34690                       00009CD8            .6E4:
34691                                           ! 5000         drive_type >>= 4;
34692                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34693 9CD8           8A46         E8            mov	al,-$18[bp]
34694 9CDB           30E4                       xor	ah,ah
34695 9CDD           B1                     04  mov	cl,*4
34696 9CDF           D3E8                       shr	ax,cl
34697 9CE1           8846         E8            mov	-$18[bp],al
34698                                           !BCC_EOS
34699                                           ! 5001       else
34700                                           ! 5002         drive_type &= 0x0f;
34701 9CE4           EB           08            jmp .6E5
34702                       00009CE6            .6E3:
34703                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34704 9CE6           8A46         E8            mov	al,-$18[bp]
34705 9CE9           24                     0F  and	al,*$F
34706 9CEB           8846         E8            mov	-$18[bp],al
34707                                           !BCC_EOS
34708                                           ! 5003       FLAGS &= 0xfffe;
34709                       00009CEE            .6E5:
34710                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34711 9CEE           8B46         1C            mov	ax,$1C[bp]
34712 9CF1           24                     FE  and	al,#$FE
34713 9CF3           8946         1C            mov	$1C[bp],ax
34714                                           !BCC_EOS
34715                                           ! 5004       if (drive_type==0) {
34716                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34717 9CF6           8A46         E8            mov	al,-$18[bp]
34718 9CF9           84C0                       test	al,al
34719 9CFB           75           0C            jne 	.6E6
34720                       00009CFD            .6E7:
34721                                           ! 5005         AX = ((AX & 0x00ff) | ((0) << 8));
34722                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34723 9CFD           8A46         16            mov	al,$16[bp]
34724                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34725 9D00           0C                     00  or	al,*0
34726                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34727 9D02           30E4                       xor	ah,ah
34728 9D04           8946         16            mov	$16[bp],ax
34729                                           !BCC_EOS
34730                                           ! 5006         }
34731                                           ! 5007       else {
34732 9D07           EB           0B            jmp .6E8
34733                       00009D09            .6E6:
34734                                           ! 5008         AX = ((AX & 0x00ff) | ((1) << 8));
34735                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34736 9D09           8A46         16            mov	al,$16[bp]
34737                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34738 9D0C           30E4                       xor	ah,ah
34739 9D0E           0D                   0100  or	ax,#$100
34740                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34741 9D11           8946         16            mov	$16[bp],ax
34742                                           !BCC_EOS
34743                                           ! 5009         }
34744                                           ! 5010       return;
34745                       00009D14            .6E8:
34746 9D14           89EC                       mov	sp,bp
34747 9D16           5D                         pop	bp
34748 9D17           C3                         ret
34749                                           !BCC_EOS
34750                                           ! 5011     case 0x16:
34751                                           ! 5012 ;
34752                       00009D18            .6E9:
34753                                           !BCC_EOS
34754                                           ! 5013       drive = ( ELDX & 0x00ff );
34755                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34756 9D18           8A46         0E            mov	al,$E[bp]
34757                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34758 9D1B           8846         FF            mov	-1[bp],al
34759                                           !BCC_EOS
34760                                           ! 5014       if (drive > 1) {
34761                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34762 9D1E           8A46         FF            mov	al,-1[bp]
34763 9D21           3C                     01  cmp	al,*1
34764 9D23           76           20            jbe 	.6EA
34765                       00009D25            .6EB:
34766                                           ! 5015         AX = ((AX & 0x00ff) | ((0x01) << 8));
34767                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34768 9D25           8A46         16            mov	al,$16[bp]
34769                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34770 9D28           30E4                       xor	ah,ah
34771 9D2A           0D                   0100  or	ax,#$100
34772                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34773 9D2D           8946         16            mov	$16[bp],ax
34774                                           !BCC_EOS
34775                                           ! 5016         set_diskette_ret_status(0x01);
34776                                           ! Debug: list int = const 1 (used reg = )
34777 9D30           B8                   0001  mov	ax,*1
34778 9D33           50                         push	ax
34779                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34780 9D34           E8         00D3            call	_set_diskette_ret_status
34781 9D37           44                         inc	sp
34782 9D38           44                         inc	sp
34783                                           !BCC_EOS
34784                                           ! 5017         FLAGS |= 0x0001;
34785                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34786 9D39           8B46         1C            mov	ax,$1C[bp]
34787 9D3C           0C                     01  or	al,*1
34788 9D3E           8946         1C            mov	$1C[bp],ax
34789                                           !BCC_EOS
34790                                           ! 5018         return;
34791 9D41           89EC                       mov	sp,bp
34792 9D43           5D                         pop	bp
34793 9D44           C3                         ret
34794                                           !BCC_EOS
34795                                           ! 5019         }
34796                                           ! 5020       AX = ((AX & 0x00ff) | ((0x06) << 8));
34797                       00009D45            .6EA:
34798                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34799 9D45           8A46         16            mov	al,$16[bp]
34800                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
34801 9D48           30E4                       xor	ah,ah
34802 9D4A           0D                   0600  or	ax,#$600
34803                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34804 9D4D           8946         16            mov	$16[bp],ax
34805                                           !BCC_EOS
34806                                           ! 5021       set_diskette_ret_status(0x06);
34807                                           ! Debug: list int = const 6 (used reg = )
34808 9D50           B8                   0006  mov	ax,*6
34809 9D53           50                         push	ax
34810                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34811 9D54           E8         00B3            call	_set_diskette_ret_status
34812 9D57           44                         inc	sp
34813 9D58           44                         inc	sp
34814                                           !BCC_EOS
34815                                           ! 5022       FLAGS |= 0x0001;
34816                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34817 9D59           8B46         1C            mov	ax,$1C[bp]
34818 9D5C           0C                     01  or	al,*1
34819 9D5E           8946         1C            mov	$1C[bp],ax
34820                                           !BCC_EOS
34821                                           ! 5023       return;
34822 9D61           89EC                       mov	sp,bp
34823 9D63           5D                         pop	bp
34824 9D64           C3                         ret
34825                                           !BCC_EOS
34826                                           ! 5024     case 0x17:
34827                                           ! 5025 ;
34828                       00009D65            .6EC:
34829                                           !BCC_EOS
34830                                           ! 5026       AX = ((AX & 0x00ff) | ((0x01) << 8));
34831                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34832 9D65           8A46         16            mov	al,$16[bp]
34833                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34834 9D68           30E4                       xor	ah,ah
34835 9D6A           0D                   0100  or	ax,#$100
34836                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34837 9D6D           8946         16            mov	$16[bp],ax
34838                                           !BCC_EOS
34839                                           ! 5027       set_diskette_ret_status(1);
34840                                           ! Debug: list int = const 1 (used reg = )
34841 9D70           B8                   0001  mov	ax,*1
34842 9D73           50                         push	ax
34843                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34844 9D74           E8         0093            call	_set_diskette_ret_status
34845 9D77           44                         inc	sp
34846 9D78           44                         inc	sp
34847                                           !BCC_EOS
34848                                           ! 5028       FLAGS |= 0x0001;
34849                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34850 9D79           8B46         1C            mov	ax,$1C[bp]
34851 9D7C           0C                     01  or	al,*1
34852 9D7E           8946         1C            mov	$1C[bp],ax
34853                                           !BCC_EOS
34854                                           ! 5029       return;
34855 9D81           89EC                       mov	sp,bp
34856 9D83           5D                         pop	bp
34857 9D84           C3                         ret
34858                                           !BCC_EOS
34859                                           ! 5030     case 0x18:
34860                                           ! 5031 ;
34861                       00009D85            .6ED:
34862                                           !BCC_EOS
34863                                           ! 5032       AX = ((AX & 0x00ff) | ((0x01) << 8));
34864                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34865 9D85           8A46         16            mov	al,$16[bp]
34866                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34867 9D88           30E4                       xor	ah,ah
34868 9D8A           0D                   0100  or	ax,#$100
34869                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34870 9D8D           8946         16            mov	$16[bp],ax
34871                                           !BCC_EOS
34872                                           ! 5033       set_diskette_ret_status(1);
34873                                           ! Debug: list int = const 1 (used reg = )
34874 9D90           B8                   0001  mov	ax,*1
34875 9D93           50                         push	ax
34876                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34877 9D94           E8         0073            call	_set_diskette_ret_status
34878 9D97           44                         inc	sp
34879 9D98           44                         inc	sp
34880                                           !BCC_EOS
34881                                           ! 5034       FLAGS |= 0x0001;
34882                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34883 9D99           8B46         1C            mov	ax,$1C[bp]
34884 9D9C           0C                     01  or	al,*1
34885 9D9E           8946         1C            mov	$1C[bp],ax
34886                                           !BCC_EOS
34887                                           ! 5035       return;
34888 9DA1           89EC                       mov	sp,bp
34889 9DA3           5D                         pop	bp
34890 9DA4           C3                         ret
34891                                           !BCC_EOS
34892                                           ! 5036     default:
34893                                           ! 5037         ;
34894                       00009DA5            .6EE:
34895                                           !BCC_EOS
34896                                           ! 5038         AX = ((AX & 0x00ff) | ((0x01) << 8));
34897                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34898 9DA5           8A46         16            mov	al,$16[bp]
34899                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34900 9DA8           30E4                       xor	ah,ah
34901 9DAA           0D                   0100  or	ax,#$100
34902                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34903 9DAD           8946         16            mov	$16[bp],ax
34904                                           !BCC_EOS
34905                                           ! 5039         set_diskette_ret_status(1);
34906                                           ! Debug: list int = const 1 (used reg = )
34907 9DB0           B8                   0001  mov	ax,*1
34908 9DB3           50                         push	ax
34909                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34910 9DB4           E8         0053            call	_set_diskette_ret_status
34911 9DB7           44                         inc	sp
34912 9DB8           44                         inc	sp
34913                                           !BCC_EOS
34914                                           ! 5040         FLAGS |= 0x0001;
34915                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34916 9DB9           8B46         1C            mov	ax,$1C[bp]
34917 9DBC           0C                     01  or	al,*1
34918 9DBE           8946         1C            mov	$1C[bp],ax
34919                                           !BCC_EOS
34920                                           ! 5041         return;
34921 9DC1           89EC                       mov	sp,bp
34922 9DC3           5D                         pop	bp
34923 9DC4           C3                         ret
34924                                           !BCC_EOS
34925                                           ! 5042     }
34926                                           ! 5043 }
34927 9DC5           EB           3F            jmp .661
34928                       00009DC7            .663:
34929 9DC7           2C                     00  sub	al,*0
34930 9DC9           72           DA            jb 	.6EE
34931 9DCB           3C                     08  cmp	al,*8
34932 9DCD           77           1D            ja  	.6EF
34933 9DCF           30E4                       xor	ah,ah
34934 9DD1           D1E0                       shl	ax,*1
34935 9DD3           89C3                       mov	bx,ax
34936 9DD5           2E                         seg	cs
34937 9DD6           FFA7       9DDA            br	.6F0[bx]
34938                       00009DDA            .6F0:
34939 9DDA                      8D28            .word	.664
34940 9DDC                      8DD2            .word	.66C
34941 9DDE                      8E14            .word	.66F
34942 9DE0                      8E14            .word	.670
34943 9DE2                      8E14            .word	.671
34944 9DE4                      969F            .word	.6A6
34945 9DE6                      9DA5            .word	.6EE
34946 9DE8                      9DA5            .word	.6EE
34947 9DEA                      9ADC            .word	.6C6
34948                       00009DEC            .6EF:
34949 9DEC           2C                     15  sub	al,*$15
34950 9DEE         0F84         FEB0            beq 	.6E0
34951 9DF2           2C                     01  sub	al,*1
34952 9DF4         0F84         FF20            beq 	.6E9
34953 9DF8           2C                     01  sub	al,*1
34954 9DFA         0F84         FF67            beq 	.6EC
34955 9DFE           2C                     01  sub	al,*1
34956 9E00         0F84         FF81            beq 	.6ED
34957 9E04           EB           9F            jmp	.6EE
34958                       00009E06            .661:
34959                       FFFFFFE0            ..FFDC	=	-$20
34960 9E06           89EC                       mov	sp,bp
34961 9E08           5D                         pop	bp
34962 9E09           C3                         ret
34963                                           ! 5044  void
34964                                           ! Register BX used in function int13_diskette_function
34965                                           ! 5045 set_diskette_ret_status(value)
34966                                           ! 5046   Bit8u value;
34967                                           export	_set_diskette_ret_status
34968                       00009E0A            _set_diskette_ret_status:
34969                                           !BCC_EOS
34970                                           ! 5047 {
34971                                           ! 5048   write_byte(0x0040, 0x0041, value);
34972 9E0A           55                         push	bp
34973 9E0B           89E5                       mov	bp,sp
34974                                           ! Debug: list unsigned char value = [S+2+2] (used reg = )
34975 9E0D           8A46         04            mov	al,4[bp]
34976 9E10           30E4                       xor	ah,ah
34977 9E12           50                         push	ax
34978                                           ! Debug: list int = const $41 (used reg = )
34979 9E13           B8                   0041  mov	ax,*$41
34980 9E16           50                         push	ax
34981                                           ! Debug: list int = const $40 (used reg = )
34982 9E17           B8                   0040  mov	ax,*$40
34983 9E1A           50                         push	ax
34984                                           ! Debug: func () void = write_byte+0 (used reg = )
34985 9E1B           E8         67FC            call	_write_byte
34986 9E1E           89EC                       mov	sp,bp
34987                                           !BCC_EOS
34988                                           ! 5049 }
34989 9E20           5D                         pop	bp
34990 9E21           C3                         ret
34991                                           ! 5050   void
34992                                           ! 5051 set_diskette_current_cyl(drive, cyl)
34993                                           ! 5052   Bit8u drive;
34994                                           export	_set_diskette_current_cyl
34995                       00009E22            _set_diskette_current_cyl:
34996                                           !BCC_EOS
34997                                           ! 5053   Bit8u cyl;
34998                                           !BCC_EOS
34999                                           ! 5054 {
35000                                           ! 5055   if (drive > 1)
35001 9E22           55                         push	bp
35002 9E23           89E5                       mov	bp,sp
35003                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
35004 9E25           8A46         04            mov	al,4[bp]
35005 9E28           3C                     01  cmp	al,*1
35006 9E2A           76           0D            jbe 	.6F1
35007                       00009E2C            .6F2:
35008                                           ! 5056     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n")
35009                                           ! 5056 ;
35010                                           ! Debug: list * char = .6F3+0 (used reg = )
35011 9E2C           BB                   D031  mov	bx,#.6F3
35012 9E2F           53                         push	bx
35013                                           ! Debug: list int = const 7 (used reg = )
35014 9E30           B8                   0007  mov	ax,*7
35015 9E33           50                         push	ax
35016                                           ! Debug: func () void = bios_printf+0 (used reg = )
35017 9E34           E8         6BE4            call	_bios_printf
35018 9E37           89EC                       mov	sp,bp
35019                                           !BCC_EOS
35020                                           ! 5057   write_byte(0x0040, 0x0094+drive, cyl);
35021                       00009E39            .6F1:
35022                                           ! Debug: list unsigned char cyl = [S+2+4] (used reg = )
35023 9E39           8A46         06            mov	al,6[bp]
35024 9E3C           30E4                       xor	ah,ah
35025 9E3E           50                         push	ax
35026                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
35027                                           ! Debug: expression subtree swapping
35028 9E3F           8A46         04            mov	al,4[bp]
35029 9E42           30E4                       xor	ah,ah
35030                                           ! Debug: list unsigned int = ax+$94 (used reg = )
35031 9E44           05                   0094  add	ax,#$94
35032 9E47           50                         push	ax
35033                                           ! Debug: list int = const $40 (used reg = )
35034 9E48           B8                   0040  mov	ax,*$40
35035 9E4B           50                         push	ax
35036                                           ! Debug: func () void = write_byte+0 (used reg = )
35037 9E4C           E8         67CB            call	_write_byte
35038 9E4F           89EC                       mov	sp,bp
35039                                           !BCC_EOS
35040                                           ! 5058 }
35041 9E51           5D                         pop	bp
35042 9E52           C3                         ret
35043                                           ! 5059   void
35044                                           ! Register BX used in function set_diskette_current_cyl
35045                                           ! 5060 determine_floppy_media(drive)
35046                                           ! 5061   Bit16u drive;
35047                                           export	_determine_floppy_media
35048                       00009E53            _determine_floppy_media:
35049                                           !BCC_EOS
35050                                           ! 5062 {
35051                                           ! 5063 }
35052 9E53           C3                         ret
35053                                           ! 5064   void
35054                                           ! 5065 int17_function(regs, ds, iret_addr)
35055                                           ! 5066   pusha_regs_t regs;
35056                                           export	_int17_function
35057                       00009E54            _int17_function:
35058                                           !BCC_EOS
35059                                           ! 5067   Bit16u ds;
35060                                           !BCC_EOS
35061                                           ! 5068   iret_addr_t iret_addr;
35062                                           !BCC_EOS
35063                                           ! 5069 {
35064                                           ! 5070   Bit16u addr,timeout;
35065                                           !BCC_EOS
35066                                           ! 5071   Bit8u val8;
35067                                           !BCC_EOS
35068                                           ! 5072 #asm
35069 9E54           55                         push	bp
35070 9E55           89E5                       mov	bp,sp
35071 9E57           83C4                   FA  add	sp,*-6
35072                                           !BCC_EOS
35073                                           !BCC_ASM
35074                       0000001A            _int17_function.ds	set	$1A
35075                       00000014            .int17_function.ds	set	$14
35076                       00000002            _int17_function.timeout	set	2
35077                       FFFFFFFC            .int17_function.timeout	set	-4
35078                       00000001            _int17_function.val8	set	1
35079                       FFFFFFFB            .int17_function.val8	set	-5
35080                       0000001C            _int17_function.iret_addr	set	$1C
35081                       00000016            .int17_function.iret_addr	set	$16
35082                       00000004            _int17_function.addr	set	4
35083                       FFFFFFFE            .int17_function.addr	set	-2
35084                       0000000A            _int17_function.regs	set	$A
35085                       00000004            .int17_function.regs	set	4
35086 9E5A           FB                           sti
35087                                           ! 5074 endasm
35088                                           !BCC_ENDASM
35089                                           !BCC_EOS
35090                                           ! 5075   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
35091                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
35092 9E5B           8B46         0E            mov	ax,$E[bp]
35093 9E5E           D1E0                       shl	ax,*1
35094                                           ! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
35095                                           ! Debug: list unsigned int = ax+8 (used reg = )
35096 9E60           05                   0008  add	ax,*8
35097 9E63           50                         push	ax
35098                                           ! Debug: list int = const $40 (used reg = )
35099 9E64           B8                   0040  mov	ax,*$40
35100 9E67           50                         push	ax
35101                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35102 9E68           E8         679C            call	_read_word
35103 9E6B           83C4                   04  add	sp,*4
35104                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
35105 9E6E           8946         FE            mov	-2[bp],ax
35106                                           !BCC_EOS
35107                                           ! 5076   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
35108                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
35109 9E71           8A46         13            mov	al,$13[bp]
35110 9E74           3C                     03  cmp	al,*3
35111 9E76         0F83         0106            bhis	.6F4
35112                       00009E7A            .6F7:
35113                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
35114 9E7A           8B46         0E            mov	ax,$E[bp]
35115 9E7D           3D                   0003  cmp	ax,*3
35116 9E80         0F83         00FC            bhis	.6F4
35117                       00009E84            .6F6:
35118                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
35119 9E84           8B46         FE            mov	ax,-2[bp]
35120 9E87           85C0                       test	ax,ax
35121 9E89         0F84         00F3            beq 	.6F4
35122                       00009E8D            .6F5:
35123                                           ! 5077     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
35124                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
35125                                           ! Debug: expression subtree swapping
35126 9E8D           8B46         0E            mov	ax,$E[bp]
35127                                           ! Debug: list unsigned int = ax+$78 (used reg = )
35128 9E90           05                   0078  add	ax,*$78
35129 9E93           50                         push	ax
35130                                           ! Debug: list int = const $40 (used reg = )
35131 9E94           B8                   0040  mov	ax,*$40
35132 9E97           50                         push	ax
35133                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
35134 9E98           E8         6759            call	_read_byte
35135 9E9B           83C4                   04  add	sp,*4
35136                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
35137 9E9E           30E4                       xor	ah,ah
35138 9EA0           88C4                       mov	ah,al
35139 9EA2           30C0                       xor	al,al
35140                                           ! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
35141 9EA4           8946         FC            mov	-4[bp],ax
35142                                           !BCC_EOS
35143                                           ! 5078     if (regs.u.r8.ah == 0) {
35144                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
35145 9EA7           8A46         13            mov	al,$13[bp]
35146 9EAA           84C0                       test	al,al
35147 9EAC           75           66            jne 	.6F8
35148                       00009EAE            .6F9:
35149                                           ! 5079       outb(addr, regs.u.r8.al);
35150                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
35151 9EAE           8A46         12            mov	al,$12[bp]
35152 9EB1           30E4                       xor	ah,ah
35153 9EB3           50                         push	ax
35154                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
35155 9EB4           FF76         FE            push	-2[bp]
35156                                           ! Debug: func () void = outb+0 (used reg = )
35157 9EB7           E8         669A            call	_outb
35158 9EBA           83C4                   04  add	sp,*4
35159                                           !BCC_EOS
35160                                           ! 5080       val8 = inb(addr+2);
35161                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
35162 9EBD           8B46         FE            mov	ax,-2[bp]
35163                                           ! Debug: list unsigned int = ax+2 (used reg = )
35164 9EC0           40                         inc	ax
35165 9EC1           40                         inc	ax
35166 9EC2           50                         push	ax
35167                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35168 9EC3           E8         6678            call	_inb
35169 9EC6           44                         inc	sp
35170 9EC7           44                         inc	sp
35171                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35172 9EC8           8846         FB            mov	-5[bp],al
35173                                           !BCC_EOS
35174                                           ! 5081       outb(addr+2, val8 | 0x01);
35175                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
35176 9ECB           8A46         FB            mov	al,-5[bp]
35177 9ECE           0C                     01  or	al,*1
35178                                           ! Debug: list unsigned char = al+0 (used reg = )
35179 9ED0           30E4                       xor	ah,ah
35180 9ED2           50                         push	ax
35181                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35182 9ED3           8B46         FE            mov	ax,-2[bp]
35183                                           ! Debug: list unsigned int = ax+2 (used reg = )
35184 9ED6           40                         inc	ax
35185 9ED7           40                         inc	ax
35186 9ED8           50                         push	ax
35187                                           ! Debug: func () void = outb+0 (used reg = )
35188 9ED9           E8         6678            call	_outb
35189 9EDC           83C4                   04  add	sp,*4
35190                                           !BCC_EOS
35191                                           ! 5082 #asm
35192                                           !BCC_EOS
35193                                           !BCC_ASM
35194                       0000001A            _int17_function.ds	set	$1A
35195                       00000014            .int17_function.ds	set	$14
35196                       00000002            _int17_function.timeout	set	2
35197                       FFFFFFFC            .int17_function.timeout	set	-4
35198                       00000001            _int17_function.val8	set	1
35199                       FFFFFFFB            .int17_function.val8	set	-5
35200                       0000001C            _int17_function.iret_addr	set	$1C
35201                       00000016            .int17_function.iret_addr	set	$16
35202                       00000004            _int17_function.addr	set	4
35203                       FFFFFFFE            .int17_function.addr	set	-2
35204                       0000000A            _int17_function.regs	set	$A
35205                       00000004            .int17_function.regs	set	4
35206 9EDF           90                               nop
35207                                           ! 5084 endasm
35208                                           !BCC_ENDASM
35209                                           !BCC_EOS
35210                                           ! 5085       outb(addr+2, val8 & ~0x01);
35211                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
35212 9EE0           8A46         FB            mov	al,-5[bp]
35213 9EE3           24                     FE  and	al,#$FE
35214                                           ! Debug: list unsigned char = al+0 (used reg = )
35215 9EE5           30E4                       xor	ah,ah
35216 9EE7           50                         push	ax
35217                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35218 9EE8           8B46         FE            mov	ax,-2[bp]
35219                                           ! Debug: list unsigned int = ax+2 (used reg = )
35220 9EEB           40                         inc	ax
35221 9EEC           40                         inc	ax
35222 9EED           50                         push	ax
35223                                           ! Debug: func () void = outb+0 (used reg = )
35224 9EEE           E8         6663            call	_outb
35225 9EF1           83C4                   04  add	sp,*4
35226                                           !BCC_EOS
35227                                           ! 5086       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
35228 9EF4           EB           07            jmp .6FB
35229                       00009EF6            .6FC:
35230                                           ! 5087         timeout--;
35231                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
35232 9EF6           8B46         FC            mov	ax,-4[bp]
35233 9EF9           48                         dec	ax
35234 9EFA           8946         FC            mov	-4[bp],ax
35235                                           !BCC_EOS
35236                                           ! 5088       }
35237                                           ! 5089     }
35238                       00009EFD            .6FB:
35239                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
35240 9EFD           8B46         FE            mov	ax,-2[bp]
35241                                           ! Debug: list unsigned int = ax+1 (used reg = )
35242 9F00           40                         inc	ax
35243 9F01           50                         push	ax
35244                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35245 9F02           E8         6639            call	_inb
35246 9F05           44                         inc	sp
35247 9F06           44                         inc	sp
35248                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
35249 9F07           24                     40  and	al,*$40
35250                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
35251 9F09           3C                     40  cmp	al,*$40
35252 9F0B           75           07            jne 	.6FD
35253                       00009F0D            .6FE:
35254 9F0D           8B46         FC            mov	ax,-4[bp]
35255 9F10           85C0                       test	ax,ax
35256 9F12           75           E2            jne	.6FC
35257                       00009F14            .6FD:
35258                       00009F14            .6FA:
35259                                           ! 5090     if (regs.u.r8.ah == 1) {
35260                       00009F14            .6F8:
35261                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
35262 9F14           8A46         13            mov	al,$13[bp]
35263 9F17           3C                     01  cmp	al,*1
35264 9F19           75           37            jne 	.6FF
35265                       00009F1B            .700:
35266                                           ! 5091       val8 = inb(addr+2);
35267                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
35268 9F1B           8B46         FE            mov	ax,-2[bp]
35269                                           ! Debug: list unsigned int = ax+2 (used reg = )
35270 9F1E           40                         inc	ax
35271 9F1F           40                         inc	ax
35272 9F20           50                         push	ax
35273                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35274 9F21           E8         661A            call	_inb
35275 9F24           44                         inc	sp
35276 9F25           44                         inc	sp
35277                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35278 9F26           8846         FB            mov	-5[bp],al
35279                                           !BCC_EOS
35280                                           ! 5092       outb(addr+2, val8 & ~0x04);
35281                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
35282 9F29           8A46         FB            mov	al,-5[bp]
35283 9F2C           24                     FB  and	al,#$FB
35284                                           ! Debug: list unsigned char = al+0 (used reg = )
35285 9F2E           30E4                       xor	ah,ah
35286 9F30           50                         push	ax
35287                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35288 9F31           8B46         FE            mov	ax,-2[bp]
35289                                           ! Debug: list unsigned int = ax+2 (used reg = )
35290 9F34           40                         inc	ax
35291 9F35           40                         inc	ax
35292 9F36           50                         push	ax
35293                                           ! Debug: func () void = outb+0 (used reg = )
35294 9F37           E8         661A            call	_outb
35295 9F3A           83C4                   04  add	sp,*4
35296                                           !BCC_EOS
35297                                           ! 5093 #asm
35298                                           !BCC_EOS
35299                                           !BCC_ASM
35300                       0000001A            _int17_function.ds	set	$1A
35301                       00000014            .int17_function.ds	set	$14
35302                       00000002            _int17_function.timeout	set	2
35303                       FFFFFFFC            .int17_function.timeout	set	-4
35304                       00000001            _int17_function.val8	set	1
35305                       FFFFFFFB            .int17_function.val8	set	-5
35306                       0000001C            _int17_function.iret_addr	set	$1C
35307                       00000016            .int17_function.iret_addr	set	$16
35308                       00000004            _int17_function.addr	set	4
35309                       FFFFFFFE            .int17_function.addr	set	-2
35310                       0000000A            _int17_function.regs	set	$A
35311                       00000004            .int17_function.regs	set	4
35312 9F3D           90                               nop
35313                                           ! 5095 endasm
35314                                           !BCC_ENDASM
35315                                           !BCC_EOS
35316                                           ! 5096       outb(addr+2, val8 | 0x04);
35317                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
35318 9F3E           8A46         FB            mov	al,-5[bp]
35319 9F41           0C                     04  or	al,*4
35320                                           ! Debug: list unsigned char = al+0 (used reg = )
35321 9F43           30E4                       xor	ah,ah
35322 9F45           50                         push	ax
35323                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35324 9F46           8B46         FE            mov	ax,-2[bp]
35325                                           ! Debug: list unsigned int = ax+2 (used reg = )
35326 9F49           40                         inc	ax
35327 9F4A           40                         inc	ax
35328 9F4B           50                         push	ax
35329                                           ! Debug: func () void = outb+0 (used reg = )
35330 9F4C           E8         6605            call	_outb
35331 9F4F           83C4                   04  add	sp,*4
35332                                           !BCC_EOS
35333                                           ! 5097     }
35334                                           ! 5098     val8 = inb(addr+1);
35335                       00009F52            .6FF:
35336                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
35337 9F52           8B46         FE            mov	ax,-2[bp]
35338                                           ! Debug: list unsigned int = ax+1 (used reg = )
35339 9F55           40                         inc	ax
35340 9F56           50                         push	ax
35341                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35342 9F57           E8         65E4            call	_inb
35343 9F5A           44                         inc	sp
35344 9F5B           44                         inc	sp
35345                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35346 9F5C           8846         FB            mov	-5[bp],al
35347                                           !BCC_EOS
35348                                           ! 5099     regs.u.r8.ah = (val8 ^ 0x48);
35349                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
35350 9F5F           8A46         FB            mov	al,-5[bp]
35351 9F62           34                     48  xor	al,*$48
35352                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
35353 9F64           8846         13            mov	$13[bp],al
35354                                           !BCC_EOS
35355                                           ! 5100     if (!timeout) regs.u.r8.ah |= 0x01;
35356 9F67           8B46         FC            mov	ax,-4[bp]
35357 9F6A           85C0                       test	ax,ax
35358 9F6C           75           08            jne 	.701
35359                       00009F6E            .702:
35360                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
35361 9F6E           8A46         13            mov	al,$13[bp]
35362 9F71           0C                     01  or	al,*1
35363 9F73           8846         13            mov	$13[bp],al
35364                                           !BCC_EOS
35365                                           ! 5101     iret_addr.flags.u.r8.flagsl &= 0xfe;
35366                       00009F76            .701:
35367                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
35368 9F76           8A46         1A            mov	al,$1A[bp]
35369 9F79           24                     FE  and	al,#$FE
35370 9F7B           8846         1A            mov	$1A[bp],al
35371                                           !BCC_EOS
35372                                           ! 5102   } else {
35373 9F7E           EB           08            jmp .703
35374                       00009F80            .6F4:
35375                                           ! 5103     iret_addr.flags.u.r8.flagsl |= 0x01;
35376                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
35377 9F80           8A46         1A            mov	al,$1A[bp]
35378 9F83           0C                     01  or	al,*1
35379 9F85           8846         1A            mov	$1A[bp],al
35380                                           !BCC_EOS
35381                                           ! 5104   }
35382                                           ! 5105 }
35383                       00009F88            .703:
35384 9F88           89EC                       mov	sp,bp
35385 9F8A           5D                         pop	bp
35386 9F8B           C3                         ret
35387                                           ! 5106 void
35388                                           ! 5107 int18_function(seq_nr)
35389                                           ! 5108 Bit16u seq_nr;
35390                                           export	_int18_function
35391                       00009F8C            _int18_function:
35392                                           !BCC_EOS
35393                                           ! 5109 {
35394                                           ! 5110   Bit16u ebda_seg=read_word(0x0040,0x000E);
35395 9F8C           55                         push	bp
35396 9F8D           89E5                       mov	bp,sp
35397 9F8F           4C                         dec	sp
35398 9F90           4C                         dec	sp
35399                                           ! Debug: list int = const $E (used reg = )
35400 9F91           B8                   000E  mov	ax,*$E
35401 9F94           50                         push	ax
35402                                           ! Debug: list int = const $40 (used reg = )
35403 9F95           B8                   0040  mov	ax,*$40
35404 9F98           50                         push	ax
35405                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35406 9F99           E8         666B            call	_read_word
35407 9F9C           83C4                   04  add	sp,*4
35408                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
35409 9F9F           8946         FE            mov	-2[bp],ax
35410                                           !BCC_EOS
35411                                           ! 5111   Bit16u bootdev;
35412                                           !BCC_EOS
35413                                           ! 5112   Bit8u bootdrv;
35414                                           !BCC_EOS
35415                                           ! 5113   Bit8u bootchk;
35416                                           !BCC_EOS
35417                                           ! 5114   Bit16u bootseg;
35418                                           !BCC_EOS
35419                                           ! 5115   Bit16u bootip;
35420                                           !BCC_EOS
35421                                           ! 5116   Bit16u status;
35422                                           !BCC_EOS
35423                                           ! 5117   Bit16u bootfirst;
35424                                           !BCC_EOS
35425                                           ! 5118   ipl_entry_t e;
35426                                           !BCC_EOS
35427                                           ! 5119   bootdev = inb_cmos(0x3d);
35428 9FA2           83C4                   E4  add	sp,*-$1C
35429                                           ! Debug: list int = const $3D (used reg = )
35430 9FA5           B8                   003D  mov	ax,*$3D
35431 9FA8           50                         push	ax
35432                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35433 9FA9           E8         65D7            call	_inb_cmos
35434 9FAC           44                         inc	sp
35435 9FAD           44                         inc	sp
35436                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35437 9FAE           30E4                       xor	ah,ah
35438 9FB0           8946         FC            mov	-4[bp],ax
35439                                           !BCC_EOS
35440                                           ! 5120   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
35441                                           ! Debug: list int = const $38 (used reg = )
35442 9FB3           B8                   0038  mov	ax,*$38
35443 9FB6           50                         push	ax
35444                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35445 9FB7           E8         65C9            call	_inb_cmos
35446 9FBA           44                         inc	sp
35447 9FBB           44                         inc	sp
35448                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
35449 9FBC           24                     F0  and	al,#$F0
35450                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
35451 9FBE           30E4                       xor	ah,ah
35452 9FC0           B1                     04  mov	cl,*4
35453 9FC2           D3E0                       shl	ax,cl
35454                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35455 9FC4           0B46         FC            or	ax,-4[bp]
35456 9FC7           8946         FC            mov	-4[bp],ax
35457                                           !BCC_EOS
35458                                           ! 5121   bootdev >>= 4 * seq_nr;
35459                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
35460                                           ! Debug: expression subtree swapping
35461 9FCA           8B46         04            mov	ax,4[bp]
35462 9FCD           D1E0                       shl	ax,*1
35463 9FCF           D1E0                       shl	ax,*1
35464                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35465 9FD1           89C3                       mov	bx,ax
35466 9FD3           8B46         FC            mov	ax,-4[bp]
35467 9FD6           89D9                       mov	cx,bx
35468 9FD8           D3E8                       shr	ax,cl
35469 9FDA           8946         FC            mov	-4[bp],ax
35470                                           !BCC_EOS
35471                                           ! 5122   bootdev &= 0xf;
35472                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
35473 9FDD           8A46         FC            mov	al,-4[bp]
35474 9FE0           24                     0F  and	al,*$F
35475 9FE2           30E4                       xor	ah,ah
35476 9FE4           8946         FC            mov	-4[bp],ax
35477                                           !BCC_EOS
35478                                           ! 5123   bootfirst = read_word(ebda_seg, 0x0384);
35479                                           ! Debug: list int = const $384 (used reg = )
35480 9FE7           B8                   0384  mov	ax,#$384
35481 9FEA           50                         push	ax
35482                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
35483 9FEB           FF76         FE            push	-2[bp]
35484                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35485 9FEE           E8         6616            call	_read_word
35486 9FF1           83C4                   04  add	sp,*4
35487                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
35488 9FF4           8946         F2            mov	-$E[bp],ax
35489                                           !BCC_EOS
35490                                           ! 5124   if (bootfirst != 0xFFFF) {
35491                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
35492 9FF7           8B46         F2            mov	ax,-$E[bp]
35493 9FFA           3D                   FFFF  cmp	ax,#$FFFF
35494 9FFD           74           2A            je  	.704
35495                       00009FFF            .705:
35496                                           ! 5125     bootdev = bootfirst;
35497                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
35498 9FFF           8B46         F2            mov	ax,-$E[bp]
35499 A002           8946         FC            mov	-4[bp],ax
35500                                           !BCC_EOS
35501                                           ! 5126     write_word(ebda_seg, 0x0384, 0xFFFF);
35502                                           ! Debug: list unsigned int = const $FFFF (used reg = )
35503 A005           B8                   FFFF  mov	ax,#$FFFF
35504 A008           50                         push	ax
35505                                           ! Debug: list int = const $384 (used reg = )
35506 A009           B8                   0384  mov	ax,#$384
35507 A00C           50                         push	ax
35508                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
35509 A00D           FF76         FE            push	-2[bp]
35510                                           ! Debug: func () void = write_word+0 (used reg = )
35511 A010           E8         661F            call	_write_word
35512 A013           83C4                   06  add	sp,*6
35513                                           !BCC_EOS
35514                                           ! 5127     write_word(ebda_seg, 0x0382, 0xFFFF);
35515                                           ! Debug: list unsigned int = const $FFFF (used reg = )
35516 A016           B8                   FFFF  mov	ax,#$FFFF
35517 A019           50                         push	ax
35518                                           ! Debug: list int = const $382 (used reg = )
35519 A01A           B8                   0382  mov	ax,#$382
35520 A01D           50                         push	ax
35521                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
35522 A01E           FF76         FE            push	-2[bp]
35523                                           ! Debug: func () void = write_word+0 (used reg = )
35524 A021           E8         660E            call	_write_word
35525 A024           83C4                   06  add	sp,*6
35526                                           !BCC_EOS
35527                                           ! 5128   } else if (bootdev == 0) {
35528 A027           EB           3C            jmp .706
35529                       0000A029            .704:
35530                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
35531 A029           8B46         FC            mov	ax,-4[bp]
35532 A02C           85C0                       test	ax,ax
35533 A02E           75           35            jne 	.707
35534                       0000A030            .708:
35535                                           ! 5129     bios_printf(2, "\nNo bootable device.\n");
35536                                           ! Debug: list * char = .709+0 (used reg = )
35537 A030           BB                   D01B  mov	bx,#.709
35538 A033           53                         push	bx
35539                                           ! Debug: list int = const 2 (used reg = )
35540 A034           B8                   0002  mov	ax,*2
35541 A037           50                         push	ax
35542                                           ! Debug: func () void = bios_printf+0 (used reg = )
35543 A038           E8         69E0            call	_bios_printf
35544 A03B           83C4                   04  add	sp,*4
35545                                           !BCC_EOS
35546                                           ! 5130     bios_printf(2, "Powering off in 30 seconds.\n");
35547                                           ! Debug: list * char = .70A+0 (used reg = )
35548 A03E           BB                   CFFE  mov	bx,#.70A
35549 A041           53                         push	bx
35550                                           ! Debug: list int = const 2 (used reg = )
35551 A042           B8                   0002  mov	ax,*2
35552 A045           50                         push	ax
35553                                           ! Debug: func () void = bios_printf+0 (used reg = )
35554 A046           E8         69D2            call	_bios_printf
35555 A049           83C4                   04  add	sp,*4
35556                                           !BCC_EOS
35557                                           ! 5131 #asm
35558                                           !BCC_EOS
35559                                           !BCC_ASM
35560                       00000014            _int18_function.bootip	set	$14
35561                       FFFFFFF6            .int18_function.bootip	set	-$A
35562                       00000022            _int18_function.seq_nr	set	$22
35563                       00000004            .int18_function.seq_nr	set	4
35564                       00000018            _int18_function.bootchk	set	$18
35565                       FFFFFFFA            .int18_function.bootchk	set	-6
35566                       00000016            _int18_function.bootseg	set	$16
35567                       FFFFFFF8            .int18_function.bootseg	set	-8
35568                       0000001C            _int18_function.ebda_seg	set	$1C
35569                       FFFFFFFE            .int18_function.ebda_seg	set	-2
35570                       00000012            _int18_function.status	set	$12
35571                       FFFFFFF4            .int18_function.status	set	-$C
35572                       00000010            _int18_function.bootfirst	set	$10
35573                       FFFFFFF2            .int18_function.bootfirst	set	-$E
35574                       00000019            _int18_function.bootdrv	set	$19
35575                       FFFFFFFB            .int18_function.bootdrv	set	-5
35576                       0000001A            _int18_function.bootdev	set	$1A
35577                       FFFFFFFC            .int18_function.bootdev	set	-4
35578                       00000000            _int18_function.e	set	0
35579                       FFFFFFE2            .int18_function.e	set	-$1E
35580 A04C           FB                             sti
35581 A04D           B9                   01C9      mov cx, #0x01c9
35582 A050           BA                   C380      mov dx, #0xc380
35583 A053           B4                     86      mov ah, #0x86 ;; INT 15/86: wait CX:DX usec.
35584 A055           CD                     15      int #0x15
35585                                           ! 5137 endasm
35586                                           !BCC_ENDASM
35587                                           !BCC_EOS
35588                                           ! 5138     bios_printf(1, "");
35589                                           ! Debug: list * char = .70B+0 (used reg = )
35590 A057           BB                   CFFD  mov	bx,#.70B
35591 A05A           53                         push	bx
35592                                           ! Debug: list int = const 1 (used reg = )
35593 A05B           B8                   0001  mov	ax,*1
35594 A05E           50                         push	ax
35595                                           ! Debug: func () void = bios_printf+0 (used reg = )
35596 A05F           E8         69B9            call	_bios_printf
35597 A062           83C4                   04  add	sp,*4
35598                                           !BCC_EOS
35599                                           ! 5139   }
35600                                           ! 5140   bootdev -= 1;
35601                       0000A065            .707:
35602                       0000A065            .706:
35603                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
35604 A065           8B46         FC            mov	ax,-4[bp]
35605 A068           48                         dec	ax
35606 A069           8946         FC            mov	-4[bp],ax
35607                                           !BCC_EOS
35608                                           ! 5141   if (get_boot_vector(bootdev, &e) == 0) {
35609                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
35610 A06C           8D5E         E2            lea	bx,-$1E[bp]
35611 A06F           53                         push	bx
35612                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
35613 A070           FF76         FC            push	-4[bp]
35614                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
35615 A073           E8         7498            call	_get_boot_vector
35616 A076           83C4                   04  add	sp,*4
35617                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
35618 A079           84C0                       test	al,al
35619 A07B           75           04            jne 	.70C
35620                       0000A07D            .70D:
35621                                           ! 5142     ;
35622                                           !BCC_EOS
35623                                           ! 5143     return;
35624 A07D           89EC                       mov	sp,bp
35625 A07F           5D                         pop	bp
35626 A080           C3                         ret
35627                                           !BCC_EOS
35628                                           ! 5144   }
35629                                           ! 5145   print_boot_device(e.type, e.description);
35630                       0000A081            .70C:
35631                                           ! Debug: list unsigned long e = [S+$20-$18] (used reg = )
35632 A081           FF76         EC            push	-$14[bp]
35633 A084           FF76         EA            push	-$16[bp]
35634                                           ! Debug: list unsigned short e = [S+$24-$20] (used reg = )
35635 A087           FF76         E2            push	-$1E[bp]
35636                                           ! Debug: func () void = print_boot_device+0 (used reg = )
35637 A08A           E8         76DA            call	_print_boot_device
35638 A08D           83C4                   06  add	sp,*6
35639                                           !BCC_EOS
35640                                           ! 5146   switch(e.type) {
35641 A090           8B46         E2            mov	ax,-$1E[bp]
35642 A093           E9         012A            br 	.710
35643                                           ! 5147   case 0x01:
35644                                           ! 5148   case 0x02:
35645                       0000A096            .711:
35646                                           ! 5149     boot
35647                                           ! 5149 drv = (e.type == 0x02) ? 0x80 : 0x00;
35648                       0000A096            .712:
35649                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
35650 A096           8B46         E2            mov	ax,-$1E[bp]
35651 A099           3D                   0002  cmp	ax,*2
35652 A09C           75           04            jne 	.713
35653                       0000A09E            .714:
35654 A09E           B0                     80  mov	al,#$80
35655 A0A0           EB           02            jmp .715
35656                       0000A0A2            .713:
35657 A0A2           30C0                       xor	al,al
35658                       0000A0A4            .715:
35659                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
35660 A0A4           8846         FB            mov	-5[bp],al
35661                                           !BCC_EOS
35662                                           ! 5150     bootseg = 0x07c0;
35663                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
35664 A0A7           B8                   07C0  mov	ax,#$7C0
35665 A0AA           8946         F8            mov	-8[bp],ax
35666                                           !BCC_EOS
35667                                           ! 5151     status = 0;
35668                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
35669 A0AD           31C0                       xor	ax,ax
35670 A0AF           8946         F4            mov	-$C[bp],ax
35671                                           !BCC_EOS
35672                                           ! 5152 #asm
35673                                           !BCC_EOS
35674                                           !BCC_ASM
35675                       00000014            _int18_function.bootip	set	$14
35676                       FFFFFFF6            .int18_function.bootip	set	-$A
35677                       00000022            _int18_function.seq_nr	set	$22
35678                       00000004            .int18_function.seq_nr	set	4
35679                       00000018            _int18_function.bootchk	set	$18
35680                       FFFFFFFA            .int18_function.bootchk	set	-6
35681                       00000016            _int18_function.bootseg	set	$16
35682                       FFFFFFF8            .int18_function.bootseg	set	-8
35683                       0000001C            _int18_function.ebda_seg	set	$1C
35684                       FFFFFFFE            .int18_function.ebda_seg	set	-2
35685                       00000012            _int18_function.status	set	$12
35686                       FFFFFFF4            .int18_function.status	set	-$C
35687                       00000010            _int18_function.bootfirst	set	$10
35688                       FFFFFFF2            .int18_function.bootfirst	set	-$E
35689                       00000019            _int18_function.bootdrv	set	$19
35690                       FFFFFFFB            .int18_function.bootdrv	set	-5
35691                       0000001A            _int18_function.bootdev	set	$1A
35692                       FFFFFFFC            .int18_function.bootdev	set	-4
35693                       00000000            _int18_function.e	set	0
35694                       FFFFFFE2            .int18_function.e	set	-$1E
35695 A0B2           55                             push bp
35696 A0B3           89E5                           mov bp, sp
35697 A0B5           50                             push ax
35698 A0B6           53                             push bx
35699 A0B7           51                             push cx
35700 A0B8           52                             push dx
35701 A0B9           8A56         1B                mov dl, _int18_function.bootdrv + 2[bp]
35702 A0BC           8B46         18                mov ax, _int18_function.bootseg + 2[bp]
35703 A0BF           8EC0                           mov es, ax ;; segment
35704 A0C1           31DB                           xor bx, bx ;; offset
35705 A0C3           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
35706 A0C5           B0                     01      mov al, #0x01 ;; read 1 sector
35707 A0C7           B5                     00      mov ch, #0x00 ;; track 0
35708 A0C9           B1                     01      mov cl, #0x01 ;; sector 1
35709 A0CB           B6                     00      mov dh, #0x00 ;; head 0
35710 A0CD           CD                     13      int #0x13 ;; read sector
35711 A0CF           73           06                jnc int19_load_done
35712 A0D1           B8                   0001      mov ax, #0x0001
35713 A0D4           8946         14                mov _int18_function.status + 2[bp], ax
35714                       0000A0D7            int19_load_done:
35715 A0D7           5A                             pop dx
35716 A0D8           59                             pop cx
35717 A0D9           5B                             pop bx
35718 A0DA           58                             pop ax
35719 A0DB           5D                             pop bp
35720                                           ! 5178 endasm
35721                                           !BCC_ENDASM
35722                                           !BCC_EOS
35723                                           ! 5179     if (status != 0) {
35724                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
35725 A0DC           8B46         F4            mov	ax,-$C[bp]
35726 A0DF           85C0                       test	ax,ax
35727 A0E1           74           11            je  	.716
35728                       0000A0E3            .717:
35729                                           ! 5180       print_boot_failure(e.type, 1);
35730                                           ! Debug: list int = const 1 (used reg = )
35731 A0E3           B8                   0001  mov	ax,*1
35732 A0E6           50                         push	ax
35733                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
35734 A0E7           FF76         E2            push	-$1E[bp]
35735                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
35736 A0EA           E8         7735            call	_print_boot_failure
35737 A0ED           83C4                   04  add	sp,*4
35738                                           !BCC_EOS
35739                                           ! 5181       return;
35740 A0F0           89EC                       mov	sp,bp
35741 A0F2           5D                         pop	bp
35742 A0F3           C3                         ret
35743                                           !BCC_EOS
35744                                           ! 5182     }
35745                                           ! 5183     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
35746                       0000A0F4            .716:
35747                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
35748 A0F4           8B46         E2            mov	ax,-$1E[bp]
35749 A0F7           3D                   0001  cmp	ax,*1
35750 A0FA           75           0F            jne 	.719
35751                       0000A0FC            .71A:
35752                                           ! Debug: list int = const $38 (used reg = )
35753 A0FC           B8                   0038  mov	ax,*$38
35754 A0FF           50                         push	ax
35755                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35756 A100           E8         6480            call	_inb_cmos
35757 A103           44                         inc	sp
35758 A104           44                         inc	sp
35759                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
35760 A105           24                     01  and	al,*1
35761 A107           84C0                       test	al,al
35762 A109           75           22            jne 	.718
35763                       0000A10B            .719:
35764                                           ! 5184       if (read_word(bootseg,0x1fe) != 0xaa55) {
35765                                           ! Debug: list int = const $1FE (used reg = )
35766 A10B           B8                   01FE  mov	ax,#$1FE
35767 A10E           50                         push	ax
35768                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
35769 A10F           FF76         F8            push	-8[bp]
35770                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35771 A112           E8         64F2            call	_read_word
35772 A115           83C4                   04  add	sp,*4
35773                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
35774 A118           3D                   AA55  cmp	ax,#$AA55
35775 A11B           74           10            je  	.71B
35776                       0000A11D            .71C:
35777                                           ! 5185         print_boot_failure(e.type, 0);
35778                                           ! Debug: list int = const 0 (used reg = )
35779 A11D           31C0                       xor	ax,ax
35780 A11F           50                         push	ax
35781                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
35782 A120           FF76         E2            push	-$1E[bp]
35783                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
35784 A123           E8         76FC            call	_print_boot_failure
35785 A126           83C4                   04  add	sp,*4
35786                                           !BCC_EOS
35787                                           ! 5186         return;
35788 A129           89EC                       mov	sp,bp
35789 A12B           5D                         pop	bp
35790 A12C           C3                         ret
35791                                           !BCC_EOS
35792                                           ! 5187       }
35793                                           ! 5188     }
35794                       0000A12D            .71B:
35795                                           ! 5189     bootip = (bootseg & 0x0fff) << 4;
35796                       0000A12D            .718:
35797                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
35798 A12D           8B46         F8            mov	ax,-8[bp]
35799 A130           25                   0FFF  and	ax,#$FFF
35800                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
35801 A133           B1                     04  mov	cl,*4
35802 A135           D3E0                       shl	ax,cl
35803                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
35804 A137           8946         F6            mov	-$A[bp],ax
35805                                           !BCC_EOS
35806                                           ! 5190     bootseg &= 0xf000;
35807                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
35808 A13A           8B46         F8            mov	ax,-8[bp]
35809 A13D           25                   F000  and	ax,#$F000
35810 A140           8946         F8            mov	-8[bp],ax
35811                                           !BCC_EOS
35812                                           ! 5191   break;
35813 A143           E9         0096            br 	.70E
35814                                           !BCC_EOS
35815                                           ! 5192   case 0x03:
35816                                           ! 5193     status = cdrom_boot();
35817                       0000A146            .71D:
35818                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
35819 A146           E8         9CB7            call	_cdrom_boot
35820                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
35821 A149           8946         F4            mov	-$C[bp],ax
35822                                           !BCC_EOS
35823                                           ! 5194     if ( (status & 0x00ff) !=0 ) {
35824                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
35825 A14C           8A46         F4            mov	al,-$C[bp]
35826                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35827 A14F           84C0                       test	al,al
35828 A151           74           19            je  	.71E
35829                       0000A153            .71F:
35830                                           ! 5195       print_cdromboot_failure(status);
35831                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
35832 A153           FF76         F4            push	-$C[bp]
35833                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
35834 A156           E8         7741            call	_print_cdromboot_failure
35835 A159           44                         inc	sp
35836 A15A           44                         inc	sp
35837                                           !BCC_EOS
35838                                           ! 5196       print_boot_failure(e.type, 1);
35839                                           ! Debug: list int = const 1 (used reg = )
35840 A15B           B8                   0001  mov	ax,*1
35841 A15E           50                         push	ax
35842                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
35843 A15F           FF76         E2            push	-$1E[bp]
35844                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
35845 A162           E8         76BD            call	_print_boot_failure
35846 A165           83C4                   04  add	sp,*4
35847                                           !BCC_EOS
35848                                           ! 5197       return;
35849 A168           89EC                       mov	sp,bp
35850 A16A           5D                         pop	bp
35851 A16B           C3                         ret
35852                                           !BCC_EOS
35853                                           ! 5198     }
35854                                           ! 5199     bootdrv = (Bit8u)(status>>8);
35855                       0000A16C            .71E:
35856                                           ! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
35857 A16C           8B46         F4            mov	ax,-$C[bp]
35858 A16F           88E0                       mov	al,ah
35859 A171           30E4                       xor	ah,ah
35860                                           ! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
35861                                           ! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
35862 A173           8846         FB            mov	-5[bp],al
35863                                           !BCC_EOS
35864                                           ! 5200     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
35865                                           ! Debug: list * unsigned short = const $266 (used reg = )
35866 A176           B8                   0266  mov	ax,#$266
35867 A179           50                         push	ax
35868                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
35869 A17A           FF76         FE            push	-2[bp]
35870                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35871 A17D           E8         6487            call	_read_word
35872 A180           83C4                   04  add	sp,*4
35873                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
35874 A183           8946         F8            mov	-8[bp],ax
35875                                           !BCC_EOS
35876                                           ! 5201     bootip = (bootseg & 0x0fff) << 4;
35877                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
35878 A186           8B46         F8            mov	ax,-8[bp]
35879 A189           25                   0FFF  and	ax,#$FFF
35880                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
35881 A18C           B1                     04  mov	cl,*4
35882 A18E           D3E0                       shl	ax,cl
35883                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
35884 A190           8946         F6            mov	-$A[bp],ax
35885                                           !BCC_EOS
35886                                           ! 5202     bootseg &= 0xf000;
35887                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
35888 A193           8B46         F8            mov	ax,-8[bp]
35889 A196           25                   F000  and	ax,#$F000
35890 A199           8946         F8            mov	-8[bp],ax
35891                                           !BCC_EOS
35892                                           ! 5203     break;
35893 A19C           EB           3E            jmp .70E
35894                                           !BCC_EOS
35895                                           ! 5204   case 0x80:
35896                                           ! 5205     bootseg = e.vector >> 16;
35897                       0000A19E            .720:
35898                                           ! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
35899 A19E           8B46         E6            mov	ax,-$1A[bp]
35900 A1A1           8B5E         E8            mov	bx,-$18[bp]
35901 A1A4           93                         xchg	bx,ax
35902 A1A5           31DB                       xor	bx,bx
35903                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
35904 A1A7           8946         F8            mov	-8[bp],ax
35905                                           !BCC_EOS
35906                                           ! 5206     bootip = e.vector & 0xffff;
35907                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
35908                                           ! Debug: expression subtree swapping
35909 A1AA           B8                   FFFF  mov	ax,#$FFFF
35910 A1AD           31DB                       xor	bx,bx
35911 A1AF           8D7E         E6            lea	di,-$1A[bp]
35912 A1B2           E8         5F06            call	landul
35913                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
35914 A1B5           8946         F6            mov	-$A[bp],ax
35915                                           !BCC_EOS
35916                                           ! 5207     break;
35917 A1B8           EB           22            jmp .70E
35918                                           !BCC_EOS
35919                                           ! 5208   default: return;
35920                       0000A1BA            .721:
35921 A1BA           89EC                       mov	sp,bp
35922 A1BC           5D                         pop	bp
35923 A1BD           C3                         ret
35924                                           !BCC_EOS
35925                                           ! 5209   }
35926                                           ! 5210   bios_printf(2, " - success.\n");
35927 A1BE           EB           1C            jmp .70E
35928                       0000A1C0            .710:
35929 A1C0           2D                   0001  sub	ax,*1
35930 A1C3         0F84         FECF            beq 	.711
35931 A1C7           2D                   0001  sub	ax,*1
35932 A1CA         0F84         FEC8            beq 	.712
35933 A1CE           2D                   0001  sub	ax,*1
35934 A1D1         0F84         FF71            beq 	.71D
35935 A1D5           2D                   007D  sub	ax,*$7D
35936 A1D8           74           C4            je 	.720
35937 A1DA           EB           DE            jmp	.721
35938                       0000A1DC            .70E:
35939                       FFFFFFE0            ..FFDB	=	-$20
35940                                           ! Debug: list * char = .722+0 (used reg = )
35941 A1DC           BB                   CFF0  mov	bx,#.722
35942 A1DF           53                         push	bx
35943                                           ! Debug: list int = const 2 (used reg = )
35944 A1E0           B8                   0002  mov	ax,*2
35945 A1E3           50                         push	ax
35946                                           ! Debug: func () void = bios_printf+0 (used reg = )
35947 A1E4           E8         6834            call	_bios_printf
35948 A1E7           83C4                   04  add	sp,*4
35949                                           !BCC_EOS
35950                                           ! 5211   ;
35951                                           !BCC_EOS
35952                                           ! 5212 #asm
35953                                           !BCC_EOS
35954                                           !BCC_ASM
35955                       00000014            _int18_function.bootip	set	$14
35956                       FFFFFFF6            .int18_function.bootip	set	-$A
35957                       00000022            _int18_function.seq_nr	set	$22
35958                       00000004            .int18_function.seq_nr	set	4
35959                       00000018            _int18_function.bootchk	set	$18
35960                       FFFFFFFA            .int18_function.bootchk	set	-6
35961                       00000016            _int18_function.bootseg	set	$16
35962                       FFFFFFF8            .int18_function.bootseg	set	-8
35963                       0000001C            _int18_function.ebda_seg	set	$1C
35964                       FFFFFFFE            .int18_function.ebda_seg	set	-2
35965                       00000012            _int18_function.status	set	$12
35966                       FFFFFFF4            .int18_function.status	set	-$C
35967                       00000010            _int18_function.bootfirst	set	$10
35968                       FFFFFFF2            .int18_function.bootfirst	set	-$E
35969                       00000019            _int18_function.bootdrv	set	$19
35970                       FFFFFFFB            .int18_function.bootdrv	set	-5
35971                       0000001A            _int18_function.bootdev	set	$1A
35972                       FFFFFFFC            .int18_function.bootdev	set	-4
35973                       00000000            _int18_function.e	set	0
35974                       FFFFFFE2            .int18_function.e	set	-$1E
35975 A1EA           89E5                           mov bp, sp
35976 A1EC           0E                             push cs
35977 A1ED           68                   A73E      push #int18_handler
35978                                               ;; Build an iret stack frame that will take us to the boot vector.
35979                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
35980 A1F0           9C                             pushf
35981 A1F1           8B46         16                mov ax, _int18_function.bootseg + 0[bp]
35982 A1F4           50                             push ax
35983 A1F5           8B46         14                mov ax, _int18_function.bootip + 0[bp]
35984 A1F8           50                             push ax
35985                                               ;; Set the magic number in ax and the boot drive in dl.
35986 A1F9           B8                   AA55      mov ax, #0xaa55
35987 A1FC           8A56         19                mov dl, _int18_function.bootdrv + 0[bp]
35988                                               ;; Zero some of the other registers.
35989 A1FF           31DB                           xor bx, bx
35990 A201           8EDB                           mov ds, bx
35991 A203           8EC3                           mov es, bx
35992 A205           89DD                           mov bp, bx
35993                                               ;; Go!
35994 A207           CF                             iret
35995                                           ! 5233 endasm
35996                                           !BCC_ENDASM
35997                                           !BCC_EOS
35998                                           ! 5234 }
35999 A208           89EC                       mov	sp,bp
36000 A20A           5D                         pop	bp
36001 A20B           C3                         ret
36002                                           ! 5235   void
36003                                           ! Register BX used in function int18_function
36004                                           ! 5236 int1a_function(regs, ds, iret_addr)
36005                                           ! 5237   pusha_regs_t regs;
36006                                           export	_int1a_function
36007                       0000A20C            _int1a_function:
36008                                           !BCC_EOS
36009                                           ! 5238   Bit16u ds;
36010                                           !BCC_EOS
36011                                           ! 5239   iret_addr_t iret_addr;
36012                                           !BCC_EOS
36013                                           ! 5240 {
36014                                           ! 5241   Bit8u val8;
36015                                           !BCC_EOS
36016                                           ! 5242   ;
36017 A20C           55                         push	bp
36018 A20D           89E5                       mov	bp,sp
36019 A20F           4C                         dec	sp
36020 A210           4C                         dec	sp
36021                                           !BCC_EOS
36022                                           ! 5243 #asm
36023                                           !BCC_EOS
36024                                           !BCC_ASM
36025                       00000016            _int1a_function.ds	set	$16
36026                       00000014            .int1a_function.ds	set	$14
36027                       00000001            _int1a_function.val8	set	1
36028                       FFFFFFFF            .int1a_function.val8	set	-1
36029                       00000018            _int1a_function.iret_addr	set	$18
36030                       00000016            .int1a_function.iret_addr	set	$16
36031                       00000006            _int1a_function.regs	set	6
36032                       00000004            .int1a_function.regs	set	4
36033 A211           FB                           sti
36034                                           ! 5245 endasm
36035                                           !BCC_ENDASM
36036                                           !BCC_EOS
36037                                           ! 5246   switch (regs.u.r8.ah) {
36038 A212           8A46         13            mov	al,$13[bp]
36039 A215           E9         0309            br 	.725
36040                                           ! 5247     case 0:
36041                                           ! 5248 #asm
36042                       0000A218            .726:
36043                                           !BCC_EOS
36044                                           !BCC_ASM
36045                       00000016            _int1a_function.ds	set	$16
36046                       00000014            .int1a_function.ds	set	$14
36047                       00000001            _int1a_function.val8	set	1
36048                       FFFFFFFF            .int1a_function.val8	set	-1
36049                       00000018            _int1a_function.iret_addr	set	$18
36050                       00000016            .int1a_function.iret_addr	set	$16
36051                       00000006            _int1a_function.regs	set	6
36052                       00000004            .int1a_function.regs	set	4
36053 A218           FA                               cli
36054                                           ! 5250 endasm
36055                                           !BCC_ENDASM
36056                                           !BCC_EOS
36057                                           ! 5251       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
36058                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
36059 A219           A1         046E            mov	ax,[$46E]
36060 A21C           8946         10            mov	$10[bp],ax
36061                                           !BCC_EOS
36062                                           ! 5252       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
36063                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
36064 A21F           A1         046C            mov	ax,[$46C]
36065 A222           8946         0E            mov	$E[bp],ax
36066                                           !BCC_EOS
36067                                           ! 5253       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
36068                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
36069 A225           A0         0470            mov	al,[$470]
36070 A228           8846         12            mov	$12[bp],al
36071                                           !BCC_EOS
36072                                           ! 5254       ((bios_data_t *) 0)->midnight_flag = 0;
36073                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
36074 A22B           30C0                       xor	al,al
36075 A22D           A2         0470            mov	[$470],al
36076                                           !BCC_EOS
36077                                           ! 5255 #asm
36078                                           !BCC_EOS
36079                                           !BCC_ASM
36080                       00000016            _int1a_function.ds	set	$16
36081                       00000014            .int1a_function.ds	set	$14
36082                       00000001            _int1a_function.val8	set	1
36083                       FFFFFFFF            .int1a_function.val8	set	-1
36084                       00000018            _int1a_function.iret_addr	set	$18
36085                       00000016            .int1a_function.iret_addr	set	$16
36086                       00000006            _int1a_function.regs	set	6
36087                       00000004            .int1a_function.regs	set	4
36088 A230           FB                               sti
36089                                           ! 5257 endasm
36090                                           !BCC_ENDASM
36091                                           !BCC_EOS
36092                                           ! 5258       iret_addr.flags.u.r8.flagsl &= 0xfe;
36093                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36094 A231           8A46         1A            mov	al,$1A[bp]
36095 A234           24                     FE  and	al,#$FE
36096 A236           8846         1A            mov	$1A[bp],al
36097                                           !BCC_EOS
36098                                           ! 5259       break;
36099 A239           E9         030E            br 	.723
36100                                           !BCC_EOS
36101                                           ! 5260     case 1:
36102                                           ! 5261 #asm
36103                       0000A23C            .727:
36104                                           !BCC_EOS
36105                                           !BCC_ASM
36106                       00000016            _int1a_function.ds	set	$16
36107                       00000014            .int1a_function.ds	set	$14
36108                       00000001            _int1a_function.val8	set	1
36109                       FFFFFFFF            .int1a_function.val8	set	-1
36110                       00000018            _int1a_function.iret_addr	set	$18
36111                       00000016            .int1a_function.iret_addr	set	$16
36112                       00000006            _int1a_function.regs	set	6
36113                       00000004            .int1a_function.regs	set	4
36114 A23C           FA                               cli
36115                                           ! 5263 endasm
36116                                           !BCC_ENDASM
36117                                           !BCC_EOS
36118                                           ! 5264       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
36119                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
36120 A23D           8B46         10            mov	ax,$10[bp]
36121 A240           A3         046E            mov	[$46E],ax
36122                                           !BCC_EOS
36123                                           ! 5265       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
36124                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
36125 A243           8B46         0E            mov	ax,$E[bp]
36126 A246           A3         046C            mov	[$46C],ax
36127                                           !BCC_EOS
36128                                           ! 5266       ((bios_data_t *) 0)->midnight_flag = 0;
36129                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
36130 A249           30C0                       xor	al,al
36131 A24B           A2         0470            mov	[$470],al
36132                                           !BCC_EOS
36133                                           ! 5267 #asm
36134                                           !BCC_EOS
36135                                           !BCC_ASM
36136                       00000016            _int1a_function.ds	set	$16
36137                       00000014            .int1a_function.ds	set	$14
36138                       00000001            _int1a_function.val8	set	1
36139                       FFFFFFFF            .int1a_function.val8	set	-1
36140                       00000018            _int1a_function.iret_addr	set	$18
36141                       00000016            .int1a_function.iret_addr	set	$16
36142                       00000006            _int1a_function.regs	set	6
36143                       00000004            .int1a_function.regs	set	4
36144 A24E           FB                               sti
36145                                           ! 5269 endasm
36146                                           !BCC_ENDASM
36147                                           !BCC_EOS
36148                                           ! 5270       regs.u.r8.ah = 0;
36149                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36150 A24F           30C0                       xor	al,al
36151 A251           8846         13            mov	$13[bp],al
36152                                           !BCC_EOS
36153                                           ! 5271       iret_addr.flags.u.r8.flagsl &= 0xfe;
36154                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36155 A254           8A46         1A            mov	al,$1A[bp]
36156 A257           24                     FE  and	al,#$FE
36157 A259           8846         1A            mov	$1A[bp],al
36158                                           !BCC_EOS
36159                                           ! 5272       break;
36160 A25C           E9         02EB            br 	.723
36161                                           !BCC_EOS
36162                                           ! 5273     case 2:
36163                                           ! 5274       if (rtc_updating()) {
36164                       0000A25F            .728:
36165                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36166 A25F           E8         635E            call	_rtc_updating
36167 A262           85C0                       test	ax,ax
36168 A264           74           0B            je  	.729
36169                       0000A266            .72A:
36170                                           ! 5275         iret_addr.flags.u.r8.flagsl |= 0x01;
36171                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36172 A266           8A46         1A            mov	al,$1A[bp]
36173 A269           0C                     01  or	al,*1
36174 A26B           8846         1A            mov	$1A[bp],al
36175                                           !BCC_EOS
36176                                           ! 5276         break;
36177 A26E           E9         02D9            br 	.723
36178                                           !BCC_EOS
36179                                           ! 5277         }
36180                                           ! 5278       regs.u.r8.dh = inb_cmos(0x00);
36181                       0000A271            .729:
36182                                           ! Debug: list int = const 0 (used reg = )
36183 A271           31C0                       xor	ax,ax
36184 A273           50                         push	ax
36185                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36186 A274           E8         630C            call	_inb_cmos
36187 A277           44                         inc	sp
36188 A278           44                         inc	sp
36189                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
36190 A279           8846         0F            mov	$F[bp],al
36191                                           !BCC_EOS
36192                                           ! 5279       regs.u.r8.cl = inb_cmos(0x02);
36193                                           ! Debug: list int = const 2 (used reg = )
36194 A27C           B8                   0002  mov	ax,*2
36195 A27F           50                         push	ax
36196                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36197 A280           E8         6300            call	_inb_cmos
36198 A283           44                         inc	sp
36199 A284           44                         inc	sp
36200                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
36201 A285           8846         10            mov	$10[bp],al
36202                                           !BCC_EOS
36203                                           ! 5280       regs.u.r8.ch = inb_cmos(0x04);
36204                                           ! Debug: list int = const 4 (used reg = )
36205 A288           B8                   0004  mov	ax,*4
36206 A28B           50                         push	ax
36207                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36208 A28C           E8         62F4            call	_inb_cmos
36209 A28F           44                         inc	sp
36210 A290           44                         inc	sp
36211                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
36212 A291           8846         11            mov	$11[bp],al
36213                                           !BCC_EOS
36214                                           ! 5281       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
36215                                           ! Debug: list int = const $B (used reg = )
36216 A294           B8                   000B  mov	ax,*$B
36217 A297           50                         push	ax
36218                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36219 A298           E8         62E8            call	_inb_cmos
36220 A29B           44                         inc	sp
36221 A29C           44                         inc	sp
36222                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
36223 A29D           24                     01  and	al,*1
36224                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
36225 A29F           8846         0E            mov	$E[bp],al
36226                                           !BCC_EOS
36227                                           ! 5282       regs.u.r8.ah = 0;
36228                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36229 A2A2           30C0                       xor	al,al
36230 A2A4           8846         13            mov	$13[bp],al
36231                                           !BCC_EOS
36232                                           ! 5283       regs.u.r8.al = regs.u.r8.ch;
36233                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
36234 A2A7           8A46         11            mov	al,$11[bp]
36235 A2AA           8846         12            mov	$12[bp],al
36236                                           !BCC_EOS
36237                                           ! 5284       iret_addr.flags.u.r8.flagsl &= 0xfe;
36238                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36239 A2AD           8A46         1A            mov	al,$1A[bp]
36240 A2B0           24                     FE  and	al,#$FE
36241 A2B2           8846         1A            mov	$1A[bp],al
36242                                           !BCC_EOS
36243                                           ! 5285       break;
36244 A2B5           E9         0292            br 	.723
36245                                           !BCC_EOS
36246                                           ! 5286     case 3:
36247                                           ! 5287       if (rtc_updating()) {
36248                       0000A2B8            .72B:
36249                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36250 A2B8           E8         6305            call	_rtc_updating
36251 A2BB           85C0                       test	ax,ax
36252 A2BD           74           03            je  	.72C
36253                       0000A2BF            .72D:
36254                                           ! 5288         init_rtc();
36255                                           ! Debug: func () void = init_rtc+0 (used reg = )
36256 A2BF           E8         62CD            call	_init_rtc
36257                                           !BCC_EOS
36258                                           ! 5289         }
36259                                           ! 5290       outb_cmos(0x00, regs.u.r8.dh);
36260                       0000A2C2            .72C:
36261                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36262 A2C2           8A46         0F            mov	al,$F[bp]
36263 A2C5           30E4                       xor	ah,ah
36264 A2C7           50                         push	ax
36265                                           ! Debug: list int = const 0 (used reg = )
36266 A2C8           31C0                       xor	ax,ax
36267 A2CA           50                         push	ax
36268                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36269 A2CB           E8         62A6            call	_outb_cmos
36270 A2CE           83C4                   04  add	sp,*4
36271                                           !BCC_EOS
36272                                           ! 5291       outb_cmos(0x02, regs.u.r8.cl);
36273                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36274 A2D1           8A46         10            mov	al,$10[bp]
36275 A2D4           30E4                       xor	ah,ah
36276 A2D6           50                         push	ax
36277                                           ! Debug: list int = const 2 (used reg = )
36278 A2D7           B8                   0002  mov	ax,*2
36279 A2DA           50                         push	ax
36280                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36281 A2DB           E8         6296            call	_outb_cmos
36282 A2DE           83C4                   04  add	sp,*4
36283                                           !BCC_EOS
36284                                           ! 5292       outb_cmos(0x04, regs.u.r8.ch);
36285                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36286 A2E1           8A46         11            mov	al,$11[bp]
36287 A2E4           30E4                       xor	ah,ah
36288 A2E6           50                         push	ax
36289                                           ! Debug: list int = const 4 (used reg = )
36290 A2E7           B8                   0004  mov	ax,*4
36291 A2EA           50                         push	ax
36292                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36293 A2EB           E8         6286            call	_outb_cmos
36294 A2EE           83C4                   04  add	sp,*4
36295                                           !BCC_EOS
36296                                           ! 5293       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
36297                                           ! Debug: expression subtree swapping
36298                                           ! Debug: list int = const $B (used reg = )
36299 A2F1           B8                   000B  mov	ax,*$B
36300 A2F4           50                         push	ax
36301                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36302 A2F5           E8         628B            call	_inb_cmos
36303 A2F8           44                         inc	sp
36304 A2F9           44                         inc	sp
36305                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
36306 A2FA           24                     60  and	al,*$60
36307                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
36308 A2FC           0C                     02  or	al,*2
36309 A2FE           50                         push	ax
36310                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
36311 A2FF           8A46         0E            mov	al,$E[bp]
36312 A302           24                     01  and	al,*1
36313                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
36314 A304           0A46         FC            or	al,0+..FFDA[bp]
36315 A307           44                         inc	sp
36316 A308           44                         inc	sp
36317                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36318 A309           8846         FF            mov	-1[bp],al
36319                                           !BCC_EOS
36320                                           ! 5294       outb_cmos(0x0b, val8);
36321                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
36322 A30C           8A46         FF            mov	al,-1[bp]
36323 A30F           30E4                       xor	ah,ah
36324 A311           50                         push	ax
36325                                           ! Debug: list int = const $B (used reg = )
36326 A312           B8                   000B  mov	ax,*$B
36327 A315           50                         push	ax
36328                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36329 A316           E8         625B            call	_outb_cmos
36330 A319           83C4                   04  add	sp,*4
36331                                           !BCC_EOS
36332                                           ! 5295       regs.u.r8.ah = 0;
36333                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36334 A31C           30C0                       xor	al,al
36335 A31E           8846         13            mov	$13[bp],al
36336                                           !BCC_EOS
36337                                           ! 5296       regs.u.r8.al = val8;
36338                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36339 A321           8A46         FF            mov	al,-1[bp]
36340 A324           8846         12            mov	$12[bp],al
36341                                           !BCC_EOS
36342                                           ! 5297       iret_addr.flags.u.r8.flagsl &= 0xfe;
36343                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36344 A327           8A46         1A            mov	al,$1A[bp]
36345 A32A           24                     FE  and	al,#$FE
36346 A32C           8846         1A            mov	$1A[bp],al
36347                                           !BCC_EOS
36348                                           ! 5298       break;
36349 A32F           E9         0218            br 	.723
36350                                           !BCC_EOS
36351                                           ! 5299     case 4:
36352                                           ! 5300       regs.u.r8.ah = 0;
36353                       0000A332            .72E:
36354                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36355 A332           30C0                       xor	al,al
36356 A334           8846         13            mov	$13[bp],al
36357                                           !BCC_EOS
36358                                           ! 5301       if (rtc_updating()) {
36359                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36360 A337           E8         6286            call	_rtc_updating
36361 A33A           85C0                       test	ax,ax
36362 A33C           74           0B            je  	.72F
36363                       0000A33E            .730:
36364                                           ! 5302         iret_addr.flags.u.r8.flagsl |= 0x01;
36365                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36366 A33E           8A46         1A            mov	al,$1A[bp]
36367 A341           0C                     01  or	al,*1
36368 A343           8846         1A            mov	$1A[bp],al
36369                                           !BCC_EOS
36370                                           ! 5303         break;
36371 A346           E9         0201            br 	.723
36372                                           !BCC_EOS
36373                                           ! 5304         }
36374                                           ! 5305       regs.u.r8.cl = inb_cmos(0x09);
36375                       0000A349            .72F:
36376                                           ! Debug: list int = const 9 (used reg = )
36377 A349           B8                   0009  mov	ax,*9
36378 A34C           50                         push	ax
36379                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36380 A34D           E8         6233            call	_inb_cmos
36381 A350           44                         inc	sp
36382 A351           44                         inc	sp
36383                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
36384 A352           8846         10            mov	$10[bp],al
36385                                           !BCC_EOS
36386                                           ! 5306       regs.u.r8.dh = inb_cmos(0x08);
36387                                           ! Debug: list int = const 8 (used reg = )
36388 A355           B8                   0008  mov	ax,*8
36389 A358           50                         push	ax
36390                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36391 A359           E8         6227            call	_inb_cmos
36392 A35C           44                         inc	sp
36393 A35D           44                         inc	sp
36394                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
36395 A35E           8846         0F            mov	$F[bp],al
36396                                           !BCC_EOS
36397                                           ! 5307       regs.u.r8.dl = inb_cmos(0x07);
36398                                           ! Debug: list int = const 7 (used reg = )
36399 A361           B8                   0007  mov	ax,*7
36400 A364           50                         push	ax
36401                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36402 A365           E8         621B            call	_inb_cmos
36403 A368           44                         inc	sp
36404 A369           44                         inc	sp
36405                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
36406 A36A           8846         0E            mov	$E[bp],al
36407                                           !BCC_EOS
36408                                           ! 5308       regs.u.r8.ch = inb_cmos(0x32);
36409                                           ! Debug: list int = const $32 (used reg = )
36410 A36D           B8                   0032  mov	ax,*$32
36411 A370           50                         push	ax
36412                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36413 A371           E8         620F            call	_inb_cmos
36414 A374           44                         inc	sp
36415 A375           44                         inc	sp
36416                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
36417 A376           8846         11            mov	$11[bp],al
36418                                           !BCC_EOS
36419                                           ! 5309       regs.u.r8.al = regs.u.r8.ch;
36420                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
36421 A379           8A46         11            mov	al,$11[bp]
36422 A37C           8846         12            mov	$12[bp],al
36423                                           !BCC_EOS
36424                                           ! 5310       iret_addr.flags.u.r8.flagsl &= 0xfe;
36425                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36426 A37F           8A46         1A            mov	al,$1A[bp]
36427 A382           24                     FE  and	al,#$FE
36428 A384           8846         1A            mov	$1A[bp],al
36429                                           !BCC_EOS
36430                                           ! 5311       break;
36431 A387           E9         01C0            br 	.723
36432                                           !BCC_EOS
36433                                           ! 5312     case 5:
36434                                           ! 5313       if (rtc_updating()) {
36435                       0000A38A            .731:
36436                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36437 A38A           E8         6233            call	_rtc_updating
36438 A38D           85C0                       test	ax,ax
36439 A38F           74           0E            je  	.732
36440                       0000A391            .733:
36441                                           ! 5314         init_rtc();
36442                                           ! Debug: func () void = init_rtc+0 (used reg = )
36443 A391           E8         61FB            call	_init_rtc
36444                                           !BCC_EOS
36445                                           ! 5315         iret_addr.flags.u.r8.flagsl |
36446                                           ! 5315 = 0x01;
36447                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36448 A394           8A46         1A            mov	al,$1A[bp]
36449 A397           0C                     01  or	al,*1
36450 A399           8846         1A            mov	$1A[bp],al
36451                                           !BCC_EOS
36452                                           ! 5316         break;
36453 A39C           E9         01AB            br 	.723
36454                                           !BCC_EOS
36455                                           ! 5317         }
36456                                           ! 5318       outb_cmos(0x09, regs.u.r8.cl);
36457                       0000A39F            .732:
36458                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36459 A39F           8A46         10            mov	al,$10[bp]
36460 A3A2           30E4                       xor	ah,ah
36461 A3A4           50                         push	ax
36462                                           ! Debug: list int = const 9 (used reg = )
36463 A3A5           B8                   0009  mov	ax,*9
36464 A3A8           50                         push	ax
36465                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36466 A3A9           E8         61C8            call	_outb_cmos
36467 A3AC           83C4                   04  add	sp,*4
36468                                           !BCC_EOS
36469                                           ! 5319       outb_cmos(0x08, regs.u.r8.dh);
36470                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36471 A3AF           8A46         0F            mov	al,$F[bp]
36472 A3B2           30E4                       xor	ah,ah
36473 A3B4           50                         push	ax
36474                                           ! Debug: list int = const 8 (used reg = )
36475 A3B5           B8                   0008  mov	ax,*8
36476 A3B8           50                         push	ax
36477                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36478 A3B9           E8         61B8            call	_outb_cmos
36479 A3BC           83C4                   04  add	sp,*4
36480                                           !BCC_EOS
36481                                           ! 5320       outb_cmos(0x07, regs.u.r8.dl);
36482                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
36483 A3BF           8A46         0E            mov	al,$E[bp]
36484 A3C2           30E4                       xor	ah,ah
36485 A3C4           50                         push	ax
36486                                           ! Debug: list int = const 7 (used reg = )
36487 A3C5           B8                   0007  mov	ax,*7
36488 A3C8           50                         push	ax
36489                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36490 A3C9           E8         61A8            call	_outb_cmos
36491 A3CC           83C4                   04  add	sp,*4
36492                                           !BCC_EOS
36493                                           ! 5321       outb_cmos(0x32, regs.u.r8.ch);
36494                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36495 A3CF           8A46         11            mov	al,$11[bp]
36496 A3D2           30E4                       xor	ah,ah
36497 A3D4           50                         push	ax
36498                                           ! Debug: list int = const $32 (used reg = )
36499 A3D5           B8                   0032  mov	ax,*$32
36500 A3D8           50                         push	ax
36501                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36502 A3D9           E8         6198            call	_outb_cmos
36503 A3DC           83C4                   04  add	sp,*4
36504                                           !BCC_EOS
36505                                           ! 5322       val8 = inb_cmos(0x0b) & 0x7f;
36506                                           ! Debug: list int = const $B (used reg = )
36507 A3DF           B8                   000B  mov	ax,*$B
36508 A3E2           50                         push	ax
36509                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36510 A3E3           E8         619D            call	_inb_cmos
36511 A3E6           44                         inc	sp
36512 A3E7           44                         inc	sp
36513                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
36514 A3E8           24                     7F  and	al,*$7F
36515                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36516 A3EA           8846         FF            mov	-1[bp],al
36517                                           !BCC_EOS
36518                                           ! 5323       outb_cmos(0x0b, val8);
36519                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
36520 A3ED           8A46         FF            mov	al,-1[bp]
36521 A3F0           30E4                       xor	ah,ah
36522 A3F2           50                         push	ax
36523                                           ! Debug: list int = const $B (used reg = )
36524 A3F3           B8                   000B  mov	ax,*$B
36525 A3F6           50                         push	ax
36526                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36527 A3F7           E8         617A            call	_outb_cmos
36528 A3FA           83C4                   04  add	sp,*4
36529                                           !BCC_EOS
36530                                           ! 5324       regs.u.r8.ah = 0;
36531                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36532 A3FD           30C0                       xor	al,al
36533 A3FF           8846         13            mov	$13[bp],al
36534                                           !BCC_EOS
36535                                           ! 5325       regs.u.r8.al = val8;
36536                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36537 A402           8A46         FF            mov	al,-1[bp]
36538 A405           8846         12            mov	$12[bp],al
36539                                           !BCC_EOS
36540                                           ! 5326       iret_addr.flags.u.r8.flagsl &= 0xfe;
36541                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36542 A408           8A46         1A            mov	al,$1A[bp]
36543 A40B           24                     FE  and	al,#$FE
36544 A40D           8846         1A            mov	$1A[bp],al
36545                                           !BCC_EOS
36546                                           ! 5327       break;
36547 A410           E9         0137            br 	.723
36548                                           !BCC_EOS
36549                                           ! 5328     case 6:
36550                                           ! 5329       val8 = inb_cmos(0x0b);
36551                       0000A413            .734:
36552                                           ! Debug: list int = const $B (used reg = )
36553 A413           B8                   000B  mov	ax,*$B
36554 A416           50                         push	ax
36555                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36556 A417           E8         6169            call	_inb_cmos
36557 A41A           44                         inc	sp
36558 A41B           44                         inc	sp
36559                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36560 A41C           8846         FF            mov	-1[bp],al
36561                                           !BCC_EOS
36562                                           ! 5330       regs.u.r16.ax = 0;
36563                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
36564 A41F           31C0                       xor	ax,ax
36565 A421           8946         12            mov	$12[bp],ax
36566                                           !BCC_EOS
36567                                           ! 5331       if (val8 & 0x20) {
36568                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
36569 A424           8A46         FF            mov	al,-1[bp]
36570 A427           24                     20  and	al,*$20
36571 A429           84C0                       test	al,al
36572 A42B           74           0B            je  	.735
36573                       0000A42D            .736:
36574                                           ! 5332         iret_addr.flags.u.r8.flagsl |= 0x01;
36575                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36576 A42D           8A46         1A            mov	al,$1A[bp]
36577 A430           0C                     01  or	al,*1
36578 A432           8846         1A            mov	$1A[bp],al
36579                                           !BCC_EOS
36580                                           ! 5333         break;
36581 A435           E9         0112            br 	.723
36582                                           !BCC_EOS
36583                                           ! 5334         }
36584                                           ! 5335       if (rtc_updating()) {
36585                       0000A438            .735:
36586                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36587 A438           E8         6185            call	_rtc_updating
36588 A43B           85C0                       test	ax,ax
36589 A43D           74           03            je  	.737
36590                       0000A43F            .738:
36591                                           ! 5336         init_rtc();
36592                                           ! Debug: func () void = init_rtc+0 (used reg = )
36593 A43F           E8         614D            call	_init_rtc
36594                                           !BCC_EOS
36595                                           ! 5337         }
36596                                           ! 5338       outb_cmos(0x01, regs.u.r8.dh);
36597                       0000A442            .737:
36598                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36599 A442           8A46         0F            mov	al,$F[bp]
36600 A445           30E4                       xor	ah,ah
36601 A447           50                         push	ax
36602                                           ! Debug: list int = const 1 (used reg = )
36603 A448           B8                   0001  mov	ax,*1
36604 A44B           50                         push	ax
36605                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36606 A44C           E8         6125            call	_outb_cmos
36607 A44F           83C4                   04  add	sp,*4
36608                                           !BCC_EOS
36609                                           ! 5339       outb_cmos(0x03, regs.u.r8.cl);
36610                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36611 A452           8A46         10            mov	al,$10[bp]
36612 A455           30E4                       xor	ah,ah
36613 A457           50                         push	ax
36614                                           ! Debug: list int = const 3 (used reg = )
36615 A458           B8                   0003  mov	ax,*3
36616 A45B           50                         push	ax
36617                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36618 A45C           E8         6115            call	_outb_cmos
36619 A45F           83C4                   04  add	sp,*4
36620                                           !BCC_EOS
36621                                           ! 5340       outb_cmos(0x05, regs.u.r8.ch);
36622                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36623 A462           8A46         11            mov	al,$11[bp]
36624 A465           30E4                       xor	ah,ah
36625 A467           50                         push	ax
36626                                           ! Debug: list int = const 5 (used reg = )
36627 A468           B8                   0005  mov	ax,*5
36628 A46B           50                         push	ax
36629                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36630 A46C           E8         6105            call	_outb_cmos
36631 A46F           83C4                   04  add	sp,*4
36632                                           !BCC_EOS
36633                                           ! 5341       outb(0xa1, inb(0xa1) & 0xfe);
36634                                           ! Debug: list int = const $A1 (used reg = )
36635 A472           B8                   00A1  mov	ax,#$A1
36636 A475           50                         push	ax
36637                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36638 A476           E8         60C5            call	_inb
36639 A479           44                         inc	sp
36640 A47A           44                         inc	sp
36641                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
36642 A47B           24                     FE  and	al,#$FE
36643                                           ! Debug: list unsigned char = al+0 (used reg = )
36644 A47D           30E4                       xor	ah,ah
36645 A47F           50                         push	ax
36646                                           ! Debug: list int = const $A1 (used reg = )
36647 A480           B8                   00A1  mov	ax,#$A1
36648 A483           50                         push	ax
36649                                           ! Debug: func () void = outb+0 (used reg = )
36650 A484           E8         60CD            call	_outb
36651 A487           83C4                   04  add	sp,*4
36652                                           !BCC_EOS
36653                                           ! 5342       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
36654                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
36655 A48A           8A46         FF            mov	al,-1[bp]
36656 A48D           24                     7F  and	al,*$7F
36657                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
36658 A48F           0C                     20  or	al,*$20
36659                                           ! Debug: list unsigned char = al+0 (used reg = )
36660 A491           30E4                       xor	ah,ah
36661 A493           50                         push	ax
36662                                           ! Debug: list int = const $B (used reg = )
36663 A494           B8                   000B  mov	ax,*$B
36664 A497           50                         push	ax
36665                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36666 A498           E8         60D9            call	_outb_cmos
36667 A49B           83C4                   04  add	sp,*4
36668                                           !BCC_EOS
36669                                           ! 5343       iret_addr.flags.u.r8.flagsl &= 0xfe;
36670                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36671 A49E           8A46         1A            mov	al,$1A[bp]
36672 A4A1           24                     FE  and	al,#$FE
36673 A4A3           8846         1A            mov	$1A[bp],al
36674                                           !BCC_EOS
36675                                           ! 5344       break;
36676 A4A6           E9         00A1            br 	.723
36677                                           !BCC_EOS
36678                                           ! 5345     case 7:
36679                                           ! 5346       val8 = inb_cmos(0x0b);
36680                       0000A4A9            .739:
36681                                           ! Debug: list int = const $B (used reg = )
36682 A4A9           B8                   000B  mov	ax,*$B
36683 A4AC           50                         push	ax
36684                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36685 A4AD           E8         60D3            call	_inb_cmos
36686 A4B0           44                         inc	sp
36687 A4B1           44                         inc	sp
36688                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36689 A4B2           8846         FF            mov	-1[bp],al
36690                                           !BCC_EOS
36691                                           ! 5347       outb_cmos(0x0b, val8 & 0x57);
36692                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
36693 A4B5           8A46         FF            mov	al,-1[bp]
36694 A4B8           24                     57  and	al,*$57
36695                                           ! Debug: list unsigned char = al+0 (used reg = )
36696 A4BA           30E4                       xor	ah,ah
36697 A4BC           50                         push	ax
36698                                           ! Debug: list int = const $B (used reg = )
36699 A4BD           B8                   000B  mov	ax,*$B
36700 A4C0           50                         push	ax
36701                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36702 A4C1           E8         60B0            call	_outb_cmos
36703 A4C4           83C4                   04  add	sp,*4
36704                                           !BCC_EOS
36705                                           ! 5348       regs.u.r8.ah = 0;
36706                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36707 A4C7           30C0                       xor	al,al
36708 A4C9           8846         13            mov	$13[bp],al
36709                                           !BCC_EOS
36710                                           ! 5349       regs.u.r8.al = val8;
36711                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36712 A4CC           8A46         FF            mov	al,-1[bp]
36713 A4CF           8846         12            mov	$12[bp],al
36714                                           !BCC_EOS
36715                                           ! 5350       iret_addr.flags.u.r8.flagsl &= 0xfe;
36716                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36717 A4D2           8A46         1A            mov	al,$1A[bp]
36718 A4D5           24                     FE  and	al,#$FE
36719 A4D7           8846         1A            mov	$1A[bp],al
36720                                           !BCC_EOS
36721                                           ! 5351       break;
36722 A4DA           EB           6E            jmp .723
36723                                           !BCC_EOS
36724                                           ! 5352     case 0xb1:
36725                                           ! 5353       if (regs.u.r8.bl == 0xff) {
36726                       0000A4DC            .73A:
36727                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
36728 A4DC           8A46         0C            mov	al,$C[bp]
36729 A4DF           3C                     FF  cmp	al,#$FF
36730 A4E1           75           02            jne 	.73B
36731                       0000A4E3            .73C:
36732                                           ! 5354         ;
36733                                           !BCC_EOS
36734                                           ! 5355       } else if (regs.u.r8.bl == 0x81) {
36735 A4E3           EB           22            jmp .73D
36736                       0000A4E5            .73B:
36737                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
36738 A4E5           8A46         0C            mov	al,$C[bp]
36739 A4E8           3C                     81  cmp	al,#$81
36740 A4EA           75           02            jne 	.73E
36741                       0000A4EC            .73F:
36742                                           ! 5356         ;
36743                                           !BCC_EOS
36744                                           ! 5357       } else if (regs.u.r8.bl == 0x83) {
36745 A4EC           EB           19            jmp .740
36746                       0000A4EE            .73E:
36747                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
36748 A4EE           8A46         0C            mov	al,$C[bp]
36749 A4F1           3C                     83  cmp	al,#$83
36750 A4F3           75           02            jne 	.741
36751                       0000A4F5            .742:
36752                                           ! 5358         ;
36753                                           !BCC_EOS
36754                                           ! 5359       } else if (regs.u.r8.bl == 0x86) {
36755 A4F5           EB           10            jmp .743
36756                       0000A4F7            .741:
36757                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
36758 A4F7           8A46         0C            mov	al,$C[bp]
36759 A4FA           3C                     86  cmp	al,#$86
36760 A4FC           75           09            jne 	.744
36761                       0000A4FE            .745:
36762                                           ! 5360         if (regs.u.r8.al == 0x02) {
36763                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
36764 A4FE           8A46         12            mov	al,$12[bp]
36765 A501           3C                     02  cmp	al,*2
36766 A503           75           02            jne 	.746
36767                       0000A505            .747:
36768                                           ! 5361           ;
36769                                           !BCC_EOS
36770                                           ! 5362         } else {
36771 A505           EB           00            jmp .748
36772                       0000A507            .746:
36773                                           ! 5363           ;
36774                                           !BCC_EOS
36775                                           ! 5364         }
36776                                           ! 5365       }
36777                       0000A507            .748:
36778                                           ! 5366       regs.u.r8.ah = regs.u.r8.bl;
36779                       0000A507            .744:
36780                       0000A507            .743:
36781                       0000A507            .740:
36782                       0000A507            .73D:
36783                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
36784 A507           8A46         0C            mov	al,$C[bp]
36785 A50A           8846         13            mov	$13[bp],al
36786                                           !BCC_EOS
36787                                           ! 5367       iret_addr.flags.u.r8.flagsl |= 0x01;
36788                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36789 A50D           8A46         1A            mov	al,$1A[bp]
36790 A510           0C                     01  or	al,*1
36791 A512           8846         1A            mov	$1A[bp],al
36792                                           !BCC_EOS
36793                                           ! 5368       break;
36794 A515           EB           33            jmp .723
36795                                           !BCC_EOS
36796                                           ! 5369     default:
36797                                           ! 5370       iret_addr.flags.u.r8.flagsl |= 0x01;
36798                       0000A517            .749:
36799                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36800 A517           8A46         1A            mov	al,$1A[bp]
36801 A51A           0C                     01  or	al,*1
36802 A51C           8846         1A            mov	$1A[bp],al
36803                                           !BCC_EOS
36804                                           ! 5371     }
36805                                           ! 5372 }
36806 A51F           EB           29            jmp .723
36807                       0000A521            .725:
36808 A521           2C                     00  sub	al,*0
36809 A523           72           F2            jb 	.749
36810 A525           3C                     07  cmp	al,*7
36811 A527           77           1B            ja  	.74A
36812 A529           30E4                       xor	ah,ah
36813 A52B           D1E0                       shl	ax,*1
36814 A52D           89C3                       mov	bx,ax
36815 A52F           2E                         seg	cs
36816 A530           FFA7       A534            br	.74B[bx]
36817                       0000A534            .74B:
36818 A534                      A218            .word	.726
36819 A536                      A23C            .word	.727
36820 A538                      A25F            .word	.728
36821 A53A                      A2B8            .word	.72B
36822 A53C                      A332            .word	.72E
36823 A53E                      A38A            .word	.731
36824 A540                      A413            .word	.734
36825 A542                      A4A9            .word	.739
36826                       0000A544            .74A:
36827 A544           2C                     B1  sub	al,#$B1
36828 A546           74           94            je 	.73A
36829 A548           EB           CD            jmp	.749
36830                       0000A54A            .723:
36831                       FFFFFFFC            ..FFDA	=	-4
36832 A54A           89EC                       mov	sp,bp
36833 A54C           5D                         pop	bp
36834 A54D           C3                         ret
36835                                           ! 5373   void
36836                                           ! 5374 int70_function(regs, ds, iret_addr)
36837                                           ! 5375   pusha_regs_t regs;
36838                                           export	_int70_function
36839                       0000A54E            _int70_function:
36840                                           !BCC_EOS
36841                                           ! 5376   Bit16u ds;
36842                                           !BCC_EOS
36843                                           ! 5377   iret_addr_t iret_addr;
36844                                           !BCC_EOS
36845                                           ! 5378 {
36846                                           ! 5379   Bit8u registerB = 0, registerC = 0;
36847 A54E           55                         push	bp
36848 A54F           89E5                       mov	bp,sp
36849 A551           4C                         dec	sp
36850                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
36851 A552           30C0                       xor	al,al
36852 A554           8846         FF            mov	-1[bp],al
36853 A557           4C                         dec	sp
36854                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
36855 A558           30C0                       xor	al,al
36856 A55A           8846         FE            mov	-2[bp],al
36857                                           !BCC_EOS
36858                                           ! 5380   registerB = inb_cmos( 0xB );
36859                                           ! Debug: list int = const $B (used reg = )
36860 A55D           B8                   000B  mov	ax,*$B
36861 A560           50                         push	ax
36862                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36863 A561           E8         601F            call	_inb_cmos
36864 A564           44                         inc	sp
36865 A565           44                         inc	sp
36866                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
36867 A566           8846         FF            mov	-1[bp],al
36868                                           !BCC_EOS
36869                                           ! 5381   registerC = inb_cmos( 0xC );
36870                                           ! Debug: list int = const $C (used reg = )
36871 A569           B8                   000C  mov	ax,*$C
36872 A56C           50                         push	ax
36873                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36874 A56D           E8         6013            call	_inb_cmos
36875 A570           44                         inc	sp
36876 A571           44                         inc	sp
36877                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
36878 A572           8846         FE            mov	-2[bp],al
36879                                           !BCC_EOS
36880                                           ! 5382   if( ( registerB & 0x60 ) != 0 ) {
36881                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
36882 A575           8A46         FF            mov	al,-1[bp]
36883 A578           24                     60  and	al,*$60
36884                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
36885 A57A           84C0                       test	al,al
36886 A57C         0F84         00EF            beq 	.74C
36887                       0000A580            .74D:
36888                                           ! 5383     if( ( registerC & 0x20 ) != 0 ) {
36889                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
36890 A580           8A46         FE            mov	al,-2[bp]
36891 A583           24                     20  and	al,*$20
36892                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
36893 A585           84C0                       test	al,al
36894 A587           74           04            je  	.74E
36895                       0000A589            .74F:
36896                                           ! 5384 #asm
36897                                           !BCC_EOS
36898                                           !BCC_ASM
36899                       00000000            _int70_function.registerC	set	0
36900                       FFFFFFFE            .int70_function.registerC	set	-2
36901                       00000016            _int70_function.ds	set	$16
36902                       00000014            .int70_function.ds	set	$14
36903                       00000001            _int70_function.registerB	set	1
36904                       FFFFFFFF            .int70_function.registerB	set	-1
36905                       00000018            _int70_function.iret_addr	set	$18
36906                       00000016            .int70_function.iret_addr	set	$16
36907                       00000006            _int70_function.regs	set	6
36908                       00000004            .int70_function.regs	set	4
36909 A589           FB                               sti
36910 A58A           CD                     4A        int #0x4a
36911 A58C           FA                               cli
36912                                           ! 5388 endasm
36913                                           !BCC_ENDASM
36914                                           !BCC_EOS
36915                                           ! 5389     }
36916                                           ! 5390     if( ( registerC & 0x40 ) != 0 ) {
36917                       0000A58D            .74E:
36918                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
36919 A58D           8A46         FE            mov	al,-2[bp]
36920 A590           24                     40  and	al,*$40
36921                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
36922 A592           84C0                       test	al,al
36923 A594         0F84         00D7            beq 	.750
36924                       0000A598            .751:
36925                                           ! 5391       if( read_byte( 0x40, 0xA0 ) != 0 ) {
36926                                           ! Debug: list int = const $A0 (used reg = )
36927 A598           B8                   00A0  mov	ax,#$A0
36928 A59B           50                         push	ax
36929                                           ! Debug: list int = const $40 (used reg = )
36930 A59C           B8                   0040  mov	ax,*$40
36931 A59F           50                         push	ax
36932                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
36933 A5A0           E8         6051            call	_read_byte
36934 A5A3           83C4                   04  add	sp,*4
36935                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
36936 A5A6           84C0                       test	al,al
36937 A5A8         0F84         00C3            beq 	.752
36938                       0000A5AC            .753:
36939                                           ! 5392         Bit32u time, toggle;
36940                                           !BCC_EOS
36941                                           ! 5393         time = read_dword( 0x40, 0x9C );
36942 A5AC           83C4                   F8  add	sp,*-8
36943                                           ! Debug: list int = const $9C (used reg = )
36944 A5AF           B8                   009C  mov	ax,#$9C
36945 A5B2           50                         push	ax
36946                                           ! Debug: list int = const $40 (used reg = )
36947 A5B3           B8                   0040  mov	ax,*$40
36948 A5B6           50                         push	ax
36949                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
36950 A5B7           E8         5AC9            call	_read_dword
36951 A5BA           89D3                       mov	bx,dx
36952 A5BC           83C4                   04  add	sp,*4
36953                                           ! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
36954 A5BF           8946         FA            mov	-6[bp],ax
36955 A5C2           895E         FC            mov	-4[bp],bx
36956                                           !BCC_EOS
36957                                           ! 5394         if( time < 0x3D1 ) {
36958                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
36959 A5C5           B8                   03D1  mov	ax,#$3D1
36960 A5C8           31DB                       xor	bx,bx
36961 A5CA           8D7E         FA            lea	di,-6[bp]
36962 A5CD           E8         5AFB            call	lcmpul
36963 A5D0           76           6A            jbe 	.754
36964                       0000A5D2            .755:
36965                                           ! 5395           Bit16u segment, offset;
36966                                           !BCC_EOS
36967                                           ! 5396           segment = read_word( 0x40, 0x98 );
36968 A5D2           83C4                   FC  add	sp,*-4
36969                                           ! Debug: list int = const $98 (used reg = )
36970 A5D5           B8                   0098  mov	ax,#$98
36971 A5D8           50                         push	ax
36972                                           ! Debug: list int = const $40 (used reg = )
36973 A5D9           B8                   0040  mov	ax,*$40
36974 A5DC           50                         push	ax
36975                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36976 A5DD           E8         6027            call	_read_word
36977 A5E0           83C4                   04  add	sp,*4
36978                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
36979 A5E3           8946         F4            mov	-$C[bp],ax
36980                                           !BCC_EOS
36981                                           ! 5397 
36982                                           ! 5397           offset = read_word( 0x40, 0x9A );
36983                                           ! Debug: list int = const $9A (used reg = )
36984 A5E6           B8                   009A  mov	ax,#$9A
36985 A5E9           50                         push	ax
36986                                           ! Debug: list int = const $40 (used reg = )
36987 A5EA           B8                   0040  mov	ax,*$40
36988 A5ED           50                         push	ax
36989                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36990 A5EE           E8         6016            call	_read_word
36991 A5F1           83C4                   04  add	sp,*4
36992                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
36993 A5F4           8946         F2            mov	-$E[bp],ax
36994                                           !BCC_EOS
36995                                           ! 5398           write_byte( 0x40, 0xA0, 0 );
36996                                           ! Debug: list int = const 0 (used reg = )
36997 A5F7           31C0                       xor	ax,ax
36998 A5F9           50                         push	ax
36999                                           ! Debug: list int = const $A0 (used reg = )
37000 A5FA           B8                   00A0  mov	ax,#$A0
37001 A5FD           50                         push	ax
37002                                           ! Debug: list int = const $40 (used reg = )
37003 A5FE           B8                   0040  mov	ax,*$40
37004 A601           50                         push	ax
37005                                           ! Debug: func () void = write_byte+0 (used reg = )
37006 A602           E8         6015            call	_write_byte
37007 A605           83C4                   06  add	sp,*6
37008                                           !BCC_EOS
37009                                           ! 5399           outb_cmos( 0xB, registerB & 0x37 );
37010                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
37011 A608           8A46         FF            mov	al,-1[bp]
37012 A60B           24                     37  and	al,*$37
37013                                           ! Debug: list unsigned char = al+0 (used reg = )
37014 A60D           30E4                       xor	ah,ah
37015 A60F           50                         push	ax
37016                                           ! Debug: list int = const $B (used reg = )
37017 A610           B8                   000B  mov	ax,*$B
37018 A613           50                         push	ax
37019                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37020 A614           E8         5F5D            call	_outb_cmos
37021 A617           83C4                   04  add	sp,*4
37022                                           !BCC_EOS
37023                                           ! 5400           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
37024                                           ! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
37025 A61A           FF76         F2            push	-$E[bp]
37026                                           ! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
37027 A61D           FF76         F4            push	-$C[bp]
37028                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37029 A620           E8         5FD1            call	_read_byte
37030 A623           83C4                   04  add	sp,*4
37031                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
37032 A626           0C                     80  or	al,#$80
37033                                           ! Debug: list unsigned char = al+0 (used reg = )
37034 A628           30E4                       xor	ah,ah
37035 A62A           50                         push	ax
37036                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
37037 A62B           FF76         F2            push	-$E[bp]
37038                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
37039 A62E           FF76         F4            push	-$C[bp]
37040                                           ! Debug: func () void = write_byte+0 (used reg = )
37041 A631           E8         5FE6            call	_write_byte
37042 A634           83C4                   06  add	sp,*6
37043                                           !BCC_EOS
37044                                           ! 5401         } else {
37045 A637           83C4                   04  add	sp,*4
37046 A63A           EB           30            jmp .756
37047                       0000A63C            .754:
37048                                           ! 5402           time -= 0x3D1;
37049                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
37050 A63C           B8                   03D1  mov	ax,#$3D1
37051 A63F           31DB                       xor	bx,bx
37052 A641           53                         push	bx
37053 A642           50                         push	ax
37054 A643           8B46         FA            mov	ax,-6[bp]
37055 A646           8B5E         FC            mov	bx,-4[bp]
37056 A649           8D7E         F2            lea	di,-$E[bp]
37057 A64C           E8         5A92            call	lsubul
37058 A64F           8946         FA            mov	-6[bp],ax
37059 A652           895E         FC            mov	-4[bp],bx
37060 A655           83C4                   04  add	sp,*4
37061                                           !BCC_EOS
37062                                           ! 5403           write_dword( 0x40, 0x9C, time );
37063                                           ! Debug: list unsigned long time = [S+$C-8] (used reg = )
37064 A658           FF76         FC            push	-4[bp]
37065 A65B           FF76         FA            push	-6[bp]
37066                                           ! Debug: list int = const $9C (used reg = )
37067 A65E           B8                   009C  mov	ax,#$9C
37068 A661           50                         push	ax
37069                                           ! Debug: list int = const $40 (used reg = )
37070 A662           B8                   0040  mov	ax,*$40
37071 A665           50                         push	ax
37072                                           ! Debug: func () void = write_dword+0 (used reg = )
37073 A666           E8         5A32            call	_write_dword
37074 A669           83C4                   08  add	sp,*8
37075                                           !BCC_EOS
37076                                           ! 5404         }
37077                                           ! 5405       }
37078                       0000A66C            .756:
37079 A66C           83C4                   08  add	sp,*8
37080                                           ! 5406     }
37081                       0000A66F            .752:
37082                                           ! 5407   }
37083                       0000A66F            .750:
37084                                           ! 5408 #asm
37085                       0000A66F            .74C:
37086                                           !BCC_EOS
37087                                           !BCC_ASM
37088                       00000000            _int70_function.registerC	set	0
37089                       FFFFFFFE            .int70_function.registerC	set	-2
37090                       00000016            _int70_function.ds	set	$16
37091                       00000014            .int70_function.ds	set	$14
37092                       00000001            _int70_function.registerB	set	1
37093                       FFFFFFFF            .int70_function.registerB	set	-1
37094                       00000018            _int70_function.iret_addr	set	$18
37095                       00000016            .int70_function.iret_addr	set	$16
37096                       00000006            _int70_function.regs	set	6
37097                       00000004            .int70_function.regs	set	4
37098 A66F           E8         03FC              call eoi_both_pics
37099                                           ! 5410 endasm
37100                                           !BCC_ENDASM
37101                                           !BCC_EOS
37102                                           ! 5411 }
37103 A672           89EC                       mov	sp,bp
37104 A674           5D                         pop	bp
37105 A675           C3                         ret
37106                                           ! 5412 #asm
37107                                           !BCC_ASM
37108                       00000012            _int70_function.ds	set	$12
37109                       00000014            _int70_function.iret_addr	set	$14
37110                       00000002            _int70_function.regs	set	2
37111                                           ;------------------------------------------
37112                                           ;- INT74h : PS/2 mouse hardware interrupt -
37113                                           ;------------------------------------------
37114                       0000A676            int74_handler:
37115 A676           FB                           sti
37116 A677           60                           pusha
37117 A678           1E                           push ds ;; save DS
37118 A679           6A                     00    push #0x00 ;; placeholder for status
37119 A67B           6A                     00    push #0x00 ;; placeholder for X
37120 A67D           6A                     00    push #0x00 ;; placeholder for Y
37121 A67F           6A                     00    push #0x00 ;; placeholder for Z
37122 A681           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
37123 A683           E8         BF78              call _int74_function
37124 A686           59                           pop cx ;; remove make_far_call from stack
37125 A687           E3           0C              jcxz int74_done
37126                                             ;; make far call to EBDA:0022
37127 A689           6A                     00    push #0x00
37128 A68B           1F                           pop ds
37129 A68C           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
37130 A690           1F                           pop ds
37131 A691           FF1E       0022              call far ptr[0x22]
37132                       0000A695            int74_done:
37133 A695           FA                           cli
37134 A696           E8         03D5              call eoi_both_pics
37135 A699           83C4                   08    add sp, #8 ;; pop status, x, y, z
37136 A69C           1F                           pop ds ;; restore DS
37137 A69D           61                           popa
37138 A69E           CF                           iret
37139                                           ;; This will perform an IRET, but will retain value of current CF
37140                                           ;; by altering flags on stack. Better than RETF #02.
37141                       0000A69F            iret_modify_cf:
37142 A69F           72           09              jc carry_set
37143 A6A1           55                           push bp
37144 A6A2           89E5                         mov bp, sp
37145 A6A4           8066         06        FE    and BYTE [bp + 0x06], #0xfe
37146 A6A8           5D                           pop bp
37147 A6A9           CF                           iret
37148                       0000A6AA            carry_set:
37149 A6AA           55                           push bp
37150 A6AB           89E5                         mov bp, sp
37151 A6AD           804E         06        01    or BYTE [bp + 0x06], #0x01
37152 A6B1           5D                           pop bp
37153 A6B2           CF                           iret
37154                                           ;----------------------
37155                                           ;- INT13h (relocated) -
37156                                           ;----------------------
37157                                           ;
37158                                           ; int13_relocated is a little bit messed up since I played with it
37159                                           ; I have to rewrite it:
37160                                           ; - call a function that detect which function to call
37161                                           ; - make all called C function get the same parameters list
37162                                           ;
37163                       0000A6B3            int13_relocated:
37164                                             ;; check for an eltorito function
37165 A6B3           80FC                   4A    cmp ah,#0x4a
37166 A6B6           72           10              jb int13_not_eltorito
37167 A6B8           80FC                   4D    cmp ah,#0x4d
37168 A6BB           77           0B              ja int13_not_eltorito
37169 A6BD           60                           pusha
37170 A6BE           06                           push es
37171 A6BF           1E                           push ds
37172 A6C0           16                           push ss
37173 A6C1           1F                           pop ds
37174 A6C2           68                   A73A    push #int13_out
37175 A6C5           E9         D9FB              jmp _int13_eltorito ;; ELDX not used
37176                       0000A6C8            int13_not_eltorito:
37177 A6C8           50                           push ax
37178 A6C9           53                           push bx
37179 A6CA           51                           push cx
37180 A6CB           52                           push dx
37181                                             ;; check if emulation active
37182 A6CC           E8         96C5              call _cdemu_isactive
37183 A6CF           3C                     00    cmp al,#0x00
37184 A6D1           74           2B              je int13_cdemu_inactive
37185                                             ;; check if access to the emulated drive
37186 A6D3           E8         96E5              call _cdemu_emulated_drive
37187 A6D6           5A                           pop dx
37188 A6D7           52                           push dx
37189 A6D8           38D0                         cmp al,dl ;; int13 on emulated drive
37190 A6DA           75           0F              jne int13_nocdemu
37191 A6DC           5A                           pop dx
37192 A6DD           59                           pop cx
37193 A6DE           5B                           pop bx
37194 A6DF           58                           pop ax
37195 A6E0           60                           pusha
37196 A6E1           06                           push es
37197 A6E2           1E                           push ds
37198 A6E3           16                           push ss
37199 A6E4           1F                           pop ds
37200 A6E5           68                   A73A    push #int13_out
37201 A6E8           E9         DC12              jmp _int13_cdemu ;; ELDX not used
37202                       0000A6EB            int13_nocdemu:
37203 A6EB           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
37204 A6EE           38D0                         cmp al,dl ;; al is 0x00 or 0x80
37205 A6F0           75           0C              jne int13_cdemu_inactive ;; inactive for device class
37206 A6F2           5A                           pop dx
37207 A6F3           59                           pop cx
37208 A6F4           5B                           pop bx
37209 A6F5           58                           pop ax
37210 A6F6           50                           push ax
37211 A6F7           51                           push cx
37212 A6F8           52                           push dx
37213 A6F9           53                           push bx
37214 A6FA           FECA                         dec dl ;; real drive is dl - 1
37215 A6FC           EB           08              jmp int13_legacy
37216                       0000A6FE            int13_cdemu_inactive:
37217 A6FE           5A                           pop dx
37218 A6FF           59                           pop cx
37219 A700           5B                           pop bx
37220 A701           58                           pop ax
37221                       0000A702            int13_noeltorito:
37222 A702           50                           push ax
37223 A703           51                           push cx
37224 A704           52                           push dx
37225 A705           53                           push bx
37226                       0000A706            int13_legacy:
37227 A706           52                           push dx ;; push eltorito value of dx instead of sp
37228 A707           55                           push bp
37229 A708           56                           push si
37230 A709           57                           push di
37231 A70A           06                           push es
37232 A70B           1E                           push ds
37233 A70C           16                           push ss
37234 A70D           1F                           pop ds
37235                                             ;; now the 16-bit registers can be restored with:
37236                                             ;; pop ds; pop es; popa; iret
37237                                             ;; arguments passed to functions should be
37238                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
37239 A70E           F6C2                   80    test dl, #0x80
37240 A711           75           06              jnz int13_notfloppy
37241 A713           68                   A73A    push #int13_out
37242 A716           E9         E5F9              jmp _int13_diskette_function
37243                       0000A719            int13_notfloppy:
37244 A719           80FA                   E0    cmp dl, #0xE0
37245 A71C           72           0F              jb int13_notcdrom
37246 A71E     66    C1EB                   10    shr ebx, #16
37247 A722           53                           push bx
37248 A723           E8         CED8              call _int13_cdrom
37249 A726           5B                           pop bx
37250 A727     66    C1E3                   10    shl ebx, #16
37251 A72B           EB           0D              jmp int13_out
37252                       0000A72D            int13_notcdrom:
37253                       0000A72D            int13_disk:
37254                                             ;; int13_harddisk modifies high word of EAX
37255 A72D     66    C1E8                   10    shr eax, #16
37256 A731           50                           push ax
37257 A732           E8         BFE4              call _int13_harddisk
37258 A735           58                           pop ax
37259 A736     66    C1E0                   10    shl eax, #16
37260                       0000A73A            int13_out:
37261 A73A           1F                           pop ds
37262 A73B           07                           pop es
37263 A73C           61                           popa
37264 A73D           CF                           iret
37265                                           ;----------
37266                                           ;- INT18h -
37267                                           ;----------
37268                       0000A73E            int18_handler: ;; Boot Failure recovery: try the next device.
37269                                             ;; Reset SP and SS
37270 A73E           B8                   0FFE    mov ax, #0x0ffe
37271 A741           89C4                         mov sp, ax
37272 A743           B8                   9E00    mov ax, #0x9e00
37273 A746           8ED0                         mov ss, ax
37274                                             ;; The first time we do this it will have been set to -1 so
37275                                             ;; we will start from device 0.
37276 A748           31C0                         xor ax, ax
37277 A74A           8ED8                         mov ds, ax
37278 A74C           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
37279 A750           8EDB                         mov ds, bx ;; Set segment
37280 A752           8B1E       0382              mov bx, 0x0382 ;; BX is now the sequence number
37281 A756           43                           inc bx ;; ++
37282 A757           891E       0382              mov 0x0382, bx ;; Write it back
37283 A75B           8ED8                         mov ds, ax ;; and reset the segment to zero.
37284                                             ;; Call the C code for the next boot device
37285 A75D           53                           push bx
37286 A75E           E8         F82B              call _int18_function
37287                                             ;; Boot failed: invoke the boot recovery function...
37288 A761           CD                     18    int #0x18
37289                                           ;----------
37290                                           ;- INT19h -
37291                                           ;----------
37292                       0000A763            int19_relocated: ;; Boot function, relocated
37293                                             ;;
37294                                             ;; *** Warning: INT 19h resets the whole machine ***
37295                                             ;;
37296                                             ;; Because PV drivers in HVM guests detach some of the emulated devices,
37297                                             ;; it is not safe to do a soft reboot by just dropping to real mode and
37298                                             ;; invoking INT 19h -- the boot drives might have disappeared!
37299                                             ;; If the user asks for a soft reboot, the only thing we can do is
37300                                             ;; reset the whole machine. When it comes back up, the normal BIOS
37301                                             ;; boot sequence will start, which is more or less the required behaviour.
37302                                             ;;
37303                                             ;; Reset SP and SS
37304 A763           B8                   0FFE    mov ax, #0x0ffe
37305 A766           89C4                         mov sp, ax
37306 A768           B8                   9E00    mov ax, #0x9e00
37307 A76B           8ED0                         mov ss, ax
37308 A76D           E8         6B57              call _machine_reset
37309                                           ;----------
37310                                           ;- INT1Ch -
37311                                           ;----------
37312                       0000A770            int1c_handler: ;; User Timer Tick
37313 A770           CF                           iret
37314                                           ;----------------------
37315                                           ;- POST: Floppy Drive -
37316                                           ;----------------------
37317                       0000A771            floppy_drive_post:
37318 A771           31C0                         xor ax, ax
37319 A773           8ED8                         mov ds, ax
37320 A775           B0                     00    mov al, #0x00
37321 A777           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
37322 A77A           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
37323 A77D           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
37324 A780           A2         0441              mov 0x0441, al ;; diskette controller status return code
37325 A783           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
37326 A786           A2         0443              mov 0x0443, al ;; diskette controller status register 1
37327 A789           A2         0444              mov 0x0444, al ;; diskette controller status register 2
37328 A78C           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
37329 A78F           A2         0446              mov 0x0446, al ;; diskette controller head number
37330 A792           A2         0447              mov 0x0447, al ;; diskette controller sector number
37331 A795           A2         0448              mov 0x0448, al ;; diskette controller bytes written
37332 A798           A2         048B              mov 0x048b, al ;; diskette configuration data
37333                                             ;; -----------------------------------------------------------------
37334                                             ;; (048F) diskette controller information
37335                                             ;;
37336 A79B           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
37337 A79D           E6                     70    out 0x70, AL
37338 A79F           E4                     71    in AL, 0x71
37339 A7A1           88C4                         mov ah, al ;; save byte to AH
37340                       0000A7A3            look_drive0:
37341 A7A3           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
37342 A7A6           74           04              jz f0_missing ;; jump if no drive0
37343 A7A8           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
37344 A7AA           EB           02              jmp look_drive1
37345                       0000A7AC            f0_missing:
37346 A7AC           B3                     00    mov bl, #0x00 ;; no drive0
37347                       0000A7AE            look_drive1:
37348 A7AE           88E0                         mov al, ah ;; restore from AH
37349 A7B0           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
37350 A7B2           74           03              jz f1_missing ;; jump if no drive1
37351 A7B4           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
37352                       0000A7B7            f1_missing:
37353                                                              ;; leave high bits in BL zerod
37354 A7B7           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
37355                                             ;; -----------------------------------------------------------------
37356 A7BB           B0                     00    mov al, #0x00
37357 A7BD           A2         0490              mov 0x0490, al ;; diskette 0 media state
37358 A7C0           A2         0491              mov 0x0491, al ;; diskette 1 media state
37359                                                              ;; diskette 0,1 operational starting state
37360                                                              ;; drive type has not been determined,
37361                                                              ;; has no changed detection line
37362 A7C3           A2         0492              mov 0x0492, al
37363 A7C6           A2         0493              mov 0x0493, al
37364 A7C9           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
37365 A7CC           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
37366 A7CF           B0                     02    mov al, #0x02
37367 A7D1           E6                     0A    out #0x0a, al ;; clear DMA-1 channel 2 mask bit
37368                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   A7D3           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   A7D6           A3         0078              mov 0x1E*4, ax
 +a   A7D9           B8                   F000    mov ax,  #0xF000
 +a   A7DC           A3         007A              mov 0x1E*4+2, ax
37369                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   A7DF           B8                   EC59    mov ax,  #int13_diskette
 +a   A7E2           A3         0100              mov 0x40*4, ax
 +a   A7E5           B8                   F000    mov ax,  #0xF000
 +a   A7E8           A3         0102              mov 0x40*4+2, ax
37370                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   A7EB           B8                   EF57    mov ax,  #int0e_handler
 +a   A7EE           A3         0038              mov 0x0E*4, ax
 +a   A7F1           B8                   F000    mov ax,  #0xF000
 +a   A7F4           A3         003A              mov 0x0E*4+2, ax
37371 A7F7           C3                           ret
37372                                           ;--------------------
37373                                           ;- POST: HARD DRIVE -
37374                                           ;--------------------
37375                                           ; relocated here because the primary POST area isnt big enough.
37376                       0000A7F8            hard_drive_post:
37377 A7F8           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
37378 A7FA           BA                   03F6    mov dx, #0x03f6
37379 A7FD           EE                           out dx, al
37380 A7FE           31C0                         xor ax, ax
37381 A800           8ED8                         mov ds, ax
37382 A802           A2         0474              mov 0x0474, al
37383 A805           A2         0477              mov 0x0477, al
37384 A808           A2         048C              mov 0x048c, al
37385 A80B           A2         048D              mov 0x048d, al
37386 A80E           A2         048E              mov 0x048e, al
37387 A811           B0                     01    mov al, #0x01
37388 A813           A2         0475              mov 0x0475, al
37389 A816           B0                     C0    mov al, #0xc0
37390 A818           A2         0476              mov 0x0476, al
37391                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   A81B           B8                   E3FE    mov ax,  #int13_handler
 +a   A81E           A3         004C              mov 0x13*4, ax
 +a   A821           B8                   F000    mov ax,  #0xF000
 +a   A824           A3         004E              mov 0x13*4+2, ax
37392                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   A827           B8                   AAFD    mov ax,  #int76_handler
 +a   A82A           A3         01D8              mov 0x76*4, ax
 +a   A82D           B8                   F000    mov ax,  #0xF000
 +a   A830           A3         01DA              mov 0x76*4+2, ax
37393                                             ;; INT 41h: hard disk 0 configuration pointer
37394                                             ;; INT 46h: hard disk 1 configuration pointer
37395                                             SET_INT_VECTOR(0x41, word ptr [0x40E], #0x003D)
 +a   A833           B8                   003D    mov ax,  #0x003D
 +a   A836           A3         0104              mov 0x41*4, ax
 +a   A839           A1         040E              mov ax,  word ptr [0x40E]
 +a   A83C           A3         0106              mov 0x41*4+2, ax
37396                                             SET_INT_VECTOR(0x46, word ptr [0x40E], #0x004D)
 +a   A83F           B8                   004D    mov ax,  #0x004D
 +a   A842           A3         0118              mov 0x46*4, ax
 +a   A845           A1         040E              mov ax,  word ptr [0x40E]
 +a   A848           A3         011A              mov 0x46*4+2, ax
37397                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
37398 A84B           B0                     12    mov al, #0x12
37399 A84D           E6                     70    out #0x70, al
37400 A84F           E4                     71    in al, #0x71
37401 A851           24                     F0    and al, #0xf0
37402 A853           3C                     F0    cmp al, #0xf0
37403 A855           74           03              je post_d0_extended
37404 A857           E9         00D8              jmp check_for_hd1
37405                       0000A85A            post_d0_extended:
37406 A85A           B0                     19    mov al, #0x19
37407 A85C           E6                     70    out #0x70, al
37408 A85E           E4                     71    in al, #0x71
37409 A860           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
37410 A862           74           07              je post_d0_type47
37411                                             HALT(9010)
 +a   A864           BA                   0400    mov dx,#0x400
 +a   A867           B8                   2332    mov ax,#9010
 +a   A86A           EF                           out dx,ax
37412                       0000A86B            post_d0_type47:
37413                                             ;; CMOS purpose param table offset
37414                                             ;; 1b cylinders low 0
37415                                             ;; 1c cylinders high 1
37416                                             ;; 1d heads 2
37417                                             ;; 1e write pre-comp low 5
37418                                             ;; 1f write pre-comp high 6
37419                                             ;; 20 retries/bad map/heads>8 8
37420                                             ;; 21 landing zone low C
37421                                             ;; 22 landing zone high D
37422                                             ;; 23 sectors/track E
37423 A86B           31C0                         xor ax, ax
37424 A86D           8ED8                         mov ds, ax
37425 A86F           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
37426 A872           8ED8                         mov ds, ax
37427                                             ;;; Filling EBDA table for hard disk 0.
37428 A874           B0                     1F    mov al, #0x1f
37429 A876           E6                     70    out #0x70, al
37430 A878           E4                     71    in al, #0x71
37431 A87A           88C4                         mov ah, al
37432 A87C           B0                     1E    mov al, #0x1e
37433 A87E           E6                     70    out #0x70, al
37434 A880           E4                     71    in al, #0x71
37435 A882           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
37436 A885           B0                     20    mov al, #0x20
37437 A887           E6                     70    out #0x70, al
37438 A889           E4                     71    in al, #0x71
37439 A88B           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
37440 A88E           B0                     22    mov al, #0x22
37441 A890           E6                     70    out #0x70, al
37442 A892           E4                     71    in al, #0x71
37443 A894           88C4                         mov ah, al
37444 A896           B0                     21    mov al, #0x21
37445 A898           E6                     70    out #0x70, al
37446 A89A           E4                     71    in al, #0x71
37447 A89C           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
37448 A89F           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
37449 A8A1           E6                     70    out #0x70, al
37450 A8A3           E4                     71    in al, #0x71 ;; high byte
37451 A8A5           88C4                         mov ah, al
37452 A8A7           B0                     1B    mov al, #0x1b
37453 A8A9           E6                     70    out #0x70, al
37454 A8AB           E4                     71    in al, #0x71 ;; low byte
37455 A8AD           89C3                         mov bx, ax ;; BX = cylinders
37456 A8AF           B0                     1D    mov al, #0x1d
37457 A8B1           E6                     70    out #0x70, al
37458 A8B3           E4                     71    in al, #0x71
37459 A8B5           88C1                         mov cl, al ;; CL = heads
37460 A8B7           B0                     23    mov al, #0x23
37461 A8B9           E6                     70    out #0x70, al
37462 A8BB           E4                     71    in al, #0x71
37463 A8BD           88C2                         mov dl, al ;; DL = sectors
37464 A8BF           81FB                 0400    cmp bx, #1024
37465 A8C3           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
37466                       0000A8C5            hd0_post_physical_chs:
37467                                             ;; no logical CHS mapping used, just physical CHS
37468                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
37469 A8C5           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
37470 A8C9           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
37471 A8CD           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
37472 A8D1           EB           5F              jmp check_for_hd1
37473                       0000A8D3            hd0_post_logical_chs:
37474                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
37475 A8D3           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
37476 A8D7           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
37477 A8DB           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
37478 A8DF           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
37479 A8E3           B0                     A0    mov al, #0xa0
37480 A8E5           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
37481 A8E8           81FB                 0800    cmp bx, #2048
37482 A8EC           77           06              jnbe hd0_post_above_2048
37483                                             ;; 1024 < c <= 2048 cylinders
37484 A8EE           D1EB                         shr bx, #0x01
37485 A8F0           D0E1                         shl cl, #0x01
37486 A8F2           EB           22              jmp hd0_post_store_logical
37487                       0000A8F4            hd0_post_above_2048:
37488 A8F4           81FB                 1000    cmp bx, #4096
37489 A8F8           77           08              jnbe hd0_post_above_4096
37490                                             ;; 2048 < c <= 4096 cylinders
37491 A8FA           C1EB                   02    shr bx, #0x02
37492 A8FD           C0E1                   02    shl cl, #0x02
37493 A900           EB           14              jmp hd0_post_store_logical
37494                       0000A902            hd0_post_above_4096:
37495 A902           81FB                 2000    cmp bx, #8192
37496 A906           77           08              jnbe hd0_post_above_8192
37497                                             ;; 4096 < c <= 8192 cylinders
37498 A908           C1EB                   03    shr bx, #0x03
37499 A90B           C0E1                   03    shl cl, #0x03
37500 A90E           EB           06              jmp hd0_post_store_logical
37501                       0000A910            hd0_post_above_8192:
37502                                             ;; 8192 < c <= 16384 cylinders
37503 A910           C1EB                   04    shr bx, #0x04
37504 A913           C0E1                   04    shl cl, #0x04
37505                       0000A916            hd0_post_store_logical:
37506 A916           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
37507 A91A           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
37508                                             ;; checksum
37509 A91E           B1                     0F    mov cl, #0x0f ;; repeat count
37510 A920           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
37511 A923           B0                     00    mov al, #0x00 ;; sum
37512                       0000A925            hd0_post_checksum_loop:
37513 A925           0204                         add al, [si]
37514 A927           46                           inc si
37515 A928           FEC9                         dec cl
37516 A92A           75           F9              jnz hd0_post_checksum_loop
37517 A92C           F6D0                         not al ;; now take 2s complement
37518 A92E           FEC0                         inc al
37519 A930           8804                         mov [si], al
37520                                           ;;; Done filling EBDA table for hard disk 0.
37521                       0000A932            check_for_hd1:
37522                                             ;; is there really a second hard disk? if not, return now
37523 A932           B0                     12    mov al, #0x12
37524 A934           E6                     70    out #0x70, al
37525 A936           E4                     71    in al, #0x71
37526 A938           24                     0F    and al, #0x0f
37527 A93A           75           01              jnz post_d1_exists
37528 A93C           C3                           ret
37529                       0000A93D            post_d1_exists:
37530                                             ;; check that the hd type is really 0x0f.
37531 A93D           3C                     0F    cmp al, #0x0f
37532 A93F           74           07              jz post_d1_extended
37533                                             HALT(9149)
 +a   A941           BA                   0400    mov dx,#0x400
 +a   A944           B8                   23BD    mov ax,#9149
 +a   A947           EF                           out dx,ax
37534                       0000A948            post_d1_extended:
37535                                             ;; check that the extended type is 47 - user definable
37536 A948           B0                     1A    mov al, #0x1a
37537 A94A           E6                     70    out #0x70, al
37538 A94C           E4                     71    in al, #0x71
37539 A94E           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
37540 A950           74           07              je post_d1_type47
37541                                             HALT(9157)
 +a   A952           BA                   0400    mov dx,#0x400
 +a   A955           B8                   23C5    mov ax,#9157
 +a   A958           EF                           out dx,ax
37542                       0000A959            post_d1_type47:
37543                                             ;; Table for disk1.
37544                                             ;; CMOS purpose param table offset
37545                                             ;; 0x24 cylinders low 0
37546                                             ;; 0x25 cylinders high 1
37547                                             ;; 0x26 heads 2
37548                                             ;; 0x27 write pre-comp low 5
37549                                             ;; 0x28 write pre-comp high 6
37550                                             ;; 0x29 heads>8 8
37551                                             ;; 0x2a landing zone low C
37552                                             ;; 0x2b landing zone high D
37553                                             ;; 0x2c sectors/track E
37554                                           ;;; Fill EBDA table for hard disk 1.
37555 A959           31C0                         xor ax, ax
37556 A95B           8ED8                         mov ds, ax
37557 A95D           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
37558 A960           8ED8                         mov ds, ax
37559 A962           B0                     28    mov al, #0x28
37560 A964           E6                     70    out #0x70, al
37561 A966           E4                     71    in al, #0x71
37562 A968           88C4                         mov ah, al
37563 A96A           B0                     27    mov al, #0x27
37564 A96C           E6                     70    out #0x70, al
37565 A96E           E4                     71    in al, #0x71
37566 A970           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
37567 A973           B0                     29    mov al, #0x29
37568 A975           E6                     70    out #0x70, al
37569 A977           E4                     71    in al, #0x71
37570 A979           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
37571 A97C           B0                     2B    mov al, #0x2b
37572 A97E           E6                     70    out #0x70, al
37573 A980           E4                     71    in al, #0x71
37574 A982           88C4                         mov ah, al
37575 A984           B0                     2A    mov al, #0x2a
37576 A986           E6                     70    out #0x70, al
37577 A988           E4                     71    in al, #0x71
37578 A98A           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
37579 A98D           B0                     25    mov al, #0x25 ;; get cylinders word in AX
37580 A98F           E6                     70    out #0x70, al
37581 A991           E4                     71    in al, #0x71 ;; high byte
37582 A993           88C4                         mov ah, al
37583 A995           B0                     24    mov al, #0x24
37584 A997           E6                     70    out #0x70, al
37585 A999           E4                     71    in al, #0x71 ;; low byte
37586 A99B           89C3                         mov bx, ax ;; BX = cylinders
37587 A99D           B0                     26    mov al, #0x26
37588 A99F           E6                     70    out #0x70, al
37589 A9A1           E4                     71    in al, #0x71
37590 A9A3           88C1                         mov cl, al ;; CL = heads
37591 A9A5           B0                     2C    mov al, #0x2c
37592 A9A7           E6                     70    out #0x70, al
37593 A9A9           E4                     71    in al, #0x71
37594 A9AB           88C2                         mov dl, al ;; DL = sectors
37595 A9AD           81FB                 0400    cmp bx, #1024
37596 A9B1           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
37597                       0000A9B3            hd1_post_physical_chs:
37598                                             ;; no logical CHS mapping used, just physical CHS
37599                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
37600 A9B3           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
37601 A9B7           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
37602 A9BB           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
37603 A9BF           C3                           ret
37604                       0000A9C0            hd1_post_logical_chs:
37605                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
37606 A9C0           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
37607 A9C4           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
37608 A9C8           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
37609 A9CC           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
37610 A9D0           B0                     A0    mov al, #0xa0
37611 A9D2           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
37612 A9D5           81FB                 0800    cmp bx, #2048
37613 A9D9           77           06              jnbe hd1_post_above_2048
37614                                             ;; 1024 < c <= 2048 cylinders
37615 A9DB           D1EB                         shr bx, #0x01
37616 A9DD           D0E1                         shl cl, #0x01
37617 A9DF           EB           22              jmp hd1_post_store_logical
37618                       0000A9E1            hd1_post_above_2048:
37619 A9E1           81FB                 1000    cmp bx, #4096
37620 A9E5           77           08              jnbe hd1_post_above_4096
37621                                             ;; 2048 < c <= 4096 cylinders
37622 A9E7           C1EB                   02    shr bx, #0x02
37623 A9EA           C0E1                   02    shl cl, #0x02
37624 A9ED           EB           14              jmp hd1_post_store_logical
37625                       0000A9EF            hd1_post_above_4096:
37626 A9EF           81FB                 2000    cmp bx, #8192
37627 A9F3           77           08              jnbe hd1_post_above_8192
37628                                             ;; 4096 < c <= 8192 cylinders
37629 A9F5           C1EB                   03    shr bx, #0x03
37630 A9F8           C0E1                   03    shl cl, #0x03
37631 A9FB           EB           06              jmp hd1_post_store_logical
37632                       0000A9FD            hd1_post_above_8192:
37633                                             ;; 8192 < c <= 16384 cylinders
37634 A9FD           C1EB                   04    shr bx, #0x04
37635 AA00           C0E1                   04    shl cl, #0x04
37636                       0000AA03            hd1_post_store_logical:
37637 AA03           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
37638 AA07           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
37639                                             ;; checksum
37640 AA0B           B1                     0F    mov cl, #0x0f ;; repeat count
37641 AA0D           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
37642 AA10           B0                     00    mov al, #0x00 ;; sum
37643                       0000AA12            hd1_post_checksum_loop:
37644 AA12           0204                         add al, [si]
37645 AA14           46                           inc si
37646 AA15           FEC9                         dec cl
37647 AA17           75           F9              jnz hd1_post_checksum_loop
37648 AA19           F6D0                         not al ;; now take 2s complement
37649 AA1B           FEC0                         inc al
37650 AA1D           8804                         mov [si], al
37651                                           ;;; Done filling EBDA table for hard disk 1.
37652 AA1F           C3                           ret
37653                                           ;--------------------
37654                                           ;- POST: EBDA segment
37655                                           ;--------------------
37656                                           ; relocated here because the primary POST area isnt big enough.
37657                       0000AA20            ebda_post:
37658 AA20           B8                   9FC0    mov ax, #0x9FC0
37659 AA23           8ED8                         mov ds, ax
37660 AA25           C606       0000        01    mov byte ptr [0x0], #1
37661 AA2A           31C0                         xor ax, ax ; mov EBDA seg into 40E
37662 AA2C           8ED8                         mov ds, ax
37663 AA2E           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
37664 AA34           C3                           ret;;
37665                                           ;--------------------
37666                                           ;- POST: EOI + jmp via [0x40:67)
37667                                           ;--------------------
37668                                           ; relocated here because the primary POST area isnt big enough.
37669                       0000AA35            eoi_jmp_post:
37670 AA35           B0                     20    mov al, #0x20
37671 AA37           E6                     A0    out #0xA0, al ;; slave PIC EOI
37672 AA39           B0                     20    mov al, #0x20
37673 AA3B           E6                     20    out #0x20, al ;; master PIC EOI
37674                       0000AA3D            jmp_post_0x467:
37675 AA3D           31C0                         xor ax, ax
37676 AA3F           8ED8                         mov ds, ax
37677 AA41           FF2E       0467              jmp far ptr [0x467]
37678                       0000AA45            iret_post_0x467:
37679 AA45           31C0                         xor ax, ax
37680 AA47           8ED8                         mov ds, ax
37681 AA49           8B26       0467              mov sp, [0x467]
37682 AA4D           8E16       0469              mov ss, [0x469]
37683 AA51           CF                           iret
37684                       0000AA52            retf_post_0x467:
37685 AA52           31C0                         xor ax, ax
37686 AA54           8ED8                         mov ds, ax
37687 AA56           8B26       0467              mov sp, [0x467]
37688 AA5A           8E16       0469              mov ss, [0x469]
37689 AA5E           CB                           retf
37690                       0000AA5F            s3_post:
37691 AA5F           E8         6EDC              call _s3_resume
37692 AA62           B3                     00    mov bl, #0x00
37693 AA64           21C0                         and ax, ax
37694 AA66   7503    E9         363C              jz normal_post
37695 AA6B           E8         68CD              call _s3_resume_panic
37696                                           ;--------------------
37697                       0000AA6E            eoi_both_pics:
37698 AA6E           B0                     20    mov al, #0x20
37699 AA70           E6                     A0    out #0xA0, al ;; slave PIC EOI
37700                       0000AA72            eoi_master_pic:
37701 AA72           B0                     20    mov al, #0x20
37702 AA74           E6                     20    out #0x20, al ;; master PIC EOI
37703 AA76           C3                           ret
37704                                           ;--------------------
37705                       0000AA77            BcdToBin:
37706                                             ;; in: AL in BCD format
37707                                             ;; out: AL in binary format, AH will always be 0
37708                                             ;; trashes BX
37709 AA77           88C3                         mov bl, al
37710 AA79           80E3                   0F    and bl, #0x0f ;; bl has low digit
37711 AA7C           C0E8                   04    shr al, #4 ;; al has high digit
37712 AA7F           B7                     0A    mov bh, #10
37713 AA81           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
37714 AA83           00D8                         add al, bl ;; then add low digit
37715 AA85           C3                           ret
37716                                           ;--------------------
37717                       0000AA86            timer_tick_post:
37718                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
37719                                             ;; Timer Ticks Roller Flag (0x470:byte)
37720                                             ;; The Timer Ticks Count needs to be set according to
37721                                             ;; the current CMOS time, as if ticks have been occurring
37722                                             ;; at 18.2hz since midnight up to this point. Calculating
37723                                             ;; this is a little complicated. Here are the factors I gather
37724                                             ;; regarding this. 14,318,180 hz was the original clock speed,
37725                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
37726                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
37727                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
37728                                             ;; the timer. With a maximum 16bit timer count, this is again
37729                                             ;; divided down by 65536 to 18.2hz.
37730                                             ;;
37731                                             ;; 14,318,180 Hz clock
37732                                             ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
37733                                             ;; /4 = 1,193,181 Hz fed to timer
37734                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
37735                                             ;; 1 second = 18.20650736 ticks
37736                                             ;; 1 minute = 1092.390442 ticks
37737                                             ;; 1 hour = 65543.42651 ticks
37738                                             ;;
37739                                             ;; Given the values in the CMOS clock, one could calculate
37740                                             ;; the number of ticks by the following:
37741                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
37742                                             ;; (BcdToBin(minutes) * 1092.3904)
37743                                             ;; (BcdToBin(hours) * 65543.427)
37744                                             ;; To get a little more accuracy, since Im using integer
37745                                             ;; arithmatic, I use:
37746                                             ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
37747                                             ;; (BcdToBin(minutes) * 10923904) / 10000 +
37748                                             ;; (BcdToBin(hours) * 65543427) / 1000
37749                                             ;; assuming DS=0000
37750                                             ;; get CMOS seconds
37751 AA86     66    31C0                         xor eax, eax ;; clear EAX
37752 AA89           B0                     00    mov al, #0x00
37753 AA8B           E6                     70    out #0x70, al
37754 AA8D           E4                     71    in al, #0x71 ;; AL has CMOS seconds in BCD
37755 AA8F           E8         FFE5              call BcdToBin ;; EAX now has seconds in binary
37756 AA92     66    BA               0115CF2B    mov edx, #18206507
37757 AA98     66    F7E2                         mul eax, edx
37758 AA9B     66    BB               000F4240    mov ebx, #1000000
37759 AAA1     66    31D2                         xor edx, edx
37760 AAA4     66    F7F3                         div eax, ebx
37761 AAA7     66    89C1                         mov ecx, eax ;; ECX will accumulate total ticks
37762                                             ;; get CMOS minutes
37763 AAAA     66    31C0                         xor eax, eax ;; clear EAX
37764 AAAD           B0                     02    mov al, #0x02
37765 AAAF           E6                     70    out #0x70, al
37766 AAB1           E4                     71    in al, #0x71 ;; AL has CMOS minutes in BCD
37767 AAB3           E8         FFC1              call BcdToBin ;; EAX now has minutes in binary
37768 AAB6     66    BA               00A6AF80    mov edx, #10923904
37769 AABC     66    F7E2                         mul eax, edx
37770 AABF     66    BB               00002710    mov ebx, #10000
37771 AAC5     66    31D2                         xor edx, edx
37772 AAC8     66    F7F3                         div eax, ebx
37773 AACB     66    01C1                         add ecx, eax ;; add to total ticks
37774                                             ;; get CMOS hours
37775 AACE     66    31C0                         xor eax, eax ;; clear EAX
37776 AAD1           B0                     04    mov al, #0x04
37777 AAD3           E6                     70    out #0x70, al
37778 AAD5           E4                     71    in al, #0x71 ;; AL has CMOS hours in BCD
37779 AAD7           E8         FF9D              call BcdToBin ;; EAX now has hours in binary
37780 AADA     66    BA               03E81D03    mov edx, #65543427
37781 AAE0     66    F7E2                         mul eax, edx
37782 AAE3     66    BB               000003E8    mov ebx, #1000
37783 AAE9     66    31D2                         xor edx, edx
37784 AAEC     66    F7F3                         div eax, ebx
37785 AAEF     66    01C1                         add ecx, eax ;; add to total ticks
37786 AAF2     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
37787 AAF7           30C0                         xor al, al
37788 AAF9           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
37789 AAFC           C3                           ret
37790                                           ;--------------------
37791                       0000AAFD            int76_handler:
37792                                             ;; record completion in BIOS task complete flag
37793 AAFD           50                           push ax
37794 AAFE           1E                           push ds
37795 AAFF           B8                   0040    mov ax, #0x0040
37796 AB02           8ED8                         mov ds, ax
37797 AB04           C706       008E      00FF    mov 0x008E, #0xff
37798 AB0A           E8         FF61              call eoi_both_pics
37799 AB0D           1F                           pop ds
37800 AB0E           58                           pop ax
37801 AB0F           CF                           iret
37802                                           ;--------------------
37803                                           use32 386
37804                       0000AB10            apm32_out_str:
37805 AB10           50                           push eax
37806 AB11           53                           push ebx
37807 AB12           89C3                         mov ebx, eax
37808                       0000AB14            apm32_out_str1:
37809 AB14           2E                           SEG CS
37810 AB15   67      8A07                         mov al, byte ptr [bx]
37811 AB18           3C                     00    cmp al, #0
37812 AB1A           74           04              je apm32_out_str2
37813 AB1C           EE                           outb dx, al
37814 AB1D           43                           inc ebx
37815 AB1E           EB           F4              jmp apm32_out_str1
37816                       0000AB20            apm32_out_str2:
37817 AB20           5B                           pop ebx
37818 AB21           58                           pop eax
37819 AB22           C3                           ret
37820                       0000AB23            apm32_07_poweroff_str:
37821 AB23                        53              .ascii "Shutdown"
37822 AB2B                        00              db 0
37823                       0000AB2C            apm32_07_suspend_str:
37824 AB2C                        53              .ascii "Suspend"
37825 AB33                        00              db 0
37826                       0000AB34            apm32_07_standby_str:
37827 AB34                        53              .ascii "Standby"
37828 AB3B                        00              db 0
37829                       0000AB3C            _apm32_entry:
37830 AB3C     66    9C                           pushf
37831                                           ;-----------------
37832                                           ; APM interface disconnect
37833                       0000AB3E            apm32_04:
37834 AB3E           3C                     04    cmp al, #0x04
37835 AB40           75           05              jne apm32_05
37836 AB42           E9     000000A5              jmp apm32_ok
37837                                           ;-----------------
37838                                           ; APM cpu idle
37839                       0000AB47            apm32_05:
37840 AB47           3C                     05    cmp al, #0x05
37841 AB49           75           0B              jne apm32_07
37842 AB4B     66    9C                           pushf ; XEN
37843 AB4D           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
37844 AB4E           F4                           hlt
37845 AB4F     66    9D                           popf ; XEN
37846 AB51           E9     00000096              jmp apm32_ok
37847                                           ;-----------------
37848                                           ; APM Set Power State
37849                       0000AB56            apm32_07:
37850 AB56           3C                     07    cmp al, #0x07
37851 AB58           75           52              jne apm32_08
37852 AB5A     66    83FB                   01    cmp bx, #1
37853 AB5E   7405    E9     00000087              jne apm32_ok
37854 AB65     66    83F9                   03    cmp cx, #3
37855 AB69           74           0E              je apm32_07_poweroff
37856 AB6B     66    83F9                   02    cmp cx, #2
37857 AB6F           74           19              je apm32_07_suspend
37858 AB71     66    83F9                   01    cmp cx, #1
37859 AB75           74           24              je apm32_07_standby
37860 AB77           75           73              jne apm32_ok
37861                       0000AB79            apm32_07_poweroff:
37862 AB79           FA                           cli
37863 AB7A     66    BA                   8900    mov dx, #0x8900
37864 AB7E     66    B8                   AB23    mov ax, #apm32_07_poweroff_str
37865 AB82           E8     FFFFFF89              call apm32_out_str
37866                       0000AB87            apm32_07_1:
37867 AB87           F4                           hlt
37868 AB88           EB           FD              jmp apm32_07_1
37869                       0000AB8A            apm32_07_suspend:
37870 AB8A           52                           push edx
37871 AB8B     66    BA                   8900    mov dx, #0x8900
37872 AB8F     66    B8                   AB2C    mov ax, #apm32_07_suspend_str
37873 AB93           E8     FFFFFF78              call apm32_out_str
37874 AB98           5A                           pop edx
37875 AB99           EB           51              jmp apm32_ok
37876                       0000AB9B            apm32_07_standby:
37877 AB9B           52                           push edx
37878 AB9C     66    BA                   8900    mov dx, #0x8900
37879 ABA0     66    B8                   AB34    mov ax, #apm32_07_standby_str
37880 ABA4           E8     FFFFFF67              call apm32_out_str
37881 ABA9           5A                           pop edx
37882 ABAA           EB           40              jmp apm32_ok
37883                                           ;-----------------
37884                                           ; APM Enable / Disable
37885                       0000ABAC            apm32_08:
37886 ABAC           3C                     08    cmp al, #0x08
37887 ABAE           75           02              jne apm32_0a
37888 ABB0           EB           3A              jmp apm32_ok
37889                                           ;-----------------
37890                                           ; Get Power Status
37891                       0000ABB2            apm32_0a:
37892 ABB2           3C                     0A    cmp al, #0x0a
37893 ABB4           75           12              jne apm32_0b
37894 ABB6           B7                     01    mov bh, #0x01
37895 ABB8           B3                     FF    mov bl, #0xff
37896 ABBA           B5                     80    mov ch, #0x80
37897 ABBC           B1                     FF    mov cl, #0xff
37898 ABBE     66    BA                   FFFF    mov dx, #0xffff
37899 ABC2     66    BE                   0000    mov si, #0
37900 ABC6           EB           24              jmp apm32_ok
37901                                           ;-----------------
37902                                           ; Get PM Event
37903                       0000ABC8            apm32_0b:
37904 ABC8           3C                     0B    cmp al, #0x0b
37905 ABCA           75           04              jne apm32_0e
37906 ABCC           B4                     80    mov ah, #0x80
37907 ABCE           EB           20              jmp apm32_error
37908                                           ;-----------------
37909                                           ; APM Driver Version
37910                       0000ABD0            apm32_0e:
37911 ABD0           3C                     0E    cmp al, #0x0e
37912 ABD2           75           06              jne apm32_0f
37913 ABD4           B4                     01    mov ah, #1
37914 ABD6           B0                     02    mov al, #2
37915 ABD8           EB           12              jmp apm32_ok
37916                                           ;-----------------
37917                                           ; APM Engage / Disengage
37918                       0000ABDA            apm32_0f:
37919 ABDA           3C                     0F    cmp al, #0x0f
37920 ABDC           75           02              jne apm32_10
37921 ABDE           EB           0C              jmp apm32_ok
37922                                           ;-----------------
37923                                           ; APM Get Capabilities
37924                       0000ABE0            apm32_10:
37925 ABE0           3C                     10    cmp al, #0x10
37926 ABE2           75           0C              jne apm32_unimplemented
37927 ABE4           B3                     00    mov bl, #0
37928 ABE6     66    B9                   0000    mov cx, #0
37929 ABEA           EB           00              jmp apm32_ok
37930                                           ;-----------------
37931                       0000ABEC            apm32_ok:
37932 ABEC     66    9D                           popf
37933 ABEE           F8                           clc
37934 ABEF           CB                           retf
37935                       0000ABF0            apm32_unimplemented:
37936                       0000ABF0            apm32_error:
37937 ABF0     66    9D                           popf
37938 ABF2           F9                           stc
37939 ABF3           CB                           retf
37940                                           use16 386
37941                       0000ABF4            apm16_out_str:
37942 ABF4     66    50                           push eax
37943 ABF6     66    53                           push ebx
37944 ABF8     66    89C3                         mov ebx, eax
37945                       0000ABFB            apm16_out_str1:
37946 ABFB           2E                           SEG CS
37947 ABFC           8A07                         mov al, byte ptr [bx]
37948 ABFE           3C                     00    cmp al, #0
37949 AC00           74           05              je apm16_out_str2
37950 AC02           EE                           outb dx, al
37951 AC03     66    43                           inc ebx
37952 AC05           EB           F4              jmp apm16_out_str1
37953                       0000AC07            apm16_out_str2:
37954 AC07     66    5B                           pop ebx
37955 AC09     66    58                           pop eax
37956 AC0B           C3                           ret
37957                       0000AC0C            apm16_07_poweroff_str:
37958 AC0C                        53              .ascii "Shutdown"
37959 AC14                        00              db 0
37960                       0000AC15            apm16_07_suspend_str:
37961 AC15                        53              .ascii "Suspend"
37962 AC1C                        00              db 0
37963                       0000AC1D            apm16_07_standby_str:
37964 AC1D                        53              .ascii "Standby"
37965 AC24                        00              db 0
37966                       0000AC25            _apm16_entry:
37967 AC25           9C                           pushf
37968                                           ;-----------------
37969                                           ; APM interface disconnect
37970                       0000AC26            apm16_04:
37971 AC26           3C                     04    cmp al, #0x04
37972 AC28           75           03              jne apm16_05
37973 AC2A           E9         008D              jmp apm16_ok
37974                                           ;-----------------
37975                                           ; APM cpu idle
37976                       0000AC2D            apm16_05:
37977 AC2D           3C                     05    cmp al, #0x05
37978 AC2F           75           07              jne apm16_07
37979 AC31           9C                           pushf ; XEN
37980 AC32           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
37981 AC33           F4                           hlt
37982 AC34           9D                           popf ; XEN
37983 AC35           E9         0082              jmp apm16_ok
37984                                           ;-----------------
37985                                           ; APM Set Power State
37986                       0000AC38            apm16_07:
37987 AC38           3C                     07    cmp al, #0x07
37988 AC3A           75           41              jne apm16_08
37989 AC3C           83FB                   01    cmp bx, #1
37990 AC3F           75           79              jne apm16_ok
37991 AC41           83F9                   03    cmp cx, #3
37992 AC44           74           0C              je apm16_07_poweroff
37993 AC46           83F9                   02    cmp cx, #2
37994 AC49           74           14              je apm16_07_suspend
37995 AC4B           83F9                   01    cmp cx, #1
37996 AC4E           74           1E              je apm16_07_standby
37997 AC50           75           68              jne apm16_ok
37998                       0000AC52            apm16_07_poweroff:
37999 AC52           FA                           cli
38000 AC53           BA                   8900    mov dx, #0x8900
38001 AC56           B8                   AC0C    mov ax, #apm16_07_poweroff_str
38002 AC59           E8         FF98              call apm16_out_str
38003                       0000AC5C            apm16_07_1:
38004 AC5C           F4                           hlt
38005 AC5D           EB           FD              jmp apm16_07_1
38006                       0000AC5F            apm16_07_suspend:
38007 AC5F     66    52                           push edx
38008 AC61           BA                   8900    mov dx, #0x8900
38009 AC64           B8                   AC15    mov ax, #apm16_07_suspend_str
38010 AC67           E8         FF8A              call apm16_out_str
38011 AC6A     66    5A                           pop edx
38012 AC6C           EB           4C              jmp apm16_ok
38013                       0000AC6E            apm16_07_standby:
38014 AC6E     66    52                           push edx
38015 AC70           BA                   8900    mov dx, #0x8900
38016 AC73           B8                   AC1D    mov ax, #apm16_07_standby_str
38017 AC76           E8         FF7B              call apm16_out_str
38018 AC79     66    5A                           pop edx
38019 AC7B           EB           3D              jmp apm16_ok
38020                                           ;-----------------
38021                                           ; APM Enable / Disable
38022                       0000AC7D            apm16_08:
38023 AC7D           3C                     08    cmp al, #0x08
38024 AC7F           75           02              jne apm16_0a
38025 AC81           EB           37              jmp apm16_ok
38026                                           ;-----------------
38027                                           ; Get Power Status
38028                       0000AC83            apm16_0a:
38029 AC83           3C                     0A    cmp al, #0x0a
38030 AC85           75           10              jne apm16_0b
38031 AC87           B7                     01    mov bh, #0x01
38032 AC89           B3                     FF    mov bl, #0xff
38033 AC8B           B5                     80    mov ch, #0x80
38034 AC8D           B1                     FF    mov cl, #0xff
38035 AC8F           BA                   FFFF    mov dx, #0xffff
38036 AC92           BE                   0000    mov si, #0
38037 AC95           EB           23              jmp apm16_ok
38038                                           ;-----------------
38039                                           ; Get PM Event
38040                       0000AC97            apm16_0b:
38041 AC97           3C                     0B    cmp al, #0x0b
38042 AC99           75           04              jne apm16_0e
38043 AC9B           B4                     80    mov ah, #0x80
38044 AC9D           EB           1E              jmp apm16_error
38045                                           ;-----------------
38046                                           ; APM Driver Version
38047                       0000AC9F            apm16_0e:
38048 AC9F           3C                     0E    cmp al, #0x0e
38049 ACA1           75           06              jne apm16_0f
38050 ACA3           B4                     01    mov ah, #1
38051 ACA5           B0                     02    mov al, #2
38052 ACA7           EB           11              jmp apm16_ok
38053                                           ;-----------------
38054                                           ; APM Engage / Disengage
38055                       0000ACA9            apm16_0f:
38056 ACA9           3C                     0F    cmp al, #0x0f
38057 ACAB           75           02              jne apm16_10
38058 ACAD           EB           0B              jmp apm16_ok
38059                                           ;-----------------
38060                                           ; APM Get Capabilities
38061                       0000ACAF            apm16_10:
38062 ACAF           3C                     10    cmp al, #0x10
38063 ACB1           75           0A              jne apm16_unimplemented
38064 ACB3           B3                     00    mov bl, #0
38065 ACB5           B9                   0000    mov cx, #0
38066 ACB8           EB           00              jmp apm16_ok
38067                                           ;-----------------
38068                       0000ACBA            apm16_ok:
38069 ACBA           9D                           popf
38070 ACBB           F8                           clc
38071 ACBC           CB                           retf
38072                       0000ACBD            apm16_unimplemented:
38073                       0000ACBD            apm16_error:
38074 ACBD           9D                           popf
38075 ACBE           F9                           stc
38076 ACBF           CB                           retf
38077                       0000ACC0            apmreal_out_str:
38078 ACC0     66    50                           push eax
38079 ACC2     66    53                           push ebx
38080 ACC4     66    89C3                         mov ebx, eax
38081                       0000ACC7            apmreal_out_str1:
38082 ACC7           2E                           SEG CS
38083 ACC8           8A07                         mov al, byte ptr [bx]
38084 ACCA           3C                     00    cmp al, #0
38085 ACCC           74           05              je apmreal_out_str2
38086 ACCE           EE                           outb dx, al
38087 ACCF     66    43                           inc ebx
38088 ACD1           EB           F4              jmp apmreal_out_str1
38089                       0000ACD3            apmreal_out_str2:
38090 ACD3     66    5B                           pop ebx
38091 ACD5     66    58                           pop eax
38092 ACD7           C3                           ret
38093                       0000ACD8            apmreal_07_poweroff_str:
38094 ACD8                        53              .ascii "Shutdown"
38095 ACE0                        00              db 0
38096                       0000ACE1            apmreal_07_suspend_str:
38097 ACE1                        53              .ascii "Suspend"
38098 ACE8                        00              db 0
38099                       0000ACE9            apmreal_07_standby_str:
38100 ACE9                        53              .ascii "Standby"
38101 ACF0                        00              db 0
38102 ACF1           9C                           pushf
38103                       0000ACF2            _apmreal_entry:
38104                                           ;-----------------
38105                                           ; APM installation check
38106                       0000ACF2            apmreal_00:
38107 ACF2           3C                     00    cmp al, #0x00
38108 ACF4           75           0E              jne apmreal_01
38109 ACF6           B4                     01    mov ah, #1
38110 ACF8           B0                     02    mov al, #2
38111 ACFA           B7                     50    mov bh, #0x50
38112 ACFC           B3                     4D    mov bl, #0x4d
38113 ACFE           B9                   0003    mov cx, #0x3
38114 AD01           E9         00D0              jmp apmreal_ok
38115                                           ;-----------------
38116                                           ; APM real mode interface connect
38117                       0000AD04            apmreal_01:
38118 AD04           3C                     01    cmp al, #0x01
38119 AD06           75           03              jne apmreal_02
38120 AD08           E9         00C9              jmp apmreal_ok
38121                                           ;-----------------
38122                                           ; APM 16 bit protected mode interface connect
38123                       0000AD0B            apmreal_02:
38124 AD0B           3C                     02    cmp al, #0x02
38125 AD0D           75           12              jne apmreal_03
38126 AD0F           BB                   AC25    mov bx, #_apm16_entry
38127 AD12           B8                   F000    mov ax, #0xf000
38128 AD15           BE                   FFF0    mov si, #0xfff0
38129 AD18           B9                   F000    mov cx, #0xf000
38130 AD1B           BF                   FFF0    mov di, #0xfff0
38131 AD1E           E9         00B3              jmp apmreal_ok
38132                                           ;-----------------
38133                                           ; APM 32 bit protected mode interface connect
38134                       0000AD21            apmreal_03:
38135 AD21           3C                     03    cmp al, #0x03
38136 AD23           75           1B              jne apmreal_04
38137 AD25           B8                   F000    mov ax, #0xf000
38138 AD28     66    BB               0000AB3C    mov ebx, #_apm32_entry
38139 AD2E           B9                   F000    mov cx, #0xf000
38140 AD31     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
38141 AD37           BA                   F000    mov dx, #0xf000
38142 AD3A           BF                   FFF0    mov di, #0xfff0
38143 AD3D           E9         0094              jmp apmreal_ok
38144                                           ;-----------------
38145                                           ; APM interface disconnect
38146                       0000AD40            apmreal_04:
38147 AD40           3C                     04    cmp al, #0x04
38148 AD42           75           03              jne apmreal_05
38149 AD44           E9         008D              jmp apmreal_ok
38150                                           ;-----------------
38151                                           ; APM cpu idle
38152                       0000AD47            apmreal_05:
38153 AD47           3C                     05    cmp al, #0x05
38154 AD49           75           07              jne apmreal_07
38155 AD4B           9C                           pushf ; XEN
38156 AD4C           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
38157 AD4D           F4                           hlt
38158 AD4E           9D                           popf ; XEN
38159 AD4F           E9         0082              jmp apmreal_ok
38160                                           ;-----------------
38161                                           ; APM Set Power State
38162                       0000AD52            apmreal_07:
38163 AD52           3C                     07    cmp al, #0x07
38164 AD54           75           41              jne apmreal_08
38165 AD56           83FB                   01    cmp bx, #1
38166 AD59           75           79              jne apmreal_ok
38167 AD5B           83F9                   03    cmp cx, #3
38168 AD5E           74           0C              je apmreal_07_poweroff
38169 AD60           83F9                   02    cmp cx, #2
38170 AD63           74           14              je apmreal_07_suspend
38171 AD65           83F9                   01    cmp cx, #1
38172 AD68           74           1E              je apmreal_07_standby
38173 AD6A           75           68              jne apmreal_ok
38174                       0000AD6C            apmreal_07_poweroff:
38175 AD6C           FA                           cli
38176 AD6D           BA                   8900    mov dx, #0x8900
38177 AD70           B8                   ACD8    mov ax, #apmreal_07_poweroff_str
38178 AD73           E8         FF4A              call apmreal_out_str
38179                       0000AD76            apmreal_07_1:
38180 AD76           F4                           hlt
38181 AD77           EB           FD              jmp apmreal_07_1
38182                       0000AD79            apmreal_07_suspend:
38183 AD79     66    52                           push edx
38184 AD7B           BA                   8900    mov dx, #0x8900
38185 AD7E           B8                   ACE1    mov ax, #apmreal_07_suspend_str
38186 AD81           E8         FF3C              call apmreal_out_str
38187 AD84     66    5A                           pop edx
38188 AD86           EB           4C              jmp apmreal_ok
38189                       0000AD88            apmreal_07_standby:
38190 AD88     66    52                           push edx
38191 AD8A           BA                   8900    mov dx, #0x8900
38192 AD8D           B8                   ACE9    mov ax, #apmreal_07_standby_str
38193 AD90           E8         FF2D              call apmreal_out_str
38194 AD93     66    5A                           pop edx
38195 AD95           EB           3D              jmp apmreal_ok
38196                                           ;-----------------
38197                                           ; APM Enable / Disable
38198                       0000AD97            apmreal_08:
38199 AD97           3C                     08    cmp al, #0x08
38200 AD99           75           02              jne apmreal_0a
38201 AD9B           EB           37              jmp apmreal_ok
38202                                           ;-----------------
38203                                           ; Get Power Status
38204                       0000AD9D            apmreal_0a:
38205 AD9D           3C                     0A    cmp al, #0x0a
38206 AD9F           75           10              jne apmreal_0b
38207 ADA1           B7                     01    mov bh, #0x01
38208 ADA3           B3                     FF    mov bl, #0xff
38209 ADA5           B5                     80    mov ch, #0x80
38210 ADA7           B1                     FF    mov cl, #0xff
38211 ADA9           BA                   FFFF    mov dx, #0xffff
38212 ADAC           BE                   0000    mov si, #0
38213 ADAF           EB           23              jmp apmreal_ok
38214                                           ;-----------------
38215                                           ; Get PM Event
38216                       0000ADB1            apmreal_0b:
38217 ADB1           3C                     0B    cmp al, #0x0b
38218 ADB3           75           04              jne apmreal_0e
38219 ADB5           B4                     80    mov ah, #0x80
38220 ADB7           EB           20              jmp apmreal_error
38221                                           ;-----------------
38222                                           ; APM Driver Version
38223                       0000ADB9            apmreal_0e:
38224 ADB9           3C                     0E    cmp al, #0x0e
38225 ADBB           75           06              jne apmreal_0f
38226 ADBD           B4                     01    mov ah, #1
38227 ADBF           B0                     02    mov al, #2
38228 ADC1           EB           11              jmp apmreal_ok
38229                                           ;-----------------
38230                                           ; APM Engage / Disengage
38231                       0000ADC3            apmreal_0f:
38232 ADC3           3C                     0F    cmp al, #0x0f
38233 ADC5           75           02              jne apmreal_10
38234 ADC7           EB           0B              jmp apmreal_ok
38235                                           ;-----------------
38236                                           ; APM Get Capabilities
38237                       0000ADC9            apmreal_10:
38238 ADC9           3C                     10    cmp al, #0x10
38239 ADCB           75           0C              jne apmreal_unimplemented
38240 ADCD           B3                     00    mov bl, #0
38241 ADCF           B9                   0000    mov cx, #0
38242 ADD2           EB           00              jmp apmreal_ok
38243                                           ;-----------------
38244                       0000ADD4            apmreal_ok:
38245 ADD4           9D                           popf
38246 ADD5           F8                           clc
38247 ADD6           E9         F8C6              jmp iret_modify_cf
38248                       0000ADD9            apmreal_unimplemented:
38249                       0000ADD9            apmreal_error:
38250 ADD9           9D                           popf
38251 ADDA           F9                           stc
38252 ADDB           E9         F8C1              jmp iret_modify_cf
38253 ADDE                  00000010                .align 16
38254                       0000ADE0            gdt_base:
38255 ADE0                      0000                .word 0,0
38256 ADE4                        00                .byte 0,0,0,0
38257                       0000ADE8            gdt_entry_pm_32bit_cs:
38258 ADE8                      FFFF                .word 0xffff, 0x0000
38259 ADEC                        00                .byte 0x00, 0x9b, 0xcf, 0x00
38260                       0000ADF0            gdt_entry_pm_16bit_cs:
38261 ADF0                      FFFF                .word 0xffff, 0x0000
38262 ADF4                        0F                .byte 0xf0000 >> 16, 0x9b, 0x8f, 0x0
38263                       0000ADF8            gdt_entry_pm_32bit_ds:
38264 ADF8                      FFFF                .word 0xffff, 0x0000
38265 ADFC                        00                .byte 0x0, 0x93, 0xcf, 0x0
38266                       0000AE00            gdt_entry_pm_16bit_ds:
38267 AE00                      FFFF                .word 0xffff, 0x0000
38268 AE04                        00                .byte 0x0, 0x93, 0x8f, 0x0
38269                       0000AE08            gdt_entry_end:
38270                       0000AE08            protmode_gdtdesc:
38271 AE08                      0027                .word (gdt_entry_end - gdt_base) - 1
38272 AE0A                  000FADE0                .long gdt_base | 0xf0000
38273                       0000AE0E            realmode_gdtdesc:
38274 AE0E                      FFFF                .word 0xffff
38275 AE10                  00000000                .long 0x0
38276                       0000AE14            Upcall:
38277                                               ; Do an upcall into 32 bit space
38278                                               ;
38279                                               ; Input:
38280                                               ; bx: index of function to call
38281                                               ; Ouput:
38282                                               ; dx, ax: 32 bit result of call (even if 'void' is expected)
38283                                               ; Save caller state, stack frame offsets listed below
38284 AE14           9C                             pushf
38285 AE15           FA                             cli
38286 AE16           1E                             push ds
38287 AE17           06                             push es
38288 AE18           16                             push ss
38289 AE19     66    54                             push esp
38290                                               ; Calculate protected-mode esp from ss:sp
38291 AE1B     66    81E4             0000FFFF      and esp, #0xffff
38292 AE22     66    31C0                           xor eax, eax
38293 AE25           8CD0                           mov ax, ss
38294 AE27     66    C1E0                   04      shl eax, #4
38295 AE2B     66    01C4                           add esp, eax
38296                                               ; Switch to protected mode
38297 AE2E           2E                             seg cs
38298 AE2F         0F0116       AE08                lgdt protmode_gdtdesc
38299 AE34         0F20C0                           mov eax, cr0
38300 AE37           0C                     01      or al, #0x1 ; protected mode on
38301 AE39         0F22C0                           mov cr0, eax
38302 AE3C     66    EA     000FAE44      0008      jmpf DWORD (0xf0000|upcall1), #(gdt_entry_pm_32bit_cs - gdt_base)
38303                       0000AE44            upcall1:
38304                                               USE32
38305 AE44     66    B8                   0018      mov ax, #(gdt_entry_pm_32bit_ds - gdt_base)
38306 AE48           8ED8                           mov ds, ax
38307 AE4A           8EC0                           mov es, ax
38308 AE4C           8ED0                           mov ss, ax
38309                                               ; Marshal arguments and call 32-bit function
38310 AE4E           B9               00000008      mov ecx, #32/4
38311                       0000AE53            upcall2:
38312 AE53           FF7424       2A                push 32 -4+14[esp]
38313 AE57           E2           FA                loop upcall2
38314 AE59           A1     000EA000                mov eax, [0x000EA000 + 0]
38315 AE5E           FFD0                           call eax
38316 AE60           83C4                   20      add esp, #32
38317 AE63           89C1                           mov ecx, eax ; Result in ecx
38318                                               ; Restore real-mode stack pointer
38319 AE65           31C0                           xor eax, eax
38320 AE67     66    8B4424       04                mov ax, 4[esp]
38321 AE6C     66    89C3                           mov bx, ax ; Real-mode ss in bx
38322 AE6F           C1E0                   04      shl eax, 4
38323 AE72           29C4                           sub esp, eax
38324                                               ; Return to real mode
38325 AE74           EA     0000AE7B      0010      jmpf upcall3, #(gdt_entry_pm_16bit_cs - gdt_base)
38326                       0000AE7B            upcall3:
38327                                               USE16
38328 AE7B           B8                   0020      mov ax, #(gdt_entry_pm_16bit_ds - gdt_base)
38329 AE7E           8ED8                           mov ds, ax
38330 AE80           8EC0                           mov es, ax
38331 AE82           8ED0                           mov ss, ax
38332 AE84         0F20C0                           mov eax, cr0
38333 AE87           24                     FE      and al, #0xfe ; protected mode off
38334 AE89         0F22C0                           mov cr0, eax
38335 AE8C           EA         AE91      F000      jmpf upcall4, #0xf0000>>4
38336                       0000AE91            upcall4:
38337 AE91           2E                             seg cs
38338 AE92         0F0116       AE0E                lgdt realmode_gdtdesc
38339                                               ; Restore real-mode ss
38340 AE97           8ED3                           mov ss, bx
38341                                               ; Convert result into dx:ax format
38342 AE99     66    89C8                           mov eax, ecx
38343 AE9C     66    C1C8                   10      ror eax, #16
38344 AEA0           89C2                           mov dx, ax
38345 AEA2     66    C1C8                   10      ror eax, #16
38346                                               ; Restore caller state and return
38347 AEA6     66    5C                             pop esp
38348 AEA8           5B                             pop bx ; skip ss
38349 AEA9           07                             pop es
38350 AEAA           1F                             pop ds
38351 AEAB           9D                             popf
38352 AEAC           C3                             ret
38353                                           MACRO DoUpcall
38354                                               mov bx, #?1
38355                                               jmp Upcall
38356                                           MEND
38357                       0000AEAD            _TCGInterruptHandler: DoUpcall(0)
 +a   AEAD           BB                   0000      mov bx, #0
 +a   AEB0           E9         FF61                jmp Upcall
38358                       0000AEB3            _tcpa_acpi_init: DoUpcall(1)
 +a   AEB3           BB                   0001      mov bx, #1
 +a   AEB6           E9         FF5B                jmp Upcall
38359                       0000AEB9            _tcpa_extend_acpi_log: DoUpcall(2)
 +a   AEB9           BB                   0002      mov bx, #2
 +a   AEBC           E9         FF55                jmp Upcall
38360                       0000AEBF            _tcpa_calling_int19h: DoUpcall(3)
 +a   AEBF           BB                   0003      mov bx, #3
 +a   AEC2           E9         FF4F                jmp Upcall
38361                       0000AEC5            _tcpa_returned_int19h: DoUpcall(4)
 +a   AEC5           BB                   0004      mov bx, #4
 +a   AEC8           E9         FF49                jmp Upcall
38362                       0000AECB            _tcpa_add_event_separators: DoUpcall(5)
 +a   AECB           BB                   0005      mov bx, #5
 +a   AECE           E9         FF43                jmp Upcall
38363                       0000AED1            _tcpa_wake_event: DoUpcall(6)
 +a   AED1           BB                   0006      mov bx, #6
 +a   AED4           E9         FF3D                jmp Upcall
38364                       0000AED7            _tcpa_add_bootdevice: DoUpcall(7)
 +a   AED7           BB                   0007      mov bx, #7
 +a   AEDA           E9         FF37                jmp Upcall
38365                       0000AEDD            _tcpa_start_option_rom_scan: DoUpcall(8)
 +a   AEDD           BB                   0008      mov bx, #8
 +a   AEE0           E9         FF31                jmp Upcall
38366                       0000AEE3            _tcpa_option_rom: DoUpcall(9)
 +a   AEE3           BB                   0009      mov bx, #9
 +a   AEE6           E9         FF2B                jmp Upcall
38367                       0000AEE9            _tcpa_ipl: DoUpcall(10)
 +a   AEE9           BB                   000A      mov bx, #10
 +a   AEEC           E9         FF25                jmp Upcall
38368                       0000AEEF            _tcpa_measure_post: DoUpcall(11)
 +a   AEEF           BB                   000B      mov bx, #11
 +a   AEF2           E9         FF1F                jmp Upcall
38369                       0000AEF5            _tcpa_initialize_tpm: DoUpcall(12)
 +a   AEF5           BB                   000C      mov bx, #12
 +a   AEF8           E9         FF19                jmp Upcall
38370                       0000AEFB            _get_s3_waking_vector: DoUpcall(13)
 +a   AEFB           BB                   000D      mov bx, #13
 +a   AEFE           E9         FF13                jmp Upcall
38371                       0000AF01            _pmm: DoUpcall(14)
 +a   AF01           BB                   000E      mov bx, #14
 +a   AF04           E9         FF0D                jmp Upcall
38372                                           ! 6674 endasm
38373                                           !BCC_ENDASM
38374                                           ! 6675 #asm
38375                                           !BCC_ASM
38376                       00000012            _int70_function.ds	set	$12
38377                       00000014            _int70_function.iret_addr	set	$14
38378                       00000002            _int70_function.regs	set	2
38379                                           MACRO POST_MEASURE
38380                                            push word #0x000f
38381                                            push #?2
38382                                            push word #0x000f
38383                                            push #?1
38384                                            call _tcpa_measure_post
38385                                            add sp, #8
38386                                           MEND
38387                                           ! 6684 endasm
38388                                           !BCC_ENDASM
38389                                           ! 6685 void
38390                                           ! Register BX used in function int70_function
38391                                           ! 6686 tcpa_do_measure_POSTs()
38392                                           ! 6687 {
38393                                           export	_tcpa_do_measure_POSTs
38394                       0000AF07            _tcpa_do_measure_POSTs:
38395                                           ! 6688 #asm
38396                                           !BCC_ASM
38397                                            POST_MEASURE(post, nmi)
 +a   AF07           6A                     0F   push word #0x000f
 +a   AF09           68                   E2C3   push # nmi
 +a   AF0C           6A                     0F   push word #0x000f
 +a   AF0E           68                   E05B   push #post
 +a   AF11           E8         FFDB             call _tcpa_measure_post
 +a   AF14           83C4                   08   add sp, #8
38398                                            POST_MEASURE(floppy_drive_post, hard_drive_post)
 +a   AF17           6A                     0F   push word #0x000f
 +a   AF19           68                   A7F8   push # hard_drive_post
 +a   AF1C           6A                     0F   push word #0x000f
 +a   AF1E           68                   A771   push #floppy_drive_post
 +a   AF21           E8         FFCB             call _tcpa_measure_post
 +a   AF24           83C4                   08   add sp, #8
38399                                            POST_MEASURE(hard_drive_post, ebda_post)
 +a   AF27           6A                     0F   push word #0x000f
 +a   AF29           68                   AA20   push # ebda_post
 +a   AF2C           6A                     0F   push word #0x000f
 +a   AF2E           68                   A7F8   push #hard_drive_post
 +a   AF31           E8         FFBB             call _tcpa_measure_post
 +a   AF34           83C4                   08   add sp, #8
38400                                            POST_MEASURE(ebda_post, eoi_jmp_post)
 +a   AF37           6A                     0F   push word #0x000f
 +a   AF39           68                   AA35   push # eoi_jmp_post
 +a   AF3C           6A                     0F   push word #0x000f
 +a   AF3E           68                   AA20   push #ebda_post
 +a   AF41           E8         FFAB             call _tcpa_measure_post
 +a   AF44           83C4                   08   add sp, #8
38401                                            POST_MEASURE(eoi_jmp_post, timer_tick_post)
 +a   AF47           6A                     0F   push word #0x000f
 +a   AF49           68                   AA86   push # timer_tick_post
 +a   AF4C           6A                     0F   push word #0x000f
 +a   AF4E           68                   AA35   push #eoi_jmp_post
 +a   AF51           E8         FF9B             call _tcpa_measure_post
 +a   AF54           83C4                   08   add sp, #8
38402                                            POST_MEASURE(timer_tick_post, int76_handler)
 +a   AF57           6A                     0F   push word #0x000f
 +a   AF59           68                   AAFD   push # int76_handler
 +a   AF5C           6A                     0F   push word #0x000f
 +a   AF5E           68                   AA86   push #timer_tick_post
 +a   AF61           E8         FF8B             call _tcpa_measure_post
 +a   AF64           83C4                   08   add sp, #8
38403 AF67           C3                          ret
38404                                           ! 6696 endasm
38405                                           !BCC_ENDASM
38406                                           ! 6697 }
38407 AF68           C3                         ret
38408                                           ! 6698   void
38409                                           ! 6699 int1a_function32(regs, ES, DS, FLAGS)
38410                                           ! 6700   pushad_regs_t regs;
38411                                           export	_int1a_function32
38412                       0000AF69            _int1a_function32:
38413                                           !BCC_EOS
38414                                           ! 6701   Bit16u ES, DS, FLAGS;
38415                                           !BCC_EOS
38416                                           ! 6702 {
38417                                           ! 6703  Bit16u rc;
38418                                           !BCC_EOS
38419                                           ! 6704  ;
38420 AF69           55                         push	bp
38421 AF6A           89E5                       mov	bp,sp
38422 AF6C           4C                         dec	sp
38423 AF6D           4C                         dec	sp
38424                                           !BCC_EOS
38425                                           ! 6705  switch (regs.u.r8.ah) {
38426 AF6E           8A46         21            mov	al,$21[bp]
38427 AF71           E9         00BC            br 	.759
38428                                           ! 6706  case 0xbb:
38429                                           ! 6707   if (regs.u.r8.al != 0 &&
38430                       0000AF74            .75A:
38431                                           ! 6708       regs.u.r32.ebx != 0x41504354L) {
38432                                           ! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
38433 AF74           8A46         20            mov	al,$20[bp]
38434 AF77           84C0                       test	al,al
38435 AF79           74           25            je  	.75B
38436                       0000AF7B            .75D:
38437                                           ! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
38438                                           ! Debug: expression subtree swapping
38439 AF7B           B8                   4354  mov	ax,#$4354
38440 AF7E           BB                   4150  mov	bx,#$4150
38441 AF81           53                         push	bx
38442 AF82           50                         push	ax
38443 AF83           8B46         14            mov	ax,$14[bp]
38444 AF86           8B5E         16            mov	bx,$16[bp]
38445 AF89           8D7E         FA            lea	di,-2+..FFD9[bp]
38446 AF8C           E8         513C            call	lcmpul
38447 AF8F           8D66         FE            lea	sp,2+..FFD9[bp]
38448 AF92           74           0C            je  	.75B
38449                       0000AF94            .75C:
38450                                           ! 6709       FLAGS |= 0x0001;
38451                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38452 AF94           8B46         28            mov	ax,$28[bp]
38453 AF97           0C                     01  or	al,*1
38454 AF99           8946         28            mov	$28[bp],ax
38455                                           !BCC_EOS
38456                                           ! 6710       return;
38457 AF9C           89EC                       mov	sp,bp
38458 AF9E           5D                         pop	bp
38459 AF9F           C3                         ret
38460                                           !BCC_EOS
38461                                           ! 6711   }
38462                                           ! 6712   switch(regs.u.r8.al) {
38463                       0000AFA0            .75B:
38464 AFA0           8A46         20            mov	al,$20[bp]
38465 AFA3           EB           58            jmp .760
38466                                           ! 6713   case 0x00:
38467                                           ! 6714   case 0x01:
38468                       0000AFA5            .761:
38469                                           ! 6715   case 0x02:
38470                       0000AFA5            .762:
38471                                           ! 6716   case 0x03:
38472                       0000AFA5            .763:
38473                                           ! 6717   case 0x04:
38474                       0000AFA5            .764:
38475                                           ! 6718   case 0x05:
38476                       0000AFA5            .765:
38477                                           ! 6719   case 0x06:
38478                       0000AFA5            .766:
38479                                           ! 6720   case 0x07:
38480                       0000AFA5            .767:
38481                                           ! 6721    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
38482                       0000AFA5            .768:
38483                                           ! 6722                        ES, DS,
38484                                           ! 6723                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
38485                                           ! Debug: expression subtree swapping
38486                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
38487 AFA5           E8         56A5            call	_get_SS
38488                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
38489 AFA8           31DB                       xor	bx,bx
38490                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
38491 AFAA           BF                   0004  mov	di,*4
38492 AFAD           E8         5197            call	lslul
38493 AFB0           53                         push	bx
38494 AFB1           50                         push	ax
38495                                           ! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
38496 AFB2           89E8                       mov	ax,bp
38497 AFB4           05                   0028  add	ax,*$28
38498 AFB7           31DB                       xor	bx,bx
38499                                           ! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
38500 AFB9           8D7E         FA            lea	di,-2+..FFD9[bp]
38501 AFBC           E8         5104            call	laddul
38502 AFBF           83C4                   04  add	sp,*4
38503                                           ! Debug: list unsigned long = bx+0 (used reg = )
38504 AFC2           53                         push	bx
38505 AFC3           50                         push	ax
38506                                           ! Debug: list unsigned short DS = [S+8+$24] (used reg = )
38507 AFC4           FF76         26            push	$26[bp]
38508                                           ! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
38509 AFC7           FF76         24            push	$24[bp]
38510                                           ! Debug: expression subtree swapping
38511                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
38512 AFCA           E8         5680            call	_get_SS
38513                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
38514 AFCD           31DB                       xor	bx,bx
38515                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
38516 AFCF           BF                   0004  mov	di,*4
38517 AFD2           E8         5172            call	lslul
38518 AFD5           53                         push	bx
38519 AFD6           50                         push	ax
38520                                           ! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
38521 AFD7           89E8                       mov	ax,bp
38522 AFD9           05                   0004  add	ax,*4
38523 AFDC           31DB                       xor	bx,bx
38524                                           ! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
38525 AFDE           8D7E         F2            lea	di,-$A+..FFD9[bp]
38526 AFE1           E8         50DF            call	laddul
38527 AFE4           83C4                   04  add	sp,*4
38528                                           ! Debug: list unsigned long = bx+0 (used reg = )
38529 AFE7           53                         push	bx
38530 AFE8           50                         push	ax
38531                                           ! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
38532 AFE9           E8         FEC1            call	_TCGInterruptHandler
38533 AFEC           89D3                       mov	bx,dx
38534 AFEE           83C4                   0C  add	sp,*$C
38535                                           !BCC_EOS
38536                                           ! 6724    break;
38537 AFF1           EB           2F            jmp .75E
38538                                           !BCC_EOS
38539                                           ! 6725   default:
38540                                           ! 6726    FLAGS |= 0x0001;
38541                       0000AFF3            .769:
38542                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38543 AFF3           8B46         28            mov	ax,$28[bp]
38544 AFF6           0C                     01  or	al,*1
38545 AFF8           8946         28            mov	$28[bp],ax
38546                                           !BCC_EOS
38547                                           ! 6727   }
38548                                           ! 6728   break;
38549 AFFB           EB           25            jmp .75E
38550                       0000AFFD            .760:
38551 AFFD           2C                     00  sub	al,*0
38552 AFFF           72           F2            jb 	.769
38553 B001           3C                     07  cmp	al,*7
38554 B003           77           1B            ja  	.76A
38555 B005           30E4                       xor	ah,ah
38556 B007           D1E0                       shl	ax,*1
38557 B009           89C3                       mov	bx,ax
38558 B00B           2E                         seg	cs
38559 B00C           FFA7       B010            br	.76B[bx]
38560                       0000B010            .76B:
38561 B010                      AFA5            .word	.761
38562 B012                      AFA5            .word	.762
38563 B014                      AFA5            .word	.763
38564 B016                      AFA5            .word	.764
38565 B018                      AFA5            .word	.765
38566 B01A                      AFA5            .word	.766
38567 B01C                      AFA5            .word	.767
38568 B01E                      AFA5            .word	.768
38569                       0000B020            .76A:
38570 B020           EB           D1            jmp	.769
38571                       0000B022            .75E:
38572 B022           EB           14            jmp .757
38573                                           !BCC_EOS
38574                                           ! 6729  default:
38575                                           ! 6730   FLAGS |= 0x0001;
38576                       0000B024            .76C:
38577                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38578 B024           8B46         28            mov	ax,$28[bp]
38579 B027           0C                     01  or	al,*1
38580 B029           8946         28            mov	$28[bp],ax
38581                                           !BCC_EOS
38582                                           ! 6731   break;
38583 B02C           EB           0A            jmp .757
38584                                           !BCC_EOS
38585                                           ! 6732  }
38586                                           ! 6733  ;
38587 B02E           EB           08            jmp .757
38588                       0000B030            .759:
38589 B030           2C                     BB  sub	al,#$BB
38590 B032         0F84         FF3E            beq 	.75A
38591 B036           EB           EC            jmp	.76C
38592                       0000B038            .757:
38593                       FFFFFFFC            ..FFD9	=	-4
38594                                           !BCC_EOS
38595                                           ! 6734 }
38596 B038           89EC                       mov	sp,bp
38597 B03A           5D                         pop	bp
38598 B03B           C3                         ret
38599                                           ! 6735 #asm
38600                                           !BCC_ASM
38601                       00000026            _int1a_function32.FLAGS	set	$26
38602                       00000024            _int1a_function32.DS	set	$24
38603                       00000022            _int1a_function32.ES	set	$22
38604                       00000002            _int1a_function32.regs	set	2
38605                                           ;--------------------
38606                                           use32 386
38607 B03C                  00000010            .align 16
38608                       0000B040            bios32_structure:
38609 B040                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
38610 B044                      B050              dw bios32_entry_point, 0xf ;; 32 bit physical address
38611 B048                        00              db 0 ;; revision level
38612                                             ;; length in paragraphs and checksum stored in a word to prevent errors
38613 B049                      CD01              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
38614 B04B                        00              db 0,0,0,0,0 ;; reserved
38615 B050                  00000010            .align 16
38616                       0000B050            bios32_entry_point:
38617 B050           9C                           pushfd
38618 B051           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
38619 B056           75           29              jne unknown_service
38620 B058           B8               80000000    mov eax, #0x80000000
38621 B05D     66    BA                   0CF8    mov dx, #0x0cf8
38622 B061           EF                           out dx, eax
38623 B062     66    BA                   0CFC    mov dx, #0x0cfc
38624 B066           ED                           in eax, dx
38625                                             ;; say ok if a device is present
38626 B067           3D               FFFFFFFF    cmp eax, #0xffffffff
38627 B06C           74           13              je unknown_service
38628 B06E           BB               000F0000    mov ebx, #0x000f0000
38629 B073           B9               00000000    mov ecx, #0
38630 B078           BA               0000B090    mov edx, #pcibios_protected
38631 B07D           30C0                         xor al, al
38632 B07F           EB           02              jmp bios32_end
38633                       0000B081            unknown_service:
38634 B081           B0                     80    mov al, #0x80
38635                       0000B083            bios32_end:
38636 B083           9D                           popfd
38637 B084           CB                           retf
38638 B085                  00000010            .align 16
38639                       0000B090            pcibios_protected:
38640 B090           9C                           pushfd
38641 B091           FA                           cli
38642 B092           56                           push esi
38643 B093           57                           push edi
38644 B094           3C                     01    cmp al, #0x01 ;; installation check
38645 B096           75           14              jne pci_pro_f02
38646 B098     66    BB                   0210    mov bx, #0x0210
38647 B09C     66    B9                   0000    mov cx, #0
38648 B0A0           BA               20494350    mov edx, #0x20494350 ;; "PCI "
38649 B0A5           B0                     01    mov al, #0x01
38650 B0A7           E9     0000011B              jmp pci_pro_ok
38651                       0000B0AC            pci_pro_f02: ;; find pci device
38652 B0AC           3C                     02    cmp al, #0x02
38653 B0AE           75           38              jne pci_pro_f03
38654 B0B0           C1E1                   10    shl ecx, #16
38655 B0B3     66    89D1                         mov cx, dx
38656 B0B6     66    31DB                         xor bx, bx
38657 B0B9     66    BF                   0000    mov di, #0x00
38658                       0000B0BD            pci_pro_devloop:
38659 B0BD           E8     0000010C              call pci_pro_select_reg
38660 B0C2     66    BA                   0CFC    mov dx, #0x0cfc
38661 B0C6           ED                           in eax, dx
38662 B0C7           39C8                         cmp eax, ecx
38663 B0C9           75           0D              jne pci_pro_nextdev
38664 B0CB     66    83FE                   00    cmp si, #0
38665 B0CF   7505    E9     000000F1              je pci_pro_ok
38666 B0D6     66    4E                           dec si
38667                       0000B0D8            pci_pro_nextdev:
38668 B0D8     66    43                           inc bx
38669 B0DA     66    81FB                 0100    cmp bx, #0x0100
38670 B0DF           75           DC              jne pci_pro_devloop
38671 B0E1           B4                     86    mov ah, #0x86
38672 B0E3           E9     000000DA              jmp pci_pro_fail
38673                       0000B0E8            pci_pro_f03: ;; find class code
38674 B0E8           3C                     03    cmp al, #0x03
38675 B0EA           75           35              jne pci_pro_f08
38676 B0EC     66    31DB                         xor bx, bx
38677 B0EF     66    BF                   0008    mov di, #0x08
38678                       0000B0F3            pci_pro_devloop2:
38679 B0F3           E8     000000D6              call pci_pro_select_reg
38680 B0F8     66    BA                   0CFC    mov dx, #0x0cfc
38681 B0FC           ED                           in eax, dx
38682 B0FD           C1E8                   08    shr eax, #8
38683 B100           39C8                         cmp eax, ecx
38684 B102           75           0D              jne pci_pro_nextdev2
38685 B104     66    83FE                   00    cmp si, #0
38686 B108   7505    E9     000000B8              je pci_pro_ok
38687 B10F     66    4E                           dec si
38688                       0000B111            pci_pro_nextdev2:
38689 B111     66    43                           inc bx
38690 B113     66    81FB                 0100    cmp bx, #0x0100
38691 B118           75           D9              jne pci_pro_devloop2
38692 B11A           B4                     86    mov ah, #0x86
38693 B11C           E9     000000A1              jmp pci_pro_fail
38694                       0000B121            pci_pro_f08: ;; read configuration byte
38695 B121           3C                     08    cmp al, #0x08
38696 B123           75           1B              jne pci_pro_f09
38697 B125           E8     000000A4              call pci_pro_select_reg
38698 B12A           52                           push edx
38699 B12B     66    89FA                         mov dx, di
38700 B12E     66    83E2                   03    and dx, #0x03
38701 B132     66    81C2                 0CFC    add dx, #0x0cfc
38702 B137           EC                           in al, dx
38703 B138           5A                           pop edx
38704 B139           88C1                         mov cl, al
38705 B13B           E9     00000087              jmp pci_pro_ok
38706                       0000B140            pci_pro_f09: ;; read configuration word
38707 B140           3C                     09    cmp al, #0x09
38708 B142           75           1A              jne pci_pro_f0a
38709 B144           E8     00000085              call pci_pro_select_reg
38710 B149           52                           push edx
38711 B14A     66    89FA                         mov dx, di
38712 B14D     66    83E2                   02    and dx, #0x02
38713 B151     66    81C2                 0CFC    add dx, #0x0cfc
38714 B156     66    ED                           in ax, dx
38715 B158           5A                           pop edx
38716 B159     66    89C1                         mov cx, ax
38717 B15C           EB           69              jmp pci_pro_ok
38718                       0000B15E            pci_pro_f0a: ;; read configuration dword
38719 B15E           3C                     0A    cmp al, #0x0a
38720 B160           75           10              jne pci_pro_f0b
38721 B162           E8     00000067              call pci_pro_select_reg
38722 B167           52                           push edx
38723 B168     66    BA                   0CFC    mov dx, #0x0cfc
38724 B16C           ED                           in eax, dx
38725 B16D           5A                           pop edx
38726 B16E           89C1                         mov ecx, eax
38727 B170           EB           55              jmp pci_pro_ok
38728                       0000B172            pci_pro_f0b: ;; write configuration byte
38729 B172           3C                     0B    cmp al, #0x0b
38730 B174           75           18              jne pci_pro_f0c
38731 B176           E8     00000053              call pci_pro_select_reg
38732 B17B           52                           push edx
38733 B17C     66    89FA                         mov dx, di
38734 B17F     66    83E2                   03    and dx, #0x03
38735 B183     66    81C2                 0CFC    add dx, #0x0cfc
38736 B188           88C8                         mov al, cl
38737 B18A           EE                           out dx, al
38738 B18B           5A                           pop edx
38739 B18C           EB           39              jmp pci_pro_ok
38740                       0000B18E            pci_pro_f0c: ;; write configuration word
38741 B18E           3C                     0C    cmp al, #0x0c
38742 B190           75           1A              jne pci_pro_f0d
38743 B192           E8     00000037              call pci_pro_select_reg
38744 B197           52                           push edx
38745 B198     66    89FA                         mov dx, di
38746 B19B     66    83E2                   02    and dx, #0x02
38747 B19F     66    81C2                 0CFC    add dx, #0x0cfc
38748 B1A4     66    89C8                         mov ax, cx
38749 B1A7     66    EF                           out dx, ax
38750 B1A9           5A                           pop edx
38751 B1AA           EB           1B              jmp pci_pro_ok
38752                       0000B1AC            pci_pro_f0d: ;; write configuration dword
38753 B1AC           3C                     0D    cmp al, #0x0d
38754 B1AE           75           10              jne pci_pro_unknown
38755 B1B0           E8     00000019              call pci_pro_select_reg
38756 B1B5           52                           push edx
38757 B1B6     66    BA                   0CFC    mov dx, #0x0cfc
38758 B1BA           89C8                         mov eax, ecx
38759 B1BC           EF                           out dx, eax
38760 B1BD           5A                           pop edx
38761 B1BE           EB           07              jmp pci_pro_ok
38762                       0000B1C0            pci_pro_unknown:
38763 B1C0           B4                     81    mov ah, #0x81
38764                       0000B1C2            pci_pro_fail:
38765 B1C2           5F                           pop edi
38766 B1C3           5E                           pop esi
38767 B1C4           9D                           popfd
38768 B1C5           F9                           stc
38769 B1C6           CB                           retf
38770                       0000B1C7            pci_pro_ok:
38771 B1C7           30E4                         xor ah, ah
38772 B1C9           5F                           pop edi
38773 B1CA           5E                           pop esi
38774 B1CB           9D                           popfd
38775 B1CC           F8                           clc
38776 B1CD           CB                           retf
38777                       0000B1CE            pci_pro_select_reg:
38778 B1CE           52                           push edx
38779 B1CF           B8               00800000    mov eax, #0x800000
38780 B1D4     66    89D8                         mov ax, bx
38781 B1D7           C1E0                   08    shl eax, #8
38782 B1DA     66    81E7                 00FF    and di, #0xff
38783 B1DF     66    09F8                         or ax, di
38784 B1E2           24                     FC    and al, #0xfc
38785 B1E4     66    BA                   0CF8    mov dx, #0x0cf8
38786 B1E8           EF                           out dx, eax
38787 B1E9           5A                           pop edx
38788 B1EA           C3                           ret
38789                                           use16 386
38790                       0000B1EB            pcibios_real:
38791 B1EB     66    50                           push eax
38792 B1ED           52                           push dx
38793 B1EE     66    B8               80000000    mov eax, #0x80000000
38794 B1F4           BA                   0CF8    mov dx, #0x0cf8
38795 B1F7     66    EF                           out dx, eax
38796 B1F9           BA                   0CFC    mov dx, #0x0cfc
38797 B1FC     66    ED                           in eax, dx
38798                                             ;; say ok if a device is present
38799 B1FE     66    3D               FFFFFFFF    cmp eax, #0xffffffff
38800 B204           75           07              jne pci_present
38801 B206           5A                           pop dx
38802 B207     66    58                           pop eax
38803 B209           B4                     FF    mov ah, #0xff
38804 B20B           F9                           stc
38805 B20C           C3                           ret
38806                       0000B20D            pci_present:
38807 B20D           5A                           pop dx
38808 B20E     66    58                           pop eax
38809 B210           3C                     01    cmp al, #0x01 ;; installation check
38810 B212           75           1A              jne pci_real_f02
38811 B214           B8                   0001    mov ax, #0x0001
38812 B217           BB                   0210    mov bx, #0x0210
38813 B21A           B9                   0000    mov cx, #0
38814 B21D     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
38815 B223     66    BF               000F0000    mov edi, #0xf0000
38816 B229           BF                   B090    mov di, #pcibios_protected
38817 B22C           F8                           clc
38818 B22D           C3                           ret
38819                       0000B22E            pci_real_f02: ;; find pci device
38820 B22E     66    56                           push esi
38821 B230     66    57                           push edi
38822 B232           3C                     02    cmp al, #0x02
38823 B234           75           34              jne pci_real_f03
38824 B236     66    C1E1                   10    shl ecx, #16
38825 B23A           89D1                         mov cx, dx
38826 B23C           31DB                         xor bx, bx
38827 B23E           BF                   0000    mov di, #0x00
38828                       0000B241            pci_real_devloop:
38829 B241           E8         012F              call pci_real_select_reg
38830 B244           BA                   0CFC    mov dx, #0x0cfc
38831 B247     66    ED                           in eax, dx
38832 B249     66    39C8                         cmp eax, ecx
38833 B24C           75           09              jne pci_real_nextdev
38834 B24E           83FE                   00    cmp si, #0
38835 B251   7503    E9         0115              je pci_real_ok
38836 B256           4E                           dec si
38837                       0000B257            pci_real_nextdev:
38838 B257           43                           inc bx
38839 B258           81FB                 0100    cmp bx, #0x0100
38840 B25C           75           E3              jne pci_real_devloop
38841 B25E           89CA                         mov dx, cx
38842 B260     66    C1E9                   10    shr ecx, #16
38843 B264           B8                   8602    mov ax, #0x8602
38844 B267           E9         00FB              jmp pci_real_fail
38845                       0000B26A            pci_real_f03: ;; find class code
38846 B26A           3C                     03    cmp al, #0x03
38847 B26C           75           32              jne pci_real_f08
38848 B26E           31DB                         xor bx, bx
38849 B270           BF                   0008    mov di, #0x08
38850                       0000B273            pci_real_devloop2:
38851 B273           E8         00FD              call pci_real_select_reg
38852 B276           BA                   0CFC    mov dx, #0x0cfc
38853 B279     66    ED                           in eax, dx
38854 B27B     66    C1E8                   08    shr eax, #8
38855 B27F     66    39C8                         cmp eax, ecx
38856 B282           75           09              jne pci_real_nextdev2
38857 B284           83FE                   00    cmp si, #0
38858 B287   7503    E9         00DF              je pci_real_ok
38859 B28C           4E                           dec si
38860                       0000B28D            pci_real_nextdev2:
38861 B28D           43                           inc bx
38862 B28E           81FB                 0100    cmp bx, #0x0100
38863 B292           75           DF              jne pci_real_devloop2
38864 B294           89CA                         mov dx, cx
38865 B296     66    C1E9                   10    shr ecx, #16
38866 B29A           B8                   8603    mov ax, #0x8603
38867 B29D           E9         00C5              jmp pci_real_fail
38868                       0000B2A0            pci_real_f08: ;; read configuration byte
38869 B2A0           3C                     08    cmp al, #0x08
38870 B2A2           75           14              jne pci_real_f09
38871 B2A4           E8         00CC              call pci_real_select_reg
38872 B2A7           52                           push dx
38873 B2A8           89FA                         mov dx, di
38874 B2AA           83E2                   03    and dx, #0x03
38875 B2AD           81C2                 0CFC    add dx, #0x0cfc
38876 B2B1           EC                           in al, dx
38877 B2B2           5A                           pop dx
38878 B2B3           88C1                         mov cl, al
38879 B2B5           E9         00B3              jmp pci_real_ok
38880                       0000B2B8            pci_real_f09: ;; read configuration word
38881 B2B8           3C                     09    cmp al, #0x09
38882 B2BA           75           14              jne pci_real_f0a
38883 B2BC           E8         00B4              call pci_real_select_reg
38884 B2BF           52                           push dx
38885 B2C0           89FA                         mov dx, di
38886 B2C2           83E2                   02    and dx, #0x02
38887 B2C5           81C2                 0CFC    add dx, #0x0cfc
38888 B2C9           ED                           in ax, dx
38889 B2CA           5A                           pop dx
38890 B2CB           89C1                         mov cx, ax
38891 B2CD           E9         009B              jmp pci_real_ok
38892                       0000B2D0            pci_real_f0a: ;; read configuration dword
38893 B2D0           3C                     0A    cmp al, #0x0a
38894 B2D2           75           10              jne pci_real_f0b
38895 B2D4           E8         009C              call pci_real_select_reg
38896 B2D7           52                           push dx
38897 B2D8           BA                   0CFC    mov dx, #0x0cfc
38898 B2DB     66    ED                           in eax, dx
38899 B2DD           5A                           pop dx
38900 B2DE     66    89C1                         mov ecx, eax
38901 B2E1           E9         0087              jmp pci_real_ok
38902                       0000B2E4            pci_real_f0b: ;; write configuration byte
38903 B2E4           3C                     0B    cmp al, #0x0b
38904 B2E6           75           13              jne pci_real_f0c
38905 B2E8           E8         0088              call pci_real_select_reg
38906 B2EB           52                           push dx
38907 B2EC           89FA                         mov dx, di
38908 B2EE           83E2                   03    and dx, #0x03
38909 B2F1           81C2                 0CFC    add dx, #0x0cfc
38910 B2F5           88C8                         mov al, cl
38911 B2F7           EE                           out dx, al
38912 B2F8           5A                           pop dx
38913 B2F9           EB           70              jmp pci_real_ok
38914                       0000B2FB            pci_real_f0c: ;; write configuration word
38915 B2FB           3C                     0C    cmp al, #0x0c
38916 B2FD           75           13              jne pci_real_f0d
38917 B2FF           E8         0071              call pci_real_select_reg
38918 B302           52                           push dx
38919 B303           89FA                         mov dx, di
38920 B305           83E2                   02    and dx, #0x02
38921 B308           81C2                 0CFC    add dx, #0x0cfc
38922 B30C           89C8                         mov ax, cx
38923 B30E           EF                           out dx, ax
38924 B30F           5A                           pop dx
38925 B310           EB           59              jmp pci_real_ok
38926                       0000B312            pci_real_f0d: ;; write configuration dword
38927 B312           3C                     0D    cmp al, #0x0d
38928 B314           75           0F              jne pci_real_f0e
38929 B316           E8         005A              call pci_real_select_reg
38930 B319           52                           push dx
38931 B31A           BA                   0CFC    mov dx, #0x0cfc
38932 B31D     66    89C8                         mov eax, ecx
38933 B320     66    EF                           out dx, eax
38934 B322           5A                           pop dx
38935 B323           EB           46              jmp pci_real_ok
38936                       0000B325            pci_real_f0e: ;; get irq routing options
38937 B325           3C                     0E    cmp al, #0x0e
38938 B327           75           3A              jne pci_real_unknown
38939 B329           26                           SEG ES
38940 B32A           833D                   60    cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
38941 B32D           72           2B              jb pci_real_too_small
38942 B32F           26                           SEG ES
38943 B330           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
38944 B334           9C                           pushf
38945 B335           1E                           push ds
38946 B336           06                           push es
38947 B337           51                           push cx
38948 B338           56                           push si
38949 B339           57                           push di
38950 B33A           FC                           cld
38951 B33B           BE                   B3B0    mov si, #pci_routing_table_structure_start
38952 B33E           0E                           push cs
38953 B33F           1F                           pop ds
38954 B340           26                           SEG ES
38955 B341           8B4D         02              mov cx, [di+2]
38956 B344           26                           SEG ES
38957 B345           8E45         04              mov es, [di+4]
38958 B348           89CF                         mov di, cx
38959 B34A           B9                   0060    mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
38960 B34D           F3                           rep
38961 B34E           A4                               movsb
38962 B34F           5F                           pop di
38963 B350           5E                           pop si
38964 B351           59                           pop cx
38965 B352           07                           pop es
38966 B353           1F                           pop ds
38967 B354           9D                           popf
38968 B355           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
38969 B358           EB           11              jmp pci_real_ok
38970                       0000B35A            pci_real_too_small:
38971 B35A           26                           SEG ES
38972 B35B           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
38973 B35F           B4                     89    mov ah, #0x89
38974 B361           EB           02              jmp pci_real_fail
38975                       0000B363            pci_real_unknown:
38976 B363           B4                     81    mov ah, #0x81
38977                       0000B365            pci_real_fail:
38978 B365     66    5F                           pop edi
38979 B367     66    5E                           pop esi
38980 B369           F9                           stc
38981 B36A           C3                           ret
38982                       0000B36B            pci_real_ok:
38983 B36B           30E4                         xor ah, ah
38984 B36D     66    5F                           pop edi
38985 B36F     66    5E                           pop esi
38986 B371           F8                           clc
38987 B372           C3                           ret
38988                       0000B373            pci_real_select_reg:
38989 B373           52                           push dx
38990 B374     66    B8               00800000    mov eax, #0x800000
38991 B37A           89D8                         mov ax, bx
38992 B37C     66    C1E0                   08    shl eax, #8
38993 B380           81E7                 00FF    and di, #0xff
38994 B384           09F8                         or ax, di
38995 B386           24                     FC    and al, #0xfc
38996 B388           BA                   0CF8    mov dx, #0x0cf8
38997 B38B     66    EF                           out dx, eax
38998 B38D           5A                           pop dx
38999 B38E           C3                           ret
39000 B38F                  00000010            .align 16
39001                       0000B390            pci_routing_table_structure:
39002 B390                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
39003 B394                        00              db 0, 1 ;; version
39004 B396                      0080              dw 32 + (6 * 16) ;; table size
39005 B398                        00              db 0 ;; PCI interrupt router bus
39006 B399                        08              db 0x08 ;; PCI interrupt router DevFunc
39007 B39A                      0000              dw 0x0000 ;; PCI exclusive IRQs
39008 B39C                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
39009 B39E                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
39010 B3A0                      0000              dw 0,0 ;; Miniport data
39011 B3A4                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
39012 B3AF                        37              db 0x37 ;; checksum
39013                       0000B3B0            pci_routing_table_structure_start:
39014                                             ;; first slot entry PCI-to-ISA (embedded)
39015 B3B0                        00              db 0 ;; pci bus number
39016 B3B1                        08              db 0x08 ;; pci device number (bit 7-3)
39017 B3B2                        61              db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
39018 B3B3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39019 B3B5                        62              db 0x62 ;; link value INTB#
39020 B3B6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39021 B3B8                        63              db 0x63 ;; link value INTC#
39022 B3B9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39023 B3BB                        60              db 0x60 ;; link value INTD#
39024 B3BC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39025 B3BE                        00              db 0 ;; physical slot (0 = embedded)
39026 B3BF                        00              db 0 ;; reserved
39027                                             ;; second slot entry: 1st PCI slot
39028 B3C0                        00              db 0 ;; pci bus number
39029 B3C1                        10              db 0x10 ;; pci device number (bit 7-3)
39030 B3C2                        62              db 0x62 ;; link value INTA#
39031 B3C3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39032 B3C5                        63              db 0x63 ;; link value INTB#
39033 B3C6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39034 B3C8                        60              db 0x60 ;; link value INTC#
39035 B3C9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39036 B3CB                        61              db 0x61 ;; link value INTD#
39037 B3CC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39038 B3CE                        01              db 1 ;; physical slot (0 = embedded)
39039 B3CF                        00              db 0 ;; reserved
39040                                             ;; third slot entry: 2nd PCI slot
39041 B3D0                        00              db 0 ;; pci bus number
39042 B3D1                        18              db 0x18 ;; pci device number (bit 7-3)
39043 B3D2                        63              db 0x63 ;; link value INTA#
39044 B3D3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39045 B3D5                        60              db 0x60 ;; link value INTB#
39046 B3D6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39047 B3D8                        61              db 0x61 ;; link value INTC#
39048 B3D9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39049 B3DB                        62              db 0x62 ;; link value INTD#
39050 B3DC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39051 B3DE                        02              db 2 ;; physical slot (0 = embedded)
39052 B3DF                        00              db 0 ;; reserved
39053                                             ;; 4th slot entry: 3rd PCI slot
39054 B3E0                        00              db 0 ;; pci bus number
39055 B3E1                        20              db 0x20 ;; pci device number (bit 7-3)
39056 B3E2                        60              db 0x60 ;; link value INTA#
39057 B3E3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39058 B3E5                        61              db 0x61 ;; link value INTB#
39059 B3E6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39060 B3E8                        62              db 0x62 ;; link value INTC#
39061 B3E9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39062 B3EB                        63              db 0x63 ;; link value INTD#
39063 B3EC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39064 B3EE                        03              db 3 ;; physical slot (0 = embedded)
39065 B3EF                        00              db 0 ;; reserved
39066                                             ;; 5th slot entry: 4rd PCI slot
39067 B3F0                        00              db 0 ;; pci bus number
39068 B3F1                        28              db 0x28 ;; pci device number (bit 7-3)
39069 B3F2                        61              db 0x61 ;; link value INTA#
39070 B3F3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39071 B3F5                        62              db 0x62 ;; link value INTB#
39072 B3F6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39073 B3F8                        63              db 0x63 ;; link value INTC#
39074 B3F9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39075 B3FB                        60              db 0x60 ;; link value INTD#
39076 B3FC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39077 B3FE                        04              db 4 ;; physical slot (0 = embedded)
39078 B3FF                        00              db 0 ;; reserved
39079                                             ;; 6th slot entry: 5rd PCI slot
39080 B400                        00              db 0 ;; pci bus number
39081 B401                        30              db 0x30 ;; pci device number (bit 7-3)
39082 B402                        62              db 0x62 ;; link value INTA#
39083 B403                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39084 B405                        63              db 0x63 ;; link value INTB#
39085 B406                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39086 B408                        60              db 0x60 ;; link value INTC#
39087 B409                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39088 B40B                        61              db 0x61 ;; link value INTD#
39089 B40C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39090 B40E                        05              db 5 ;; physical slot (0 = embedded)
39091 B40F                        00              db 0 ;; reserved
39092                       0000B410            pci_routing_table_structure_end:
39093                                           ; according to POST Memory Manager Specification Version 1.01
39094 B410                  00000010            .align 16
39095                       0000B410            pmm_structure:
39096 B410                        24              db 0x24,0x50,0x4d,0x4d ;; "$PMM" signature
39097 B414                        01              db 0x01 ;; revision
39098 B415                        10              db 16 ;; length
39099 B416                        1D              db (-((pmm_entry_point>>8)+pmm_entry_point+0x20f))&0xff;; checksum
39100 B417                      B420              dw pmm_entry_point,0xf000 ;; far call entrypoint
39101 B41B                        00              db 0,0,0,0,0 ;; reserved
39102                       0000B420            pmm_entry_point:
39103 B420           9C                           pushf
39104 B421     66    60                           pushad
39105                                           ; Calculate protected-mode address of PMM function args
39106 B423     66    31C0                         xor eax, eax
39107 B426           89E0                         mov ax, sp
39108 B428     66    31DB                         xor ebx, ebx
39109 B42B           8CD3                         mov bx, ss
39110 B42D     66    C1E3                   04    shl ebx, 4
39111 B431   6766    8D5C18       26              lea ebx, [eax+ebx+38] ;; ebx=(ss<<4)+sp+4(far call)+2(pushf)+32(pushad)
39112 B437     66    53                           push ebx
39113                                           ;
39114                                           ; Stack layout at this point:
39115                                           ;
39116                                           ; : +0x0 +0x2 +0x4 +0x6 +0x8 +0xa +0xc +0xe
39117                                           ; -----------------------------------------------------------------------
39118                                           ; sp : [&arg1 ][edi ][esi ][ebp ]
39119                                           ; sp+0x10: [esp ][ebx ][edx ][ecx ]
39120                                           ; sp+0x20: [eax ][flags ][ip ][cs ][arg1 ][arg2, ...
39121                                           ;
39122 B439           E8         FAC5              call _pmm
39123 B43C           89E3                         mov bx, sp
39124 B43E           36                         SEG SS
39125 B43F           8947         20              mov [bx+0x20], ax
39126 B442           36                         SEG SS
39127 B443           8957         18              mov [bx+0x18], dx
39128 B446     66    5B                           pop ebx
39129 B448     66    61                           popad
39130 B44A           9D                           popf
39131 B44B           CB                           retf
39132                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
39133                       0000B44C            detect_parport:
39134 B44C           52                           push dx
39135 B44D           83C2                   02    add dx, #2
39136 B450           EC                           in al, dx
39137 B451           24                     DF    and al, #0xdf ; clear input mode
39138 B453           EE                           out dx, al
39139 B454           5A                           pop dx
39140 B455           B0                     AA    mov al, #0xaa
39141 B457           EE                           out dx, al
39142 B458           EC                           in al, dx
39143 B459           3C                     AA    cmp al, #0xaa
39144 B45B           75           0D              jne no_parport
39145 B45D           53                           push bx
39146 B45E           D1E3                         shl bx, #1
39147 B460           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
39148 B464           5B                           pop bx
39149 B465           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
39150 B469           43                           inc bx
39151                       0000B46A            no_parport:
39152 B46A           C3                           ret
39153                                           ; serial port detection: base address in DX, index in BX, timeout in CL
39154                       0000B46B            detect_serial:
39155 B46B           52                           push dx
39156 B46C           42                           inc dx
39157 B46D           B0                     02    mov al, #0x02
39158 B46F           EE                           out dx, al
39159 B470           EC                           in al, dx
39160 B471           3C                     02    cmp al, #0x02
39161 B473           75           19              jne no_serial
39162 B475           42                           inc dx
39163 B476           EC                           in al, dx
39164 B477           3C                     02    cmp al, #0x02
39165 B479           75           13              jne no_serial
39166 B47B           4A                           dec dx
39167 B47C           30C0                         xor al, al
39168 B47E           EE                           out dx, al
39169 B47F           5A                           pop dx
39170 B480           53                           push bx
39171 B481           D1E3                         shl bx, #1
39172 B483           8997       0400              mov [bx+0x400], dx ; Serial I/O address
39173 B487           5B                           pop bx
39174 B488           888F       047C              mov [bx+0x47c], cl ; Serial timeout
39175 B48C           43                           inc bx
39176 B48D           C3                           ret
39177                       0000B48E            no_serial:
39178 B48E           5A                           pop dx
39179 B48F           C3                           ret
39180                       0000B490            rom_checksum:
39181 B490           60                           pusha
39182 B491           1E                           push ds
39183 B492           31C0                         xor ax, ax
39184 B494           31DB                         xor bx, bx
39185 B496           31C9                         xor cx, cx
39186 B498           31D2                         xor dx, dx
39187 B49A           8A2E       0002              mov ch, [2]
39188 B49E           D1E1                         shl cx, #1
39189 B4A0           73           05              jnc checksum_loop
39190 B4A2           74           03              jz checksum_loop
39191 B4A4           87CA                         xchg dx, cx
39192 B4A6           49                           dec cx
39193                       0000B4A7            checksum_loop:
39194 B4A7           0207                         add al, [bx]
39195 B4A9           43                           inc bx
39196 B4AA           E2           FB              loop checksum_loop
39197 B4AC           85D2                         test dx, dx
39198 B4AE           74           11              je checksum_out
39199 B4B0           0207                         add al, [bx]
39200 B4B2           89D1                         mov cx, dx
39201 B4B4           8CDA                         mov dx, ds
39202 B4B6           80C6                   10    add dh, #0x10
39203 B4B9           8EDA                         mov ds, dx
39204 B4BB           31D2                         xor dx, dx
39205 B4BD           31DB                         xor bx, bx
39206 B4BF           EB           E6              jmp checksum_loop
39207                       0000B4C1            checksum_out:
39208 B4C1           24                     FF    and al, #0xff
39209 B4C3           1F                           pop ds
39210 B4C4           61                           popa
39211 B4C5           C3                           ret
39212                                           ;; We need a copy of this string, but we are not actually a PnP BIOS,
39213                                           ;; so make sure it is *not* aligned, so OSes will not see it if they scan.
39214 B4C6                  00000010            .align 16
39215 B4D0                        00              db 0
39216                       0000B4D1            pnp_string:
39217 B4D1                        24              .ascii "$PnP"
39218                       0000B4D5            rom_scan:
39219                                             ;; Scan for existence of valid expansion ROMS.
39220                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
39221                                             ;; General ROM: from 0xC8000..0xE9FFF in 2k increments
39222                                             ;; System ROM: only 0xF0000
39223                                             ;;
39224                                             ;; Header:
39225                                             ;; Offset Value
39226                                             ;; 0 0x55
39227                                             ;; 1 0xAA
39228                                             ;; 2 ROM length in 512-byte blocks
39229                                             ;; 3 ROM initialization entry point (FAR CALL)
39230                       0000B4D5            rom_scan_loop:
39231 B4D5           50                           push ax ;; Save AX
39232 B4D6           8ED9                         mov ds, cx
39233 B4D8           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
39234 B4DB           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
39235 B4E1   7403    E9         00C2              jne rom_scan_increment
39236 B4E6           E8         FFA7              call rom_checksum
39237 B4E9   7403    E9         00BA              jnz rom_scan_increment
39238 B4EE           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
39239                                             ;; We want our increment in 512-byte quantities, rounded to
39240                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
39241 B4F1           A8                     03    test al, #0x03
39242 B4F3           74           04              jz block_count_rounded
39243 B4F5           24                     FC    and al, #0xfc ;; needs rounding up
39244 B4F7           04                     04    add al, #0x04
39245                       0000B4F9            block_count_rounded:
39246 B4F9           50                           push ax ;; Save AX
39247 B4FA           57                           push di ;; Save DI
39248                                             ;; Push addr of ROM entry point
39249 B4FB           51                           push cx ;; Push seg
39250 B4FC           6A                     03    push #0x0003 ;; Push offset
39251                                             ;; Get the BDF into ax before invoking the option ROM
39252 B4FE           8A1E       0002              mov bl, [2]
39253 B502           88D8                         mov al, bl
39254 B504           C0E8                   07    shr al, #7
39255 B507           3C                     01    cmp al, #1
39256 B509           75           07              jne fetch_bdf
39257 B50B           8CD8                         mov ax, ds ;; Increment the DS since rom size larger than an segment
39258 B50D           05                   1000    add ax, #0x1000
39259 B510           8ED8                         mov ds, ax
39260                       0000B512            fetch_bdf:
39261 B512           C1E3                   09    shl bx, #9
39262 B515           31C0                         xor ax, ax
39263 B517           8A07                         mov al, [bx]
39264                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
39265                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
39266 B519           BB                   F000    mov bx, #0xf000
39267 B51C           8EC3                         mov es, bx
39268 B51E           8D3E       B4D1              lea di, pnp_string
39269 B522           31DB                         xor bx, bx ;; Restore DS back to 0000:
39270 B524           8EDB                         mov ds, bx
39271 B526           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
39272 B528                        FF              db 0xff ;; call_far ss:[bp+0]
39273 B529                        5E              db 0x5e
39274 B52A                        00              db 0
39275 B52B           FA                           cli ;; In case expansion ROM BIOS turns IF on
39276 B52C           83C4                   02    add sp, #2 ;; Pop offset value
39277 B52F           59                           pop cx ;; Pop seg value (restore CX)
39278                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
39279                                             ;; to init all the ROMs and then go back and build an IPL table of
39280                                             ;; all the bootable devices, but we can get away with one pass.
39281 B530           8ED9                         mov ds, cx ;; ROM base
39282 B532           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
39283 B536           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
39284 B538           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
39285 B53B           75           69              jne no_bev
39286 B53D           8B47         02              mov ax, 2[bx]
39287 B540           3D                   506E    cmp ax, #0x506e
39288 B543           75           61              jne no_bev
39289 B545           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
39290 B548           3D                   0000    cmp ax, #0x0000
39291 B54B           74           17              je no_bcv
39292                                             ;; Option ROM has BCV. Run it now.
39293 B54D           51                           push cx ;; Push seg
39294 B54E           50                           push ax ;; Push offset
39295                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
39296 B54F           BB                   F000    mov bx, #0xf000
39297 B552           8EC3                         mov es, bx
39298 B554           8D3E       B4D1              lea di, pnp_string
39299 B558           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
39300 B55A                        FF              db 0xff ;; call_far ss:[bp+0]
39301 B55B                        5E              db 0x5e
39302 B55C                        00              db 0
39303 B55D           FA                           cli ;; In case expansion ROM BIOS turns IF on
39304 B55E           83C4                   02    add sp, #2 ;; Pop offset value
39305 B561           59                           pop cx ;; Pop seg value (restore CX)
39306 B562           EB           42              jmp no_bev
39307                       0000B564            no_bcv:
39308 B564           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
39309 B567           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
39310 B56A           74           3A              je no_bev
39311                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
39312 B56C           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
39313 B56F           31DB                         xor bx, bx
39314 B571           8EDB                         mov ds, bx
39315 B573           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
39316 B577           8EDB                         mov ds, bx ;; Go to the segment where the IPL table lives
39317 B579           8B1E       0380              mov bx, 0x0380 ;; Read the number of entries so far
39318 B57D           83FB                   08    cmp bx, #8
39319 B580           74           24              je no_bev ;; Get out if the table is full
39320 B582           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
39321 B585           C787       0300      0080    mov 0x0300 +0[bx], #0x80 ;; This entry is a BEV device
39322 B58B           898F       0306              mov 0x0300 +6[bx], cx ;; Build a far pointer from the segment...
39323 B58F           8987       0304              mov 0x0300 +4[bx], ax ;; and the offset
39324 B593           83FF                   00    cmp di, #0x0000
39325 B596           74           06              je no_prod_str
39326 B598           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
39327 B59B           897F         08              mov 8[bx], di ;; and the offset
39328                       0000B59E            no_prod_str:
39329 B59E           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
39330 B5A1           43                           inc bx ;; We have one more entry now
39331 B5A2           891E       0380              mov 0x0380, bx ;; Remember that.
39332                       0000B5A6            no_bev:
39333 B5A6           5F                           pop di ;; Restore DI
39334 B5A7           58                           pop ax ;; Restore AX
39335                       0000B5A8            rom_scan_increment:
39336 B5A8           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
39337                                                           ;; because the segment selector is shifted left 4 bits.
39338 B5AB           01C1                         add cx, ax
39339 B5AD           58                           pop ax ;; Restore AX
39340 B5AE           39C1                         cmp cx, ax
39341 B5B0   7703    E9         FF20              jbe rom_scan_loop
39342 B5B5           31C0                         xor ax, ax ;; Restore DS back to 0000:
39343 B5B7           8ED8                         mov ds, ax
39344 B5B9           C3                           ret
39345                                           ; Copy the SMBIOS entry point from where hvmloader left it.
39346                                           ; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
39347                                           ; but the tables themselves can be elsewhere.
39348                       0000B5BA            smbios_init:
39349 B5BA           50                           push ax
39350 B5BB           51                           push cx
39351 B5BC           06                           push es
39352 B5BD           1E                           push ds
39353 B5BE           57                           push di
39354 B5BF           56                           push si
39355 B5C0           B9                   001F    mov cx, #0x001f ; 0x1f bytes to copy
39356 B5C3           B8                   F000    mov ax, #0xf000
39357 B5C6           8EC0                         mov es, ax ; destination segment is 0xf0000
39358 B5C8           BF                   B610    mov di, #smbios_entry_point ; destination offset
39359 B5CB           B8                   EB00    mov ax, #(0x000EB000>>4)
39360 B5CE           8ED8                         mov ds, ax
39361 B5D0           BE                   0000    mov si, #(0x000EB000&15)
39362 B5D3           FC                           cld
39363 B5D4           F3                           rep
39364 B5D5           A4                             movsb
39365 B5D6           5E                           pop si
39366 B5D7           5F                           pop di
39367 B5D8           1F                           pop ds
39368 B5D9           07                           pop es
39369 B5DA           59                           pop cx
39370 B5DB           58                           pop ax
39371 B5DC           C3                           ret
39372                       0000B5DD            post_init_pic:
39373 B5DD           B0                     11    mov al, #0x11 ; send initialisation commands
39374 B5DF           E6                     20    out 0x20, al
39375 B5E1           E6                     A0    out 0xa0, al
39376 B5E3           B0                     08    mov al, #0x08
39377 B5E5           E6                     21    out 0x21, al
39378 B5E7           B0                     70    mov al, #0x70
39379 B5E9           E6                     A1    out 0xa1, al
39380 B5EB           B0                     04    mov al, #0x04
39381 B5ED           E6                     21    out 0x21, al
39382 B5EF           B0                     02    mov al, #0x02
39383 B5F1           E6                     A1    out 0xa1, al
39384 B5F3           B0                     01    mov al, #0x01
39385 B5F5           E6                     21    out 0x21, al
39386 B5F7           E6                     A1    out 0xa1, al
39387 B5F9           B0                     B8    mov al, #0xb8
39388 B5FB           E6                     21    out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
39389 B5FD           B0                     8F    mov al, #0x8f
39390 B5FF           E6                     A1    out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
39391 B601           C3                           ret
39392 B602                  00000010              .align 16
39393                       0000B610            smbios_entry_point:
39394 B610                        00              db 0,0,0,0,0,0,0,0 ; 8 bytes
39395 B618                        00              db 0,0,0,0,0,0,0,0 ; 16 bytes
39396 B620                        00              db 0,0,0,0,0,0,0,0 ; 24 bytes
39397 B628                        00              db 0,0,0,0,0,0,0 ; 31 bytes
39398                                           ;; the following area can be used to write dynamically generated tables
39399 B62F                  00000010              .align 16
39400                       0000B630            bios_table_area_start:
39401 B630                        5F              db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
39402 B638                  000019C0              dd bios_table_area_end - bios_table_area_start
39403                                           ;--------
39404                                           ;- POST -
39405                                           ;--------
39406 E05B                                      .org 0xe05b ; POST Entry Point
39407                       0000E05B            post:
39408 E05B           31C0                         xor ax, ax
39409                                             ;; first reset the DMA controllers
39410 E05D           E6                     0D    out 0x0d,al
39411 E05F           E6                     DA    out 0xda,al
39412                                             ;; then initialize the DMA controllers
39413 E061           B0                     C0    mov al, #0xC0
39414 E063           E6                     D6    out 0xD6, al ; cascade mode of channel 4 enabled
39415 E065           B0                     00    mov al, #0x00
39416 E067           E6                     D4    out 0xD4, al ; unmask channel 4
39417                                             ;; Examine CMOS shutdown status.
39418 E069           B0                     0F    mov AL, #0x0f
39419 E06B           E6                     70    out 0x70, AL
39420 E06D           E4                     71    in AL, 0x71
39421                                             ;; backup status
39422 E06F           88C3                         mov bl, al
39423                                             ;; Reset CMOS shutdown status.
39424 E071           B0                     0F    mov AL, #0x0f
39425 E073           E6                     70    out 0x70, AL ; select CMOS register Fh
39426 E075           B0                     00    mov AL, #0x00
39427 E077           E6                     71    out 0x71, AL ; set shutdown action to normal
39428                                             ;; Examine CMOS shutdown status.
39429 E079           88D8                         mov al, bl
39430                                             ;; 0x00, 0x09, 0x0D+ = normal startup
39431 E07B           3C                     00    cmp AL, #0x00
39432 E07D           74           28              jz normal_post
39433 E07F           3C                     0D    cmp AL, #0x0d
39434 E081           73           24              jae normal_post
39435 E083           3C                     09    cmp AL, #0x09
39436 E085           74           20              je normal_post
39437                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
39438 E087           3C                     05    cmp al, #0x05
39439 E089   7503    E9         C9A7              je eoi_jmp_post
39440                                             ;; 0x0A = jmp via [0x40:0x67] jump
39441 E08E           3C                     0A    cmp al, #0x0a
39442 E090   7503    E9         C9A8              je jmp_post_0x467
39443                                             ;; 0x0B = iret via [0x40:0x67]
39444 E095           3C                     0B    cmp al, #0x0b
39445 E097   7503    E9         C9A9              je iret_post_0x467
39446                                             ;; 0x0C = retf via [0x40:0x67]
39447 E09C           3C                     0C    cmp al, #0x0c
39448 E09E   7503    E9         C9AF              je retf_post_0x467
39449                                             ;; Examine CMOS shutdown status.
39450                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08 = Unimplemented shutdown status.
39451 E0A3           53                           push bx
39452 E0A4           E8         327C              call _shutdown_status_panic
39453                       0000E0A7            normal_post:
39454                                             ; case 0: normal startup
39455 E0A7           FA                           cli
39456 E0A8           B8                   0FFE    mov ax, #0x0ffe
39457 E0AB           89C4                         mov sp, ax
39458 E0AD           B8                   9E00    mov ax, #0x9e00
39459 E0B0           8ED0                         mov ss, ax
39460                                             ;; Save shutdown status
39461 E0B2           881E       04B0              mov 0x04b0, bl
39462 E0B6           80FB                   FE    cmp bl, #0xfe
39463 E0B9   7503    E9         C9A1              jz s3_post
39464                                             ;; zero out BIOS data area (40:00..40:ff)
39465 E0BE           8EC0                         mov es, ax
39466 E0C0           B9                   0080    mov cx, #0x0080 ;; 128 words
39467 E0C3           BF                   0400    mov di, #0x0400
39468 E0C6           FC                           cld
39469 E0C7           F3                           rep
39470 E0C8           AB                             stosw
39471 E0C9           E8         37F7              call _log_bios_start
39472                                             ;; set all interrupts to default handler
39473 E0CC           31DB                         xor bx, bx ;; offset index
39474 E0CE           B9                   0100    mov cx, #0x0100 ;; counter (256 interrupts)
39475 E0D1           B8                   FF53    mov ax, #dummy_iret_handler
39476 E0D4           BA                   F000    mov dx, #0xF000
39477                       0000E0D7            post_default_ints:
39478 E0D7           8907                         mov [bx], ax
39479 E0D9           83C3                   02    add bx, #2
39480 E0DC           8917                         mov [bx], dx
39481 E0DE           83C3                   02    add bx, #2
39482 E0E1           E2           F4              loop post_default_ints
39483                                             ;; set vector 0x79 to zero
39484                                             ;; this is used by 'gardian angel' protection system
39485                                             SET_INT_VECTOR(0x79, #0, #0)
 +a   E0E3           B8                   0000    mov ax,  #0
 +a   E0E6           A3         01E4              mov 0x79*4, ax
 +a   E0E9           B8                   0000    mov ax,  #0
 +a   E0EC           A3         01E6              mov 0x79*4+2, ax
39486                                             ;; base memory in K 40:13 (word)
39487 E0EF           B8                   027F    mov ax, #(640 - 1)
39488 E0F2           A3         0413              mov 0x0413, ax
39489                                             ;; Manufacturing Test 40:12
39490                                             ;; zerod out above
39491                                             ;; Warm Boot Flag 0040:0072
39492                                             ;; value of 1234h = skip memory checks
39493                                             ;; zerod out above
39494                                             ;; Printer Services vector
39495                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   E0F5           B8                   EFD2    mov ax,  #int17_handler
 +a   E0F8           A3         005C              mov 0x17*4, ax
 +a   E0FB           B8                   F000    mov ax,  #0xF000
 +a   E0FE           A3         005E              mov 0x17*4+2, ax
39496                                             ;; Bootstrap failure vector
39497                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   E101           B8                   A73E    mov ax,  #int18_handler
 +a   E104           A3         0060              mov 0x18*4, ax
 +a   E107           B8                   F000    mov ax,  #0xF000
 +a   E10A           A3         0062              mov 0x18*4+2, ax
39498                                             ;; Bootstrap Loader vector
39499                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   E10D           B8                   E6F2    mov ax,  #int19_handler
 +a   E110           A3         0064              mov 0x19*4, ax
 +a   E113           B8                   F000    mov ax,  #0xF000
 +a   E116           A3         0066              mov 0x19*4+2, ax
39500                                             ;; User Timer Tick vector
39501                                             SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
 +a   E119           B8                   A770    mov ax,  #int1c_handler
 +a   E11C           A3         0070              mov 0x1c*4, ax
 +a   E11F           B8                   F000    mov ax,  #0xF000
 +a   E122           A3         0072              mov 0x1c*4+2, ax
39502                                             ;; Memory Size Check vector
39503                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   E125           B8                   F841    mov ax,  #int12_handler
 +a   E128           A3         0048              mov 0x12*4, ax
 +a   E12B           B8                   F000    mov ax,  #0xF000
 +a   E12E           A3         004A              mov 0x12*4+2, ax
39504                                             ;; Equipment Configuration Check vector
39505                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   E131           B8                   F84D    mov ax,  #int11_handler
 +a   E134           A3         0044              mov 0x11*4, ax
 +a   E137           B8                   F000    mov ax,  #0xF000
 +a   E13A           A3         0046              mov 0x11*4+2, ax
39506                                             ;; System Services
39507                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   E13D           B8                   F859    mov ax,  #int15_handler
 +a   E140           A3         0054              mov 0x15*4, ax
 +a   E143           B8                   F000    mov ax,  #0xF000
 +a   E146           A3         0056              mov 0x15*4+2, ax
39508                                             ;; EBDA setup
39509 E149           E8         C8D4              call ebda_post
39510                                             ;; PIT setup
39511                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E14C           B8                   FEA5    mov ax,  #int08_handler
 +a   E14F           A3         0020              mov 0x08*4, ax
 +a   E152           B8                   F000    mov ax,  #0xF000
 +a   E155           A3         0022              mov 0x08*4+2, ax
39512                                             ;; int 1C already points at dummy_iret_handler (above)
39513 E158           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
39514 E15A           E6                     43    out 0x43, al
39515 E15C           B0                     0B    mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
39516 E15E           E6                     40    out 0x40, al ; lsb
39517 E160           B0                     E9    mov al, #0xe9
39518 E162           E6                     40    out 0x40, al ; msb
39519                                             ;; Keyboard
39520                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E164           B8                   E987    mov ax,  #int09_handler
 +a   E167           A3         0024              mov 0x09*4, ax
 +a   E16A           B8                   F000    mov ax,  #0xF000
 +a   E16D           A3         0026              mov 0x09*4+2, ax
39521                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E170           B8                   E82E    mov ax,  #int16_handler
 +a   E173           A3         0058              mov 0x16*4, ax
 +a   E176           B8                   F000    mov ax,  #0xF000
 +a   E179           A3         005A              mov 0x16*4+2, ax
39522 E17C           31C0                         xor ax, ax
39523 E17E           8ED8                         mov ds, ax
39524 E180           A2         0417              mov 0x0417, al
39525 E183           A2         0418              mov 0x0418, al
39526 E186           A2         0419              mov 0x0419, al
39527 E189           A2         0471              mov 0x0471, al
39528 E18C           A2         0497              mov 0x0497, al
39529 E18F           B0                     10    mov al, #0x10
39530 E191           A2         0496              mov 0x0496, al
39531 E194           BB                   001E    mov bx, #0x001E
39532 E197           891E       041A              mov 0x041A, bx
39533 E19B           891E       041C              mov 0x041C, bx
39534 E19F           BB                   001E    mov bx, #0x001E
39535 E1A2           891E       0480              mov 0x0480, bx
39536 E1A6           BB                   003E    mov bx, #0x003E
39537 E1A9           891E       0482              mov 0x0482, bx
39538 E1AD           E8         2C3E              call _keyboard_init
39539                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
39540 E1B0           A1         0410              mov ax, 0x0410
39541 E1B3           B0                     14    mov al, #0x14
39542 E1B5           E6                     70    out 0x70, al
39543 E1B7           E4                     71    in al, 0x71
39544 E1B9           A3         0410              mov 0x0410, ax
39545                                             ;; Parallel setup
39546                                             SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
 +a   E1BC           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1BF           A3         003C              mov 0x0F*4, ax
 +a   E1C2           B8                   F000    mov ax,  #0xF000
 +a   E1C5           A3         003E              mov 0x0F*4+2, ax
39547 E1C8           31C0                         xor ax, ax
39548 E1CA           8ED8                         mov ds, ax
39549 E1CC           31DB                         xor bx, bx
39550 E1CE           B1                     14    mov cl, #0x14 ; timeout value
39551 E1D0           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
39552 E1D3           E8         D276              call detect_parport
39553 E1D6           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
39554 E1D9           E8         D270              call detect_parport
39555 E1DC           C1E3                   0E    shl bx, #0x0e
39556 E1DF           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
39557 E1E2           25                   3FFF    and ax, #0x3fff
39558 E1E5           09D8                         or ax, bx ; set number of parallel ports
39559 E1E7           A3         0410              mov 0x410, ax
39560                                             ;; Serial setup
39561                                             SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
 +a   E1EA           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1ED           A3         0030              mov 0x0C*4, ax
 +a   E1F0           B8                   F000    mov ax,  #0xF000
 +a   E1F3           A3         0032              mov 0x0C*4+2, ax
39562                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E1F6           B8                   E739    mov ax,  #int14_handler
 +a   E1F9           A3         0050              mov 0x14*4, ax
 +a   E1FC           B8                   F000    mov ax,  #0xF000
 +a   E1FF           A3         0052              mov 0x14*4+2, ax
39563 E202           31DB                         xor bx, bx
39564 E204           B1                     0A    mov cl, #0x0a ; timeout value
39565 E206           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
39566 E209           E8         D25F              call detect_serial
39567 E20C           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
39568 E20F           E8         D259              call detect_serial
39569 E212           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
39570 E215           E8         D253              call detect_serial
39571 E218           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
39572 E21B           E8         D24D              call detect_serial
39573 E21E           C1E3                   09    shl bx, #0x09
39574 E221           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
39575 E224           25                   F1FF    and ax, #0xf1ff
39576 E227           09D8                         or ax, bx ; set number of serial port
39577 E229           A3         0410              mov 0x410, ax
39578                                             ;; CMOS RTC
39579                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E22C           B8                   FE6E    mov ax,  #int1a_handler
 +a   E22F           A3         0068              mov 0x1A*4, ax
 +a   E232           B8                   F000    mov ax,  #0xF000
 +a   E235           A3         006A              mov 0x1A*4+2, ax
39580                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E238           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E23B           A3         0128              mov 0x4A*4, ax
 +a   E23E           B8                   F000    mov ax,  #0xF000
 +a   E241           A3         012A              mov 0x4A*4+2, ax
39581                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E244           B8                   FE93    mov ax,  #int70_handler
 +a   E247           A3         01C0              mov 0x70*4, ax
 +a   E24A           B8                   F000    mov ax,  #0xF000
 +a   E24D           A3         01C2              mov 0x70*4+2, ax
39582                                             ;; BIOS DATA AREA 0x4CE ???
39583 E250           E8         C833              call timer_tick_post
39584                                             ;; PS/2 mouse setup
39585                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E253           B8                   A676    mov ax,  #int74_handler
 +a   E256           A3         01D0              mov 0x74*4, ax
 +a   E259           B8                   F000    mov ax,  #0xF000
 +a   E25C           A3         01D2              mov 0x74*4+2, ax
39586                                             ;; IRQ13 (FPU exception) setup
39587                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E25F           B8                   E2C7    mov ax,  #int75_handler
 +a   E262           A3         01D4              mov 0x75*4, ax
 +a   E265           B8                   F000    mov ax,  #0xF000
 +a   E268           A3         01D6              mov 0x75*4+2, ax
39588                                             ;; Video setup
39589                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E26B           B8                   F065    mov ax,  #int10_handler
 +a   E26E           A3         0040              mov 0x10*4, ax
 +a   E271           B8                   F000    mov ax,  #0xF000
 +a   E274           A3         0042              mov 0x10*4+2, ax
39590                                             ;; PIC
39591 E277           E8         D363              call post_init_pic
39592 E27A           B9                   C000    mov cx, #0xc000 ;; init vga bios
39593 E27D           B8                   C780    mov ax, #0xc780
39594 E280           E8         D252              call rom_scan
39595 E283           E8         30C7              call _print_bios_banner
39596                                             ;;
39597                                             ;; Floppy setup
39598                                             ;;
39599 E286           E8         C4E8              call floppy_drive_post
39600                                             ;;
39601                                             ;; Hard Drive setup
39602                                             ;;
39603 E289           E8         C56C              call hard_drive_post
39604                                             ;;
39605                                             ;; ATA/ATAPI driver setup
39606                                             ;;
39607 E28C           E8         373C              call _ata_init
39608 E28F           E8         3B69              call _ata_detect
39609                                             ;;
39610                                             ;;
39611                                             ;; eltorito floppy/harddisk emulation from cd
39612                                             ;;
39613 E292           E8         5AD5              call _cdemu_init
39614                                             ;;
39615 E295           E8         23FC              call _enable_rom_write_access
39616 E298           E8         3072              call _clobber_entry_point
39617 E29B           E8         23B2              call _fixup_base_mem_in_k
39618 E29E           E8         D319              call smbios_init
39619 E2A1           E8         310D              call _init_boot_vectors
39620 E2A4           B9                   C800    mov cx, #(0x000C8000 >> 4) ;; init option roms
39621 E2A7           B8                   EA00    mov ax, #(0x000EA000 >> 4)
39622 E2AA           E8         D228              call rom_scan
39623 E2AD           E8         23F5              call _disable_rom_write_access
39624 E2B0           E8         32BC              call _interactive_bootkey
39625 E2B3           FB                           sti ;; enable interrupts
39626                                             ;; Start the boot sequence. See the comments in int19_relocated
39627                                             ;; for why we use INT 18h instead of INT 19h here.
39628 E2B4           CD                     18    int #0x18
39629 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
39630                       0000E2C3            nmi:
39631                                             ;; FIXME the NMI handler should not panic
39632                                             ;; but iret when called from int75 (fpu exception)
39633 E2C3           E8         35D9              call _nmi_handler_msg
39634 E2C6           CF                           iret
39635                       0000E2C7            int75_handler:
39636 E2C7           E6                     F0    out 0xf0, al
39637 E2C9           E8         C7A2              call eoi_both_pics
39638 E2CC           CD                     02    int 2
39639 E2CE           CF                           iret
39640                                           ;-------------------------------------------
39641                                           ;- INT 13h Fixed Disk Services Entry Point -
39642                                           ;-------------------------------------------
39643 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
39644                       0000E3FE            int13_handler:
39645 E3FE           E9         C2B2              jmp int13_relocated
39646 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
39647                                           ;----------
39648                                           ;- INT19h -
39649                                           ;----------
39650 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
39651                       0000E6F2            int19_handler:
39652 E6F2           E9         C06E              jmp int19_relocated
39653                                           ;-------------------------------------------
39654                                           ;- System BIOS Configuration Data Table
39655                                           ;-------------------------------------------
39656 E6F5                                      .org 0xe6f5
39657 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
39658 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
39659 E6F7                        FC            db 0xFC
39660 E6F8                        00            db 0x00
39661 E6F9                        01            db 1
39662                                           ; Feature byte 1
39663                                           ; b7: 1=DMA channel 3 used by hard disk
39664                                           ; b6: 1=2 interrupt controllers present
39665                                           ; b5: 1=RTC present
39666                                           ; b4: 1=BIOS calls int 15h/4Fh every key
39667                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
39668                                           ; b2: 1=extended BIOS data area used
39669                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
39670                                           ; b0: 1=Dual bus (MicroChannel + ISA)
39671 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
39672                                           ; Feature byte 2
39673                                           ; b7: 1=32-bit DMA supported
39674                                           ; b6: 1=int16h, function 9 supported
39675                                           ; b5: 1=int15h/C6h (get POS data) supported
39676                                           ; b4: 1=int15h/C7h (get mem map info) supported
39677                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
39678                                           ; b2: 1=non-8042 kb controller
39679                                           ; b1: 1=data streaming supported
39680                                           ; b0: reserved
39681 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
39682                                           ; Feature byte 3
39683                                           ; b7: not used
39684                                           ; b6: reserved
39685                                           ; b5: reserved
39686                                           ; b4: POST supports ROM-to-RAM enable/disable
39687                                           ; b3: SCSI on system board
39688                                           ; b2: info panel installed
39689                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
39690                                           ; b0: SCSI supported in IML
39691 E6FC                        00            db 0x00
39692                                           ; Feature byte 4
39693                                           ; b7: IBM private
39694                                           ; b6: EEPROM present
39695                                           ; b5-3: ABIOS presence (011 = not supported)
39696                                           ; b2: private
39697                                           ; b1: memory split above 16Mb supported
39698                                           ; b0: POSTEXT directly supported by POST
39699 E6FD                        00            db 0x00
39700                                           ; Feature byte 5 (IBM)
39701                                           ; b1: enhanced mouse
39702                                           ; b0: flash EPROM
39703 E6FE                        00            db 0x00
39704 E729                                      .org 0xe729 ; Baud Rate Generator Table
39705                                           ;----------
39706                                           ;- INT14h -
39707                                           ;----------
39708 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
39709                       0000E739            int14_handler:
39710 E739           1E                           push ds
39711 E73A           60                           pusha
39712 E73B           31C0                         xor ax, ax
39713 E73D           8ED8                         mov ds, ax
39714 E73F           E8         5E42              call _int14_function
39715 E742           61                           popa
39716 E743           1F                           pop ds
39717 E744           CF                           iret
39718                                           ;----------------------------------------
39719                                           ;- INT 16h Keyboard Service Entry Point -
39720                                           ;----------------------------------------
39721 E82E                                      .org 0xe82e
39722                       0000E82E            int16_handler:
39723 E82E           FB                           sti
39724 E82F           1E                           push ds
39725 E830           9C                           pushf
39726 E831           60                           pusha
39727 E832           80FC                   00    cmp ah, #0x00
39728 E835           74           24              je int16_F00
39729 E837           80FC                   10    cmp ah, #0x10
39730 E83A           74           1F              je int16_F00
39731 E83C           BB                   F000    mov bx, #0xf000
39732 E83F           8EDB                         mov ds, bx
39733 E841           E8         6F5B              call _int16_function
39734 E844           61                           popa
39735 E845           9D                           popf
39736 E846           1F                           pop ds
39737 E847           74           09              jz int16_zero_set
39738                       0000E849            int16_zero_clear:
39739 E849           55                           push bp
39740 E84A           89E5                         mov bp, sp
39741 E84C           8066         06        BF    and BYTE [bp + 0x06], #0xbf
39742 E850           5D                           pop bp
39743 E851           CF                           iret
39744                       0000E852            int16_zero_set:
39745 E852           55                           push bp
39746 E853           89E5                         mov bp, sp
39747 E855           804E         06        40    or BYTE [bp + 0x06], #0x40
39748 E859           5D                           pop bp
39749 E85A           CF                           iret
39750                       0000E85B            int16_F00:
39751 E85B           BB                   0040    mov bx, #0x0040
39752 E85E           8EDB                         mov ds, bx
39753                       0000E860            int16_wait_for_key:
39754 E860           FA                           cli
39755 E861           8B1E       001A              mov bx, 0x001a
39756 E865           3B1E       001C              cmp bx, 0x001c
39757 E869           75           04              jne int16_key_found
39758 E86B           FB                           sti
39759 E86C           F4                           hlt
39760 E86D           EB           F1              jmp int16_wait_for_key
39761                       0000E86F            int16_key_found:
39762 E86F           BB                   F000    mov bx, #0xf000
39763 E872           8EDB                         mov ds, bx
39764 E874           E8         6F28              call _int16_function
39765 E877           61                           popa
39766 E878           9D                           popf
39767 E879           1F                           pop ds
39768 E87A           CF                           iret
39769                                           ;-------------------------------------------------
39770                                           ;- INT09h : Keyboard Hardware Service Entry Point -
39771                                           ;-------------------------------------------------
39772 E987                                      .org 0xe987
39773                       0000E987            int09_handler:
39774 E987           FA                           cli
39775 E988           50                           push ax
39776 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
39777 E98B           E6                     64    out #0x64, al
39778 E98D           B0                     0B    mov al, #0x0B
39779 E98F           E6                     20    out #0x20, al
39780 E991           E4                     20    in al, #0x20
39781 E993           24                     02    and al, #0x02
39782 E995           74           3E              jz int09_finish
39783 E997           E4                     60    in al, #0x60 ;;read key from keyboard controller
39784 E999           FB                           sti
39785 E99A           1E                           push ds
39786 E99B           60                           pusha
39787 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
39788 E99E           F9                           stc
39789 E99F           CD                     15    int #0x15
39790 E9A1           73           2C              jnc int09_done
39791                                             ;; check for extended key
39792 E9A3           3C                     E0    cmp al, #0xe0
39793 E9A5           75           0E              jne int09_check_pause
39794 E9A7           31C0                         xor ax, ax
39795 E9A9           8ED8                         mov ds, ax
39796 E9AB           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x02
39797 E9AE           0C                     02    or al, #0x02
39798 E9B0           A2         0496              mov BYTE [0x496], al
39799 E9B3           EB           1A              jmp int09_done
39800                       0000E9B5            int09_check_pause: ;; check for pause key
39801 E9B5           3C                     E1    cmp al, #0xe1
39802 E9B7           75           0E              jne int09_process_key
39803 E9B9           31C0                         xor ax, ax
39804 E9BB           8ED8                         mov ds, ax
39805 E9BD           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x01
39806 E9C0           0C                     01    or al, #0x01
39807 E9C2           A2         0496              mov BYTE [0x496], al
39808 E9C5           EB           08              jmp int09_done
39809                       0000E9C7            int09_process_key:
39810 E9C7           BB                   F000    mov bx, #0xf000
39811 E9CA           8EDB                         mov ds, bx
39812 E9CC           E8         7528              call _int09_function
39813                       0000E9CF            int09_done:
39814 E9CF           61                           popa
39815 E9D0           1F                           pop ds
39816 E9D1           FA                           cli
39817 E9D2           E8         C09D              call eoi_master_pic
39818                       0000E9D5            int09_finish:
39819 E9D5           B0                     AE    mov al, #0xAE ;;enable keyboard
39820 E9D7           E6                     64    out #0x64, al
39821 E9D9           58                           pop ax
39822 E9DA           CF                           iret
39823                                           ;----------------------------------------
39824                                           ;- INT 13h Diskette Service Entry Point -
39825                                           ;----------------------------------------
39826 EC59                                      .org 0xec59
39827                       0000EC59            int13_diskette:
39828 EC59           E9         BAA6              jmp int13_noeltorito
39829                                           ;---------------------------------------------
39830                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
39831                                           ;---------------------------------------------
39832 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
39833                       0000EF57            int0e_handler:
39834 EF57           50                           push ax
39835 EF58           52                           push dx
39836 EF59           BA                   03F4    mov dx, #0x03f4
39837 EF5C           EC                           in al, dx
39838 EF5D           24                     C0    and al, #0xc0
39839 EF5F           3C                     C0    cmp al, #0xc0
39840 EF61           74           1E              je int0e_normal
39841 EF63           BA                   03F5    mov dx, #0x03f5
39842 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
39843 EF68           EE                           out dx, al
39844                       0000EF69            int0e_loop1:
39845 EF69           BA                   03F4    mov dx, #0x03f4
39846 EF6C           EC                           in al, dx
39847 EF6D           24                     C0    and al, #0xc0
39848 EF6F           3C                     C0    cmp al, #0xc0
39849 EF71           75           F6              jne int0e_loop1
39850                       0000EF73            int0e_loop2:
39851 EF73           BA                   03F5    mov dx, #0x03f5
39852 EF76           EC                           in al, dx
39853 EF77           BA                   03F4    mov dx, #0x03f4
39854 EF7A           EC                           in al, dx
39855 EF7B           24                     C0    and al, #0xc0
39856 EF7D           3C                     C0    cmp al, #0xc0
39857 EF7F           74           F2              je int0e_loop2
39858                       0000EF81            int0e_normal:
39859 EF81           1E                           push ds
39860 EF82           31C0                         xor ax, ax ;; segment 0000
39861 EF84           8ED8                         mov ds, ax
39862 EF86           E8         BAE9              call eoi_master_pic
39863 EF89           A0         043E              mov al, 0x043e
39864 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
39865 EF8E           A2         043E              mov 0x043e, al
39866 EF91           1F                           pop ds
39867 EF92           5A                           pop dx
39868 EF93           58                           pop ax
39869 EF94           CF                           iret
39870 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
39871                       0000EFC7            diskette_param_table:
39872                                           ;; Since no provisions are made for multiple drive types, most
39873                                           ;; values in this table are ignored. I set parameters for 1.44M
39874                                           ;; floppy here
39875 EFC7                        AF            db 0xAF
39876 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
39877 EFC9                        25            db 0x25
39878 EFCA                        02            db 0x02
39879 EFCB                        12            db 18
39880 EFCC                        1B            db 0x1B
39881 EFCD                        FF            db 0xFF
39882 EFCE                        6C            db 0x6C
39883 EFCF                        F6            db 0xF6
39884 EFD0                        0F            db 0x0F
39885 EFD1                        08            db 0x08
39886                                           ;----------------------------------------
39887                                           ;- INT17h : Printer Service Entry Point -
39888                                           ;----------------------------------------
39889 EFD2                                      .org 0xefd2
39890                       0000EFD2            int17_handler:
39891 EFD2           1E                           push ds
39892 EFD3           60                           pusha
39893 EFD4           31C0                         xor ax, ax
39894 EFD6           8ED8                         mov ds, ax
39895 EFD8           E8         AE79              call _int17_function
39896 EFDB           61                           popa
39897 EFDC           1F                           pop ds
39898 EFDD           CF                           iret
39899                       0000EFDE            diskette_param_table2:
39900                                           ;; New diskette parameter table adding 3 parameters from IBM
39901                                           ;; Since no provisions are made for multiple drive types, most
39902                                           ;; values in this table are ignored. I set parameters for 1.44M
39903                                           ;; floppy here
39904 EFDE                        AF            db 0xAF
39905 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
39906 EFE0                        25            db 0x25
39907 EFE1                        02            db 0x02
39908 EFE2                        12            db 18
39909 EFE3                        1B            db 0x1B
39910 EFE4                        FF            db 0xFF
39911 EFE5                        6C            db 0x6C
39912 EFE6                        F6            db 0xF6
39913 EFE7                        0F            db 0x0F
39914 EFE8                        08            db 0x08
39915 EFE9                        4F            db 79 ;; maximum track
39916 EFEA                        00            db 0 ;; data transfer rate
39917 EFEB                        04            db 4 ;; drive type in cmos
39918 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
39919                                             HALT(11440)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2CB0    mov ax,#11440
 +a   F04B           EF                           out dx,ax
39920 F04C           CF                           iret
39921                                           ;----------
39922                                           ;- INT10h -
39923                                           ;----------
39924 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
39925                       0000F065            int10_handler:
39926                                             ;; dont do anything, since the VGA BIOS handles int10h requests
39927 F065           CF                           iret
39928 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
39929                                           ;----------
39930                                           ;- INT12h -
39931                                           ;----------
39932 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
39933                                           ; ??? different for Pentium (machine check)?
39934                       0000F841            int12_handler:
39935 F841           1E                           push ds
39936 F842           B8                   0040    mov ax, #0x0040
39937 F845           8ED8                         mov ds, ax
39938 F847           A1         0013              mov ax, 0x0013
39939 F84A           1F                           pop ds
39940 F84B           CF                           iret
39941                                           ;----------
39942                                           ;- INT11h -
39943                                           ;----------
39944 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
39945                       0000F84D            int11_handler:
39946 F84D           1E                           push ds
39947 F84E           B8                   0040    mov ax, #0x0040
39948 F851           8ED8                         mov ds, ax
39949 F853           A1         0010              mov ax, 0x0010
39950 F856           1F                           pop ds
39951 F857           CF                           iret
39952                                           ;----------
39953                                           ;- INT15h -
39954                                           ;----------
39955 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
39956                       0000F859            int15_handler:
39957 F859           9C                           pushf
39958 F85A           80FC                   53    cmp ah, #0x53
39959 F85D           74           1C              je apm_call
39960 F85F           1E                           push ds
39961 F860           06                           push es
39962 F861           80FC                   86    cmp ah, #0x86
39963 F864           74           1D              je int15_handler32
39964 F866           80FC                   E8    cmp ah, #0xE8
39965 F869           74           18              je int15_handler32
39966 F86B           60                           pusha
39967 F86C           80FC                   C2    cmp ah, #0xC2
39968 F86F           74           0D              je int15_handler_mouse
39969 F871           E8         4F80              call _int15_function
39970                       0000F874            int15_handler_mouse_ret:
39971 F874           61                           popa
39972                       0000F875            int15_handler32_ret:
39973 F875           07                           pop es
39974 F876           1F                           pop ds
39975 F877           9D                           popf
39976 F878           E9         AE24              jmp iret_modify_cf
39977                       0000F87B            apm_call:
39978 F87B           E9         B474              jmp _apmreal_entry
39979                       0000F87E            int15_handler_mouse:
39980 F87E           E8         546F              call _int15_function_mouse
39981 F881           EB           F1              jmp int15_handler_mouse_ret
39982                       0000F883            int15_handler32:
39983 F883     66    60                           pushad
39984 F885           E8         5BAB              call _int15_function32
39985 F888     66    61                           popad
39986 F88A           EB           E9              jmp int15_handler32_ret
39987                                           ;; Protected mode IDT descriptor
39988                                           ;;
39989                                           ;; I just make the limit 0, so the machine will shutdown
39990                                           ;; if an exception occurs during protected mode memory
39991                                           ;; transfers.
39992                                           ;;
39993                                           ;; Set base to f0000 to correspond to beginning of BIOS,
39994                                           ;; in case I actually define an IDT later
39995                                           ;; Set limit to 0
39996                       0000F88C            pmode_IDT_info:
39997 F88C                      0000            dw 0x0000 ;; limit 15:00
39998 F88E                      0000            dw 0x0000 ;; base 15:00
39999 F890                        0F            db 0x0f ;; base 23:16
40000                                           ;; Real mode IDT descriptor
40001                                           ;;
40002                                           ;; Set to typical real-mode values.
40003                                           ;; base = 000000
40004                                           ;; limit = 03ff
40005                       0000F891            rmode_IDT_info:
40006 F891                      03FF            dw 0x03ff ;; limit 15:00
40007 F893                      0000            dw 0x0000 ;; base 15:00
40008 F895                        00            db 0x00 ;; base 23:16
40009                                           ;----------
40010                                           ;- INT1Ah -
40011                                           ;----------
40012 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
40013                       0000FE6E            int1a_handler:
40014 FE6E           80FC                   B1    cmp ah, #0xb1
40015 FE71           75           14              jne int1a_normal
40016 FE73           E8         B375              call pcibios_real
40017 FE76           72           03              jc pcibios_error
40018 FE78           CA                   0002    retf 2
40019                       0000FE7B            pcibios_error:
40020 FE7B           88E3                         mov bl, ah
40021 FE7D           B4                     B1    mov ah, #0xb1
40022 FE7F           1E                           push ds
40023 FE80           60                           pusha
40024 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
40025 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
40026 FE85           EB           06              jmp int1a_callfunction
40027                       0000FE87            int1a_normal:
40028 FE87           1E                           push ds
40029 FE88           60                           pusha
40030 FE89           31C0                         xor ax, ax
40031 FE8B           8ED8                         mov ds, ax
40032                       0000FE8D            int1a_callfunction:
40033 FE8D           E8         A37C              call _int1a_function
40034 FE90           61                           popa
40035 FE91           1F                           pop ds
40036 FE92           CF                           iret
40037                                           ;;
40038                                           ;; int70h: IRQ8 - CMOS RTC
40039                                           ;;
40040                       0000FE93            int70_handler:
40041 FE93           1E                           push ds
40042 FE94     66    60                           pushad
40043 FE96           31C0                         xor ax, ax
40044 FE98           8ED8                         mov ds, ax
40045 FE9A           E8         A6B1              call _int70_function
40046 FE9D     66    61                           popad
40047 FE9F           1F                           pop ds
40048 FEA0           CF                           iret
40049                                           ;---------
40050                                           ;- INT08 -
40051                                           ;---------
40052 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
40053                       0000FEA5            int08_handler:
40054 FEA5           FB                           sti
40055 FEA6     66    50                           push eax
40056 FEA8           1E                           push ds
40057 FEA9           31C0                         xor ax, ax
40058 FEAB           8ED8                         mov ds, ax
40059                                             ;; time to turn off drive(s)?
40060 FEAD           A0         0440              mov al,0x0440
40061 FEB0           08C0                         or al,al
40062 FEB2           74           10              jz int08_floppy_off
40063 FEB4           FEC8                         dec al
40064 FEB6           A2         0440              mov 0x0440,al
40065 FEB9           75           09              jnz int08_floppy_off
40066                                             ;; turn motor(s) off
40067 FEBB           52                           push dx
40068 FEBC           BA                   03F2    mov dx,#0x03f2
40069 FEBF           EC                           in al,dx
40070 FEC0           24                     CF    and al,#0xcf
40071 FEC2           EE                           out dx,al
40072 FEC3           5A                           pop dx
40073                       0000FEC4            int08_floppy_off:
40074 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
40075 FEC8     66    40                           inc eax
40076                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
40077 FECA     66    3D               001800B0    cmp eax, #0x001800B0
40078 FED0           72           07              jb int08_store_ticks
40079                                             ;; there has been a midnight rollover at this point
40080 FED2     66    31C0                         xor eax, eax ;; zero out counter
40081 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
40082                       0000FED9            int08_store_ticks:
40083 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
40084                                             ;; chain to user timer tick INT #0x1c
40085 FEDD           CD                     1C    int #0x1c
40086 FEDF           FA                           cli
40087 FEE0           E8         AB8F              call eoi_master_pic
40088 FEE3           1F                           pop ds
40089 FEE4     66    58                           pop eax
40090 FEE6           CF                           iret
40091 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
40092 FFEA                                      .org 0xffea ;; OEM string
40093 FFEA                        5F            .ascii "______"
40094 FF00                                      .org 0xff00
40095 FF00                        28            .ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
40096                                           ;------------------------------------------------
40097                                           ;- IRET Instruction for Dummy Interrupt Handler -
40098                                           ;------------------------------------------------
40099 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
40100                       0000FF53            dummy_iret_handler:
40101 FF53           CF                           iret
40102 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
40103                                             HALT(11676)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2D9C    mov ax,#11676
 +a   FF5A           EF                           out dx,ax
40104 FF5B           CF                           iret
40105 FFF0                                      .org 0xfff0 ; Power-up Entry Point
40106 FFF0           EA         E05B      F000     jmp 0xf000:post
40107 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
40108 FFF5                        30            .ascii "06/23/99"
40109 FFFE                                      .org 0xfffe ; System Model ID
40110 FFFE                        FC            db 0xFC
40111 FFFF                        00            db 0x00 ; filler
40112 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
40113                                           ! 8244 endasm
40114                                           !BCC_ENDASM
40115                                           ! 8245 static Bit8u vgafont8[128*8]=
40116                                           ! Register BX used in function int1a_function32
40117                                           ! 8246 {
40118                                           
40119                       0000FA6E            _vgafont8:
40120                                           ! 8247  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40121 FA6E                        00            .byte	0
40122 FA6F                        00            .byte	0
40123 FA70                        00            .byte	0
40124 FA71                        00            .byte	0
40125 FA72                        00            .byte	0
40126 FA73                        00            .byte	0
40127 FA74                        00            .byte	0
40128 FA75                        00            .byte	0
40129                                           ! 8248  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
40130 FA76                        7E            .byte	$7E
40131 FA77                        81            .byte	$81
40132 FA78                        A5            .byte	$A5
40133 FA79                        81            .byte	$81
40134 FA7A                        BD            .byte	$BD
40135 FA7B                        99            .byte	$99
40136 FA7C                        81            .byte	$81
40137 FA7D                        7E            .byte	$7E
40138                                           ! 8249  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
40139 FA7E                        7E            .byte	$7E
40140 FA7F                        FF            .byte	$FF
40141 FA80                        DB            .byte	$DB
40142 FA81                        FF            .byte	$FF
40143 FA82                        C3            .byte	$C3
40144 FA83                        E7            .byte	$E7
40145 FA84                        FF            .byte	$FF
40146 FA85                        7E            .byte	$7E
40147                                           ! 8250  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40148 FA86                        6C            .byte	$6C
40149 FA87                        FE            .byte	$FE
40150 FA88                        FE            .byte	$FE
40151 FA89                        FE            .byte	$FE
40152 FA8A                        7C            .byte	$7C
40153 FA8B                        38            .byte	$38
40154 FA8C                        10            .byte	$10
40155 FA8D                        00            .byte	0
40156                                           ! 8251  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40157 FA8E                        10            .byte	$10
40158 FA8F                        38            .byte	$38
40159 FA90                        7C            .byte	$7C
40160 FA91                        FE            .byte	$FE
40161 FA92                        7C            .byte	$7C
40162 FA93                        38            .byte	$38
40163 FA94                        10            .byte	$10
40164 FA95                        00            .byte	0
40165                                           ! 8252  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
40166 FA96                        38            .byte	$38
40167 FA97                        7C            .byte	$7C
40168 FA98                        38            .byte	$38
40169 FA99                        FE            .byte	$FE
40170 FA9A                        FE            .byte	$FE
40171 FA9B                        7C            .byte	$7C
40172 FA9C                        38            .byte	$38
40173 FA9D                        7C            .byte	$7C
40174                                           ! 8253  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
40175 FA9E                        10            .byte	$10
40176 FA9F                        10            .byte	$10
40177 FAA0                        38            .byte	$38
40178 FAA1                        7C            .byte	$7C
40179 FAA2                        FE            .byte	$FE
40180 FAA3                        7C            .byte	$7C
40181 FAA4                        38            .byte	$38
40182 FAA5                        7C            .byte	$7C
40183                                           ! 8254  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
40184 FAA6                        00            .byte	0
40185 FAA7                        00            .byte	0
40186 FAA8                        18            .byte	$18
40187 FAA9                        3C            .byte	$3C
40188 FAAA                        3C            .byte	$3C
40189 FAAB                        18            .byte	$18
40190 FAAC                        00            .byte	0
40191 FAAD                        00            .byte	0
40192                                           ! 8255  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
40193 FAAE                        FF            .byte	$FF
40194 FAAF                        FF            .byte	$FF
40195 FAB0                        E7            .byte	$E7
40196 FAB1                        C3            .byte	$C3
40197 FAB2                        C3            .byte	$C3
40198 FAB3                        E7            .byte	$E7
40199 FAB4                        FF            .byte	$FF
40200 FAB5                        FF            .byte	$FF
40201                                           ! 8256  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
40202 FAB6                        00            .byte	0
40203 FAB7                        3C            .byte	$3C
40204 FAB8                        66            .byte	$66
40205 FAB9                        42            .byte	$42
40206 FABA                        42            .byte	$42
40207 FABB                        66            .byte	$66
40208 FABC                        3C            .byte	$3C
40209 FABD                        00            .byte	0
40210                                           ! 8257  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
40211 FABE                        FF            .byte	$FF
40212 FABF                        C3            .byte	$C3
40213 FAC0                        99            .byte	$99
40214 FAC1                        BD            .byte	$BD
40215 FAC2                        BD            .byte	$BD
40216 FAC3                        99            .byte	$99
40217 FAC4                        C3            .byte	$C3
40218 FAC5                        FF            .byte	$FF
40219                                           ! 8258  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
40220 FAC6                        0F            .byte	$F
40221 FAC7                        07            .byte	7
40222 FAC8                        0F            .byte	$F
40223 FAC9                        7D            .byte	$7D
40224 FACA                        CC            .byte	$CC
40225 FACB                        CC            .byte	$CC
40226 FACC                        CC            .byte	$CC
40227 FACD                        78            .byte	$78
40228                                           ! 8259  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
40229 FACE                        3C            .byte	$3C
40230 FACF                        66            .byte	$66
40231 FAD0                        66            .byte	$66
40232 FAD1                        66            .byte	$66
40233 FAD2                        3C            .byte	$3C
40234 FAD3                        18            .byte	$18
40235 FAD4                        7E            .byte	$7E
40236 FAD5                        18            .byte	$18
40237                                           ! 8260  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
40238 FAD6                        3F            .byte	$3F
40239 FAD7                        33            .byte	$33
40240 FAD8                        3F            .byte	$3F
40241 FAD9                        30            .byte	$30
40242 FADA                        30            .byte	$30
40243 FADB                        70            .byte	$70
40244 FADC                        F0            .byte	$F0
40245 FADD                        E0            .byte	$E0
40246                                           ! 8261  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
40247 FADE                        7F            .byte	$7F
40248 FADF                        63            .byte	$63
40249 FAE0                        7F            .byte	$7F
40250 FAE1                        63            .byte	$63
40251 FAE2                        63            .byte	$63
40252 FAE3                        67            .byte	$67
40253 FAE4                        E6            .byte	$E6
40254 FAE5                        C0            .byte	$C0
40255                                           ! 8262  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
40256 FAE6                        99            .byte	$99
40257 FAE7                        5A            .byte	$5A
40258 FAE8                        3C            .byte	$3C
40259 FAE9                        E7            .byte	$E7
40260 FAEA                        E7            .byte	$E7
40261 FAEB                        3C            .byte	$3C
40262 FAEC                        5A            .byte	$5A
40263 FAED                        99            .byte	$99
40264                                           ! 8263  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
40265 FAEE                        80            .byte	$80
40266 FAEF                        E0            .byte	$E0
40267 FAF0                        F8            .byte	$F8
40268 FAF1                        FE            .byte	$FE
40269 FAF2                        F8            .byte	$F8
40270 FAF3                        E0            .byte	$E0
40271 FAF4                        80            .byte	$80
40272 FAF5                        00            .byte	0
40273                                           ! 8264  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
40274 FAF6                        02            .byte	2
40275 FAF7                        0E            .byte	$E
40276 FAF8                        3E            .byte	$3E
40277 FAF9                        FE            .byte	$FE
40278 FAFA                        3E            .byte	$3E
40279 FAFB                        0E            .byte	$E
40280 FAFC                        02            .byte	2
40281 FAFD                        00            .byte	0
40282                                           ! 8265  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
40283 FAFE                        18            .byte	$18
40284 FAFF                        3C            .byte	$3C
40285 FB00                        7E            .byte	$7E
40286 FB01                        18            .byte	$18
40287 FB02                        18            .byte	$18
40288 FB03                        7E            .byte	$7E
40289 FB04                        3C            .byte	$3C
40290 FB05                        18            .byte	$18
40291                                           ! 8266  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
40292 FB06                        66            .byte	$66
40293 FB07                        66            .byte	$66
40294 FB08                        66            .byte	$66
40295 FB09                        66            .byte	$66
40296 FB0A                        66            .byte	$66
40297 FB0B                        00            .byte	0
40298 FB0C                        66            .byte	$66
40299 FB0D                        00            .byte	0
40300                                           ! 8267  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
40301 FB0E                        7F            .byte	$7F
40302 FB0F                        DB            .byte	$DB
40303 FB10                        DB            .byte	$DB
40304 FB11                        7B            .byte	$7B
40305 FB12                        1B            .byte	$1B
40306 FB13                        1B            .byte	$1B
40307 FB14                        1B            .byte	$1B
40308 FB15                        00            .byte	0
40309                                           ! 8268  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
40310 FB16                        3E            .byte	$3E
40311 FB17                        63            .byte	$63
40312 FB18                        38            .byte	$38
40313 FB19                        6C            .byte	$6C
40314 FB1A                        6C            .byte	$6C
40315 FB1B                        38            .byte	$38
40316 FB1C                        CC            .byte	$CC
40317 FB1D                        78            .byte	$78
40318                                           ! 8269  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
40319 FB1E                        00            .byte	0
40320 FB1F                        00            .byte	0
40321 FB20                        00            .byte	0
40322 FB21                        00            .byte	0
40323 FB22                        7E            .byte	$7E
40324 FB23                        7E            .byte	$7E
40325 FB24                        7E            .byte	$7E
40326 FB25                        00            .byte	0
40327                                           ! 8270  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
40328 FB26                        18            .byte	$18
40329 FB27                        3C            .byte	$3C
40330 FB28                        7E            .byte	$7E
40331 FB29                        18            .byte	$18
40332 FB2A                        7E            .byte	$7E
40333 FB2B                        3C            .byte	$3C
40334 FB2C                        18            .byte	$18
40335 FB2D                        FF            .byte	$FF
40336                                           ! 8271  0x18
40337                                           ! 8271 , 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
40338 FB2E                        18            .byte	$18
40339 FB2F                        3C            .byte	$3C
40340 FB30                        7E            .byte	$7E
40341 FB31                        18            .byte	$18
40342 FB32                        18            .byte	$18
40343 FB33                        18            .byte	$18
40344 FB34                        18            .byte	$18
40345 FB35                        00            .byte	0
40346                                           ! 8272  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
40347 FB36                        18            .byte	$18
40348 FB37                        18            .byte	$18
40349 FB38                        18            .byte	$18
40350 FB39                        18            .byte	$18
40351 FB3A                        7E            .byte	$7E
40352 FB3B                        3C            .byte	$3C
40353 FB3C                        18            .byte	$18
40354 FB3D                        00            .byte	0
40355                                           ! 8273  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
40356 FB3E                        00            .byte	0
40357 FB3F                        18            .byte	$18
40358 FB40                        0C            .byte	$C
40359 FB41                        FE            .byte	$FE
40360 FB42                        0C            .byte	$C
40361 FB43                        18            .byte	$18
40362 FB44                        00            .byte	0
40363 FB45                        00            .byte	0
40364                                           ! 8274  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
40365 FB46                        00            .byte	0
40366 FB47                        30            .byte	$30
40367 FB48                        60            .byte	$60
40368 FB49                        FE            .byte	$FE
40369 FB4A                        60            .byte	$60
40370 FB4B                        30            .byte	$30
40371 FB4C                        00            .byte	0
40372 FB4D                        00            .byte	0
40373                                           ! 8275  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
40374 FB4E                        00            .byte	0
40375 FB4F                        00            .byte	0
40376 FB50                        C0            .byte	$C0
40377 FB51                        C0            .byte	$C0
40378 FB52                        C0            .byte	$C0
40379 FB53                        FE            .byte	$FE
40380 FB54                        00            .byte	0
40381 FB55                        00            .byte	0
40382                                           ! 8276  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
40383 FB56                        00            .byte	0
40384 FB57                        24            .byte	$24
40385 FB58                        66            .byte	$66
40386 FB59                        FF            .byte	$FF
40387 FB5A                        66            .byte	$66
40388 FB5B                        24            .byte	$24
40389 FB5C                        00            .byte	0
40390 FB5D                        00            .byte	0
40391                                           ! 8277  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
40392 FB5E                        00            .byte	0
40393 FB5F                        18            .byte	$18
40394 FB60                        3C            .byte	$3C
40395 FB61                        7E            .byte	$7E
40396 FB62                        FF            .byte	$FF
40397 FB63                        FF            .byte	$FF
40398 FB64                        00            .byte	0
40399 FB65                        00            .byte	0
40400                                           ! 8278  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
40401 FB66                        00            .byte	0
40402 FB67                        FF            .byte	$FF
40403 FB68                        FF            .byte	$FF
40404 FB69                        7E            .byte	$7E
40405 FB6A                        3C            .byte	$3C
40406 FB6B                        18            .byte	$18
40407 FB6C                        00            .byte	0
40408 FB6D                        00            .byte	0
40409                                           ! 8279  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40410 FB6E                        00            .byte	0
40411 FB6F                        00            .byte	0
40412 FB70                        00            .byte	0
40413 FB71                        00            .byte	0
40414 FB72                        00            .byte	0
40415 FB73                        00            .byte	0
40416 FB74                        00            .byte	0
40417 FB75                        00            .byte	0
40418                                           ! 8280  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
40419 FB76                        30            .byte	$30
40420 FB77                        78            .byte	$78
40421 FB78                        78            .byte	$78
40422 FB79                        30            .byte	$30
40423 FB7A                        30            .byte	$30
40424 FB7B                        00            .byte	0
40425 FB7C                        30            .byte	$30
40426 FB7D                        00            .byte	0
40427                                           ! 8281  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
40428 FB7E                        6C            .byte	$6C
40429 FB7F                        6C            .byte	$6C
40430 FB80                        6C            .byte	$6C
40431 FB81                        00            .byte	0
40432 FB82                        00            .byte	0
40433 FB83                        00            .byte	0
40434 FB84                        00            .byte	0
40435 FB85                        00            .byte	0
40436                                           ! 8282  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
40437 FB86                        6C            .byte	$6C
40438 FB87                        6C            .byte	$6C
40439 FB88                        FE            .byte	$FE
40440 FB89                        6C            .byte	$6C
40441 FB8A                        FE            .byte	$FE
40442 FB8B                        6C            .byte	$6C
40443 FB8C                        6C            .byte	$6C
40444 FB8D                        00            .byte	0
40445                                           ! 8283  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
40446 FB8E                        30            .byte	$30
40447 FB8F                        7C            .byte	$7C
40448 FB90                        C0            .byte	$C0
40449 FB91                        78            .byte	$78
40450 FB92                        0C            .byte	$C
40451 FB93                        F8            .byte	$F8
40452 FB94                        30            .byte	$30
40453 FB95                        00            .byte	0
40454                                           ! 8284  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
40455 FB96                        00            .byte	0
40456 FB97                        C6            .byte	$C6
40457 FB98                        CC            .byte	$CC
40458 FB99                        18            .byte	$18
40459 FB9A                        30            .byte	$30
40460 FB9B                        66            .byte	$66
40461 FB9C                        C6            .byte	$C6
40462 FB9D                        00            .byte	0
40463                                           ! 8285  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
40464 FB9E                        38            .byte	$38
40465 FB9F                        6C            .byte	$6C
40466 FBA0                        38            .byte	$38
40467 FBA1                        76            .byte	$76
40468 FBA2                        DC            .byte	$DC
40469 FBA3                        CC            .byte	$CC
40470 FBA4                        76            .byte	$76
40471 FBA5                        00            .byte	0
40472                                           ! 8286  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
40473 FBA6                        60            .byte	$60
40474 FBA7                        60            .byte	$60
40475 FBA8                        C0            .byte	$C0
40476 FBA9                        00            .byte	0
40477 FBAA                        00            .byte	0
40478 FBAB                        00            .byte	0
40479 FBAC                        00            .byte	0
40480 FBAD                        00            .byte	0
40481                                           ! 8287  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
40482 FBAE                        18            .byte	$18
40483 FBAF                        30            .byte	$30
40484 FBB0                        60            .byte	$60
40485 FBB1                        60            .byte	$60
40486 FBB2                        60            .byte	$60
40487 FBB3                        30            .byte	$30
40488 FBB4                        18            .byte	$18
40489 FBB5                        00            .byte	0
40490                                           ! 8288  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
40491 FBB6                        60            .byte	$60
40492 FBB7                        30            .byte	$30
40493 FBB8                        18            .byte	$18
40494 FBB9                        18            .byte	$18
40495 FBBA                        18            .byte	$18
40496 FBBB                        30            .byte	$30
40497 FBBC                        60            .byte	$60
40498 FBBD                        00            .byte	0
40499                                           ! 8289  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
40500 FBBE                        00            .byte	0
40501 FBBF                        66            .byte	$66
40502 FBC0                        3C            .byte	$3C
40503 FBC1                        FF            .byte	$FF
40504 FBC2                        3C            .byte	$3C
40505 FBC3                        66            .byte	$66
40506 FBC4                        00            .byte	0
40507 FBC5                        00            .byte	0
40508                                           ! 8290  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
40509 FBC6                        00            .byte	0
40510 FBC7                        30            .byte	$30
40511 FBC8                        30            .byte	$30
40512 FBC9                        FC            .byte	$FC
40513 FBCA                        30            .byte	$30
40514 FBCB                        30            .byte	$30
40515 FBCC                        00            .byte	0
40516 FBCD                        00            .byte	0
40517                                           ! 8291  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
40518 FBCE                        00            .byte	0
40519 FBCF                        00            .byte	0
40520 FBD0                        00            .byte	0
40521 FBD1                        00            .byte	0
40522 FBD2                        00            .byte	0
40523 FBD3                        30            .byte	$30
40524 FBD4                        30            .byte	$30
40525 FBD5                        60            .byte	$60
40526                                           ! 8292  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
40527 FBD6                        00            .byte	0
40528 FBD7                        00            .byte	0
40529 FBD8                        00            .byte	0
40530 FBD9                        FC            .byte	$FC
40531 FBDA                        00            .byte	0
40532 FBDB                        00            .byte	0
40533 FBDC                        00            .byte	0
40534 FBDD                        00            .byte	0
40535                                           ! 8293  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
40536 FBDE                        00            .byte	0
40537 FBDF                        00            .byte	0
40538 FBE0                        00            .byte	0
40539 FBE1                        00            .byte	0
40540 FBE2                        00            .byte	0
40541 FBE3                        30            .byte	$30
40542 FBE4                        30            .byte	$30
40543 FBE5                        00            .byte	0
40544                                           ! 8294  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
40545 FBE6                        06            .byte	6
40546 FBE7                        0C            .byte	$C
40547 FBE8                        18            .byte	$18
40548 FBE9                        30            .byte	$30
40549 FBEA                        60            .byte	$60
40550 FBEB                        C0            .byte	$C0
40551 FBEC                        80            .byte	$80
40552 FBED                        00            .byte	0
40553                                           ! 8295  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
40554 FBEE                        7C            .byte	$7C
40555 FBEF                        C6            .byte	$C6
40556 FBF0                        CE            .byte	$CE
40557 FBF1                        DE            .byte	$DE
40558 FBF2                        F6            .byte	$F6
40559 FBF3                        E6            .byte	$E6
40560 FBF4                        7C            .byte	$7C
40561 FBF5                        00            .byte	0
40562                                           ! 8296  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
40563 FBF6                        30            .byte	$30
40564 FBF7                        70            .byte	$70
40565 FBF8                        30            .byte	$30
40566 FBF9                        30            .byte	$30
40567 FBFA                        30            .byte	$30
40568 FBFB                        30            .byte	$30
40569 FBFC                        FC            .byte	$FC
40570 FBFD                        00            .byte	0
40571                                           ! 8297  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
40572 FBFE                        78            .byte	$78
40573 FBFF                        CC            .byte	$CC
40574 FC00                        0C            .byte	$C
40575 FC01                        38            .byte	$38
40576 FC02                        60            .byte	$60
40577 FC03                        CC            .byte	$CC
40578 FC04                        FC            .byte	$FC
40579 FC05                        00            .byte	0
40580                                           ! 8298  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
40581 FC06                        78            .byte	$78
40582 FC07                        CC            .byte	$CC
40583 FC08                        0C            .byte	$C
40584 FC09                        38            .byte	$38
40585 FC0A                        0C            .byte	$C
40586 FC0B                        CC            .byte	$CC
40587 FC0C                        78            .byte	$78
40588 FC0D                        00            .byte	0
40589                                           ! 8299  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
40590 FC0E                        1C            .byte	$1C
40591 FC0F                        3C            .byte	$3C
40592 FC10                        6C            .byte	$6C
40593 FC11                        CC            .byte	$CC
40594 FC12                        FE            .byte	$FE
40595 FC13                        0C            .byte	$C
40596 FC14                        1E            .byte	$1E
40597 FC15                        00            .byte	0
40598                                           ! 8300  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
40599 FC16                        FC            .byte	$FC
40600 FC17                        C0            .byte	$C0
40601 FC18                        F8            .byte	$F8
40602 FC19                        0C            .byte	$C
40603 FC1A                        0C            .byte	$C
40604 FC1B                        CC            .byte	$CC
40605 FC1C                        78            .byte	$78
40606 FC1D                        00            .byte	0
40607                                           ! 8301  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
40608 FC1E                        38            .byte	$38
40609 FC1F                        60            .byte	$60
40610 FC20                        C0            .byte	$C0
40611 FC21                        F8            .byte	$F8
40612 FC22                        CC            .byte	$CC
40613 FC23                        CC            .byte	$CC
40614 FC24                        78            .byte	$78
40615 FC25                        00            .byte	0
40616                                           ! 8302  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
40617 FC26                        FC            .byte	$FC
40618 FC27                        CC            .byte	$CC
40619 FC28                        0C            .byte	$C
40620 FC29                        18            .byte	$18
40621 FC2A                        30            .byte	$30
40622 FC2B                        30            .byte	$30
40623 FC2C                        30            .byte	$30
40624 FC2D                        00            .byte	0
40625                                           ! 8303  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
40626 FC2E                        78            .byte	$78
40627 FC2F                        CC            .byte	$CC
40628 FC30                        CC            .byte	$CC
40629 FC31                        78            .byte	$78
40630 FC32                        CC            .byte	$CC
40631 FC33                        CC            .byte	$CC
40632 FC34                        78            .byte	$78
40633 FC35                        00            .byte	0
40634                                           ! 8304  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
40635 FC36                        78            .byte	$78
40636 FC37                        CC            .byte	$CC
40637 FC38                        CC            .byte	$CC
40638 FC39                        7C            .byte	$7C
40639 FC3A                        0C            .byte	$C
40640 FC3B                        18            .byte	$18
40641 FC3C                        70            .byte	$70
40642 FC3D                        00            .byte	0
40643                                           ! 8305  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
40644 FC3E                        00            .byte	0
40645 FC3F                        30            .byte	$30
40646 FC40                        30            .byte	$30
40647 FC41                        00            .byte	0
40648 FC42                        00            .byte	0
40649 FC43                        30            .byte	$30
40650 FC44                        30            .byte	$30
40651 FC45                        00            .byte	0
40652                                           ! 8306  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
40653 FC46                        00            .byte	0
40654 FC47                        30            .byte	$30
40655 FC48                        30            .byte	$30
40656 FC49                        00            .byte	0
40657 FC4A                        00            .byte	0
40658 FC4B                        30            .byte	$30
40659 FC4C                        30            .byte	$30
40660 FC4D                        60            .byte	$60
40661                                           ! 8307  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
40662 FC4E                        18            .byte	$18
40663 FC4F                        30            .byte	$30
40664 FC50                        60            .byte	$60
40665 FC51                        C0            .byte	$C0
40666 FC52                        60            .byte	$60
40667 FC53                        30            .byte	$30
40668 FC54                        18            .byte	$18
40669 FC55                        00            .byte	0
40670                                           ! 8308  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
40671 FC56                        00            .byte	0
40672 FC57                        00            .byte	0
40673 FC58                        FC            .byte	$FC
40674 FC59                        00            .byte	0
40675 FC5A                        00            .byte	0
40676 FC5B                        FC            .byte	$FC
40677 FC5C                        00            .byte	0
40678 FC5D                        00            .byte	0
40679                                           ! 8309  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
40680 FC5E                        60            .byte	$60
40681 FC5F                        30            .byte	$30
40682 FC60                        18            .byte	$18
40683 FC61                        0C            .byte	$C
40684 FC62                        18            .byte	$18
40685 FC63                        30            .byte	$30
40686 FC64                        60            .byte	$60
40687 FC65                        00            .byte	0
40688                                           ! 8310  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
40689 FC66                        78            .byte	$78
40690 FC67                        CC            .byte	$CC
40691 FC68                        0C            .byte	$C
40692 FC69                        18            .byte	$18
40693 FC6A                        30            .byte	$30
40694 FC6B                        00            .byte	0
40695 FC6C                        30            .byte	$30
40696 FC6D                        00            .byte	0
40697                                           ! 8311  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
40698 FC6E                        7C            .byte	$7C
40699 FC6F                        C6            .byte	$C6
40700 FC70                        DE            .byte	$DE
40701 FC71                        DE            .byte	$DE
40702 FC72                        DE            .byte	$DE
40703 FC73                        C0            .byte	$C0
40704 FC74                        78            .byte	$78
40705 FC75                        00            .byte	0
40706                                           ! 8312  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0
40707 FC76                        30            .byte	$30
40708 FC77                        78            .byte	$78
40709 FC78                        CC            .byte	$CC
40710 FC79                        CC            .byte	$CC
40711 FC7A                        FC            .byte	$FC
40712 FC7B                        CC            .byte	$CC
40713 FC7C                        CC            .byte	$CC
40714                                           ! 8312 x00,
40715 FC7D                        00            .byte	0
40716                                           ! 8313  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
40717 FC7E                        FC            .byte	$FC
40718 FC7F                        66            .byte	$66
40719 FC80                        66            .byte	$66
40720 FC81                        7C            .byte	$7C
40721 FC82                        66            .byte	$66
40722 FC83                        66            .byte	$66
40723 FC84                        FC            .byte	$FC
40724 FC85                        00            .byte	0
40725                                           ! 8314  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
40726 FC86                        3C            .byte	$3C
40727 FC87                        66            .byte	$66
40728 FC88                        C0            .byte	$C0
40729 FC89                        C0            .byte	$C0
40730 FC8A                        C0            .byte	$C0
40731 FC8B                        66            .byte	$66
40732 FC8C                        3C            .byte	$3C
40733 FC8D                        00            .byte	0
40734                                           ! 8315  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
40735 FC8E                        F8            .byte	$F8
40736 FC8F                        6C            .byte	$6C
40737 FC90                        66            .byte	$66
40738 FC91                        66            .byte	$66
40739 FC92                        66            .byte	$66
40740 FC93                        6C            .byte	$6C
40741 FC94                        F8            .byte	$F8
40742 FC95                        00            .byte	0
40743                                           ! 8316  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
40744 FC96                        FE            .byte	$FE
40745 FC97                        62            .byte	$62
40746 FC98                        68            .byte	$68
40747 FC99                        78            .byte	$78
40748 FC9A                        68            .byte	$68
40749 FC9B                        62            .byte	$62
40750 FC9C                        FE            .byte	$FE
40751 FC9D                        00            .byte	0
40752                                           ! 8317  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
40753 FC9E                        FE            .byte	$FE
40754 FC9F                        62            .byte	$62
40755 FCA0                        68            .byte	$68
40756 FCA1                        78            .byte	$78
40757 FCA2                        68            .byte	$68
40758 FCA3                        60            .byte	$60
40759 FCA4                        F0            .byte	$F0
40760 FCA5                        00            .byte	0
40761                                           ! 8318  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
40762 FCA6                        3C            .byte	$3C
40763 FCA7                        66            .byte	$66
40764 FCA8                        C0            .byte	$C0
40765 FCA9                        C0            .byte	$C0
40766 FCAA                        CE            .byte	$CE
40767 FCAB                        66            .byte	$66
40768 FCAC                        3E            .byte	$3E
40769 FCAD                        00            .byte	0
40770                                           ! 8319  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
40771 FCAE                        CC            .byte	$CC
40772 FCAF                        CC            .byte	$CC
40773 FCB0                        CC            .byte	$CC
40774 FCB1                        FC            .byte	$FC
40775 FCB2                        CC            .byte	$CC
40776 FCB3                        CC            .byte	$CC
40777 FCB4                        CC            .byte	$CC
40778 FCB5                        00            .byte	0
40779                                           ! 8320  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
40780 FCB6                        78            .byte	$78
40781 FCB7                        30            .byte	$30
40782 FCB8                        30            .byte	$30
40783 FCB9                        30            .byte	$30
40784 FCBA                        30            .byte	$30
40785 FCBB                        30            .byte	$30
40786 FCBC                        78            .byte	$78
40787 FCBD                        00            .byte	0
40788                                           ! 8321  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
40789 FCBE                        1E            .byte	$1E
40790 FCBF                        0C            .byte	$C
40791 FCC0                        0C            .byte	$C
40792 FCC1                        0C            .byte	$C
40793 FCC2                        CC            .byte	$CC
40794 FCC3                        CC            .byte	$CC
40795 FCC4                        78            .byte	$78
40796 FCC5                        00            .byte	0
40797                                           ! 8322  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
40798 FCC6                        E6            .byte	$E6
40799 FCC7                        66            .byte	$66
40800 FCC8                        6C            .byte	$6C
40801 FCC9                        78            .byte	$78
40802 FCCA                        6C            .byte	$6C
40803 FCCB                        66            .byte	$66
40804 FCCC                        E6            .byte	$E6
40805 FCCD                        00            .byte	0
40806                                           ! 8323  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
40807 FCCE                        F0            .byte	$F0
40808 FCCF                        60            .byte	$60
40809 FCD0                        60            .byte	$60
40810 FCD1                        60            .byte	$60
40811 FCD2                        62            .byte	$62
40812 FCD3                        66            .byte	$66
40813 FCD4                        FE            .byte	$FE
40814 FCD5                        00            .byte	0
40815                                           ! 8324  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
40816 FCD6                        C6            .byte	$C6
40817 FCD7                        EE            .byte	$EE
40818 FCD8                        FE            .byte	$FE
40819 FCD9                        FE            .byte	$FE
40820 FCDA                        D6            .byte	$D6
40821 FCDB                        C6            .byte	$C6
40822 FCDC                        C6            .byte	$C6
40823 FCDD                        00            .byte	0
40824                                           ! 8325  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
40825 FCDE                        C6            .byte	$C6
40826 FCDF                        E6            .byte	$E6
40827 FCE0                        F6            .byte	$F6
40828 FCE1                        DE            .byte	$DE
40829 FCE2                        CE            .byte	$CE
40830 FCE3                        C6            .byte	$C6
40831 FCE4                        C6            .byte	$C6
40832 FCE5                        00            .byte	0
40833                                           ! 8326  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
40834 FCE6                        38            .byte	$38
40835 FCE7                        6C            .byte	$6C
40836 FCE8                        C6            .byte	$C6
40837 FCE9                        C6            .byte	$C6
40838 FCEA                        C6            .byte	$C6
40839 FCEB                        6C            .byte	$6C
40840 FCEC                        38            .byte	$38
40841 FCED                        00            .byte	0
40842                                           ! 8327  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
40843 FCEE                        FC            .byte	$FC
40844 FCEF                        66            .byte	$66
40845 FCF0                        66            .byte	$66
40846 FCF1                        7C            .byte	$7C
40847 FCF2                        60            .byte	$60
40848 FCF3                        60            .byte	$60
40849 FCF4                        F0            .byte	$F0
40850 FCF5                        00            .byte	0
40851                                           ! 8328  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
40852 FCF6                        78            .byte	$78
40853 FCF7                        CC            .byte	$CC
40854 FCF8                        CC            .byte	$CC
40855 FCF9                        CC            .byte	$CC
40856 FCFA                        DC            .byte	$DC
40857 FCFB                        78            .byte	$78
40858 FCFC                        1C            .byte	$1C
40859 FCFD                        00            .byte	0
40860                                           ! 8329  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
40861 FCFE                        FC            .byte	$FC
40862 FCFF                        66            .byte	$66
40863 FD00                        66            .byte	$66
40864 FD01                        7C            .byte	$7C
40865 FD02                        6C            .byte	$6C
40866 FD03                        66            .byte	$66
40867 FD04                        E6            .byte	$E6
40868 FD05                        00            .byte	0
40869                                           ! 8330  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
40870 FD06                        78            .byte	$78
40871 FD07                        CC            .byte	$CC
40872 FD08                        E0            .byte	$E0
40873 FD09                        70            .byte	$70
40874 FD0A                        1C            .byte	$1C
40875 FD0B                        CC            .byte	$CC
40876 FD0C                        78            .byte	$78
40877 FD0D                        00            .byte	0
40878                                           ! 8331  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
40879 FD0E                        FC            .byte	$FC
40880 FD0F                        B4            .byte	$B4
40881 FD10                        30            .byte	$30
40882 FD11                        30            .byte	$30
40883 FD12                        30            .byte	$30
40884 FD13                        30            .byte	$30
40885 FD14                        78            .byte	$78
40886 FD15                        00            .byte	0
40887                                           ! 8332  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
40888 FD16                        CC            .byte	$CC
40889 FD17                        CC            .byte	$CC
40890 FD18                        CC            .byte	$CC
40891 FD19                        CC            .byte	$CC
40892 FD1A                        CC            .byte	$CC
40893 FD1B                        CC            .byte	$CC
40894 FD1C                        FC            .byte	$FC
40895 FD1D                        00            .byte	0
40896                                           ! 8333  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
40897 FD1E                        CC            .byte	$CC
40898 FD1F                        CC            .byte	$CC
40899 FD20                        CC            .byte	$CC
40900 FD21                        CC            .byte	$CC
40901 FD22                        CC            .byte	$CC
40902 FD23                        78            .byte	$78
40903 FD24                        30            .byte	$30
40904 FD25                        00            .byte	0
40905                                           ! 8334  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
40906 FD26                        C6            .byte	$C6
40907 FD27                        C6            .byte	$C6
40908 FD28                        C6            .byte	$C6
40909 FD29                        D6            .byte	$D6
40910 FD2A                        FE            .byte	$FE
40911 FD2B                        EE            .byte	$EE
40912 FD2C                        C6            .byte	$C6
40913 FD2D                        00            .byte	0
40914                                           ! 8335  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
40915 FD2E                        C6            .byte	$C6
40916 FD2F                        C6            .byte	$C6
40917 FD30                        6C            .byte	$6C
40918 FD31                        38            .byte	$38
40919 FD32                        38            .byte	$38
40920 FD33                        6C            .byte	$6C
40921 FD34                        C6            .byte	$C6
40922 FD35                        00            .byte	0
40923                                           ! 8336  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
40924 FD36                        CC            .byte	$CC
40925 FD37                        CC            .byte	$CC
40926 FD38                        CC            .byte	$CC
40927 FD39                        78            .byte	$78
40928 FD3A                        30            .byte	$30
40929 FD3B                        30            .byte	$30
40930 FD3C                        78            .byte	$78
40931 FD3D                        00            .byte	0
40932                                           ! 8337  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
40933 FD3E                        FE            .byte	$FE
40934 FD3F                        C6            .byte	$C6
40935 FD40                        8C            .byte	$8C
40936 FD41                        18            .byte	$18
40937 FD42                        32            .byte	$32
40938 FD43                        66            .byte	$66
40939 FD44                        FE            .byte	$FE
40940 FD45                        00            .byte	0
40941                                           ! 8338  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
40942 FD46                        78            .byte	$78
40943 FD47                        60            .byte	$60
40944 FD48                        60            .byte	$60
40945 FD49                        60            .byte	$60
40946 FD4A                        60            .byte	$60
40947 FD4B                        60            .byte	$60
40948 FD4C                        78            .byte	$78
40949 FD4D                        00            .byte	0
40950                                           ! 8339  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
40951 FD4E                        C0            .byte	$C0
40952 FD4F                        60            .byte	$60
40953 FD50                        30            .byte	$30
40954 FD51                        18            .byte	$18
40955 FD52                        0C            .byte	$C
40956 FD53                        06            .byte	6
40957 FD54                        02            .byte	2
40958 FD55                        00            .byte	0
40959                                           ! 8340  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
40960 FD56                        78            .byte	$78
40961 FD57                        18            .byte	$18
40962 FD58                        18            .byte	$18
40963 FD59                        18            .byte	$18
40964 FD5A                        18            .byte	$18
40965 FD5B                        18            .byte	$18
40966 FD5C                        78            .byte	$78
40967 FD5D                        00            .byte	0
40968                                           ! 8341  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
40969 FD5E                        10            .byte	$10
40970 FD5F                        38            .byte	$38
40971 FD60                        6C            .byte	$6C
40972 FD61                        C6            .byte	$C6
40973 FD62                        00            .byte	0
40974 FD63                        00            .byte	0
40975 FD64                        00            .byte	0
40976 FD65                        00            .byte	0
40977                                           ! 8342  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
40978 FD66                        00            .byte	0
40979 FD67                        00            .byte	0
40980 FD68                        00            .byte	0
40981 FD69                        00            .byte	0
40982 FD6A                        00            .byte	0
40983 FD6B                        00            .byte	0
40984 FD6C                        00            .byte	0
40985 FD6D                        FF            .byte	$FF
40986                                           ! 8343  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
40987 FD6E                        30            .byte	$30
40988 FD6F                        30            .byte	$30
40989 FD70                        18            .byte	$18
40990 FD71                        00            .byte	0
40991 FD72                        00            .byte	0
40992 FD73                        00            .byte	0
40993 FD74                        00            .byte	0
40994 FD75                        00            .byte	0
40995                                           ! 8344  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
40996 FD76                        00            .byte	0
40997 FD77                        00            .byte	0
40998 FD78                        78            .byte	$78
40999 FD79                        0C            .byte	$C
41000 FD7A                        7C            .byte	$7C
41001 FD7B                        CC            .byte	$CC
41002 FD7C                        76            .byte	$76
41003 FD7D                        00            .byte	0
41004                                           ! 8345  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
41005 FD7E                        E0            .byte	$E0
41006 FD7F                        60            .byte	$60
41007 FD80                        60            .byte	$60
41008 FD81                        7C            .byte	$7C
41009 FD82                        66            .byte	$66
41010 FD83                        66            .byte	$66
41011 FD84                        DC            .byte	$DC
41012 FD85                        00            .byte	0
41013                                           ! 8346  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
41014 FD86                        00            .byte	0
41015 FD87                        00            .byte	0
41016 FD88                        78            .byte	$78
41017 FD89                        CC            .byte	$CC
41018 FD8A                        C0            .byte	$C0
41019 FD8B                        CC            .byte	$CC
41020 FD8C                        78            .byte	$78
41021 FD8D                        00            .byte	0
41022                                           ! 8347  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
41023 FD8E                        1C            .byte	$1C
41024 FD8F                        0C            .byte	$C
41025 FD90                        0C            .byte	$C
41026 FD91                        7C            .byte	$7C
41027 FD92                        CC            .byte	$CC
41028 FD93                        CC            .byte	$CC
41029 FD94                        76            .byte	$76
41030 FD95                        00            .byte	0
41031                                           ! 8348  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
41032 FD96                        00            .byte	0
41033 FD97                        00            .byte	0
41034 FD98                        78            .byte	$78
41035 FD99                        CC            .byte	$CC
41036 FD9A                        FC            .byte	$FC
41037 FD9B                        C0            .byte	$C0
41038 FD9C                        78            .byte	$78
41039 FD9D                        00            .byte	0
41040                                           ! 8349  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
41041 FD9E                        38            .byte	$38
41042 FD9F                        6C            .byte	$6C
41043 FDA0                        60            .byte	$60
41044 FDA1                        F0            .byte	$F0
41045 FDA2                        60            .byte	$60
41046 FDA3                        60            .byte	$60
41047 FDA4                        F0            .byte	$F0
41048 FDA5                        00            .byte	0
41049                                           ! 8350  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41050 FDA6                        00            .byte	0
41051 FDA7                        00            .byte	0
41052 FDA8                        76            .byte	$76
41053 FDA9                        CC            .byte	$CC
41054 FDAA                        CC            .byte	$CC
41055 FDAB                        7C            .byte	$7C
41056 FDAC                        0C            .byte	$C
41057 FDAD                        F8            .byte	$F8
41058                                           ! 8351  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
41059 FDAE                        E0            .byte	$E0
41060 FDAF                        60            .byte	$60
41061 FDB0                        6C            .byte	$6C
41062 FDB1                        76            .byte	$76
41063 FDB2                        66            .byte	$66
41064 FDB3                        66            .byte	$66
41065 FDB4                        E6            .byte	$E6
41066 FDB5                        00            .byte	0
41067                                           ! 8352  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
41068 FDB6                        30            .byte	$30
41069 FDB7                        00            .byte	0
41070 FDB8                        70            .byte	$70
41071 FDB9                        30            .byte	$30
41072 FDBA                        30            .byte	$30
41073 FDBB                        30            .byte	$30
41074 FDBC                        78            .byte	$78
41075 FDBD                        00            .byte	0
41076                                           ! 8353  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
41077 FDBE                        0C            .byte	$C
41078 FDBF                        00            .byte	0
41079 FDC0                        0C            .byte	$C
41080 FDC1                        0C            .byte	$C
41081 FDC2                        0C            .byte	$C
41082 FDC3                        CC            .byte	$CC
41083 FDC4                        CC            .byte	$CC
41084 FDC5                        78            .byte	$78
41085                                           ! 8354  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6
41086 FDC6                        E0            .byte	$E0
41087 FDC7                        60            .byte	$60
41088 FDC8                        66            .byte	$66
41089 FDC9                        6C            .byte	$6C
41090 FDCA                        78            .byte	$78
41091                                           ! 8354 c, 0xe6, 0x00,
41092 FDCB                        6C            .byte	$6C
41093 FDCC                        E6            .byte	$E6
41094 FDCD                        00            .byte	0
41095                                           ! 8355  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41096 FDCE                        70            .byte	$70
41097 FDCF                        30            .byte	$30
41098 FDD0                        30            .byte	$30
41099 FDD1                        30            .byte	$30
41100 FDD2                        30            .byte	$30
41101 FDD3                        30            .byte	$30
41102 FDD4                        78            .byte	$78
41103 FDD5                        00            .byte	0
41104                                           ! 8356  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
41105 FDD6                        00            .byte	0
41106 FDD7                        00            .byte	0
41107 FDD8                        CC            .byte	$CC
41108 FDD9                        FE            .byte	$FE
41109 FDDA                        FE            .byte	$FE
41110 FDDB                        D6            .byte	$D6
41111 FDDC                        C6            .byte	$C6
41112 FDDD                        00            .byte	0
41113                                           ! 8357  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
41114 FDDE                        00            .byte	0
41115 FDDF                        00            .byte	0
41116 FDE0                        F8            .byte	$F8
41117 FDE1                        CC            .byte	$CC
41118 FDE2                        CC            .byte	$CC
41119 FDE3                        CC            .byte	$CC
41120 FDE4                        CC            .byte	$CC
41121 FDE5                        00            .byte	0
41122                                           ! 8358  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
41123 FDE6                        00            .byte	0
41124 FDE7                        00            .byte	0
41125 FDE8                        78            .byte	$78
41126 FDE9                        CC            .byte	$CC
41127 FDEA                        CC            .byte	$CC
41128 FDEB                        CC            .byte	$CC
41129 FDEC                        78            .byte	$78
41130 FDED                        00            .byte	0
41131                                           ! 8359  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
41132 FDEE                        00            .byte	0
41133 FDEF                        00            .byte	0
41134 FDF0                        DC            .byte	$DC
41135 FDF1                        66            .byte	$66
41136 FDF2                        66            .byte	$66
41137 FDF3                        7C            .byte	$7C
41138 FDF4                        60            .byte	$60
41139 FDF5                        F0            .byte	$F0
41140                                           ! 8360  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
41141 FDF6                        00            .byte	0
41142 FDF7                        00            .byte	0
41143 FDF8                        76            .byte	$76
41144 FDF9                        CC            .byte	$CC
41145 FDFA                        CC            .byte	$CC
41146 FDFB                        7C            .byte	$7C
41147 FDFC                        0C            .byte	$C
41148 FDFD                        1E            .byte	$1E
41149                                           ! 8361  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
41150 FDFE                        00            .byte	0
41151 FDFF                        00            .byte	0
41152 FE00                        DC            .byte	$DC
41153 FE01                        76            .byte	$76
41154 FE02                        66            .byte	$66
41155 FE03                        60            .byte	$60
41156 FE04                        F0            .byte	$F0
41157 FE05                        00            .byte	0
41158                                           ! 8362  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
41159 FE06                        00            .byte	0
41160 FE07                        00            .byte	0
41161 FE08                        7C            .byte	$7C
41162 FE09                        C0            .byte	$C0
41163 FE0A                        78            .byte	$78
41164 FE0B                        0C            .byte	$C
41165 FE0C                        F8            .byte	$F8
41166 FE0D                        00            .byte	0
41167                                           ! 8363  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
41168 FE0E                        10            .byte	$10
41169 FE0F                        30            .byte	$30
41170 FE10                        7C            .byte	$7C
41171 FE11                        30            .byte	$30
41172 FE12                        30            .byte	$30
41173 FE13                        34            .byte	$34
41174 FE14                        18            .byte	$18
41175 FE15                        00            .byte	0
41176                                           ! 8364  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
41177 FE16                        00            .byte	0
41178 FE17                        00            .byte	0
41179 FE18                        CC            .byte	$CC
41180 FE19                        CC            .byte	$CC
41181 FE1A                        CC            .byte	$CC
41182 FE1B                        CC            .byte	$CC
41183 FE1C                        76            .byte	$76
41184 FE1D                        00            .byte	0
41185                                           ! 8365  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41186 FE1E                        00            .byte	0
41187 FE1F                        00            .byte	0
41188 FE20                        CC            .byte	$CC
41189 FE21                        CC            .byte	$CC
41190 FE22                        CC            .byte	$CC
41191 FE23                        78            .byte	$78
41192 FE24                        30            .byte	$30
41193 FE25                        00            .byte	0
41194                                           ! 8366  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
41195 FE26                        00            .byte	0
41196 FE27                        00            .byte	0
41197 FE28                        C6            .byte	$C6
41198 FE29                        D6            .byte	$D6
41199 FE2A                        FE            .byte	$FE
41200 FE2B                        FE            .byte	$FE
41201 FE2C                        6C            .byte	$6C
41202 FE2D                        00            .byte	0
41203                                           ! 8367  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
41204 FE2E                        00            .byte	0
41205 FE2F                        00            .byte	0
41206 FE30                        C6            .byte	$C6
41207 FE31                        6C            .byte	$6C
41208 FE32                        38            .byte	$38
41209 FE33                        6C            .byte	$6C
41210 FE34                        C6            .byte	$C6
41211 FE35                        00            .byte	0
41212                                           ! 8368  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41213 FE36                        00            .byte	0
41214 FE37                        00            .byte	0
41215 FE38                        CC            .byte	$CC
41216 FE39                        CC            .byte	$CC
41217 FE3A                        CC            .byte	$CC
41218 FE3B                        7C            .byte	$7C
41219 FE3C                        0C            .byte	$C
41220 FE3D                        F8            .byte	$F8
41221                                           ! 8369  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
41222 FE3E                        00            .byte	0
41223 FE3F                        00            .byte	0
41224 FE40                        FC            .byte	$FC
41225 FE41                        98            .byte	$98
41226 FE42                        30            .byte	$30
41227 FE43                        64            .byte	$64
41228 FE44                        FC            .byte	$FC
41229 FE45                        00            .byte	0
41230                                           ! 8370  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
41231 FE46                        1C            .byte	$1C
41232 FE47                        30            .byte	$30
41233 FE48                        30            .byte	$30
41234 FE49                        E0            .byte	$E0
41235 FE4A                        30            .byte	$30
41236 FE4B                        30            .byte	$30
41237 FE4C                        1C            .byte	$1C
41238 FE4D                        00            .byte	0
41239                                           ! 8371  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
41240 FE4E                        18            .byte	$18
41241 FE4F                        18            .byte	$18
41242 FE50                        18            .byte	$18
41243 FE51                        00            .byte	0
41244 FE52                        18            .byte	$18
41245 FE53                        18            .byte	$18
41246 FE54                        18            .byte	$18
41247 FE55                        00            .byte	0
41248                                           ! 8372  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
41249 FE56                        E0            .byte	$E0
41250 FE57                        30            .byte	$30
41251 FE58                        30            .byte	$30
41252 FE59                        1C            .byte	$1C
41253 FE5A                        30            .byte	$30
41254 FE5B                        30            .byte	$30
41255 FE5C                        E0            .byte	$E0
41256 FE5D                        00            .byte	0
41257                                           ! 8373  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41258 FE5E                        76            .byte	$76
41259 FE5F                        DC            .byte	$DC
41260 FE60                        00            .byte	0
41261 FE61                        00            .byte	0
41262 FE62                        00            .byte	0
41263 FE63                        00            .byte	0
41264 FE64                        00            .byte	0
41265 FE65                        00            .byte	0
41266                                           ! 8374  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
41267 FE66                        00            .byte	0
41268 FE67                        10            .byte	$10
41269 FE68                        38            .byte	$38
41270 FE69                        6C            .byte	$6C
41271 FE6A                        C6            .byte	$C6
41272 FE6B                        C6            .byte	$C6
41273 FE6C                        FE            .byte	$FE
41274 FE6D                        00            .byte	0
41275                                           ! 8375 };
41276                                           !BCC_EOS
41277                                           ! 8376 #asm
41278                                           !BCC_ASM
41279 CFF0                                      .org 0xcff0
41280                       0000CFF0            bios_table_area_end:
41281                                           ! 8379 endasm
41282                                           !BCC_ENDASM
41283                                           ! 8380 
41284                       0000CFF0            .722:
41285                       0000CFF0            .76D:
41286 CFF0                        20            .ascii	" - success."
41287 CFFB                        0A            .byte	$A
41288 CFFC                        00            .byte	0
41289                       0000CFFD            .70B:
41290                       0000CFFD            .76E:
41291 CFFD                        00            .byte	0
41292                       0000CFFE            .70A:
41293                       0000CFFE            .76F:
41294 CFFE                        50            .ascii	"Powering off in 30 seconds."
41295 D019                        0A            .byte	$A
41296 D01A                        00            .byte	0
41297                       0000D01B            .709:
41298                       0000D01B            .770:
41299 D01B                        0A            .byte	$A
41300 D01C                        4E            .ascii	"No bootable device."
41301 D02F                        0A            .byte	$A
41302 D030                        00            .byte	0
41303                       0000D031            .6F3:
41304                       0000D031            .771:
41305 D031                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
41306 D056                        0A            .byte	$A
41307 D057                        00            .byte	0
41308                       0000D058            .6DD:
41309                       0000D058            .772:
41310 D058                        66            .ascii	"floppy: int13: bad floppy type"
41311 D076                        0A            .byte	$A
41312 D077                        00            .byte	0
41313                       0000D078            .6C5:
41314                       0000D078            .773:
41315 D078                        69            .ascii	"int13_diskette_function: write error"
41316 D09C                        0A            .byte	$A
41317 D09D                        00            .byte	0
41318                       0000D09E            .6BF:
41319                       0000D09E            .774:
41320 D09E                        69            .ascii	"int13_diskette: ctrl not ready"
41321 D0BC                        0A            .byte	$A
41322 D0BD                        00            .byte	0
41323                       0000D0BE            .6A4:
41324                       0000D0BE            .775:
41325 D0BE                        69            .ascii	"int13_diskette_function: read error"
41326 D0E1                        0A            .byte	$A
41327 D0E2                        00            .byte	0
41328                       0000D0E3            .69E:
41329                       0000D0E3            .776:
41330 D0E3                        69            .ascii	"int13_diskette: ctrl not ready"
41331 D101                        0A            .byte	$A
41332 D102                        00            .byte	0
41333                       0000D103            .68C:
41334                       0000D103            .777:
41335 D103                        69            .ascii	"int13_diskette: ctrl not ready"
41336 D121                        0A            .byte	$A
41337 D122                        00            .byte	0
41338                       0000D123            .5DB:
41339                       0000D123            .778:
41340 D123                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
41341 D14B                        20            .ascii	" report"
41342 D152                        0A            .byte	$A
41343 D153                        00            .byte	0
41344                       0000D154            .585:
41345                       0000D154            .779:
41346 D154                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
41347 D17C                        62            .ascii	"bits lba"
41348 D184                        0A            .byte	$A
41349 D185                        00            .byte	0
41350                       0000D186            .48D:
41351                       0000D186            .77A:
41352 D186                        73            .ascii	"setkbdcomm"
41353 D190                        00            .byte	0
41354                       0000D191            .486:
41355                       0000D191            .77B:
41356 D191                        73            .ascii	"sendmouse"
41357 D19A                        00            .byte	0
41358                       0000D19B            .483:
41359                       0000D19B            .77C:
41360 D19B                        65            .ascii	"enabmouse"
41361 D1A4                        00            .byte	0
41362                       0000D1A5            .47C:
41363                       0000D1A5            .77D:
41364 D1A5                        65            .ascii	"enabmouse"
41365 D1AE                        00            .byte	0
41366                       0000D1AF            .479:
41367                       0000D1AF            .77E:
41368 D1AF                        69            .ascii	"inhibmouse"
41369 D1B9                        00            .byte	0
41370                       0000D1BA            .472:
41371                       0000D1BA            .77F:
41372 D1BA                        69            .ascii	"inhibmouse"
41373 D1C4                        00            .byte	0
41374                       0000D1C5            .455:
41375                       0000D1C5            .780:
41376 D1C5                        4B            .ascii	"KBD: int16h: out of keyboard input"
41377 D1E7                        0A            .byte	$A
41378 D1E8                        00            .byte	0
41379                       0000D1E9            .427:
41380                       0000D1E9            .781:
41381 D1E9                        4B            .ascii	"KBD: int16h: out of keyboard input"
41382 D20B                        0A            .byte	$A
41383 D20C                        00            .byte	0
41384                       0000D20D            .3D9:
41385                       0000D20D            .782:
41386 D20D                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
41387 D225                        0A            .byte	$A
41388 D226                        00            .byte	0
41389                       0000D227            .3C3:
41390                       0000D227            .783:
41391 D227                        4D            .ascii	"Mouse status returned %02x (should be ac"
41392 D24F                        6B            .ascii	"k)"
41393 D251                        0A            .byte	$A
41394 D252                        00            .byte	0
41395                       0000D253            .3B3:
41396                       0000D253            .784:
41397 D253                        4D            .ascii	"Mouse status returned %02x (should be ac"
41398 D27B                        6B            .ascii	"k)"
41399 D27D                        0A            .byte	$A
41400 D27E                        00            .byte	0
41401                       0000D27F            .3B0:
41402                       0000D27F            .785:
41403 D27F                        4D            .ascii	"Mouse status returned %02x (should be ac"
41404 D2A7                        6B            .ascii	"k)"
41405 D2A9                        0A            .byte	$A
41406 D2AA                        00            .byte	0
41407                       0000D2AB            .38E:
41408                       0000D2AB            .786:
41409 D2AB                        4D            .ascii	"Mouse reset returned %02x (should be ack"
41410 D2D3                        29            .ascii	")"
41411 D2D4                        0A            .byte	$A
41412 D2D5                        00            .byte	0
41413                       0000D2D6            .366:
41414                       0000D2D6            .787:
41415 D2D6                        45            .ascii	"EISA BIOS not present"
41416 D2EB                        0A            .byte	$A
41417 D2EC                        00            .byte	0
41418                       0000D2ED            .2D1:
41419                       0000D2ED            .788:
41420 D2ED                        25            .ascii	"%dMB medium detected"
41421 D301                        0A            .byte	$A
41422 D302                        00            .byte	0
41423                       0000D303            .2CC:
41424                       0000D303            .789:
41425 D303                        55            .ascii	"Unsupported sector size %u"
41426 D31D                        0A            .byte	$A
41427 D31E                        00            .byte	0
41428                       0000D31F            .2C7:
41429                       0000D31F            .78A:
41430 D31F                        57            .ascii	"Waiting for device to detect medium... "
41431 D346                        00            .byte	0
41432                       0000D347            .2B9:
41433                       0000D347            .78B:
41434 D347                        6E            .ascii	"not implemented for non-ATAPI device"
41435 D36B                        0A            .byte	$A
41436 D36C                        00            .byte	0
41437                       0000D36D            .230:
41438                       0000D36D            .78C:
41439 D36D                        0A            .byte	$A
41440 D36E                        00            .byte	0
41441                       0000D36F            .22E:
41442                       0000D36F            .78D:
41443 D36F                        55            .ascii	"Unknown device"
41444 D37D                        0A            .byte	$A
41445 D37E                        00            .byte	0
41446                       0000D37F            .22C:
41447                       0000D37F            .78E:
41448 D37F                        25            .ascii	"%d             Device"
41449 D394                        0A            .byte	$A
41450 D395                        00            .byte	0
41451                       0000D396            .22A:
41452                       0000D396            .78F:
41453 D396                        25            .ascii	"%d             CD-Rom/DVD-Rom"
41454 D3B3                        0A            .byte	$A
41455 D3B4                        00            .byte	0
41456                       0000D3B5            .227:
41457                       0000D3B5            .790:
41458 D3B5                        58            .ascii	"XS Virtual ATAPI-"
41459 D3C6                        00            .byte	0
41460                       0000D3C7            .225:
41461                       0000D3C7            .791:
41462 D3C7                        20            .ascii	" (%uGB)"
41463 D3CE                        0A            .byte	$A
41464 D3CF                        00            .byte	0
41465                       0000D3D0            .223:
41466                       0000D3D0            .792:
41467 D3D0                        20            .ascii	" (%uMB)"
41468 D3D7                        0A            .byte	$A
41469 D3D8                        00            .byte	0
41470                       0000D3D9            .220:
41471                       0000D3D9            .793:
41472 D3D9                        58            .ascii	"XS Virtual IDE Controller      Hard Driv"
41473 D401                        65            .ascii	"e"
41474 D402                        00            .byte	0
41475                       0000D403            .1F5:
41476                       0000D403            .794:
41477 D403                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
41478 D42B                        65            .ascii	"e"
41479 D42C                        0A            .byte	$A
41480 D42D                        00            .byte	0
41481                       0000D42E            .1BC:
41482                       0000D42E            .795:
41483 D42E                        61            .ascii	"ata-detect: Failed to detect ATA device"
41484 D455                        0A            .byte	$A
41485 D456                        00            .byte	0
41486                       0000D457            .158:
41487                       0000D457            .796:
41488 D457                        49            .ascii	"INT18: BOOT FAILURE"
41489 D46A                        0A            .byte	$A
41490 D46B                        00            .byte	0
41491                       0000D46C            .157:
41492                       0000D46C            .797:
41493 D46C                        4E            .ascii	"NMI Handler called"
41494 D47E                        0A            .byte	$A
41495 D47F                        00            .byte	0
41496                       0000D480            .156:
41497                       0000D480            .798:
41498 D480                        0A            .byte	$A,$A
41499 D482                        00            .byte	0
41500                       0000D483            .155:
41501                       0000D483            .799:
41502 D483                        3A            .ascii	": could not read boot disk"
41503 D49D                        00            .byte	0
41504                       0000D49E            .153:
41505                       0000D49E            .79A:
41506 D49E                        3A            .ascii	": disk not bootable"
41507 D4B1                        00            .byte	0
41508                       0000D4B2            .14E:
41509                       0000D4B2            .79B:
41510 D4B2                        20            .ascii	" - failure"
41511 D4BC                        00            .byte	0
41512                       0000D4BD            .14D:
41513                       0000D4BD            .79C:
41514 D4BD                        42            .ascii	"Bad drive type"
41515 D4CB                        0A            .byte	$A
41516 D4CC                        00            .byte	0
41517                       0000D4CD            .149:
41518                       0000D4CD            .79D:
41519 D4CD                        20            .ascii	" [%S]"
41520 D4D2                        00            .byte	0
41521                       0000D4D3            .145:
41522                       0000D4D3            .79E:
41523 D4D3                        42            .ascii	"Boot device: %s"
41524 D4E2                        00            .byte	0
41525                       0000D4E3            .144:
41526                       0000D4E3            .79F:
41527 D4E3                        42            .ascii	"Bad drive type"
41528 D4F1                        0A            .byte	$A
41529 D4F2                        00            .byte	0
41530                       0000D4F3            .13D:
41531                       0000D4F3            .7A0:
41532 D4F3                        0A            .byte	$A
41533 D4F4                        00            .byte	0
41534                       0000D4F5            .131:
41535                       0000D4F5            .7A1:
41536 D4F5                        0A            .byte	$A
41537 D4F6                        00            .byte	0
41538                       0000D4F7            .130:
41539                       0000D4F7            .7A2:
41540 D4F7                        20            .ascii	" [%S]"
41541 D4FC                        00            .byte	0
41542                       0000D4FD            .12D:
41543                       0000D4FD            .7A3:
41544 D4FD                        25            .ascii	"%s"
41545 D4FF                        00            .byte	0
41546                       0000D500            .12B:
41547                       0000D500            .7A4:
41548 D500                        25            .ascii	"%s"
41549 D502                        0A            .byte	$A
41550 D503                        00            .byte	0
41551                       0000D504            .124:
41552                       0000D504            .7A5:
41553 D504                        25            .ascii	"%d. "
41554 D508                        00            .byte	0
41555                       0000D509            .11F:
41556                       0000D509            .7A6:
41557 D509                        53            .ascii	"Select boot device:"
41558 D51C                        0A            .byte	$A,$A
41559 D51E                        00            .byte	0
41560                       0000D51F            .115:
41561                       0000D51F            .7A7:
41562 D51F                        0A            .byte	$A,$A
41563 D521                        50            .ascii	"Press F12 for boot menu."
41564 D539                        0A            .byte	$A,$A
41565 D53B                        00            .byte	0
41566                       0000D53C            .10C:
41567                       0000D53C            .7A8:
41568 D53C                        50            .ascii	"Processor %d: Xen(R) Virtual CPU"
41569 D55C                        0A            .byte	$A
41570 D55D                        00            .byte	0
41571                       0000D55E            .107:
41572                       0000D55E            .7A9:
41573 D55E                        52            .ascii	"Returned from s3_resume."
41574 D576                        0A            .byte	$A
41575 D577                        00            .byte	0
41576                       0000D578            .106:
41577                       0000D578            .7AA:
41578 D578                        55            .ascii	"Unimplemented shutdown status: %02x"
41579 D59B                        0A            .byte	$A
41580 D59C                        00            .byte	0
41581                       0000D59D            .105:
41582                       0000D59D            .7AB:
41583 D59D                        43            .ascii	"Couldn't reset the machine"
41584 D5B7                        0A            .byte	$A
41585 D5B8                        00            .byte	0
41586                       0000D5B9            .104:
41587                       0000D5B9            .7AC:
41588 D5B9                        4B            .ascii	"Keyboard error:%u"
41589 D5CA                        0A            .byte	$A
41590 D5CB                        00            .byte	0
41591                       0000D5CC            .8D:
41592                       0000D5CC            .7AD:
41593 D5CC                        62            .ascii	"bios_printf: unknown format"
41594 D5E7                        0A            .byte	$A
41595 D5E8                        00            .byte	0
41596                       0000D5E9            .41:
41597                       0000D5E9            .7AE:
41598 D5E9                        46            .ascii	"FATAL: "
41599 D5F0                        00            .byte	0
41600 D5F1                                      .bss
41601                                           
41602                                           ! 0 errors detected

Symbols:
..FFD9                      0 FFFC A   ..FFDA                      0 FFFC A   
..FFDB                      0 FFE0 A   ..FFDC                      0 FFE0 A   
..FFDD                      0 FFCA A   ..FFDE                      0 FFCA A   
..FFDF                      0 FFCA A   ..FFE0                      0 FFCA A   
..FFE1                      0 FFCA A   ..FFE2                      0 FFCA A   
..FFE3                      0 FFFC A   ..FFE4                      0 FFFC A   
..FFE5                      0 FFFC A   ..FFE6                      0 FFDE A   
..FFE7                      0 FFDE A   ..FFE8                      0 FFDE A   
..FFE9                      0 FFDE A   ..FFEA                      0 FFD2 A   
..FFEB                      0 FFDE A   ..FFEC                      0 FFD8 A   
..FFED                      0 FFD8 A   ..FFEE                      0 FFD8 A   
..FFEF                      0 FFD8 A   ..FFF0                      0 FFCA A   
..FFF1                      0 FFD8 A   ..FFF2                      0 FFF8 A   
..FFF3                      0 FFF4 A   ..FFF4                      0 FFE6 A   
..FFF5                      0 FFE6 A   ..FFF6                      0 FFF0 A   
..FFF7                      0 FFEC A   ..FFF8                      0 FFF6 A   
..FFF9                      0 F7E2 A   ..FFFA                      0 FFD4 A   
..FFFB                      0 FDBA A   ..FFFC                      0 FDBA A   
..FFFD                      0 FDD8 A   ..FFFE                      0 FDD8 A   
..FFFF                      0 FFC2 A   .1                          0 0194 A   
.10                         0 075F A   .100                        0 128A A   
.101                        0 1281 A   .102                        0 12A0 A   
.103                        0 1297 A   .104                        0 D5B9 A   
.105                        0 D59D A   .106                        0 D578 A   
.107                        0 D55E A   .108                        0 137B A   
.109                        0 136C A   .10A                        0 1373 A   
.10B                        0 1359 A   .10C                        0 D53C A   
.10D                        0 137B A   .10E                        0 137F A   
.10F                        0 1389 A   .11                         0 0749 A   
.110                        0 1393 A   .111                        0 139D A   
.112                        0 13A7 A   .113                        0 154B A   
.114                        0 1545 A   .115                        0 D51F A   
.116                        0 1763 A   .117                        0 175A A   
.118                        0 15A6 A   .119                        0 15B6 A   
.11A                        0 15B3 A   .11B                        0 15C2 A   
.11C                        0 15BB A   .11D                        0 15B8 A   
.11E                        0 15C2 A   .11F                        0 D509 A   
.12                         0 078D A   .120                        0 16F2 A   
.121                        0 16DF A   .122                        0 16E6 A   
.123                        0 15E8 A   .124                        0 D504 A   
.125                        0 16DF A   .127                        0 16C3 A   
.128                        0 1624 A   .129                        0 1624 A   
.12A                        0 1624 A   .12B                        0 D500 A   
.12C                        0 1647 A   .12D                        0 D4FD A   
.12E                        0 16B1 A   .12F                        0 1670 A   
.13                         0 0779 A   .130                        0 D4F7 A   
.131                        0 D4F5 A   .132                        0 16F2 A   
.133                        0 174A A   .134                        0 1743 A   
.135                        0 16FB A   .136                        0 1717 A   
.137                        0 170F A   .138                        0 1708 A   
.139                        0 1743 A   .13A                        0 1743 A   
.13B                        0 1721 A   .13C                        0 174A A   
.13D                        0 D4F3 A   .13E                        0 1763 A   
.13F                        0 1781 A   .14                         0 076E A   
.140                        0 177B A   .141                        0 179E A   
.142                        0 1790 A   .143                        0 1788 A   
.144                        0 D4E3 A   .145                        0 D4D3 A   
.146                        0 181E A   .147                        0 17DD A   
.148                        0 17C6 A   .149                        0 D4CD A   
.14A                        0 1841 A   .14B                        0 1834 A   
.14C                        0 182C A   .14D                        0 D4BD A   
.14E                        0 D4B2 A   .14F                        0 188B A   
.15                         0 0761 A   .150                        0 1868 A   
.151                        0 187E A   .152                        0 186F A   
.153                        0 D49E A   .154                        0 188B A   
.155                        0 D483 A   .156                        0 D480 A   
.157                        0 D46C A   .158                        0 D457 A   
.159                        0 18F4 A   .15A                        0 18E0 A   
.15B                        0 1906 A   .15C                        0 1913 A   
.15D                        0 1915 A   .15E                        0 1978 A   
.15F                        0 1972 A   .16                         0 0779 A   
.160                        0 1967 A   .161                        0 1A68 A   
.162                        0 1A5A A   .163                        0 1A61 A   
.164                        0 19EA A   .165                        0 1A68 A   
.166                        0 1C39 A   .167                        0 1C29 A   
.168                        0 1C30 A   .169                        0 1A70 A   
.16A                        0 1C39 A   .16B                        0 1C80 A   
.16C                        0 1C72 A   .16D                        0 1C79 A   
.16E                        0 1C40 A   .16F                        0 1C80 A   
.17                         0 078D A   .170                        0 1DF4 A   
.171                        0 1DF1 A   .172                        0 1CC3 A   
.173                        0 1CF0 A   .174                        0 1CE5 A   
.175                        0 1D84 A   .176                        0 1D0C A   
.177                        0 1CF7 A   .178                        0 1D04 A   
.179                        0 1D00 A   .17A                        0 1D06 A   
.17B                        0 1D84 A   .17C                        0 1D30 A   
.17D                        0 1D13 A   .17E                        0 1D29 A   
.17F                        0 1D25 A   .18                         0 0780 A   
.180                        0 1D1C A   .181                        0 1D2B A   
.182                        0 1D84 A   .183                        0 1D54 A   
.184                        0 1D37 A   .185                        0 1D4D A   
.186                        0 1D49 A   .187                        0 1D40 A   
.188                        0 1D4F A   .189                        0 1D84 A   
.18A                        0 1D78 A   .18B                        0 1D5B A   
.18C                        0 1D71 A   .18D                        0 1D6D A   
.18E                        0 1D64 A   .18F                        0 1D73 A   
.19                         0 07E2 A   .190                        0 1D84 A   
.191                        0 1D84 A   .192                        0 1D7F A   
.193                        0 1D92 A   .194                        0 1D8B A   
.195                        0 1DB2 A   .196                        0 1DA3 A   
.197                        0 1DC2 A   .198                        0 1DBB A   
.199                        0 1DF1 A   .19A                        0 1DEF A   
.19B                        0 1DC9 A   .19C                        0 2B97 A   
.19D                        0 2B87 A   .19E                        0 2B8E A   
.19F                        0 1F31 A   .1A                         0 07CC A   
.1A0                        0 1FA4 A   .1A1                        0 1FA0 A   
.1A2                        0 1FA6 A   .1A3                        0 219A A   
.1A4                        0 2055 A   .1A5                        0 204B A   
.1A6                        0 208A A   .1A7                        0 2086 A   
.1A8                        0 208C A   .1A9                        0 219A A   
.1AA                        0 20D2 A   .1AB                        0 20C8 A   
.1AC                        0 2135 A   .1AD                        0 2115 A   
.1AE                        0 210D A   .1AF                        0 219A A   
.1B                         0 0810 A   .1B0                        0 216D A   
.1B1                        0 214D A   .1B2                        0 2145 A   
.1B3                        0 213D A   .1B4                        0 219A A   
.1B5                        0 219A A   .1B6                        0 217D A   
.1B7                        0 2175 A   .1B8                        0 26F4 A   
.1B9                        0 21C0 A   .1BA                        0 2248 A   
.1BB                        0 223A A   .1BC                        0 D42E A   
.1BD                        0 2261 A   .1BE                        0 225D A   
.1BF                        0 2263 A   .1C                         0 07FC A   
.1C0                        0 227E A   .1C1                        0 227A A   
.1C2                        0 2280 A   .1C3                        0 231A A   
.1C4                        0 22E6 A   .1C5                        0 233F A   
.1C6                        0 249C A   .1C7                        0 248B A   
.1C8                        0 2494 A   .1C9                        0 247D A   
.1CA                        0 249C A   .1CB                        0 24E7 A   
.1CD                        0 24D7 A   .1CE                        0 24CD A   
.1CF                        0 24CF A   .1D                         0 07F1 A   
.1D0                        0 24D1 A   .1D1                        0 24D3 A   
.1D2                        0 2665 A   .1D4                        0 264F A   
.1D5                        0 24EE A   .1D6                        0 24F1 A   
.1D7                        0 2548 A   .1D8                        0 253F A   
.1D9                        0 2585 A   .1DA                        0 255A A   
.1DB                        0 2551 A   .1DC                        0 2585 A   
.1DD                        0 256C A   .1DE                        0 2563 A   
.1DF                        0 2585 A   .1E                         0 07E4 A   
.1E0                        0 257E A   .1E1                        0 2575 A   
.1E2                        0 2585 A   .1E3                        0 25A6 A   
.1E4                        0 2621 A   .1E5                        0 25AF A   
.1E6                        0 25DA A   .1E7                        0 25D3 A   
.1E8                        0 2621 A   .1E9                        0 264B A   
.1EA                        0 2642 A   .1EB                        0 2623 A   
.1EC                        0 2642 A   .1ED                        0 2640 A   
.1EE                        0 264B A   .1EF                        0 2675 A   
.1F                         0 07FC A   .1F0                        0 266E A   
.1F1                        0 2883 A   .1F2                        0 26FD A   
.1F3                        0 2785 A   .1F4                        0 2777 A   
.1F5                        0 D403 A   .1F6                        0 27B3 A   
.1F7                        0 27AF A   .1F8                        0 27B5 A   
.1F9                        0 27D0 A   .1FA                        0 27CC A   
.1FB                        0 27D2 A   .1FC                        0 2AA4 A   
.1FE                        0 2A98 A   .1FF                        0 288C A   
.2                          0 05ED A   .20                         0 0810 A   
.200                        0 28ED A   .201                        0 294E A   
.202                        0 293D A   .203                        0 2946 A   
.204                        0 2924 A   .205                        0 293D A   
.206                        0 293B A   .207                        0 294E A   
.208                        0 29DC A   .209                        0 29C9 A   
.20A                        0 29D2 A   .20B                        0 2957 A   
.20C                        0 29DC A   .20D                        0 2A44 A   
.20E                        0 2A33 A   .20F                        0 2A3C A   
.21                         0 0803 A   .210                        0 29F6 A   
.211                        0 2A31 A   .212                        0 2A13 A   
.213                        0 2A33 A   .214                        0 2A44 A   
.215                        0 2A94 A   .216                        0 2A4C A   
.217                        0 2A94 A   .218                        0 2A83 A   
.219                        0 2A8C A   .21A                        0 2A66 A   
.21B                        0 2A94 A   .21C                        0 2B81 A   
.21E                        0 2B73 A   .21F                        0 2AAA A   
.22                         0 087D A   .220                        0 D3D9 A   
.221                        0 2ADE A   .222                        0 2AC6 A   
.223                        0 D3D0 A   .224                        0 2B04 A   
.225                        0 D3C7 A   .226                        0 2B07 A   
.227                        0 D3B5 A   .228                        0 2B4A A   
.229                        0 2B33 A   .22A                        0 D396 A   
.22B                        0 2B5F A   .22C                        0 D37F A   
.22D                        0 2B61 A   .22E                        0 D36F A   
.22F                        0 2B97 A   .23                         0 0864 A   
.230                        0 D36D A   .231                        0 2D1B A   
.232                        0 2C97 A   .233                        0 2CA2 A   
.234                        0 2C9E A   .235                        0 2CA4 A   
.236                        0 2D0A A   .237                        0 2CDF A   
.238                        0 2CD8 A   .239                        0 2CF9 A   
.23A                        0 2CE6 A   .23B                        0 2D0A A   
.23C                        0 2DCC A   .23D                        0 2DC0 A   
.23E                        0 2DD4 A   .23F                        0 2E1B A   
.24                         0 08AB A   .240                        0 2E14 A   
.241                        0 2F9C A   .242                        0 2E35 A   
.243                        0 2F3B A   .244                        0 2E7F A   
.245                        0 2E58 A   .246                        0 2E4D A   
.247                        0 2E41 A   .248                        0 2E43 A   
.24A                        0 2FFC A   .24B                        0 2FF8 A   
.24C                        0 2FFE A   .24D                        0 3047 A   
.24E                        0 303E A   .24F                        0 3057 A   
.25                         0 0897 A   .250                        0 3057 A   
.251                        0 3050 A   .252                        0 30F1 A   
.253                        0 30EE A   .254                        0 3058 A   
.255                        0 30DC A   .256                        0 30C8 A   
.257                        0 30D8 A   .258                        0 30D1 A   
.259                        0 30EE A   .25A                        0 30EC A   
.25B                        0 30E5 A   .25C                        0 30F1 A   
.25D                        0 319D A   .25E                        0 3191 A   
.25F                        0 31A5 A   .26                         0 088C A   
.260                        0 31EC A   .261                        0 31E5 A   
.262                        0 336D A   .263                        0 3206 A   
.264                        0 330C A   .265                        0 3250 A   
.266                        0 3229 A   .267                        0 321E A   
.268                        0 3212 A   .269                        0 3214 A   
.26B                        0 33CD A   .26C                        0 33C9 A   
.26D                        0 33CF A   .26E                        0 3418 A   
.26F                        0 340F A   .27                         0 087F A   
.270                        0 3428 A   .271                        0 3428 A   
.272                        0 3421 A   .273                        0 34C4 A   
.274                        0 34C1 A   .275                        0 3429 A   
.276                        0 34AF A   .277                        0 349B A   
.278                        0 34AB A   .279                        0 34A4 A   
.27A                        0 34C1 A   .27B                        0 34BF A   
.27C                        0 34B8 A   .27D                        0 34C4 A   
.27E                        0 3512 A   .27F                        0 350B A   
.28                         0 0897 A   .280                        0 3522 A   
.281                        0 351B A   .282                        0 358B A   
.283                        0 3586 A   .284                        0 3597 A   
.285                        0 3592 A   .286                        0 35E3 A   
.287                        0 35DC A   .288                        0 364E A   
.289                        0 364A A   .28A                        0 3650 A   
.28B                        0 3697 A   .28C                        0 368E A   
.28D                        0 36A7 A   .28E                        0 36A7 A   
.28F                        0 36A0 A   .29                         0 08AB A   
.290                        0 36F2 A   .291                        0 36DB A   
.292                        0 3964 A   .293                        0 3961 A   
.294                        0 395E A   .295                        0 36FB A   
.296                        0 3727 A   .297                        0 3702 A   
.298                        0 373B A   .299                        0 376D A   
.29A                        0 376A A   .29B                        0 3761 A   
.29C                        0 377D A   .29D                        0 3776 A   
.29E                        0 37DC A   .29F                        0 37C6 A   
.2A                         0 089E A   .2A0                        0 37F0 A   
.2A1                        0 381D A   .2A2                        0 37FD A   
.2A3                        0 383E A   .2A4                        0 3858 A   
.2A5                        0 3853 A   .2A6                        0 3866 A   
.2A7                        0 3861 A   .2A8                        0 3874 A   
.2A9                        0 386F A   .2AA                        0 389B A   
.2AB                        0 387D A   .2AC                        0 389B A   
.2AD                        0 3894 A   .2AE                        0 388B A   
.2AF                        0 38C2 A   .2B                         0 091E A   
.2B0                        0 38A2 A   .2B1                        0 38DA A   
.2B2                        0 3961 A   .2B3                        0 3974 A   
.2B4                        0 396D A   .2B5                        0 39E6 A   
.2B6                        0 39DF A   .2B7                        0 3A58 A   
.2B8                        0 3A43 A   .2B9                        0 D347 A   
.2BA                        0 3B4A A   .2BB                        0 3B3A A   
.2BC                        0 3A8F A   .2BD                        0 3AC4 A   
.2BE                        0 3ABE A   .2BF                        0 3B1E A   
.2C                         0 090B A   .2C0                        0 3ADD A   
.2C1                        0 3AEB A   .2C2                        0 3AE4 A   
.2C3                        0 3B1E A   .2C4                        0 3B00 A   
.2C5                        0 3AF9 A   .2C6                        0 3AF2 A   
.2C7                        0 D31F A   .2C8                        0 3B4A A   
.2C9                        0 3BF1 A   .2CA                        0 3BD6 A   
.2CB                        0 3BBE A   .2CC                        0 D303 A   
.2CD                        0 3C8E A   .2CE                        0 3C7C A   
.2CF                        0 3CD4 A   .2D                         0 08F5 A   
.2D0                        0 3CB0 A   .2D1                        0 D2ED A   
.2D2                        0 3D1B A   .2D3                        0 3D15 A   
.2D4                        0 3D3F A   .2D5                        0 3D39 A   
.2D6                        0 3D63 A   .2D7                        0 3D5D A   
.2D8                        0 3DE2 A   .2D9                        0 3DE8 A   
.2DA                        0 3E45 A   .2DB                        0 3E34 A   
.2DC                        0 3E3D A   .2DD                        0 3E22 A   
.2DE                        0 3E34 A   .2DF                        0 3E32 A   
.2E                         0 091E A   .2E0                        0 3E45 A   
.2E1                        0 3E54 A   .2E2                        0 3E4D A   
.2E3                        0 3E74 A   .2E4                        0 3E74 A   
.2E5                        0 3E68 A   .2E6                        0 3E6A A   
.2E7                        0 3EEB A   .2E8                        0 3EE4 A   
.2E9                        0 3EFA A   .2EA                        0 3EF3 A   
.2EB                        0 3F51 A   .2EC                        0 3F3F A   
.2ED                        0 3F48 A   .2EE                        0 3F02 A   
.2EF                        0 3F3F A   .2F                         0 09CE A   
.2F0                        0 3F38 A   .2F1                        0 3F51 A   
.2F2                        0 3FAA A   .2F3                        0 3F98 A   
.2F4                        0 3FA1 A   .2F5                        0 3F59 A   
.2F6                        0 3F98 A   .2F7                        0 3F91 A   
.2F8                        0 3FAA A   .2F9                        0 40E2 A   
.2FA                        0 40DB A   .2FB                        0 40F1 A   
.2FC                        0 40EA A   .2FD                        0 4100 A   
.2FE                        0 40F9 A   .2FF                        0 410F A   
.3                          0 05E2 A   .30                         0 09C0 A   
.300                        0 4108 A   .301                        0 411E A   
.302                        0 4117 A   .303                        0 412D A   
.304                        0 4126 A   .305                        0 415C A   
.306                        0 4149 A   .307                        0 4187 A   
.308                        0 4176 A   .309                        0 4164 A   
.30A                        0 4187 A   .30B                        0 41DA A   
.30C                        0 41D3 A   .30D                        0 439F A   
.30E                        0 4398 A   .30F                        0 44E7 A   
.31                         0 094A A   .311                        0 44CF A   
.312                        0 43AF A   .313                        0 43E5 A   
.314                        0 441B A   .315                        0 4451 A   
.316                        0 454A A   .317                        0 44F8 A   
.318                        0 452C A   .319                        0 4509 A   
.31A                        0 454A A   .31B                        0 456C A   
.31C                        0 455B A   .31D                        0 47E8 A   
.31E                        0 45C5 A   .31F                        0 45BC A   
.32                         0 0994 A   .320                        0 47E6 A   
.322                        0 47CE A   .323                        0 45CB A   
.324                        0 4610 A   .325                        0 45F2 A   
.326                        0 4649 A   .327                        0 4687 A   
.328                        0 46D9 A   .329                        0 46C0 A   
.32A                        0 469A A   .32B                        0 46C0 A   
.32C                        0 46B3 A   .32D                        0 46D9 A   
.32E                        0 46D2 A   .32F                        0 46EF A   
.33                         0 096E A   .330                        0 46E0 A   
.331                        0 470D A   .332                        0 4705 A   
.333                        0 4718 A   .334                        0 476A A   
.335                        0 4751 A   .336                        0 472B A   
.337                        0 4751 A   .338                        0 4744 A   
.339                        0 476A A   .33A                        0 4763 A   
.33B                        0 4783 A   .33C                        0 4771 A   
.33D                        0 4792 A   .33E                        0 479C A   
.33F                        0 47C4 A   .34                         0 09B4 A   
.340                        0 47F0 A   .341                        0 4CEC A   
.343                        0 4C9C A   .344                        0 4813 A   
.345                        0 489E A   .347                        0 488C A   
.348                        0 4818 A   .349                        0 482F A   
.34A                        0 4847 A   .34B                        0 4868 A   
.34C                        0 487D A   .34D                        0 48A1 A   
.34E                        0 48B1 A   .34F                        0 48BC A   
.35                         0 09B4 A   .350                        0 48CC A   
.351                        0 4996 A   .352                        0 48D5 A   
.353                        0 4987 A   .354                        0 48EB A   
.355                        0 4994 A   .356                        0 49EA A   
.357                        0 49D6 A   .358                        0 499D A   
.359                        0 49EA A   .35A                        0 49ED A   
.35B                        0 4A28 A   .35C                        0 4A21 A   
.35D                        0 4BFA A   .35E                        0 4C20 A   
.35F                        0 4C1A A   .36                         0 09A2 A   
.360                        0 4C2B A   .361                        0 4C2E A   
.362                        0 4C31 A   .363                        0 4C41 A   
.364                        0 4C5D A   .365                        0 4C6E A   
.366                        0 D2D6 A   .367                        0 4C8B A   
.368                        0 5353 A   .36A                        0 534B A   
.36B                        0 4D0F A   .36C                        0 5338 A   
.36E                        0 5313 A   .36F                        0 4D15 A   
.37                         0 09CE A   .370                        0 4E12 A   
.372                        0 4E04 A   .373                        0 4D1B A   
.374                        0 4D5C A   .375                        0 4D31 A   
.376                        0 4D5C A   .377                        0 4D4B A   
.378                        0 4D44 A   .379                        0 4D71 A   
.37A                        0 4D9B A   .37B                        0 4D8A A   
.37C                        0 4DDF A   .37D                        0 4DB1 A   
.37E                        0 4DDF A   .37F                        0 4DCB A   
.38                         0 0A17 A   .380                        0 4DC4 A   
.381                        0 4DF1 A   .382                        0 4E15 A   
.383                        0 4E15 A   .384                        0 4E7A A   
.385                        0 4E1C A   .386                        0 4E34 A   
.387                        0 4E23 A   .388                        0 4F19 A   
.389                        0 4E92 A   .38A                        0 4EB1 A   
.38B                        0 4EA5 A   .38C                        0 4ECC A   
.38D                        0 4EB8 A   .38E                        0 D2AB A   
.38F                        0 4F19 A   .39                         0 0A08 A   
.390                        0 4ED3 A   .391                        0 4F19 A   
.392                        0 4EE6 A   .393                        0 4F19 A   
.394                        0 4EF9 A   .395                        0 4F2B A   
.396                        0 4F8B A   .398                        0 4F68 A   
.399                        0 4F30 A   .39A                        0 4F37 A   
.39B                        0 4F3E A   .39C                        0 4F45 A   
.39D                        0 4F4C A   .39E                        0 4F53 A   
.39F                        0 4F5A A   .3A                         0 0A0F A   
.3A0                        0 4F61 A   .3A1                        0 4F89 A   
.3A2                        0 4F7B A   .3A3                        0 4FE9 A   
.3A4                        0 4F92 A   .3A5                        0 4FDA A   
.3A6                        0 4FA5 A   .3A7                        0 4FE7 A   
.3A8                        0 4FF6 A   .3A9                        0 4FF9 A   
.3AA                        0 5095 A   .3AB                        0 5008 A   
.3AC                        0 5086 A   .3AD                        0 501B A   
.3AE                        0 5042 A   .3AF                        0 502E A   
.3B                         0 09F7 A   .3B0                        0 D27F A   
.3B1                        0 5077 A   .3B2                        0 5063 A   
.3B3                        0 D253 A   .3B4                        0 5093 A   
.3B5                        0 50A2 A   .3B6                        0 50B0 A   
.3B7                        0 50F3 A   .3B8                        0 50C6 A   
.3B9                        0 5100 A   .3BA                        0 5103 A   
.3BB                        0 5277 A   .3BD                        0 5263 A   
.3BE                        0 5109 A   .3BF                        0 51B9 A   
.3C                         0 0A08 A   .3C0                        0 5124 A   
.3C1                        0 514B A   .3C2                        0 5137 A   
.3C3                        0 D227 A   .3C4                        0 51B9 A   
.3C5                        0 5152 A   .3C6                        0 51B9 A   
.3C7                        0 5165 A   .3C8                        0 51B9 A   
.3C9                        0 5178 A   .3CA                        0 51B9 A   
.3CB                        0 518B A   .3CC                        0 51D6 A   
.3CD                        0 51D6 A   .3CE                        0 51F1 A   
.3CF                        0 51E3 A   .3D                         0 0A06 A   
.3D0                        0 51FD A   .3D1                        0 521D A   
.3D2                        0 5204 A   .3D3                        0 5218 A   
.3D4                        0 521A A   .3D5                        0 5233 A   
.3D6                        0 5224 A   .3D7                        0 5240 A   
.3D8                        0 524D A   .3D9                        0 D20D A   
.3DA                        0 527A A   .3DB                        0 52DA A   
.3DC                        0 52C4 A   .3DD                        0 52BD A   
.3DE                        0 52D8 A   .3DF                        0 52CD A   
.3E                         0 0A17 A   .3E0                        0 52E2 A   
.3E1                        0 5304 A   .3E2                        0 5336 A   
.3E3                        0 5326 A   .3E4                        0 533A A   
.3E5                        0 579B A   .3E7                        0 578D A   
.3E8                        0 544C A   .3E9                        0 5492 A   
.3EA                        0 577A A   .3EC                        0 576C A   
.3ED                        0 5498 A   .3EE                        0 54CC A   
.3EF                        0 54C6 A   .3F                         0 0A5B A   
.3F0                        0 5565 A   .3F1                        0 54E1 A   
.3F2                        0 5507 A   .3F3                        0 54EC A   
.3F4                        0 5562 A   .3F5                        0 5558 A   
.3F6                        0 5620 A   .3F7                        0 561A A   
.3F8                        0 556F A   .3F9                        0 55E0 A   
.3FA                        0 55CF A   .3FB                        0 55D8 A   
.3FC                        0 5576 A   .3FD                        0 55CF A   
.3FE                        0 55CD A   .3FF                        0 55B5 A   
.4                          0 05CD A   .40                         0 0A40 A   
.400                        0 55E0 A   .401                        0 55F3 A   
.402                        0 55E8 A   .403                        0 5620 A   
.404                        0 5642 A   .405                        0 5685 A   
.406                        0 567F A   .407                        0 56F6 A   
.408                        0 56E5 A   .409                        0 56EE A   
.40A                        0 568C A   .40B                        0 56E5 A   
.40C                        0 56E3 A   .40D                        0 56CB A   
.40E                        0 56F6 A   .40F                        0 5757 A   
.41                         0 D5E9 A   .410                        0 5703 A   
.411                        0 5757 A   .412                        0 572F A   
.413                        0 5765 A   .414                        0 577C A   
.415                        0 5886 A   .416                        0 57E3 A   
.417                        0 5811 A   .418                        0 5802 A   
.419                        0 57F4 A   .41A                        0 5811 A   
.41B                        0 5885 A   .41C                        0 581E A   
.41D                        0 5868 A   .41E                        0 5859 A   
.41F                        0 584B A   .42                         0 0DDD A   
.420                        0 5868 A   .421                        0 5BC8 A   
.423                        0 5B7E A   .424                        0 5890 A   
.425                        0 58B4 A   .426                        0 58A6 A   
.427                        0 D1E9 A   .428                        0 58C9 A   
.429                        0 58C2 A   .42A                        0 58BB A   
.42B                        0 58D5 A   .42C                        0 58D5 A   
.42D                        0 58D0 A   .42E                        0 58E7 A   
.42F                        0 5908 A   .43                         0 0DC7 A   
.430                        0 58FC A   .431                        0 591D A   
.432                        0 5916 A   .433                        0 590F A   
.434                        0 5929 A   .435                        0 5929 A   
.436                        0 5924 A   .437                        0 5943 A   
.438                        0 5962 A   .439                        0 5986 A   
.43A                        0 597A A   .43B                        0 5990 A   
.43C                        0 5993 A   .43D                        0 59A0 A   
.43E                        0 59E7 A   .43F                        0 59CD A   
.44                         0 0A5E A   .440                        0 59C0 A   
.441                        0 59E7 A   .442                        0 59DC A   
.443                        0 5A5D A   .444                        0 59F0 A   
.445                        0 5A5D A   .446                        0 59FD A   
.447                        0 5A5D A   .448                        0 5A52 A   
.449                        0 59FD A   .44A                        0 5A2C A   
.44B                        0 5A12 A   .44C                        0 5A05 A   
.44D                        0 5A2C A   .44E                        0 5A21 A   
.44F                        0 5A52 A   .45                         0 0A73 A   
.450                        0 5A33 A   .451                        0 5A5D A   
.452                        0 5A66 A   .453                        0 5A8A A   
.454                        0 5A7C A   .455                        0 D1C5 A   
.456                        0 5A9D A   .457                        0 5A98 A   
.458                        0 5A91 A   .459                        0 5AAF A   
.45A                        0 5AD0 A   .45B                        0 5AC4 A   
.45C                        0 5AE3 A   .45D                        0 5ADE A   
.45E                        0 5AD7 A   .45F                        0 5AFD A   
.46                         0 0A65 A   .460                        0 5B5B A   
.461                        0 5B68 A   .462                        0 5B6A A   
.463                        0 5B7C A   .464                        0 5B71 A   
.465                        0 5B7C A   .466                        0 5BB7 A   
.467                        0 5B91 A   .468                        0 5CA3 A   
.469                        0 5C20 A   .46A                        0 5C9A A   
.46B                        0 5C73 A   .46C                        0 5C89 A   
.46D                        0 5C83 A   .46E                        0 5CA9 A   
.46F                        0 5CAD A   .47                         0 0DC0 A   
.470                        0 5CF3 A   .471                        0 5CE1 A   
.472                        0 D1BA A   .473                        0 5D12 A   
.474                        0 5D03 A   .475                        0 5D03 A   
.476                        0 5D12 A   .477                        0 5D45 A   
.478                        0 5D33 A   .479                        0 D1AF A   
.47A                        0 5DA0 A   .47B                        0 5D8E A   
.47C                        0 D1A5 A   .47D                        0 5DBF A   
.47E                        0 5DB0 A   .47F                        0 5DB0 A   
.48                         0 0DB1 A   .480                        0 5DBF A   
.481                        0 5DEC A   .482                        0 5DDA A   
.483                        0 D19B A   .484                        0 5E44 A   
.485                        0 5E32 A   .486                        0 D191 A   
.487                        0 5E7F A   .488                        0 5E70 A   
.489                        0 5E70 A   .48A                        0 5E7F A   
.48B                        0 5ECC A   .48C                        0 5EBB A   
.48D                        0 D186 A   .48E                        0 5F0E A   
.48F                        0 5F0A A   .49                         0 0A7C A   
.490                        0 6519 A   .492                        0 64BC A   
.493                        0 5F4C A   .494                        0 5F87 A   
.495                        0 5FA6 A   .496                        0 5FC5 A   
.497                        0 5FE4 A   .498                        0 6003 A   
.499                        0 6022 A   .49A                        0 608A A   
.49B                        0 602B A   .49C                        0 606E A   
.49D                        0 6050 A   .49E                        0 608A A   
.49F                        0 608D A   .4A                         0 0AAB A   
.4A0                        0 60F5 A   .4A1                        0 6096 A   
.4A2                        0 60D9 A   .4A3                        0 60BB A   
.4A4                        0 60F5 A   .4A5                        0 60F8 A   
.4A6                        0 613B A   .4A7                        0 611D A   
.4A8                        0 6157 A   .4A9                        0 615A A   
.4AA                        0 619D A   .4AB                        0 617F A   
.4AC                        0 61B9 A   .4AD                        0 61BC A   
.4AE                        0 61FD A   .4AF                        0 61C5 A   
.4B                         0 0A8A A   .4B0                        0 6200 A   
.4B1                        0 6225 A   .4B2                        0 6209 A   
.4B3                        0 6228 A   .4B4                        0 6263 A   
.4B5                        0 6282 A   .4B6                        0 628E A   
.4B7                        0 628B A   .4B8                        0 628E A   
.4B9                        0 629A A   .4BA                        0 6297 A   
.4BB                        0 62A5 A   .4BC                        0 62A1 A   
.4BD                        0 62EB A   .4BE                        0 62AE A   
.4BF                        0 6498 A   .4C                         0 0A83 A   
.4C0                        0 6331 A   .4C1                        0 62F4 A   
.4C2                        0 6498 A   .4C3                        0 636C A   
.4C4                        0 6348 A   .4C5                        0 633A A   
.4C6                        0 6341 A   .4C7                        0 6498 A   
.4C8                        0 6409 A   .4C9                        0 6377 A   
.4CA                        0 63CC A   .4CB                        0 6396 A   
.4CC                        0 6406 A   .4CD                        0 6498 A   
.4CE                        0 6464 A   .4CF                        0 6428 A   
.4D                         0 0DAF A   .4D0                        0 6498 A   
.4D1                        0 64A6 A   .4D2                        0 64A6 A   
.4D3                        0 649F A   .4D4                        0 652A A   
.4D5                        0 6522 A   .4D6                        0 65B0 A   
.4D7                        0 65AA A   .4D8                        0 65BE A   
.4D9                        0 65B8 A   .4DA                        0 6635 A   
.4DB                        0 6631 A   .4DC                        0 666E A   
.4DD                        0 666A A   .4DE                        0 66FB A   
.4DF                        0 66AA A   .4E                         0 0B46 A   
.4E0                        0 66F9 A   .4E1                        0 66F3 A   
.4E2                        0 6702 A   .4E3                        0 6758 A   
.4E4                        0 6752 A   .4E5                        0 674B A   
.4E6                        0 6780 A   .4E7                        0 677A A   
.4E8                        0 75A7 A   .4EA                        0 7529 A   
.4EB                        0 678A A   .4EC                        0 679E A   
.4ED                        0 67E6 A   .4EE                        0 67DE A   
.4EF                        0 67EC A   .4F                         0 0AD0 A   
.4F0                        0 67EF A   .4F1                        0 67EF A   
.4F2                        0 67EF A   .4F3                        0 684F A   
.4F4                        0 6849 A   .4F5                        0 6842 A   
.4F6                        0 683B A   .4F7                        0 68C4 A   
.4F8                        0 68BE A   .4F9                        0 68B6 A   
.4FA                        0 68AE A   .4FB                        0 68D6 A   
.4FC                        0 68D0 A   .4FD                        0 6992 A   
.4FE                        0 6920 A   .4FF                        0 6918 A   
.5                          0 05E2 A   .50                         0 0AC9 A   
.500                        0 69D2 A   .501                        0 699E A   
.502                        0 6A03 A   .503                        0 6A36 A   
.504                        0 6A25 A   .505                        0 6A3F A   
.506                        0 6A4C A   .507                        0 6B2A A   
.508                        0 6B62 A   .509                        0 6B5A A   
.50A                        0 6B73 A   .50B                        0 6B76 A   
.50C                        0 6C27 A   .50D                        0 6C47 A   
.50E                        0 6C47 A   .50F                        0 6C47 A   
.51                         0 0ADD A   .510                        0 6C47 A   
.511                        0 6CC1 A   .512                        0 6CBB A   
.513                        0 6D27 A   .514                        0 6D21 A   
.515                        0 6CFD A   .516                        0 6D45 A   
.517                        0 6D3F A   .518                        0 6D33 A   
.519                        0 6D84 A   .51A                        0 6D51 A   
.51B                        0 6DB5 A   .51C                        0 6DEF A   
.51D                        0 6DDE A   .51E                        0 6DF8 A   
.51F                        0 6DF8 A   .52                         0 0AD7 A   
.520                        0 6E01 A   .521                        0 6E15 A   
.522                        0 6E33 A   .523                        0 6E2D A   
.524                        0 7020 A   .525                        0 6E3D A   
.526                        0 6F89 A   .527                        0 6F61 A   
.528                        0 6F11 A   .529                        0 6F52 A   
.52A                        0 6F54 A   .52C                        0 6FB3 A   
.52D                        0 729D A   .52E                        0 702A A   
.52F                        0 7105 A   .53                         0 0AEC A   
.530                        0 7101 A   .531                        0 7107 A   
.532                        0 7123 A   .533                        0 711F A   
.534                        0 7125 A   .535                        0 713C A   
.536                        0 7138 A   .537                        0 713E A   
.538                        0 7157 A   .539                        0 7153 A   
.53A                        0 7159 A   .53B                        0 7238 A   
.53C                        0 7225 A   .53D                        0 7249 A   
.53E                        0 7280 A   .53F                        0 7272 A   
.54                         0 0AE4 A   .540                        0 7279 A   
.541                        0 7255 A   .542                        0 7280 A   
.543                        0 74E2 A   .544                        0 72A7 A   
.545                        0 73A0 A   .546                        0 734F A   
.547                        0 73A0 A   .548                        0 7434 A   
.549                        0 73F6 A   .54A                        0 7434 A   
.54B                        0 74C2 A   .54C                        0 74B4 A   
.54D                        0 74BB A   .54E                        0 7496 A   
.54F                        0 74C2 A   .55                         0 0AF2 A   
.550                        0 74EB A   .551                        0 7512 A   
.553                        0 7500 A   .554                        0 74F0 A   
.555                        0 74F0 A   .556                        0 74F0 A   
.557                        0 74F0 A   .558                        0 74F8 A   
.559                        0 7515 A   .55A                        0 7515 A   
.55B                        0 7515 A   .55C                        0 7515 A   
.55D                        0 7515 A   .55E                        0 751E A   
.55F                        0 751E A   .56                         0 0B43 A   
.560                        0 751E A   .561                        0 751E A   
.562                        0 751E A   .563                        0 7571 A   
.564                        0 753F A   .565                        0 75A4 A   
.566                        0 7584 A   .567                        0 763C A   
.568                        0 7636 A   .569                        0 762F A   
.56A                        0 7664 A   .56B                        0 765E A   
.56C                        0 806C A   .56E                        0 7FEE A   
.56F                        0 766E A   .57                         0 0B35 A   
.570                        0 766E A   .571                        0 766E A   
.572                        0 766E A   .573                        0 766E A   
.574                        0 766E A   .575                        0 766E A   
.576                        0 766E A   .577                        0 7677 A   
.578                        0 7677 A   .579                        0 7677 A   
.57A                        0 768B A   .57B                        0 76D3 A   
.57C                        0 76CB A   .57D                        0 76D9 A   
.57E                        0 76DC A   .57F                        0 76F0 A   
.58                         0 0B3C A   .580                        0 7710 A   
.581                        0 7710 A   .582                        0 7710 A   
.583                        0 7793 A   .584                        0 7777 A   
.585                        0 D154 A   .586                        0 77C9 A   
.587                        0 77C3 A   .588                        0 77B7 A   
.589                        0 78D0 A   .58A                        0 78BF A   
.58B                        0 78D9 A   .58C                        0 78E6 A   
.58D                        0 78E0 A   .58E                        0 79EE A   
.59                         0 0AFB A   .590                        0 79DE A   
.591                        0 7909 A   .592                        0 792B A   
.593                        0 7910 A   .594                        0 795C A   
.595                        0 797E A   .596                        0 7963 A   
.597                        0 79AD A   .598                        0 79A9 A   
.599                        0 79AF A   .59A                        0 79BF A   
.59B                        0 79CA A   .59C                        0 79C6 A   
.59D                        0 79CC A   .59E                        0 79F7 A   
.59F                        0 7A2C A   .5A                         0 0B22 A   
.5A0                        0 7A1B A   .5A1                        0 7A57 A   
.5A2                        0 7A46 A   .5A3                        0 7A60 A   
.5A4                        0 7A7E A   .5A5                        0 7A78 A   
.5A6                        0 7B54 A   .5A7                        0 7A88 A   
.5A8                        0 7D57 A   .5A9                        0 7B5E A   
.5AA                        0 7C32 A   .5AB                        0 7C2E A   
.5AC                        0 7C34 A   .5AD                        0 7D3A A   
.5AE                        0 7D2C A   .5AF                        0 7D33 A   
.5B                         0 0B1A A   .5B0                        0 7D0F A   
.5B1                        0 7D3A A   .5B2                        0 7F9C A   
.5B3                        0 7D61 A   .5B4                        0 7E5A A   
.5B5                        0 7E09 A   .5B6                        0 7E5A A   
.5B7                        0 7EEE A   .5B8                        0 7EB0 A   
.5B9                        0 7EEE A   .5BA                        0 7F7C A   
.5BB                        0 7F6E A   .5BC                        0 7F75 A   
.5BD                        0 7F50 A   .5BE                        0 7F7C A   
.5BF                        0 7FA5 A   .5C                         0 0B2B A   
.5C0                        0 7FB9 A   .5C1                        0 7FE0 A   
.5C3                        0 7FCE A   .5C4                        0 7FBE A   
.5C5                        0 7FBE A   .5C6                        0 7FBE A   
.5C7                        0 7FBE A   .5C8                        0 7FC6 A   
.5C9                        0 7FE3 A   .5CA                        0 7FE3 A   
.5CB                        0 7FE3 A   .5CC                        0 7FE3 A   
.5CD                        0 7FE3 A   .5CE                        0 7FE3 A   
.5CF                        0 7FE3 A   .5D                         0 0B43 A   
.5D0                        0 7FE3 A   .5D1                        0 8036 A   
.5D2                        0 8004 A   .5D3                        0 8069 A   
.5D4                        0 8049 A   .5D5                        0 82A9 A   
.5D7                        0 828B A   .5D8                        0 80E3 A   
.5D9                        0 80E3 A   .5DA                        0 80E3 A   
.5DB                        0 D123 A   .5DC                        0 80FD A   
.5DD                        0 827B A   .5DE                        0 826B A   
.5DF                        0 8282 A   .5E                         0 0DAA A   
.5E0                        0 8383 A   .5E1                        0 837D A   
.5E2                        0 8364 A   .5E3                        0 88B4 A   
.5E5                        0 8839 A   .5E6                        0 838D A   
.5E7                        0 838D A   .5E8                        0 838D A   
.5E9                        0 838D A   .5EA                        0 838D A   
.5EB                        0 838D A   .5EC                        0 838D A   
.5ED                        0 838D A   .5EE                        0 8396 A   
.5EF                        0 8396 A   .5F                         0 0B62 A   
.5F0                        0 83AA A   .5F1                        0 83F2 A   
.5F2                        0 83EA A   .5F3                        0 83F8 A   
.5F4                        0 83FB A   .5F5                        0 83FB A   
.5F6                        0 8490 A   .5F7                        0 848A A   
.5F8                        0 84AE A   .5F9                        0 84A8 A   
.5FA                        0 84A0 A   .5FB                        0 8498 A   
.5FC                        0 84C0 A   .5FD                        0 84BA A   
.5FE                        0 871D A   .5FF                        0 8702 A   
.6                          0 05DC A   .60                         0 0B4D A   
.600                        0 8726 A   .601                        0 8805 A   
.603                        0 87F9 A   .604                        0 87D3 A   
.605                        0 87DF A   .606                        0 87EB A   
.607                        0 881B A   .608                        0 882F A   
.609                        0 882F A   .60A                        0 882F A   
.60B                        0 882F A   .60C                        0 882F A   
.60D                        0 882F A   .60E                        0 882F A   
.60F                        0 882F A   .61                         0 0DAA A   
.610                        0 882F A   .611                        0 882F A   
.612                        0 882F A   .613                        0 882F A   
.614                        0 882F A   .615                        0 882F A   
.616                        0 882F A   .617                        0 887E A   
.618                        0 884C A   .619                        0 88B1 A   
.61A                        0 8891 A   .61B                        0 8952 A   
.61C                        0 8949 A   .61D                        0 893D A   
.61E                        0 8952 A   .61F                        0 89A5 A   
.62                         0 0CFA A   .620                        0 899E A   
.621                        0 89AA A   .622                        0 89F2 A   
.623                        0 89E9 A   .624                        0 89DD A   
.625                        0 89F2 A   .626                        0 8A31 A   
.627                        0 89F9 A   .628                        0 8A14 A   
.629                        0 8A0B A   .62A                        0 89FA A   
.62B                        0 8A14 A   .62C                        0 8A5D A   
.62D                        0 8A53 A   .62E                        0 8A72 A   
.62F                        0 8A6C A   .63                         0 0B6B A   
.630                        0 8A86 A   .631                        0 8A7F A   
.632                        0 8AB1 A   .633                        0 8AAB A   
.634                        0 8AD0 A   .635                        0 8ACA A   
.636                        0 8AF1 A   .637                        0 8AE3 A   
.638                        0 8AF9 A   .639                        0 8B13 A   
.63A                        0 8B00 A   .63B                        0 8BD4 A   
.63C                        0 8B2D A   .63D                        0 8B1A A   
.63E                        0 8BD4 A   .63F                        0 8B47 A   
.64                         0 0C15 A   .640                        0 8B34 A   
.641                        0 8BD4 A   .642                        0 8B61 A   
.643                        0 8B4E A   .644                        0 8BD4 A   
.645                        0 8B7A A   .646                        0 8B68 A   
.647                        0 8BD4 A   .648                        0 8B93 A   
.649                        0 8B81 A   .64A                        0 8BD4 A   
.64B                        0 8BAC A   .64C                        0 8B9A A   
.64D                        0 8BD4 A   .64E                        0 8BC5 A   
.64F                        0 8BB3 A   .65                         0 0BA2 A   
.650                        0 8BD4 A   .651                        0 8BE3 A   
.652                        0 8BDB A   .653                        0 8BE9 A   
.654                        0 8C5B A   .655                        0 8C54 A   
.656                        0 8C41 A   .657                        0 8C5B A   
.658                        0 8C91 A   .659                        0 8C81 A   
.65A                        0 8C9F A   .65B                        0 8CF0 A   
.65C                        0 8CE2 A   .65D                        0 8CF8 A   
.65E                        0 8D07 A   .65F                        0 8CFF A   
.66                         0 0BE9 A   .660                        0 8D0E A   
.661                        0 9E06 A   .663                        0 9DC7 A   
.664                        0 8D28 A   .665                        0 8D55 A   
.666                        0 8D35 A   .667                        0 8D76 A   
.668                        0 8D68 A   .669                        0 8D7E A   
.66A                        0 8DA5 A   .66B                        0 8D85 A   
.66C                        0 8DD2 A   .66D                        0 8E10 A   
.66E                        0 8E08 A   .66F                        0 8E14 A   
.67                         0 0BAC A   .670                        0 8E14 A   
.671                        0 8E14 A   .672                        0 8E87 A   
.673                        0 8E5D A   .674                        0 8E56 A   
.675                        0 8E4F A   .676                        0 8E48 A   
.677                        0 8E41 A   .678                        0 8EC0 A   
.679                        0 8E96 A   .67A                        0 8F08 A   
.67B                        0 8ECF A   .67C                        0 8F08 A   
.67D                        0 8EDE A   .67E                        0 92C5 A   
.67F                        0 8F11 A   .68                         0 0C12 A   
.680                        0 8F41 A   .681                        0 8F3A A   
.682                        0 8F8A A   .683                        0 8F60 A   
.684                        0 9131 A   .685                        0 912A A   
.686                        0 90D2 A   .687                        0 9117 A   
.688                        0 90EA A   .689                        0 9131 A   
.68A                        0 9187 A   .68B                        0 9179 A   
.68C                        0 D103 A   .68D                        0 929A A   
.68E                        0 9270 A   .68F                        0 969C A   
.69                         0 0CF7 A   .690                        0 9674 A   
.691                        0 92CE A   .692                        0 92FE A   
.693                        0 92F7 A   .694                        0 9347 A   
.695                        0 931D A   .696                        0 94E0 A   
.697                        0 94D9 A   .698                        0 9481 A   
.699                        0 94C6 A   .69A                        0 9499 A   
.69B                        0 94E0 A   .69C                        0 9536 A   
.69D                        0 9528 A   .69E                        0 D0E3 A   
.69F                        0 964A A   .6A                         0 0C48 A   
.6A0                        0 961F A   .6A1                        0 963C A   
.6A2                        0 9628 A   .6A3                        0 964A A   
.6A4                        0 D0BE A   .6A5                        0 969C A   
.6A6                        0 969F A   .6A7                        0 96FE A   
.6A8                        0 96E2 A   .6A9                        0 96DB A   
.6AA                        0 96D4 A   .6AB                        0 96CD A   
.6AC                        0 96C6 A   .6AD                        0 972D A   
.6AE                        0 970D A   .6AF                        0 9775 A   
.6B                         0 0C1C A   .6B0                        0 973C A   
.6B1                        0 9775 A   .6B2                        0 974B A   
.6B3                        0 97A5 A   .6B4                        0 979E A   
.6B5                        0 97ED A   .6B6                        0 97C3 A   
.6B7                        0 9945 A   .6B8                        0 993E A   
.6B9                        0 98F0 A   .6BA                        0 992B A   
.6BB                        0 9908 A   .6BC                        0 9945 A   
.6BD                        0 999B A   .6BE                        0 998D A   
.6BF                        0 D09E A   .6C                         0 0CF7 A   
.6C0                        0 9AAF A   .6C1                        0 9A84 A   
.6C2                        0 9AA1 A   .6C3                        0 9A8D A   
.6C4                        0 9AAF A   .6C5                        0 D078 A   
.6C6                        0 9ADC A   .6C7                        0 9B1E A   
.6C8                        0 9AE9 A   .6C9                        0 9B3F A   
.6CA                        0 9B38 A   .6CB                        0 9B4F A   
.6CC                        0 9B48 A   .6CD                        0 9B64 A   
.6CE                        0 9B56 A   .6CF                        0 9B6C A   
.6D                         0 0CF7 A   .6D0                        0 9C89 A   
.6D2                        0 9C62 A   .6D3                        0 9BA6 A   
.6D4                        0 9BB8 A   .6D5                        0 9BCC A   
.6D6                        0 9BE0 A   .6D7                        0 9BF4 A   
.6D8                        0 9C08 A   .6D9                        0 9C1B A   
.6DA                        0 9C2D A   .6DB                        0 9C3F A   
.6DC                        0 9C52 A   .6DD                        0 D058 A   
.6DE                        0 9C87 A   .6DF                        0 9C75 A   
.6E                         0 0C58 A   .6E0                        0 9CA2 A   
.6E1                        0 9CC5 A   .6E2                        0 9CAF A   
.6E3                        0 9CE6 A   .6E4                        0 9CD8 A   
.6E5                        0 9CEE A   .6E6                        0 9D09 A   
.6E7                        0 9CFD A   .6E8                        0 9D14 A   
.6E9                        0 9D18 A   .6EA                        0 9D45 A   
.6EB                        0 9D25 A   .6EC                        0 9D65 A   
.6ED                        0 9D85 A   .6EE                        0 9DA5 A   
.6EF                        0 9DEC A   .6F                         0 0C4F A   
.6F0                        0 9DDA A   .6F1                        0 9E39 A   
.6F2                        0 9E2C A   .6F3                        0 D031 A   
.6F4                        0 9F80 A   .6F5                        0 9E8D A   
.6F6                        0 9E84 A   .6F7                        0 9E7A A   
.6F8                        0 9F14 A   .6F9                        0 9EAE A   
.6FA                        0 9F14 A   .6FB                        0 9EFD A   
.6FC                        0 9EF6 A   .6FD                        0 9F14 A   
.6FE                        0 9F0D A   .6FF                        0 9F52 A   
.7                          0 05ED A   .70                         0 0C65 A   
.700                        0 9F1B A   .701                        0 9F76 A   
.702                        0 9F6E A   .703                        0 9F88 A   
.704                        0 A029 A   .705                        0 9FFF A   
.706                        0 A065 A   .707                        0 A065 A   
.708                        0 A030 A   .709                        0 D01B A   
.70A                        0 CFFE A   .70B                        0 CFFD A   
.70C                        0 A081 A   .70D                        0 A07D A   
.70E                        0 A1DC A   .71                         0 0C5F A   
.710                        0 A1C0 A   .711                        0 A096 A   
.712                        0 A096 A   .713                        0 A0A2 A   
.714                        0 A09E A   .715                        0 A0A4 A   
.716                        0 A0F4 A   .717                        0 A0E3 A   
.718                        0 A12D A   .719                        0 A10B A   
.71A                        0 A0FC A   .71B                        0 A12D A   
.71C                        0 A11D A   .71D                        0 A146 A   
.71E                        0 A16C A   .71F                        0 A153 A   
.72                         0 0C74 A   .720                        0 A19E A   
.721                        0 A1BA A   .722                        0 CFF0 A   
.723                        0 A54A A   .725                        0 A521 A   
.726                        0 A218 A   .727                        0 A23C A   
.728                        0 A25F A   .729                        0 A271 A   
.72A                        0 A266 A   .72B                        0 A2B8 A   
.72C                        0 A2C2 A   .72D                        0 A2BF A   
.72E                        0 A332 A   .72F                        0 A349 A   
.73                         0 0C6C A   .730                        0 A33E A   
.731                        0 A38A A   .732                        0 A39F A   
.733                        0 A391 A   .734                        0 A413 A   
.735                        0 A438 A   .736                        0 A42D A   
.737                        0 A442 A   .738                        0 A43F A   
.739                        0 A4A9 A   .73A                        0 A4DC A   
.73B                        0 A4E5 A   .73C                        0 A4E3 A   
.73D                        0 A507 A   .73E                        0 A4EE A   
.73F                        0 A4EC A   .74                         0 0C7A A   
.740                        0 A507 A   .741                        0 A4F7 A   
.742                        0 A4F5 A   .743                        0 A507 A   
.744                        0 A507 A   .745                        0 A4FE A   
.746                        0 A507 A   .747                        0 A505 A   
.748                        0 A507 A   .749                        0 A517 A   
.74A                        0 A544 A   .74B                        0 A534 A   
.74C                        0 A66F A   .74D                        0 A580 A   
.74E                        0 A58D A   .74F                        0 A589 A   
.75                         0 0CF7 A   .750                        0 A66F A   
.751                        0 A598 A   .752                        0 A66F A   
.753                        0 A5AC A   .754                        0 A63C A   
.755                        0 A5D2 A   .756                        0 A66C A   
.757                        0 B038 A   .759                        0 B030 A   
.75A                        0 AF74 A   .75B                        0 AFA0 A   
.75C                        0 AF94 A   .75D                        0 AF7B A   
.75E                        0 B022 A   .76                         0 0CE9 A   
.760                        0 AFFD A   .761                        0 AFA5 A   
.762                        0 AFA5 A   .763                        0 AFA5 A   
.764                        0 AFA5 A   .765                        0 AFA5 A   
.766                        0 AFA5 A   .767                        0 AFA5 A   
.768                        0 AFA5 A   .769                        0 AFF3 A   
.76A                        0 B020 A   .76B                        0 B010 A   
.76C                        0 B024 A   .76D                        0 CFF0 A   
.76E                        0 CFFD A   .76F                        0 CFFE A   
.77                         0 0CF0 A   .770                        0 D01B A   
.771                        0 D031 A   .772                        0 D058 A   
.773                        0 D078 A   .774                        0 D09E A   
.775                        0 D0BE A   .776                        0 D0E3 A   
.777                        0 D103 A   .778                        0 D123 A   
.779                        0 D154 A   .77A                        0 D186 A   
.77B                        0 D191 A   .77C                        0 D19B A   
.77D                        0 D1A5 A   .77E                        0 D1AF A   
.77F                        0 D1BA A   .78                         0 0C83 A   
.780                        0 D1C5 A   .781                        0 D1E9 A   
.782                        0 D20D A   .783                        0 D227 A   
.784                        0 D253 A   .785                        0 D27F A   
.786                        0 D2AB A   .787                        0 D2D6 A   
.788                        0 D2ED A   .789                        0 D303 A   
.78A                        0 D31F A   .78B                        0 D347 A   
.78C                        0 D36D A   .78D                        0 D36F A   
.78E                        0 D37F A   .78F                        0 D396 A   
.79                         0 0CD6 A   .790                        0 D3B5 A   
.791                        0 D3C7 A   .792                        0 D3D0 A   
.793                        0 D3D9 A   .794                        0 D403 A   
.795                        0 D42E A   .796                        0 D457 A   
.797                        0 D46C A   .798                        0 D480 A   
.799                        0 D483 A   .79A                        0 D49E A   
.79B                        0 D4B2 A   .79C                        0 D4BD A   
.79D                        0 D4CD A   .79E                        0 D4D3 A   
.79F                        0 D4E3 A   .7A                         0 0CCE A   
.7A0                        0 D4F3 A   .7A1                        0 D4F5 A   
.7A2                        0 D4F7 A   .7A3                        0 D4FD A   
.7A4                        0 D500 A   .7A5                        0 D504 A   
.7A6                        0 D509 A   .7A7                        0 D51F A   
.7A8                        0 D53C A   .7A9                        0 D55E A   
.7AA                        0 D578 A   .7AB                        0 D59D A   
.7AC                        0 D5B9 A   .7AD                        0 D5CC A   
.7AE                        0 D5E9 A   .7B                         0 0CDF A   
.7C                         0 0CF7 A   .7D                         0 0DAA A   
.7E                         0 0D39 A   .7F                         0 0D01 A   
.8                          0 06F1 A   .80                         0 0D25 A   
.81                         0 0D0B A   .82                         0 0D37 A   
.83                         0 0DAA A   .84                         0 0D52 A   
.85                         0 0D40 A   .86                         0 0DAA A   
.87                         0 0D87 A   .88                         0 0D59 A   
.89                         0 0DAA A   .8A                         0 0D9C A   
.8B                         0 0D8E A   .8C                         0 0DAA A   
.8D                         0 D5CC A   .8E                         0 0DC0 A   
.8F                         0 0DDD A   .9                          0 06E2 A   
.90                         0 0DEA A   .91                         0 0DE6 A   
.92                         0 0E22 A   .93                         0 0E08 A   
.94                         0 0DFB A   .95                         0 0E22 A   
.96                         0 0E17 A   .97                         0 0E60 A   
.98                         0 0E55 A   .99                         0 0E2A A   
.9A                         0 0E55 A   .9B                         0 0E46 A   
.9C                         0 0E60 A   .9D                         0 0E9D A   
.9E                         0 0E83 A   .9F                         0 0E76 A   
.A                          0 0709 A   .A0                         0 0E9D A   
.A1                         0 0E92 A   .A2                         0 0EAC A   
.A3                         0 0EA4 A   .A4                         0 0EDC A   
.A5                         0 0EC2 A   .A6                         0 0EB4 A   
.A7                         0 0EDC A   .A8                         0 0ED1 A   
.A9                         0 0EEC A   .AA                         0 0EE3 A   
.AB                         0 0F02 A   .AC                         0 0EF9 A   
.AD                         0 0F40 A   .AE                         0 0F26 A   
.AF                         0 0F18 A   .B                          0 06FA A   
.B0                         0 0F40 A   .B1                         0 0F35 A   
.B2                         0 0F50 A   .B3                         0 0F47 A   
.B4                         0 0F80 A   .B5                         0 0F66 A   
.B6                         0 0F58 A   .B7                         0 0F80 A   
.B8                         0 0F75 A   .B9                         0 0F90 A   
.BA                         0 0F87 A   .BB                         0 0FA6 A   
.BC                         0 0F9D A   .BD                         0 1000 A   
.BE                         0 0FE6 A   .BF                         0 0FD8 A   
.C                          0 072D A   .C0                         0 1000 A   
.C1                         0 0FF5 A   .C2                         0 1010 A   
.C3                         0 1007 A   .C4                         0 1040 A   
.C5                         0 1026 A   .C6                         0 1018 A   
.C7                         0 1040 A   .C8                         0 1035 A   
.C9                         0 1050 A   .CA                         0 1047 A   
.CB                         0 1066 A   .CC                         0 105D A   
.CD                         0 1096 A   .CE                         0 107C A   
.CF                         0 106E A   .D                          0 0712 A   
.D0                         0 1096 A   .D1                         0 108B A   
.D2                         0 10A6 A   .D3                         0 109D A   
.D4                         0 10BC A   .D5                         0 10B3 A   
.D6                         0 10FA A   .D7                         0 10E0 A   
.D8                         0 10D2 A   .D9                         0 10FA A   
.DA                         0 10EF A   .DB                         0 110A A   
.DC                         0 1101 A   .DD                         0 113A A   
.DE                         0 1120 A   .DF                         0 1112 A   
.E                          0 0722 A   .E0                         0 113A A   
.E1                         0 112F A   .E2                         0 114A A   
.E3                         0 1141 A   .E4                         0 1160 A   
.E5                         0 1157 A   .E6                         0 119E A   
.E7                         0 1184 A   .E8                         0 1176 A   
.E9                         0 119E A   .EA                         0 1193 A   
.EB                         0 11AE A   .EC                         0 11A5 A   
.ED                         0 11EC A   .EE                         0 11D2 A   
.EF                         0 11C4 A   .F                          0 0719 A   
.F0                         0 11EC A   .F1                         0 11E1 A   
.F2                         0 11FC A   .F3                         0 11F3 A   
.F4                         0 123A A   .F5                         0 1220 A   
.F6                         0 1212 A   .F7                         0 123A A   
.F8                         0 122F A   .F9                         0 124A A   
.FA                         0 1241 A   .FB                         0 127A A   
.FC                         0 1260 A   .FD                         0 1252 A   
.FE                         0 127A A   .FF                         0 126F A   
.FFDD                       0 88EB A   .FFDE                       0 88D5 A   
.FFDF                       0 88BF A   .FFE0                       0 88E1 A   
.FFE2                       0 88B4 A   .FFE3                       0 82D6 A   
.FFE4                       0 82A9 A   .FFE6                       0 80A6 A   
.FFE7                       0 8090 A   .FFE8                       0 807A A   
.FFE9                       0 809C A   .FFEB                       0 806F A   
.FFEC                       0 75B5 A   .FFED                       0 75E1 A   
.FFEE                       0 75CB A   .FFEF                       0 75D7 A   
.FFF1                       0 75AA A   .FFF4                       0 577C A   
.FFFA                       0 3B51 A   BcdToBin                    0 AA77 A   
Upcall                      0 AE14 A   _TCGInterruptHandler        0 AEAD A   
_apm16_entry                0 AC25 A   _apm32_entry                0 AB3C A   
_apmreal_entry              0 ACF2 A   _ata_cmd_data_in            0 2D37 A E 
_ata_cmd_data_out           0 3108 A E _ata_cmd_non_data           0 2D30 A E 
_ata_cmd_packet             0 34DB A E _ata_detect                 0 1DFB A E 
_ata_init                   0 19CB A E _ata_reset                  0 2BE3 A E 
_atapi_get_sense            0 398B A E _atapi_is_cdrom             0 3CF8 A E 
_atapi_is_ready             0 3A10 A E _await_ide                  0 1CA4 A   
_bios_cvs_version_string    0 0194 A   _bios_printf                0 0A1B A E 
_cdemu_emulated_drive       0 3DBB A E _cdemu_init                 0 3D6A A E 
_cdemu_isactive             0 3D94 A E _cdrom_boot                 0 3E00 A E 
_check_for_keystroke        0 09D4 A E _clobber_entry_point        0 130D A E 
_debugger_off               0 192D A E _debugger_on                0 191B A E 
_delay_ticks                0 0922 A E _delay_ticks_and_check_for+ 0 09EA A E 
_dequeue_key                0 5BCC A E _determine_floppy_media     0 9E53 A E 
_disable_rom_write_access   0 06A5 A E _drivetypes                 0 137F A   
_eltorito                   0 3DE8 A   _enable_mouse_int_and_even+ 0 5D7A A E 
_enable_rom_write_access    0 0694 A E _enqueue_key                0 654A A E 
_fixup_base_mem_in_k        0 0650 A E _floppy_drive_exists        0 8CCA A E 
_floppy_drive_recal         0 8C17 A E _floppy_media_known         0 8A35 A E 
_floppy_media_sense         0 8AB8 A E _floppy_prepare_controller  0 8956 A E 
_floppy_reset_controller    0 8908 A E _get_CS                     0 064A A E 
_get_SS                     0 064D A E _get_boot_vector            0 150E A   
_get_keystroke              0 09E2 A E _get_mouse_data             0 5E68 A E 
_get_s3_waking_vector       0 AEFB A   _inb                        0 053E A E 
_inb_cmos                   0 0583 A E _inhibit_mouse_int_and_eve+ 0 5CCD A E 
_init_boot_vectors          0 13B1 A   _init_rtc                   0 058F A E 
_int09_function             0 5EF7 A E _int13_cdemu                0 82FD A E 
_int13_cdrom                0 75FE A E _int13_diskette_function    0 8D12 A E 
_int13_eltorito             0 80C3 A E _int13_harddisk             0 6719 A E 
_int14_function             0 4584 A E _int15_function             0 47F4 A E 
_int15_function32           0 5433 A E _int15_function_mouse       0 4CF0 A E 
_int16_function             0 579F A E _int17_function             0 9E54 A E 
_int18_function             0 9F8C A E _int18_panic_msg            0 18B1 A E 
_int1a_function             0 A20C A E _int1a_function32           0 AF69 A E 
_int70_function             0 A54E A E _int74_function             0 65FE A E 
_interactive_bootkey        0 156F A E _inw                        0 0549 A E 
_isotag                     0 3DE2 A   _keyboard_init              0 0DEE A E 
_keyboard_panic             0 12B2 A E _log_bios_start             0 18C3 A E 
_machine_reset              0 12C7 A E _memcpyb                    0 0024 A E 
_memcpyd                    0 0053 A E _memsetb                    0 0000 A E 
_nmi_handler_msg            0 189F A E _outb                       0 0554 A E 
_outb_cmos                  0 0574 A E _outw                       0 0564 A E 
_panic_msg_keyb_buffer_ful+ 0 5CAD A   _pmm                        0 AF01 A   
_print_bios_banner          0 134D A E _print_boot_device          0 1767 A E 
_print_boot_failure         0 1822 A E _print_cdromboot_failure    0 189A A E 
_put_int                    0 072F A E _put_luint                  0 0837 A E 
_put_str                    0 08EE A E _put_uint                   0 07B4 A E 
_read_byte                  0 05F4 A E _read_dword                 0 0083 A E 
_read_word                  0 0607 A E _rtc_updating               0 05C0 A E 
_s3_resume                  0 193E A E _s3_resume_panic            0 133B A E 
_scan_to_scanascii          0 01C4 A   _send                       0 06C7 A E 
_send_to_mouse_ctrl         0 5E1E A E _set_diskette_current_cyl   0 9E22 A E 
_set_diskette_ret_status    0 9E0A A E _set_e820_range             0 5357 A E 
_set_enable_a20             0 18C8 A E _set_kbd_command_byte       0 5EA9 A E 
_shutdown_status_panic      0 1323 A E _tcpa_acpi_init             0 AEB3 A   
_tcpa_add_bootdevice        0 AED7 A   _tcpa_add_event_separators  0 AECB A   
_tcpa_calling_int19h        0 AEBF A   _tcpa_do_measure_POSTs      0 AF07 A E 
_tcpa_extend_acpi_log       0 AEB9 A   _tcpa_initialize_tpm        0 AEF5 A   
_tcpa_ipl                   0 AEE9 A   _tcpa_measure_post          0 AEEF A   
_tcpa_option_rom            0 AEE3 A   _tcpa_returned_int19h       0 AEC5 A   
_tcpa_start_option_rom_sca+ 0 AEDD A   _tcpa_wake_event            0 AED1 A   
_vgafont8                   0 FA6E A   _wrch                       0 06B7 A E 
_write_byte                 0 061A A E _write_dword                0 009B A E 
_write_word                 0 0632 A E apm16_04                    0 AC26 A   
apm16_05                    0 AC2D A   apm16_07                    0 AC38 A   
apm16_07_1                  0 AC5C A   apm16_07_poweroff           0 AC52 A   
apm16_07_poweroff_str       0 AC0C A   apm16_07_standby            0 AC6E A   
apm16_07_standby_str        0 AC1D A   apm16_07_suspend            0 AC5F A   
apm16_07_suspend_str        0 AC15 A   apm16_08                    0 AC7D A   
apm16_0a                    0 AC83 A   apm16_0b                    0 AC97 A   
apm16_0e                    0 AC9F A   apm16_0f                    0 ACA9 A   
apm16_10                    0 ACAF A   apm16_error                 0 ACBD A   
apm16_ok                    0 ACBA A   apm16_out_str               0 ABF4 A   
apm16_out_str1              0 ABFB A   apm16_out_str2              0 AC07 A   
apm16_unimplemented         0 ACBD A   apm32_04                    0 AB3E A   
apm32_05                    0 AB47 A   apm32_07                    0 AB56 A   
apm32_07_1                  0 AB87 A   apm32_07_poweroff           0 AB79 A   
apm32_07_poweroff_str       0 AB23 A   apm32_07_standby            0 AB9B A   
apm32_07_standby_str        0 AB34 A   apm32_07_suspend            0 AB8A A   
apm32_07_suspend_str        0 AB2C A   apm32_08                    0 ABAC A   
apm32_0a                    0 ABB2 A   apm32_0b                    0 ABC8 A   
apm32_0e                    0 ABD0 A   apm32_0f                    0 ABDA A   
apm32_10                    0 ABE0 A   apm32_error                 0 ABF0 A   
apm32_ok                    0 ABEC A   apm32_out_str               0 AB10 A   
apm32_out_str1              0 AB14 A   apm32_out_str2              0 AB20 A   
apm32_unimplemented         0 ABF0 A   apm_call                    0 F87B A   
apmreal_00                  0 ACF2 A   apmreal_01                  0 AD04 A   
apmreal_02                  0 AD0B A   apmreal_03                  0 AD21 A   
apmreal_04                  0 AD40 A   apmreal_05                  0 AD47 A   
apmreal_07                  0 AD52 A   apmreal_07_1                0 AD76 A   
apmreal_07_poweroff         0 AD6C A   apmreal_07_poweroff_str     0 ACD8 A   
apmreal_07_standby          0 AD88 A   apmreal_07_standby_str      0 ACE9 A   
apmreal_07_suspend          0 AD79 A   apmreal_07_suspend_str      0 ACE1 A   
apmreal_08                  0 AD97 A   apmreal_0a                  0 AD9D A   
apmreal_0b                  0 ADB1 A   apmreal_0e                  0 ADB9 A   
apmreal_0f                  0 ADC3 A   apmreal_10                  0 ADC9 A   
apmreal_error               0 ADD9 A   apmreal_ok                  0 ADD4 A   
apmreal_out_str             0 ACC0 A   apmreal_out_str1            0 ACC7 A   
apmreal_out_str2            0 ACD3 A   apmreal_unimplemented       0 ADD9 A   
ata_in_16                   0 307E A   ata_in_32                   0 3082 A   
ata_in_adjust               0 306A A   ata_in_done                 0 3085 A   
ata_in_no_adjust            0 3071 A   ata_out_16                  0 344F A   
ata_out_32                  0 3454 A   ata_out_adjust              0 343B A   
ata_out_done                0 3458 A   ata_out_no_adjust           0 3442 A   
ata_packet_after            0 3916 A   ata_packet_done             0 3930 A   
ata_packet_in_16            0 390F A   ata_packet_in_32            0 3913 A   
ata_packet_in_after_16      0 3923 A   ata_packet_in_after_32      0 3928 A   
ata_packet_in_after_32_loo+ 0 392A A   ata_packet_in_before_16     0 38ED A   
ata_packet_in_before_32     0 38F2 A   ata_packet_in_before_32_lo+ 0 38F4 A   
ata_packet_no_before        0 38FA A   bios32_end                  0 B083 A   
bios32_entry_point          0 B050 A   bios32_structure            0 B040 A   
bios_table_area_end         0 CFF0 A   bios_table_area_start       0 B630 A   
block_count_rounded         0 B4F9 A   carry_set                   0 A6AA A   
check_for_hd1               0 A932 A   checksum_loop               0 B4A7 A   
checksum_out                0 B4C1 A   detect_parport              0 B44C A   
detect_serial               0 B46B A   diskette_param_table        0 EFC7 A   
diskette_param_table2       0 EFDE A   done                        0 09E1 A   
dummy_iret_handler          0 FF53 A   ebda_post                   0 AA20 A   
eoi_both_pics               0 AA6E A   eoi_jmp_post                0 AA35 A   
eoi_master_pic              0 AA72 A   f0_missing                  0 A7AC A   
f1_missing                  0 A7B7 A   fetch_bdf                   0 B512 A   
floppy_drive_post           0 A771 A   gdt_base                    0 ADE0 A   
gdt_entry_end               0 AE08 A   gdt_entry_pm_16bit_cs       0 ADF0 A   
gdt_entry_pm_16bit_ds       0 AE00 A   gdt_entry_pm_32bit_cs       0 ADE8 A   
gdt_entry_pm_32bit_ds       0 ADF8 A   halt2_loop                  0 0DE7 A   
hard_drive_post             0 A7F8 A   hd0_post_above_2048         0 A8F4 A   
hd0_post_above_4096         0 A902 A   hd0_post_above_8192         0 A910 A   
hd0_post_checksum_loop      0 A925 A   hd0_post_logical_chs        0 A8D3 A   
hd0_post_physical_chs       0 A8C5 A   hd0_post_store_logical      0 A916 A   
hd1_post_above_2048         0 A9E1 A   hd1_post_above_4096         0 A9EF A   
hd1_post_above_8192         0 A9FD A   hd1_post_checksum_loop      0 AA12 A   
hd1_post_logical_chs        0 A9C0 A   hd1_post_physical_chs       0 A9B3 A   
hd1_post_store_logical      0 AA03 A   idiv_                       0 0165 A   
idiv_u                      0 0169 A   int08_floppy_off            0 FEC4 A   
int08_handler               0 FEA5 A   int08_store_ticks           0 FED9 A   
int09_check_pause           0 E9B5 A   int09_done                  0 E9CF A   
int09_finish                0 E9D5 A   int09_handler               0 E987 A   
int09_process_key           0 E9C7 A   int0e_handler               0 EF57 A   
int0e_loop1                 0 EF69 A   int0e_loop2                 0 EF73 A   
int0e_normal                0 EF81 A   int10_handler               0 F065 A   
int11_handler               0 F84D A   int12_handler               0 F841 A   
int13_cdemu_inactive        0 A6FE A   int13_cdrom_rme_end         0 7A3E A   
int13_disk                  0 A72D A   int13_diskette              0 EC59 A   
int13_handler               0 E3FE A   int13_legacy                0 A706 A   
int13_nocdemu               0 A6EB A   int13_noeltorito            0 A702 A   
int13_not_eltorito          0 A6C8 A   int13_notcdrom              0 A72D A   
int13_notfloppy             0 A719 A   int13_out                   0 A73A A   
int13_relocated             0 A6B3 A   int14_handler               0 E739 A   
int1586_tick                0 5481 A   int1586_tick_end            0 548F A   
int15_handler               0 F859 A   int15_handler32             0 F883 A   
int15_handler32_ret         0 F875 A   int15_handler_mouse         0 F87E A   
int15_handler_mouse_ret     0 F874 A   int16_F00                   0 E85B A   
int16_handler               0 E82E A   int16_key_found             0 E86F A   
int16_wait_for_key          0 E860 A   int16_zero_clear            0 E849 A   
int16_zero_set              0 E852 A   int17_handler               0 EFD2 A   
int18_handler               0 A73E A   int19_handler               0 E6F2 A   
int19_load_done             0 A0D7 A   int19_relocated             0 A763 A   
int1a_callfunction          0 FE8D A   int1a_handler               0 FE6E A   
int1a_normal                0 FE87 A   int1c_handler               0 A770 A   
int70_handler               0 FE93 A   int74_done                  0 A695 A   
int74_handler               0 A676 A   int75_handler               0 E2C7 A   
int76_handler               0 AAFD A   iret_modify_cf              0 A69F A   
iret_post_0x467             0 AA45 A   jmp_post_0x467              0 AA3D A   
laddl                       0 00C3 A   laddul                      0 00C3 A   
landl                       0 00BB A   landul                      0 00BB A   
lcmpl                       0 00CB A   lcmpul                      0 00CB A   
ldecl                       0 0102 A   ldecul                      0 0102 A   
ldivul                      0 016E A   lincl                       0 010F A   
lincul                      0 010F A   lmull                       0 00E9 A   
lmulul                      0 00E9 A   look_drive0                 0 A7A3 A   
look_drive1                 0 A7AE A   lorl                        0 0107 A   
lorul                       0 0107 A   lsl_exit                    0 0164 A   
lsl_loop                    0 0158 A   lsll                        0 0147 A   
lslul                       0 0147 A   lsr_exit                    0 0146 A   
lsr_loop                    0 013A A   lsrul                       0 0129 A   
lsubl                       0 00E1 A   lsubul                      0 00E1 A   
ltstl                       0 0114 A   ltstul                      0 0114 A   
memcpyb_end                 0 004B A   memcpyd_end                 0 007B A   
memsetb_end                 0 001E A   nmi                         0 E2C3 A   
no_bcv                      0 B564 A   no_bev                      0 B5A6 A   
no_key                      0 09DF A   no_parport                  0 B46A A   
no_prod_str                 0 B59E A   no_serial                   0 B48E A   
normal_post                 0 E0A7 A   pci_present                 0 B20D A   
pci_pro_devloop             0 B0BD A   pci_pro_devloop2            0 B0F3 A   
pci_pro_f02                 0 B0AC A   pci_pro_f03                 0 B0E8 A   
pci_pro_f08                 0 B121 A   pci_pro_f09                 0 B140 A   
pci_pro_f0a                 0 B15E A   pci_pro_f0b                 0 B172 A   
pci_pro_f0c                 0 B18E A   pci_pro_f0d                 0 B1AC A   
pci_pro_fail                0 B1C2 A   pci_pro_nextdev             0 B0D8 A   
pci_pro_nextdev2            0 B111 A   pci_pro_ok                  0 B1C7 A   
pci_pro_select_reg          0 B1CE A   pci_pro_unknown             0 B1C0 A   
pci_real_devloop            0 B241 A   pci_real_devloop2           0 B273 A   
pci_real_f02                0 B22E A   pci_real_f03                0 B26A A   
pci_real_f08                0 B2A0 A   pci_real_f09                0 B2B8 A   
pci_real_f0a                0 B2D0 A   pci_real_f0b                0 B2E4 A   
pci_real_f0c                0 B2FB A   pci_real_f0d                0 B312 A   
pci_real_f0e                0 B325 A   pci_real_fail               0 B365 A   
pci_real_nextdev            0 B257 A   pci_real_nextdev2           0 B28D A   
pci_real_ok                 0 B36B A   pci_real_select_reg         0 B373 A   
pci_real_too_small          0 B35A A   pci_real_unknown            0 B363 A   
pci_routing_table_structur+ 0 B390 A   pci_routing_table_structur+ 0 B410 A   
pci_routing_table_structur+ 0 B3B0 A   pcibios_error               0 FE7B A   
pcibios_protected           0 B090 A   pcibios_real                0 B1EB A   
pmm_entry_point             0 B420 A   pmm_structure               0 B410 A   
pmode_IDT_info              0 F88C A   pnp_string                  0 B4D1 A   
post                        0 E05B A   post_d0_extended            0 A85A A   
post_d0_type47              0 A86B A   post_d1_exists              0 A93D A   
post_d1_extended            0 A948 A   post_d1_type47              0 A959 A   
post_default_ints           0 E0D7 A   post_init_pic               0 B5DD A   
protected_mode              0 4BA3 A   protmode_gdtdesc            0 AE08 A   
real_mode                   0 4BCD A   realmode_gdtdesc            0 AE0E A   
retf_post_0x467             0 AA52 A   rmode_IDT_info              0 F891 A   
rom_checksum                0 B490 A   rom_scan                    0 B4D5 A   
rom_scan_increment          0 B5A8 A   rom_scan_loop               0 B4D5 A   
s3_post                     0 AA5F A   smbios_entry_point          0 B610 A   
smbios_init                 0 B5BA A   timer_tick_post             0 AA86 A   
unknown_service             0 B081 A   upcall1                     0 AE44 A   
upcall2                     0 AE53 A   upcall3                     0 AE7B A   
upcall4                     0 AE91 A   

00000 errors
00000 warnings
